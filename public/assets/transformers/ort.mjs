/*!
 * ONNX Runtime Web v1.25.0-dev.20260212-1a71a5f46e
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// common/dist/esm/backend-impl.js
var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
var init_backend_impl = __esm({
  "common/dist/esm/backend-impl.js"() {
    "use strict";
    backends = /* @__PURE__ */ new Map();
    backendsSortedByPriority = [];
    registerBackend = (name, backend, priority) => {
      if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
        const currentBackend = backends.get(name);
        if (currentBackend === void 0) {
          backends.set(name, { backend, priority });
        } else if (currentBackend.priority > priority) {
          return;
        } else if (currentBackend.priority === priority) {
          if (currentBackend.backend !== backend) {
            throw new Error(`cannot register backend "${name}" using priority ${priority}`);
          }
        }
        if (priority >= 0) {
          const i = backendsSortedByPriority.indexOf(name);
          if (i !== -1) {
            backendsSortedByPriority.splice(i, 1);
          }
          for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
            if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
              backendsSortedByPriority.splice(i2, 0, name);
              return;
            }
          }
          backendsSortedByPriority.push(name);
        }
        return;
      }
      throw new TypeError("not a valid backend");
    };
    tryResolveAndInitializeBackend = async (backendName) => {
      const backendInfo = backends.get(backendName);
      if (!backendInfo) {
        return "backend not found.";
      }
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        return backendInfo.error;
      } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
          if (!isInitializing) {
            backendInfo.initPromise = backendInfo.backend.init(backendName);
          }
          await backendInfo.initPromise;
          backendInfo.initialized = true;
          return backendInfo.backend;
        } catch (e) {
          if (!isInitializing) {
            backendInfo.error = `${e}`;
            backendInfo.aborted = true;
          }
          return backendInfo.error;
        } finally {
          delete backendInfo.initPromise;
        }
      }
    };
    resolveBackendAndExecutionProviders = async (options) => {
      const eps = options.executionProviders || [];
      const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
      const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
      let backend;
      const errors = [];
      const availableBackendNames = /* @__PURE__ */ new Set();
      for (const backendName of backendNames) {
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === "string") {
          errors.push({ name: backendName, err: resolveResult });
        } else {
          if (!backend) {
            backend = resolveResult;
          }
          if (backend === resolveResult) {
            availableBackendNames.add(backendName);
          }
        }
      }
      if (!backend) {
        throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
      }
      for (const { name, err } of errors) {
        if (backendHints.includes(name)) {
          console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
        }
      }
      const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
      return [
        backend,
        new Proxy(options, {
          get: (target, prop) => {
            if (prop === "executionProviders") {
              return filteredEps;
            }
            return Reflect.get(target, prop);
          }
        })
      ];
    };
  }
});

// common/dist/esm/backend.js
var init_backend = __esm({
  "common/dist/esm/backend.js"() {
    "use strict";
    init_backend_impl();
  }
});

// common/dist/esm/version.js
var version;
var init_version = __esm({
  "common/dist/esm/version.js"() {
    "use strict";
    version = "1.24.0-dev.20251116-b39e144322";
  }
});

// common/dist/esm/env-impl.js
var logLevelValue, env;
var init_env_impl = __esm({
  "common/dist/esm/env-impl.js"() {
    "use strict";
    init_version();
    logLevelValue = "warning";
    env = {
      wasm: {},
      webgl: {},
      webgpu: {},
      versions: { common: version },
      set logLevel(value) {
        if (value === void 0) {
          return;
        }
        if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
          throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
      },
      get logLevel() {
        return logLevelValue;
      }
    };
    Object.defineProperty(env, "logLevel", { enumerable: true });
  }
});

// common/dist/esm/env.js
var env2;
var init_env = __esm({
  "common/dist/esm/env.js"() {
    "use strict";
    init_env_impl();
    env2 = env;
  }
});

// common/dist/esm/tensor-conversion-impl.js
var tensorToDataURL, tensorToImageData;
var init_tensor_conversion_impl = __esm({
  "common/dist/esm/tensor-conversion-impl.js"() {
    "use strict";
    tensorToDataURL = (tensor, options) => {
      const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
      canvas.width = tensor.dims[3];
      canvas.height = tensor.dims[2];
      const pixels2DContext = canvas.getContext("2d");
      if (pixels2DContext != null) {
        let width;
        let height;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
        }
        const inputformat = options?.format !== void 0 ? options.format : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
            pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
            pixels2DContext.fillRect(j, i, 1, 1);
          }
        }
        if ("toDataURL" in canvas) {
          return canvas.toDataURL();
        } else {
          throw new Error("toDataURL is not supported");
        }
      } else {
        throw new Error("Can not access image data");
      }
    };
    tensorToImageData = (tensor, options) => {
      const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
      let image;
      if (pixels2DContext != null) {
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[1];
          channels = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
          channels = tensor.dims[1];
        }
        const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        if (options !== void 0) {
          if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
            throw new Error("Tensor format doesn't match input tensor dims");
          }
        }
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
          image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
          image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
          image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
          image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
        }
      } else {
        throw new Error("Can not access image data");
      }
      return image;
    };
  }
});

// common/dist/esm/tensor-factory-impl.js
var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromMLTensor, tensorFromPinnedBuffer;
var init_tensor_factory_impl = __esm({
  "common/dist/esm/tensor-factory-impl.js"() {
    "use strict";
    init_tensor_impl();
    bufferToTensor = (buffer, options) => {
      if (buffer === void 0) {
        throw new Error("Image buffer must be defined");
      }
      if (options.height === void 0 || options.width === void 0) {
        throw new Error("Image height and width must be defined");
      }
      if (options.tensorLayout === "NHWC") {
        throw new Error("NHWC Tensor layout is not supported yet");
      }
      const { height, width } = options;
      const norm = options.norm ?? { mean: 255, bias: 0 };
      let normMean;
      let normBias;
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
      }
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
      }
      const inputformat = options.format !== void 0 ? options.format : "RGBA";
      const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
      const stride = height * width;
      const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
      let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGB") {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
      }
      if (outputformat === "RGBA") {
        aTensorPointer = stride * 3;
      } else if (outputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      } else if (outputformat === "BGR") {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
      }
      for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
          float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
      }
      const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
      return outputTensor;
    };
    tensorFromImage = async (image, options) => {
      const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
      const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
      const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
      const isString = typeof image === "string";
      let data;
      let bufferToTensorOptions = options ?? {};
      const createCanvas = () => {
        if (typeof document !== "undefined") {
          return document.createElement("canvas");
        } else if (typeof OffscreenCanvas !== "undefined") {
          return new OffscreenCanvas(1, 1);
        } else {
          throw new Error("Canvas is not supported");
        }
      };
      const createCanvasContext = (canvas) => {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          return canvas.getContext("2d");
        } else if (canvas instanceof OffscreenCanvas) {
          return canvas.getContext("2d");
        } else {
          return null;
        }
      };
      if (isHTMLImageEle) {
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          let height = image.height;
          let width = image.width;
          if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
            if (options.tensorFormat !== void 0) {
              throw new Error("Image input config format must be RGBA for HTMLImageElement");
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
            }
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          } else {
            bufferToTensorOptions.tensorFormat = "RGBA";
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          }
          pixels2DContext.drawImage(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
          height = options.resizedHeight;
          width = options.resizedWidth;
        } else {
          height = image.height;
          width = image.width;
        }
        if (options !== void 0) {
          bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = "RGBA";
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== void 0) {
          const tempCanvas = createCanvas();
          tempCanvas.width = width;
          tempCanvas.height = height;
          const pixels2DContext = createCanvasContext(tempCanvas);
          if (pixels2DContext != null) {
            pixels2DContext.putImageData(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else {
          data = image.data;
        }
      } else if (isImageBitmap) {
        if (options === void 0) {
          throw new Error("Please provide image config with format for Imagebitmap");
        }
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          const height = image.height;
          const width = image.width;
          pixels2DContext.drawImage(image, 0, 0, width, height);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isString) {
        return new Promise((resolve, reject) => {
          const canvas = createCanvas();
          const context = createCanvasContext(canvas);
          if (!image || !context) {
            return reject();
          }
          const newImage = new Image();
          newImage.crossOrigin = "Anonymous";
          newImage.src = image;
          newImage.onload = () => {
            canvas.width = newImage.width;
            canvas.height = newImage.height;
            context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
            const img = context.getImageData(0, 0, canvas.width, canvas.height);
            bufferToTensorOptions.height = canvas.height;
            bufferToTensorOptions.width = canvas.width;
            resolve(bufferToTensor(img.data, bufferToTensorOptions));
          };
        });
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
      if (data !== void 0) {
        return bufferToTensor(data, bufferToTensorOptions);
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
    };
    tensorFromTexture = (texture, options) => {
      const { width, height, download, dispose } = options;
      const dims = [1, height, width, 4];
      return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
    };
    tensorFromGpuBuffer = (gpuBuffer, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
    };
    tensorFromMLTensor = (mlTensor, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
    };
    tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
  }
});

// common/dist/esm/tensor-impl-type-mapping.js
var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
var init_tensor_impl_type_mapping = __esm({
  "common/dist/esm/tensor-impl-type-mapping.js"() {
    "use strict";
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
      ["float32", Float32Array],
      ["uint8", Uint8Array],
      ["int8", Int8Array],
      ["uint16", Uint16Array],
      ["int16", Int16Array],
      ["int32", Int32Array],
      ["bool", Uint8Array],
      ["float64", Float64Array],
      ["uint32", Uint32Array],
      ["int4", Uint8Array],
      ["uint4", Uint8Array]
    ]);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
      [Float32Array, "float32"],
      [Uint8Array, "uint8"],
      [Int8Array, "int8"],
      [Uint16Array, "uint16"],
      [Int16Array, "int16"],
      [Int32Array, "int32"],
      [Float64Array, "float64"],
      [Uint32Array, "uint32"]
    ]);
    isTypedArrayChecked = false;
    checkTypedArray = () => {
      if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
        const Float16Array2 = globalThis.Float16Array;
        const isFloat16ArrayAvailable = typeof Float16Array2 !== "undefined" && Float16Array2.from;
        if (isBigInt64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
        }
        if (isBigUint64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
        }
        if (isFloat16ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array2);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array2, "float16");
        } else {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
        }
      }
    };
  }
});

// common/dist/esm/tensor-utils-impl.js
var calculateSize, tensorReshape;
var init_tensor_utils_impl = __esm({
  "common/dist/esm/tensor-utils-impl.js"() {
    "use strict";
    init_tensor_impl();
    calculateSize = (dims) => {
      let size = 1;
      for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
          throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
          throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
      }
      return size;
    };
    tensorReshape = (tensor, dims) => {
      switch (tensor.location) {
        case "cpu":
          return new Tensor(tensor.type, tensor.data, dims);
        case "cpu-pinned":
          return new Tensor({
            location: "cpu-pinned",
            data: tensor.data,
            type: tensor.type,
            dims
          });
        case "texture":
          return new Tensor({
            location: "texture",
            texture: tensor.texture,
            type: tensor.type,
            dims
          });
        case "gpu-buffer":
          return new Tensor({
            location: "gpu-buffer",
            gpuBuffer: tensor.gpuBuffer,
            type: tensor.type,
            dims
          });
        case "ml-tensor":
          return new Tensor({
            location: "ml-tensor",
            mlTensor: tensor.mlTensor,
            type: tensor.type,
            dims
          });
        default:
          throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
      }
    };
  }
});

// common/dist/esm/tensor-impl.js
var Tensor;
var init_tensor_impl = __esm({
  "common/dist/esm/tensor-impl.js"() {
    "use strict";
    init_tensor_conversion_impl();
    init_tensor_factory_impl();
    init_tensor_impl_type_mapping();
    init_tensor_utils_impl();
    Tensor = class {
      /**
       * implementation.
       */
      constructor(arg0, arg1, arg2) {
        checkTypedArray();
        let type;
        let dims;
        if (typeof arg0 === "object" && "location" in arg0) {
          this.dataLocation = arg0.location;
          type = arg0.type;
          dims = arg0.dims;
          switch (arg0.location) {
            case "cpu-pinned": {
              const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
              if (!expectedTypedArrayConstructor) {
                throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
              }
              if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
              }
              this.cpuData = arg0.data;
              break;
            }
            case "texture": {
              if (type !== "float32") {
                throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
              }
              this.gpuTextureData = arg0.texture;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "gpu-buffer": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
              }
              this.gpuBufferData = arg0.gpuBuffer;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "ml-tensor": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
              }
              this.mlTensorData = arg0.mlTensor;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            default:
              throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
          }
        } else {
          let data;
          let maybeDims;
          if (typeof arg0 === "string") {
            type = arg0;
            maybeDims = arg2;
            if (arg0 === "string") {
              if (!Array.isArray(arg1)) {
                throw new TypeError("A string tensor's data must be a string array.");
              }
              data = arg1;
            } else {
              const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
              if (typedArrayConstructor === void 0) {
                throw new TypeError(`Unsupported tensor type: ${arg0}.`);
              }
              if (Array.isArray(arg1)) {
                if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                  throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                } else if (arg0 === "uint64" || arg0 === "int64") {
                  data = typedArrayConstructor.from(arg1, BigInt);
                } else {
                  data = typedArrayConstructor.from(arg1);
                }
              } else if (arg1 instanceof typedArrayConstructor) {
                data = arg1;
              } else if (arg1 instanceof Uint8ClampedArray) {
                if (arg0 === "uint8") {
                  data = Uint8Array.from(arg1);
                } else {
                  throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                }
              } else if (arg0 === "float16" && arg1 instanceof Uint16Array && typedArrayConstructor !== Uint16Array) {
                data = new globalThis.Float16Array(arg1.buffer, arg1.byteOffset, arg1.length);
              } else {
                throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
              }
            }
          } else {
            maybeDims = arg1;
            if (Array.isArray(arg0)) {
              if (arg0.length === 0) {
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              }
              const firstElementType = typeof arg0[0];
              if (firstElementType === "string") {
                type = "string";
                data = arg0;
              } else if (firstElementType === "boolean") {
                type = "bool";
                data = Uint8Array.from(arg0);
              } else {
                throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
              }
            } else if (arg0 instanceof Uint8ClampedArray) {
              type = "uint8";
              data = Uint8Array.from(arg0);
            } else {
              const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
              if (mappedType === void 0) {
                throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
              }
              type = mappedType;
              data = arg0;
            }
          }
          if (maybeDims === void 0) {
            maybeDims = [data.length];
          } else if (!Array.isArray(maybeDims)) {
            throw new TypeError("A tensor's dims must be a number array");
          }
          dims = maybeDims;
          this.cpuData = data;
          this.dataLocation = "cpu";
        }
        const size = calculateSize(dims);
        if (this.cpuData && size !== this.cpuData.length) {
          if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
          } else {
            throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
          }
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
      }
      // #endregion
      // #region factory
      static async fromImage(image, options) {
        return tensorFromImage(image, options);
      }
      static fromTexture(texture, options) {
        return tensorFromTexture(texture, options);
      }
      static fromGpuBuffer(gpuBuffer, options) {
        return tensorFromGpuBuffer(gpuBuffer, options);
      }
      static fromMLTensor(mlTensor, options) {
        return tensorFromMLTensor(mlTensor, options);
      }
      static fromPinnedBuffer(type, buffer, dims) {
        return tensorFromPinnedBuffer(type, buffer, dims);
      }
      // #endregion
      // #region conversions
      toDataURL(options) {
        return tensorToDataURL(this, options);
      }
      toImageData(options) {
        return tensorToImageData(this, options);
      }
      // #endregion
      // #region properties
      get data() {
        this.ensureValid();
        if (!this.cpuData) {
          throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
        }
        return this.cpuData;
      }
      get location() {
        return this.dataLocation;
      }
      get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
          throw new Error("The data is not stored as a WebGL texture.");
        }
        return this.gpuTextureData;
      }
      get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
          throw new Error("The data is not stored as a WebGPU buffer.");
        }
        return this.gpuBufferData;
      }
      get mlTensor() {
        this.ensureValid();
        if (!this.mlTensorData) {
          throw new Error("The data is not stored as a WebNN MLTensor.");
        }
        return this.mlTensorData;
      }
      // #endregion
      // #region methods
      async getData(releaseData) {
        this.ensureValid();
        switch (this.dataLocation) {
          case "cpu":
          case "cpu-pinned":
            return this.data;
          case "texture":
          case "gpu-buffer":
          case "ml-tensor": {
            if (!this.downloader) {
              throw new Error("The current tensor is not created with a specified data downloader.");
            }
            if (this.isDownloading) {
              throw new Error("The current tensor is being downloaded.");
            }
            try {
              this.isDownloading = true;
              const data = await this.downloader();
              this.downloader = void 0;
              this.dataLocation = "cpu";
              this.cpuData = data;
              if (releaseData && this.disposer) {
                this.disposer();
                this.disposer = void 0;
              }
              return data;
            } finally {
              this.isDownloading = false;
            }
          }
          default:
            throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
      }
      dispose() {
        if (this.isDownloading) {
          throw new Error("The current tensor is being downloaded.");
        }
        if (this.disposer) {
          this.disposer();
          this.disposer = void 0;
        }
        this.cpuData = void 0;
        this.gpuTextureData = void 0;
        this.gpuBufferData = void 0;
        this.mlTensorData = void 0;
        this.downloader = void 0;
        this.isDownloading = void 0;
        this.dataLocation = "none";
      }
      // #endregion
      // #region tensor utilities
      ensureValid() {
        if (this.dataLocation === "none") {
          throw new Error("The tensor is disposed.");
        }
      }
      reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
          throw new Error("Cannot reshape a tensor that owns GPU resource.");
        }
        return tensorReshape(this, dims);
      }
    };
  }
});

// common/dist/esm/tensor.js
var Tensor2;
var init_tensor = __esm({
  "common/dist/esm/tensor.js"() {
    "use strict";
    init_tensor_impl();
    Tensor2 = Tensor;
  }
});

// common/dist/esm/trace.js
var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END, TRACE_EVENT_BEGIN, TRACE_EVENT_END;
var init_trace = __esm({
  "common/dist/esm/trace.js"() {
    "use strict";
    init_env_impl();
    TRACE = (deviceType, label) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeStamp(`${deviceType}::ORT::${label}`);
    };
    TRACE_FUNC = (msg, extraMsg) => {
      const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
      let hasTraceFunc = false;
      for (let i = 0; i < stack.length; i++) {
        if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
          let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
          if (extraMsg) {
            label += `::${extraMsg}`;
          }
          TRACE("CPU", label);
          return;
        }
        if (stack[i].includes("TRACE_FUNC")) {
          hasTraceFunc = true;
        }
      }
    };
    TRACE_FUNC_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("BEGIN", extraMsg);
    };
    TRACE_FUNC_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("END", extraMsg);
    };
    TRACE_EVENT_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.time(`ORT::${extraMsg}`);
    };
    TRACE_EVENT_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeEnd(`ORT::${extraMsg}`);
    };
  }
});

// common/dist/esm/inference-session-impl.js
var InferenceSession;
var init_inference_session_impl = __esm({
  "common/dist/esm/inference-session-impl.js"() {
    "use strict";
    init_backend_impl();
    init_tensor();
    init_trace();
    InferenceSession = class _InferenceSession {
      constructor(handler) {
        this.handler = handler;
      }
      async run(feeds, arg1, arg2) {
        TRACE_FUNC_BEGIN();
        TRACE_EVENT_BEGIN("InferenceSession.run");
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name of arg1) {
              if (typeof name !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (this.outputNames.indexOf(name) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
              }
              fetches[name] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name of this.outputNames) {
              if (arg1Keys.indexOf(name) !== -1) {
                const v = arg1[name];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name of this.inputNames) {
          if (typeof feeds[name] === "undefined") {
            throw new Error(`input '${name}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name of this.outputNames) {
            fetches[name] = null;
          }
        }
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        TRACE_EVENT_END("InferenceSession.run");
        TRACE_FUNC_END();
        return returnValue;
      }
      async release() {
        return this.handler.dispose();
      }
      static async create(arg0, arg1, arg2, arg3) {
        TRACE_FUNC_BEGIN();
        TRACE_EVENT_BEGIN("InferenceSession.create");
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === "string") {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof Uint8Array) {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
          const buffer = arg0;
          let byteOffset = 0;
          let byteLength = arg0.byteLength;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 === "number") {
            byteOffset = arg1;
            if (!Number.isSafeInteger(byteOffset)) {
              throw new RangeError("'byteOffset' must be an integer.");
            }
            if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
              throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
            }
            byteLength = arg0.byteLength - byteOffset;
            if (typeof arg2 === "number") {
              byteLength = arg2;
              if (!Number.isSafeInteger(byteLength)) {
                throw new RangeError("'byteLength' must be an integer.");
              }
              if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
              }
              if (typeof arg3 === "object" && arg3 !== null) {
                options = arg3;
              } else if (typeof arg3 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'byteLength' must be a number.");
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
          filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
          throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        TRACE_EVENT_END("InferenceSession.create");
        TRACE_FUNC_END();
        return new _InferenceSession(handler);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
      get inputMetadata() {
        return this.handler.inputMetadata;
      }
      get outputMetadata() {
        return this.handler.outputMetadata;
      }
    };
  }
});

// common/dist/esm/inference-session.js
var InferenceSession2;
var init_inference_session = __esm({
  "common/dist/esm/inference-session.js"() {
    "use strict";
    init_inference_session_impl();
    InferenceSession2 = InferenceSession;
  }
});

// common/dist/esm/tensor-conversion.js
var init_tensor_conversion = __esm({
  "common/dist/esm/tensor-conversion.js"() {
    "use strict";
  }
});

// common/dist/esm/tensor-factory.js
var init_tensor_factory = __esm({
  "common/dist/esm/tensor-factory.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-model.js
var init_onnx_model = __esm({
  "common/dist/esm/onnx-model.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-value.js
var init_onnx_value = __esm({
  "common/dist/esm/onnx-value.js"() {
    "use strict";
  }
});

// common/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  InferenceSession: () => InferenceSession2,
  TRACE: () => TRACE,
  TRACE_EVENT_BEGIN: () => TRACE_EVENT_BEGIN,
  TRACE_EVENT_END: () => TRACE_EVENT_END,
  TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
  TRACE_FUNC_END: () => TRACE_FUNC_END,
  Tensor: () => Tensor2,
  env: () => env2,
  registerBackend: () => registerBackend
});
var init_esm = __esm({
  "common/dist/esm/index.js"() {
    "use strict";
    init_backend();
    init_env();
    init_inference_session();
    init_tensor();
    init_tensor_conversion();
    init_tensor_factory();
    init_trace();
    init_onnx_model();
    init_onnx_value();
  }
});

// web/lib/wasm/wasm-utils-env.ts
var isNode;
var init_wasm_utils_env = __esm({
  "web/lib/wasm/wasm-utils-env.ts"() {
    "use strict";
    isNode = false;
  }
});

// web/lib/wasm/proxy-worker/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
var WORKER_NAME, isProxyWorker, main_default;
var init_main = __esm({
  "web/lib/wasm/proxy-worker/main.ts"() {
    "use strict";
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    WORKER_NAME = "ort-wasm-proxy-worker";
    isProxyWorker = globalThis.self?.name === WORKER_NAME;
    if (isProxyWorker) {
      self.onmessage = (ev) => {
        const { type, in: message } = ev.data;
        try {
          switch (type) {
            case "init-wasm":
              initializeWebAssembly(message.wasm).then(
                () => {
                  initRuntime(message).then(
                    () => {
                      postMessage({ type });
                    },
                    (err) => {
                      postMessage({ type, err });
                    }
                  );
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            case "init-ep": {
              const { epName, env: env3 } = message;
              initEp(env3, epName).then(
                () => {
                  postMessage({ type });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "copy-from": {
              const { buffer } = message;
              const bufferData = copyFromExternalBuffer(buffer);
              postMessage({ type, out: bufferData });
              break;
            }
            case "create": {
              const { model, options } = message;
              createSession(model, options).then(
                (sessionMetadata) => {
                  postMessage({ type, out: sessionMetadata });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "release":
              releaseSession(message);
              postMessage({ type });
              break;
            case "run": {
              const { sessionId, inputIndices, inputs, outputIndices, options } = message;
              run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                (outputs) => {
                  if (outputs.some((o) => o[3] !== "cpu")) {
                    postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                  } else {
                    postMessage(
                      { type, out: outputs },
                      extractTransferableBuffers([...inputs, ...outputs])
                    );
                  }
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "end-profiling":
              endProfiling(message);
              postMessage({ type });
              break;
            default:
          }
        } catch (err) {
          postMessage({ type, err });
        }
      };
    }
    main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: true ? "module" : "classic", name: WORKER_NAME });
  }
});

// web/lib/wasm/wasm-utils-import.ts
var origin, isEsmImportMetaUrlHardcodedAsFileUri, getScriptSrc, scriptSrc, inferWasmPathPrefixFromScriptSrc, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
var init_wasm_utils_import = __esm({
  "web/lib/wasm/wasm-utils-import.ts"() {
    "use strict";
    init_wasm_utils_env();
    origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
    isEsmImportMetaUrlHardcodedAsFileUri = import.meta.url > "file:" && import.meta.url < "file;";
    getScriptSrc = () => {
      if (isNode) {
        return void 0;
      }
      if (true) {
        if (isEsmImportMetaUrlHardcodedAsFileUri) {
          const URL2 = URL;
          return new URL(new URL2("ort.mjs", import.meta.url).href, origin).href;
        }
        return import.meta.url;
      }
      return typeof document !== "undefined" ? document.currentScript?.src : (
        // use `self.location.href` if available
        typeof self !== "undefined" ? self.location?.href : void 0
      );
    };
    scriptSrc = getScriptSrc();
    inferWasmPathPrefixFromScriptSrc = () => {
      if (scriptSrc && !scriptSrc.startsWith("blob:")) {
        return scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
      }
      return void 0;
    };
    isSameOrigin = (filename, prefixOverride) => {
      try {
        const baseUrl = prefixOverride ?? scriptSrc;
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.origin === origin;
      } catch {
        return false;
      }
    };
    normalizeUrl = (filename, prefixOverride) => {
      const baseUrl = prefixOverride ?? scriptSrc;
      try {
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.href;
      } catch {
        return void 0;
      }
    };
    fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
    preload = async (absoluteUrl) => {
      const response = await fetch(absoluteUrl, { credentials: "same-origin" });
      const blob = await response.blob();
      return URL.createObjectURL(blob);
    };
    dynamicImportDefault = async (url) => (await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      url
    )).default;
    createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
    false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
    importProxyWorker = async () => {
      if (!scriptSrc) {
        throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
      }
      if (isSameOrigin(scriptSrc)) {
        return [void 0, createProxyWorker()];
      }
      const url = await preload(scriptSrc);
      return [url, createProxyWorker(url)];
    };
    embeddedWasmModule = false ? (
      // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      (true ? null : false ? null : false ? null : null).default
    ) : void 0;
    importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded, isWasmOverridden) => {
      let useEmbeddedModule = embeddedWasmModule && !(urlOverride || prefixOverride);
      if (useEmbeddedModule) {
        if (!scriptSrc) {
          if (isWasmOverridden && !isMultiThreaded) {
            useEmbeddedModule = true;
          } else {
            throw new Error("cannot determine the script source URL.");
          }
        } else {
          useEmbeddedModule = isSameOrigin(scriptSrc);
        }
      }
      if (useEmbeddedModule) {
        return [void 0, embeddedWasmModule];
      } else {
        const wasmModuleFilename = true ? "ort-wasm-simd-threaded.jsep.mjs" : false ? "ort-wasm-simd-threaded.jspi.mjs" : false ? "ort-wasm-simd-threaded.asyncify.mjs" : "ort-wasm-simd-threaded.mjs";
        const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
        const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
        const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
        return [needPreload ? url : void 0, await dynamicImportDefault(url)];
      }
    };
  }
});

// web/lib/wasm/wasm-factory.ts
var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, isRelaxedSimdSupported, initializeWebAssembly, getInstance;
var init_wasm_factory = __esm({
  "web/lib/wasm/wasm-factory.ts"() {
    "use strict";
    init_wasm_utils_import();
    initialized = false;
    initializing = false;
    aborted = false;
    isMultiThreadSupported = () => {
      if (typeof SharedArrayBuffer === "undefined") {
        return false;
      }
      try {
        if (typeof MessageChannel !== "undefined") {
          new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        }
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            5,
            4,
            1,
            3,
            1,
            1,
            10,
            11,
            1,
            9,
            0,
            65,
            0,
            254,
            16,
            2,
            0,
            26,
            11
          ])
        );
      } catch {
        return false;
      }
    };
    isSimdSupported = () => {
      try {
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            10,
            30,
            1,
            28,
            0,
            65,
            0,
            253,
            15,
            253,
            12,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            253,
            186,
            1,
            26,
            11
          ])
        );
      } catch {
        return false;
      }
    };
    isRelaxedSimdSupported = () => {
      try {
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            5,
            1,
            96,
            0,
            1,
            123,
            3,
            2,
            1,
            0,
            10,
            19,
            1,
            17,
            0,
            65,
            1,
            253,
            15,
            65,
            2,
            253,
            15,
            65,
            3,
            253,
            15,
            253,
            147,
            2,
            11
          ])
        );
      } catch {
        return false;
      }
    };
    initializeWebAssembly = async (flags) => {
      if (initialized) {
        return Promise.resolve();
      }
      if (initializing) {
        throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
      }
      if (aborted) {
        throw new Error("previous call to 'initializeWebAssembly()' failed.");
      }
      initializing = true;
      const timeout = flags.initTimeout;
      let numThreads = flags.numThreads;
      if (flags.simd === false) {
      } else if (flags.simd === "relaxed") {
        if (!isRelaxedSimdSupported()) {
          throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.");
        }
      } else if (!isSimdSupported()) {
        throw new Error("WebAssembly SIMD is not supported in the current environment.");
      }
      if (false) {
        if (!("Suspending" in WebAssembly)) {
          throw new Error("WebAssembly JSPI is not supported in the current environment.");
        }
      }
      const multiThreadSupported = isMultiThreadSupported();
      if (numThreads > 1 && !multiThreadSupported) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          console.warn(
            "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
          );
        }
        console.warn(
          "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
        );
        flags.numThreads = numThreads = 1;
      }
      const wasmPaths = flags.wasmPaths;
      const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
      const mjsPathOverrideFlag = wasmPaths?.mjs;
      const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
      const wasmPathOverrideFlag = wasmPaths?.wasm;
      const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
      const wasmBinaryOverride = flags.wasmBinary;
      const [objectUrl, ortWasmFactory] = await importWasmModule(
        mjsPathOverride,
        wasmPrefixOverride,
        numThreads > 1,
        !!wasmBinaryOverride || !!wasmPathOverride
      );
      let isTimeout = false;
      const tasks = [];
      if (timeout > 0) {
        tasks.push(
          new Promise((resolve) => {
            setTimeout(() => {
              isTimeout = true;
              resolve();
            }, timeout);
          })
        );
      }
      tasks.push(
        new Promise((resolve, reject) => {
          const config = {
            /**
             * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
             * created.
             */
            numThreads
          };
          if (wasmBinaryOverride) {
            config.wasmBinary = wasmBinaryOverride;
          } else if (wasmPathOverride || wasmPrefixOverride) {
            config.locateFile = (fileName) => wasmPathOverride ?? wasmPrefixOverride + fileName;
          } else if (mjsPathOverride && mjsPathOverride.indexOf("blob:") !== 0) {
            config.locateFile = (fileName) => new URL(fileName, mjsPathOverride).href;
          } else if (objectUrl) {
            const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
            if (inferredWasmPathPrefix) {
              config.locateFile = (fileName) => inferredWasmPathPrefix + fileName;
            }
          }
          ortWasmFactory(config).then(
            // wasm module initialized successfully
            (module) => {
              initializing = false;
              initialized = true;
              wasm = module;
              resolve();
              if (objectUrl) {
                URL.revokeObjectURL(objectUrl);
              }
            },
            // wasm module failed to initialize
            (what) => {
              initializing = false;
              aborted = true;
              reject(what);
            }
          );
        })
      );
      await Promise.race(tasks);
      if (isTimeout) {
        throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
      }
    };
    getInstance = () => {
      if (initialized && wasm) {
        return wasm;
      }
      throw new Error("WebAssembly is not initialized yet.");
    };
  }
});

// web/lib/wasm/wasm-utils.ts
var allocWasmString, iterateExtraOptions, checkLastError;
var init_wasm_utils = __esm({
  "web/lib/wasm/wasm-utils.ts"() {
    "use strict";
    init_wasm_factory();
    allocWasmString = (data, allocs) => {
      const wasm2 = getInstance();
      const dataLength = wasm2.lengthBytesUTF8(data) + 1;
      const dataOffset = wasm2._malloc(dataLength);
      wasm2.stringToUTF8(data, dataOffset, dataLength);
      allocs.push(dataOffset);
      return dataOffset;
    };
    iterateExtraOptions = (options, prefix, seen, handler) => {
      if (typeof options == "object" && options !== null) {
        if (seen.has(options)) {
          throw new Error("Circular reference in options");
        } else {
          seen.add(options);
        }
      }
      Object.entries(options).forEach(([key, value]) => {
        const name = prefix ? prefix + key : key;
        if (typeof value === "object") {
          iterateExtraOptions(value, name + ".", seen, handler);
        } else if (typeof value === "string" || typeof value === "number") {
          handler(name, value.toString());
        } else if (typeof value === "boolean") {
          handler(name, value ? "1" : "0");
        } else {
          throw new Error(`Can't handle extra config type: ${typeof value}`);
        }
      });
    };
    checkLastError = (message) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const ptrSize = wasm2.PTR_SIZE;
        const paramsOffset = wasm2.stackAlloc(2 * ptrSize);
        wasm2._OrtGetLastError(paramsOffset, paramsOffset + ptrSize);
        const errorCode = Number(wasm2.getValue(paramsOffset, ptrSize === 4 ? "i32" : "i64"));
        const errorMessagePointer = wasm2.getValue(paramsOffset + ptrSize, "*");
        const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
        throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
  }
});

// web/lib/wasm/run-options.ts
var setRunOptions;
var init_run_options = __esm({
  "web/lib/wasm/run-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    setRunOptions = (options) => {
      const wasm2 = getInstance();
      let runOptionsHandle = 0;
      const allocs = [];
      const runOptions = options || {};
      try {
        if (options?.logSeverityLevel === void 0) {
          runOptions.logSeverityLevel = 2;
        } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
          throw new Error(`log severity level is not valid: ${options.logSeverityLevel}`);
        }
        if (options?.logVerbosityLevel === void 0) {
          runOptions.logVerbosityLevel = 0;
        } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
          throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
        }
        if (options?.terminate === void 0) {
          runOptions.terminate = false;
        }
        let tagDataOffset = 0;
        if (options?.tag !== void 0) {
          tagDataOffset = allocWasmString(options.tag, allocs);
        }
        runOptionsHandle = wasm2._OrtCreateRunOptions(
          runOptions.logSeverityLevel,
          runOptions.logVerbosityLevel,
          !!runOptions.terminate,
          tagDataOffset
        );
        if (runOptionsHandle === 0) {
          checkLastError("Can't create run options.");
        }
        if (options?.extra !== void 0) {
          iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
            }
          });
        }
        return [runOptionsHandle, allocs];
      } catch (e) {
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/session-options.ts
var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, appendSessionConfig, setExecutionProviders, setSessionOptions;
var init_session_options = __esm({
  "web/lib/wasm/session-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    getGraphOptimzationLevel = (graphOptimizationLevel) => {
      switch (graphOptimizationLevel) {
        case "disabled":
          return 0;
        case "basic":
          return 1;
        case "extended":
          return 2;
        case "layout":
          return 3;
        case "all":
          return 99;
        default:
          throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
      }
    };
    getExecutionMode = (executionMode) => {
      switch (executionMode) {
        case "sequential":
          return 0;
        case "parallel":
          return 1;
        default:
          throw new Error(`unsupported execution mode: ${executionMode}`);
      }
    };
    appendDefaultOptions = (options) => {
      if (!options.extra) {
        options.extra = {};
      }
      if (!options.extra.session) {
        options.extra.session = {};
      }
      const session = options.extra.session;
      if (!session.use_ort_model_bytes_directly) {
        session.use_ort_model_bytes_directly = "1";
      }
      if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
        options.enableMemPattern = false;
      }
    };
    appendSessionConfig = (sessionOptionsHandle, key, value, allocs) => {
      const keyDataOffset = allocWasmString(key, allocs);
      const valueDataOffset = allocWasmString(value, allocs);
      if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
        checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
      }
    };
    setExecutionProviders = async (sessionOptionsHandle, sessionOptions, allocs) => {
      const executionProviders = sessionOptions.executionProviders;
      for (const ep of executionProviders) {
        let epName = typeof ep === "string" ? ep : ep.name;
        const epOptions = [];
        switch (epName) {
          case "webnn":
            epName = "WEBNN";
            if (typeof ep !== "string") {
              const webnnOptions = ep;
              const deviceType = webnnOptions?.deviceType;
              if (deviceType) {
                appendSessionConfig(sessionOptionsHandle, "deviceType", deviceType, allocs);
              }
            }
            break;
          case "webgpu":
            if (false) {
              epName = "WebGPU";
              let customDevice;
              if (typeof ep !== "string") {
                const webgpuOptions = ep;
                if (webgpuOptions.device) {
                  if (typeof GPUDevice !== "undefined" && webgpuOptions.device instanceof GPUDevice) {
                    customDevice = webgpuOptions.device;
                  } else {
                    throw new Error("Invalid GPU device set in WebGPU EP options.");
                  }
                }
                const { enableGraphCapture } = sessionOptions;
                if (typeof enableGraphCapture === "boolean" && enableGraphCapture) {
                  appendEpOption(epOptions, "enableGraphCapture", "1", allocs);
                }
                if (typeof webgpuOptions.preferredLayout === "string") {
                  appendEpOption(epOptions, "preferredLayout", webgpuOptions.preferredLayout, allocs);
                }
                if (webgpuOptions.forceCpuNodeNames) {
                  const names = Array.isArray(webgpuOptions.forceCpuNodeNames) ? webgpuOptions.forceCpuNodeNames : [webgpuOptions.forceCpuNodeNames];
                  appendEpOption(epOptions, "forceCpuNodeNames", names.join("\n"), allocs);
                }
                if (webgpuOptions.validationMode) {
                  appendEpOption(epOptions, "validationMode", webgpuOptions.validationMode, allocs);
                }
              }
              const info = getInstance().webgpuRegisterDevice(customDevice);
              if (info) {
                const [deviceId, instanceHandle, deviceHandle] = info;
                appendEpOption(epOptions, "deviceId", deviceId.toString(), allocs);
                appendEpOption(epOptions, "webgpuInstance", instanceHandle.toString(), allocs);
                appendEpOption(epOptions, "webgpuDevice", deviceHandle.toString(), allocs);
              }
            } else {
              epName = "JS";
              if (typeof ep !== "string") {
                const webgpuOptions = ep;
                if (webgpuOptions?.preferredLayout) {
                  if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                    throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                  }
                  appendSessionConfig(sessionOptionsHandle, "preferredLayout", webgpuOptions.preferredLayout, allocs);
                }
              }
            }
            break;
          case "wasm":
          case "cpu":
            continue;
          default:
            throw new Error(`not supported execution provider: ${epName}`);
        }
        const epNameDataOffset = allocWasmString(epName, allocs);
        const epOptionsCount = epOptions.length;
        let keysOffset = 0;
        let valuesOffset = 0;
        if (epOptionsCount > 0) {
          keysOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
          allocs.push(keysOffset);
          valuesOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
          allocs.push(valuesOffset);
          for (let i = 0; i < epOptionsCount; i++) {
            getInstance().setValue(keysOffset + i * getInstance().PTR_SIZE, epOptions[i][0], "*");
            getInstance().setValue(valuesOffset + i * getInstance().PTR_SIZE, epOptions[i][1], "*");
          }
        }
        if (await getInstance()._OrtAppendExecutionProvider(
          sessionOptionsHandle,
          epNameDataOffset,
          keysOffset,
          valuesOffset,
          epOptionsCount
        ) !== 0) {
          checkLastError(`Can't append execution provider: ${epName}.`);
        }
      }
    };
    setSessionOptions = async (options) => {
      const wasm2 = getInstance();
      let sessionOptionsHandle = 0;
      const allocs = [];
      const sessionOptions = options || {};
      appendDefaultOptions(sessionOptions);
      try {
        const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
        const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
        const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
        const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
        if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
          throw new Error(`log severity level is not valid: ${logSeverityLevel}`);
        }
        const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
        if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
          throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
        }
        const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
        sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
          graphOptimizationLevel,
          !!sessionOptions.enableCpuMemArena,
          !!sessionOptions.enableMemPattern,
          executionMode,
          !!sessionOptions.enableProfiling,
          0,
          logIdDataOffset,
          logSeverityLevel,
          logVerbosityLevel,
          optimizedModelFilePathOffset
        );
        if (sessionOptionsHandle === 0) {
          checkLastError("Can't create session options.");
        }
        if (sessionOptions.executionProviders) {
          await setExecutionProviders(sessionOptionsHandle, sessionOptions, allocs);
        }
        if (sessionOptions.enableGraphCapture !== void 0) {
          if (typeof sessionOptions.enableGraphCapture !== "boolean") {
            throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
          }
          appendSessionConfig(
            sessionOptionsHandle,
            "enableGraphCapture",
            sessionOptions.enableGraphCapture.toString(),
            allocs
          );
        }
        if (sessionOptions.freeDimensionOverrides) {
          for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
            if (typeof name !== "string") {
              throw new Error(`free dimension override name must be a string: ${name}`);
            }
            if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
              throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
            }
            const nameOffset = allocWasmString(name, allocs);
            if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
              checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
            }
          }
        }
        if (sessionOptions.extra !== void 0) {
          iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            appendSessionConfig(sessionOptionsHandle, key, value, allocs);
          });
        }
        return [sessionOptionsHandle, allocs];
      } catch (e) {
        if (sessionOptionsHandle !== 0) {
          if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
            checkLastError("Can't release session options.");
          }
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/wasm-common.ts
var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, isMLTensorSupportedType, dataLocationStringToEnum;
var init_wasm_common = __esm({
  "web/lib/wasm/wasm-common.ts"() {
    "use strict";
    tensorDataTypeStringToEnum = (type) => {
      switch (type) {
        case "int8":
          return 3 /* int8 */;
        case "uint8":
          return 2 /* uint8 */;
        case "bool":
          return 9 /* bool */;
        case "int16":
          return 5 /* int16 */;
        case "uint16":
          return 4 /* uint16 */;
        case "int32":
          return 6 /* int32 */;
        case "uint32":
          return 12 /* uint32 */;
        case "float16":
          return 10 /* float16 */;
        case "float32":
          return 1 /* float */;
        case "float64":
          return 11 /* double */;
        case "string":
          return 8 /* string */;
        case "int64":
          return 7 /* int64 */;
        case "uint64":
          return 13 /* uint64 */;
        case "int4":
          return 22 /* int4 */;
        case "uint4":
          return 21 /* uint4 */;
        default:
          throw new Error(`unsupported data type: ${type}`);
      }
    };
    tensorDataTypeEnumToString = (typeProto) => {
      switch (typeProto) {
        case 3 /* int8 */:
          return "int8";
        case 2 /* uint8 */:
          return "uint8";
        case 9 /* bool */:
          return "bool";
        case 5 /* int16 */:
          return "int16";
        case 4 /* uint16 */:
          return "uint16";
        case 6 /* int32 */:
          return "int32";
        case 12 /* uint32 */:
          return "uint32";
        case 10 /* float16 */:
          return "float16";
        case 1 /* float */:
          return "float32";
        case 11 /* double */:
          return "float64";
        case 8 /* string */:
          return "string";
        case 7 /* int64 */:
          return "int64";
        case 13 /* uint64 */:
          return "uint64";
        case 22 /* int4 */:
          return "int4";
        case 21 /* uint4 */:
          return "uint4";
        default:
          throw new Error(`unsupported data type: ${typeProto}`);
      }
    };
    calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
      const elementSize = [
        -1,
        // undefined = 0
        4,
        // float = 1
        1,
        // uint8 = 2
        1,
        // int8 = 3
        2,
        // uint16 = 4
        2,
        // int16 = 5
        4,
        // int32 = 6
        8,
        // int64 = 7
        -1,
        // string = 8
        1,
        // bool = 9
        2,
        // float16 = 10
        8,
        // double = 11
        4,
        // uint32 = 12
        8,
        // uint64 = 13
        -1,
        // complex64 = 14
        -1,
        // complex128 = 15
        -1,
        // bfloat16 = 16
        -1,
        // FLOAT8E4M3FN = 17
        -1,
        // FLOAT8E4M3FNUZ = 18
        -1,
        // FLOAT8E5M2 = 19
        -1,
        // FLOAT8E5M2FNUZ = 20
        0.5,
        // uint4 = 21
        0.5
        // int4 = 22
      ][dateType];
      const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
      return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
    };
    tensorTypeToTypedArrayConstructor = (type) => {
      switch (type) {
        case "float16":
          return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
        case "float32":
          return Float32Array;
        case "uint8":
          return Uint8Array;
        case "int8":
          return Int8Array;
        case "uint16":
          return Uint16Array;
        case "int16":
          return Int16Array;
        case "int32":
          return Int32Array;
        case "bool":
          return Uint8Array;
        case "float64":
          return Float64Array;
        case "uint32":
          return Uint32Array;
        case "int64":
          return BigInt64Array;
        case "uint64":
          return BigUint64Array;
        default:
          throw new Error(`unsupported type: ${type}`);
      }
    };
    logLevelStringToEnum = (logLevel) => {
      switch (logLevel) {
        case "verbose":
          return 0;
        case "info":
          return 1;
        case "warning":
          return 2;
        case "error":
          return 3;
        case "fatal":
          return 4;
        default:
          throw new Error(`unsupported logging level: ${logLevel}`);
      }
    };
    isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
    isMLTensorSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint64" || type === "int8" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
    dataLocationStringToEnum = (location2) => {
      switch (location2) {
        case "none":
          return 0;
        case "cpu":
          return 1;
        case "cpu-pinned":
          return 2;
        case "texture":
          return 3;
        case "gpu-buffer":
          return 4;
        case "ml-tensor":
          return 5;
        default:
          throw new Error(`unsupported data location: ${location2}`);
      }
    };
  }
});

// web/lib/wasm/wasm-utils-load-file.ts
var loadFile;
var init_wasm_utils_load_file = __esm({
  "web/lib/wasm/wasm-utils-load-file.ts"() {
    "use strict";
    init_wasm_utils_env();
    loadFile = async (file) => {
      if (typeof file === "string") {
        if (isNode) {
          try {
            const { readFile } = __require("node:fs/promises");
            return new Uint8Array(await readFile(file));
          } catch (e) {
            if (e.code === "ERR_FS_FILE_TOO_LARGE") {
              const { createReadStream } = __require("node:fs");
              const stream = createReadStream(file);
              const chunks = [];
              for await (const chunk of stream) {
                chunks.push(chunk);
              }
              return new Uint8Array(Buffer.concat(chunks));
            }
            throw e;
          }
        } else {
          const response = await fetch(file);
          if (!response.ok) {
            throw new Error(`failed to load external data file: ${file}`);
          }
          const contentLengthHeader = response.headers.get("Content-Length");
          const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
          if (fileSize < 1073741824) {
            return new Uint8Array(await response.arrayBuffer());
          } else {
            if (!response.body) {
              throw new Error(`failed to load external data file: ${file}, no response body.`);
            }
            const reader = response.body.getReader();
            let buffer;
            try {
              buffer = new ArrayBuffer(fileSize);
            } catch (e) {
              if (e instanceof RangeError) {
                const pages = Math.ceil(fileSize / 65536);
                buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
              } else {
                throw e;
              }
            }
            let offset = 0;
            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              const chunkSize = value.byteLength;
              const chunk = new Uint8Array(buffer, offset, chunkSize);
              chunk.set(value);
              offset += chunkSize;
            }
            return new Uint8Array(buffer, 0, fileSize);
          }
        }
      } else if (file instanceof Blob) {
        return new Uint8Array(await file.arrayBuffer());
      } else if (file instanceof Uint8Array) {
        return file;
      } else {
        return new Uint8Array(file);
      }
    };
  }
});

// web/lib/wasm/jsep/log.ts
var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
var init_log = __esm({
  "web/lib/wasm/jsep/log.ts"() {
    "use strict";
    init_wasm_common();
    logLevelPrefix = ["V", "I", "W", "E", "F"];
    doLog = (level, message) => {
      console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
    };
    configureLogger = ($configLogLevel, $debug) => {
      configLogLevel = $configLogLevel;
      debug = $debug;
    };
    LOG = (logLevel, msg) => {
      const messageLevel = logLevelStringToEnum(logLevel);
      const configLevel = logLevelStringToEnum(configLogLevel);
      if (messageLevel >= configLevel) {
        doLog(messageLevel, typeof msg === "function" ? msg() : msg);
      }
    };
    LOG_DEBUG = (...args) => {
      if (debug) {
        LOG(...args);
      }
    };
  }
});

// web/lib/wasm/jsep/util.ts
var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
var init_util = __esm({
  "web/lib/wasm/jsep/util.ts"() {
    "use strict";
    MatMulUtil = class {
      /**
       * Calculate the expected shape when matrix multiplication
       * @param a The shape of tensor A. Should be a tuple of 2 positive integers
       * @param b The shape of tensor B. Should be a tuple of 2 positive integers
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcMatMulShape(a, b) {
        return a[1] !== b[0] ? void 0 : [a[0], b[1]];
      }
    };
    BroadcastUtil = class {
      /**
       * Calculate the expected shape when broadcasting 2 tensors
       * @param a The shape of tensor A. Should be an array of positive integers
       * @param b The shape of tensor B. Should be an array of positive integers
       * @param isMatMul Whether the operation is MatMul
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcShape(adims, bdims, isMatMul = false) {
        const arank = adims.length;
        const brank = bdims.length;
        if (arank === 0) {
          return bdims;
        }
        if (brank === 0) {
          return adims;
        }
        const crank = Math.max(adims.length, bdims.length);
        const cdims = new Array(crank);
        if (isMatMul) {
          if (arank < 2 || brank < 2) {
            return void 0;
          }
          const cShapeMatMul = MatMulUtil.calcMatMulShape(
            [adims[arank - 2], adims[arank - 1]],
            [bdims[brank - 2], bdims[brank - 1]]
          );
          if (cShapeMatMul === void 0) {
            return void 0;
          }
          [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
        }
        for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
          const aLen = arank - i < 0 ? 1 : adims[arank - i];
          const bLen = brank - i < 0 ? 1 : bdims[brank - i];
          if (aLen !== bLen && aLen > 1 && bLen > 1) {
            return void 0;
          }
          const max = Math.max(aLen, bLen);
          if (aLen && bLen) {
            cdims[crank - i] = Math.max(aLen, bLen);
          } else {
            if (max > 1) {
              return void 0;
            }
            cdims[crank - i] = 0;
          }
        }
        return cdims;
      }
      /**
       * Determine if a shape is unidirectional broadcastable to another shape
       * @param shape The input shape
       * @param finalShape The desired shape after broadcasting
       */
      static isValidBroadcast(shape, finalShape) {
        const inputRank = shape.length;
        const finalRank = finalShape.length;
        if (inputRank > finalRank) {
          return false;
        }
        for (let i = 1; i <= inputRank; i++) {
          if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
            return false;
          }
        }
        return true;
      }
    };
    ShapeUtil = class _ShapeUtil {
      /**
       * calculate the size (number of elements)
       */
      static size(dims) {
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
      }
      /**
       * convert dims corresponding to type change to pack. ex. uint8 data to uint32
       */
      static convertShape(dims, size = 4) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        }
        const newDims = new Array(rank);
        let i = rank - 1;
        while (i >= 0) {
          if (dims[i] % size === 0) {
            newDims[i] = dims[i] / size;
            break;
          }
          if (size % dims[i] !== 0) {
            throw new Error("cannot convert shape");
          }
          newDims[i] = 1;
          size /= dims[i];
          i--;
        }
        for (i--; i >= 0; i--) {
          newDims[i] = dims[i];
        }
        return newDims;
      }
      /**
       * calculate the size (number of elements) from the given axis (inclusive)
       */
      static sizeFromDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
      }
      /**
       * calculate the size (number of elements) to the given axis (exclusive)
       */
      static sizeToDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
      }
      /**
       * calculate the size (number of elements) from and to the given axis [start, end)
       */
      static getSizeFromDimensionRange(dims, start, end) {
        let size = 1;
        for (let i = start; i < end; i++) {
          if (dims[i] < 0) {
            throw new Error(
              "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
            );
          }
          size *= Number(dims[i]);
        }
        return size;
      }
      static computeStrides(dims) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [1];
        }
        const strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
      }
      /**
       * normalize axis of range [-r, r) into [0, r).
       */
      static normalizeAxis(axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
          throw new Error("unsupported axis for this operation.");
        }
        return axis < 0 ? axis + tensorRank : axis;
      }
      static normalizeAxes(axes, tensorRank) {
        return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
      }
      /**
       * Sorts a given array based on the indices in the Perm array
       * Used in Transpose
       * @param a Array to be sorted such as dims or strides
       * @param perm Perm given; if null a will be reversed
       */
      static sortBasedOnPerm(a, perm) {
        if (perm) {
          return perm.map((v) => a[v]);
        } else {
          return a.slice().reverse();
        }
      }
      /**
       * Pads a given shape according to the padding values
       * @param dims shape of the Tensor to be padded
       * @param pad pad values
       */
      static padShape(dims, pad2) {
        const rank = dims.length;
        return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
      }
      /**
       * Determines if the two shapes are identical
       * @param shape1
       * @param shape2
       */
      static areEqual(shape1, shape2) {
        if (shape1.length !== shape2.length) {
          return false;
        }
        return shape1.every((v, i) => v === shape2[i]);
      }
    };
    PoolConvUtil = class _PoolConvUtil {
      /**
       * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension.
       * @param kernelShape The size of the kernel along each axis.
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       */
      static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
        }
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            if (dim >= kernelShape.length) {
              kernelShape.push(inputDims[dim + 2]);
            } else {
              kernelShape[dim] = inputDims[dim + 2];
            }
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < strides.length) {
            if (strides[dim] < 0) {
              throw new Error("strides should be greater than or equal to 1");
            }
          } else {
            strides.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < dilations.length) {
            if (dilations[dim] < 0) {
              throw new Error("dilations should be greater than or equal to 1");
            }
          } else {
            dilations.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length * 2; dim++) {
          if (dim < pads.length) {
            if (pads[dim] < 0) {
              throw new Error("pad should be greater than or equal to 1");
            }
          } else {
            pads.push(0);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (kernelShape[dim] <= 0) {
            throw new Error("kernel shapes need to be greater than 0");
          }
          if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
            throw new Error("pads should be smaller than kernel");
          }
        }
      }
      // adjust pad values based on 'autoPad' attribute
      static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
        if (!autoPad) {
          return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
          throw new Error("length of pads should be twice the length of data dimensions");
        }
        if (strides.length !== inputDims.length - 2) {
          throw new Error("length of strides should be the length of data dimensions");
        }
        if (kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of kernel shapes should be the length of data dimensions");
        }
        for (let dim = 0; dim < inputDims.length - 2; dim++) {
          _PoolConvUtil.adjustPadAndReturnShape(
            inputDims[dim + (isChannelLast ? 1 : 2)],
            strides[dim],
            dilations[dim],
            kernelShape[dim],
            pads,
            dim,
            dim + inputDims.length - 2,
            autoPad
          );
        }
      }
      /**
       * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
          throw new Error("input shape must be of size greater than 0");
        }
        const outputDims = [inputDims[0], inputDims[1]];
        _PoolConvUtil.computeShapeHelper(
          isGlobalOperator,
          inputDims,
          outputDims,
          strides,
          dilations,
          kernelShape,
          pads,
          autoPad
        );
        return outputDims;
      }
      /**
       * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param filterDims The filter tensor dimension. (inputs[1].dims)
       * @param strides Stride along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
          throw new Error("invalid input tensor dims or invalid filter tensor dims");
        }
        const outputDims = [inputDims[0], filterDims[0]];
        _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
      }
      // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
      // called by computePoolOutputShape() and computeConvOutputShape()
      // adjust pads based on 'autoPad' attribute prior to shape computation
      static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(1);
          }
        } else {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(
              _PoolConvUtil.adjustPadAndReturnShape(
                inputDims[dim + 2],
                strides[dim],
                dilations[dim],
                kernelShape[dim],
                pads,
                dim,
                dim + inputDims.length - 2,
                autoPad
              )
            );
          }
        }
      }
      // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
      // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
      static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        const dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== "NOTSET") {
          switch (autoPad) {
            case "VALID":
              pads[padHeadIndex] = 0;
              pads[padTailIndex] = 0;
              return Math.floor((inSize - dkernel) / stride + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (dilation !== 1) {
                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              } else {
                const legacyTargetSize = (inSize + stride - 1) / stride;
                const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                return Math.floor((inSize + padNeeded - kernel) / stride + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        } else {
          return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
        }
      }
    };
    GemmUtil = class {
      // will make sure input shapes are compatible for this op
      // and return back the shape of the output in the form of a tuple
      // will throw exception if the input shapes are not compatible
      static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
          throw new Error("shape need to be of size 2");
        }
        let M;
        let K;
        let N;
        if (transLeft) {
          M = leftShape[1];
          K = leftShape[0];
        } else {
          M = leftShape[0];
          K = leftShape[1];
        }
        let kDim = -1;
        if (transRight) {
          N = rightShape[0];
          kDim = 1;
        } else {
          N = rightShape[1];
          kDim = 0;
        }
        if (rightShape[kDim] !== K) {
          throw new Error("dimension mismatch");
        }
        if (M <= 0 || N <= 0 || K <= 0) {
          throw new Error("invalid shape specified");
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
          throw new Error("gemm: invalid bias shape for broadcast");
        }
        return [M, N, K];
      }
    };
    MIN_CLIP = -34028234663852886e22;
    MAX_CLIP = 34028234663852886e22;
  }
});

// web/lib/wasm/jsep/tensor-view.ts
var createView;
var init_tensor_view = __esm({
  "web/lib/wasm/jsep/tensor-view.ts"() {
    "use strict";
    init_wasm_common();
    createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
  }
});

// web/lib/wasm/jsep/webnn/tensor-manager.ts
var webnnDataTypeToSize, convertDataToInt32, convertInt32ToData, tensorGuid, createNewTensorId, webnnDataTypeToFallback, calculateByteLength, TensorWrapper, TensorIdTracker, TensorManagerImpl, createTensorManager;
var init_tensor_manager = __esm({
  "web/lib/wasm/jsep/webnn/tensor-manager.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    webnnDataTypeToSize = /* @__PURE__ */ new Map([
      ["float32", 32],
      ["float16", 16],
      ["int32", 32],
      ["uint32", 32],
      ["int64", 64],
      ["uint64", 64],
      ["int8", 8],
      ["uint8", 8],
      ["int4", 4],
      ["uint4", 4]
    ]);
    convertDataToInt32 = (data, dataType) => {
      if (dataType === "int32") {
        return data;
      }
      const dataTypeSize = webnnDataTypeToSize.get(dataType);
      if (!dataTypeSize) {
        throw new Error(`WebNN backend does not support data type: ${dataType}`);
      }
      const bytesPerElement = dataTypeSize / 8;
      if (data.byteLength % bytesPerElement !== 0) {
        throw new Error(`Invalid Uint8Array length - must be a multiple of ${bytesPerElement}.`);
      }
      const numElements = data.byteLength / bytesPerElement;
      const originalArray = new (tensorTypeToTypedArrayConstructor(dataType))(data.buffer, data.byteOffset, numElements);
      switch (dataType) {
        case "int64":
        case "uint64": {
          const int32Array = new Int32Array(numElements);
          for (let i = 0; i < numElements; i++) {
            const value = originalArray[i];
            if (value > 2147483647n || value < -2147483648n) {
              throw new Error(`Can not convert int64 data to int32 - value out of range.`);
            }
            int32Array[i] = Number(value);
          }
          return new Uint8Array(int32Array.buffer);
        }
        case "int8":
        case "uint8":
        case "uint32": {
          if (dataType === "uint32") {
            if (originalArray.some((value) => value > 2147483647)) {
              throw new Error(`Can not convert uint32 data to int32 - value out of range.`);
            }
          }
          const int32Array = Int32Array.from(originalArray, Number);
          return new Uint8Array(int32Array.buffer);
        }
        default:
          throw new Error(`Unsupported data conversion from ${dataType} to 'int32'`);
      }
    };
    convertInt32ToData = (data, dataType) => {
      if (dataType === "int32") {
        return data;
      }
      if (data.byteLength % 4 !== 0) {
        throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");
      }
      const numElements = data.byteLength / 4;
      const int32Array = new Int32Array(data.buffer, data.byteOffset, numElements);
      switch (dataType) {
        case "int64": {
          const bigInt64Array = BigInt64Array.from(int32Array, BigInt);
          return new Uint8Array(bigInt64Array.buffer);
        }
        case "uint64": {
          if (int32Array.some((value) => value < 0)) {
            throw new Error("Can not convert int32 data to uin64 - negative value found.");
          }
          const bigUint64Array = BigUint64Array.from(int32Array, BigInt);
          return new Uint8Array(bigUint64Array.buffer);
        }
        case "int8": {
          if (int32Array.some((value) => value < -128 || value > 127)) {
            throw new Error("Can not convert int32 data to int8 - value out of range.");
          }
          const int8Array = Int8Array.from(int32Array, Number);
          return new Uint8Array(int8Array.buffer);
        }
        case "uint8": {
          if (int32Array.some((value) => value < 0 || value > 255)) {
            throw new Error("Can not convert int32 data to uint8 - value out of range.");
          }
          return Uint8Array.from(int32Array, Number);
        }
        case "uint32": {
          if (int32Array.some((value) => value < 0)) {
            throw new Error("Can not convert int32 data to uint32 - negative value found.");
          }
          const uint32Array = Uint32Array.from(int32Array, Number);
          return new Uint8Array(uint32Array.buffer);
        }
        default:
          throw new Error(`Unsupported data conversion from 'int32' to ${dataType}`);
      }
    };
    tensorGuid = 1;
    createNewTensorId = () => tensorGuid++;
    webnnDataTypeToFallback = /* @__PURE__ */ new Map([
      ["int8", "int32"],
      ["uint8", "int32"],
      ["uint32", "int32"],
      ["int64", "int32"]
    ]);
    calculateByteLength = (dataType, shape) => {
      const dataTypeSize = webnnDataTypeToSize.get(dataType);
      if (!dataTypeSize) {
        throw new Error(`WebNN backend does not support data type: ${dataType}`);
      }
      return shape.length > 0 ? Math.ceil(shape.reduce((a, b) => a * b) * dataTypeSize / 8) : 0;
    };
    TensorWrapper = class {
      constructor(descriptor) {
        // This flag is used to indicate whether the data has been converted to fallback data type.
        this.isDataConverted = false;
        const { sessionId, context, tensor, dataType, shape, fallbackDataType } = descriptor;
        this.sessionId = sessionId;
        this.mlContext = context;
        this.mlTensor = tensor;
        this.dataType = dataType;
        this.tensorShape = shape;
        this.fallbackDataType = fallbackDataType;
      }
      get tensor() {
        return this.mlTensor;
      }
      get type() {
        return this.dataType;
      }
      get fallbackType() {
        return this.fallbackDataType;
      }
      get shape() {
        return this.tensorShape;
      }
      get byteLength() {
        return calculateByteLength(this.dataType, this.tensorShape);
      }
      destroy() {
        LOG_DEBUG("verbose", () => "[WebNN] TensorWrapper.destroy");
        this.mlTensor.destroy();
      }
      write(data) {
        this.mlContext.writeTensor(this.mlTensor, data);
      }
      async read(dstBuffer) {
        if (this.fallbackDataType) {
          const data = await this.mlContext.readTensor(this.mlTensor);
          const originalData = convertInt32ToData(new Uint8Array(data), this.dataType);
          if (dstBuffer) {
            const targetBuffer = dstBuffer instanceof ArrayBuffer ? new Uint8Array(dstBuffer) : new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength);
            targetBuffer.set(originalData);
            return void 0;
          } else {
            return originalData.buffer;
          }
        } else {
          return dstBuffer ? this.mlContext.readTensor(this.mlTensor, dstBuffer) : this.mlContext.readTensor(this.mlTensor);
        }
      }
      canReuseTensor(context, dataType, shape) {
        return this.mlContext === context && this.dataType === dataType && this.tensorShape.length === shape.length && this.tensorShape.every((v, i) => v === shape[i]);
      }
      setIsDataConverted(isConverted) {
        this.isDataConverted = isConverted;
      }
    };
    TensorIdTracker = class {
      constructor(tensorManager, wrapper) {
        this.tensorManager = tensorManager;
        this.wrapper = wrapper;
      }
      get tensorWrapper() {
        return this.wrapper;
      }
      releaseTensor() {
        if (this.tensorWrapper) {
          this.tensorManager.releaseTensor(this.tensorWrapper);
          this.wrapper = void 0;
        }
      }
      async ensureTensor(sessionId, dataType, shape, copyOld) {
        const context = this.tensorManager.getMLContext(sessionId);
        const opLimits = this.tensorManager.getMLOpSupportLimits(sessionId);
        let fallbackDataType;
        if (!opLimits?.input.dataTypes.includes(dataType)) {
          fallbackDataType = webnnDataTypeToFallback.get(dataType);
          if (!fallbackDataType || opLimits?.input.dataTypes.includes(fallbackDataType)) {
            throw new Error(`WebNN backend does not support data type: ${dataType}`);
          }
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${dataType} to ${fallbackDataType}`
          );
        }
        if (this.wrapper) {
          if (this.wrapper.canReuseTensor(context, dataType, shape)) {
            return this.wrapper.tensor;
          } else {
            if (copyOld) {
              if (this.wrapper.byteLength !== calculateByteLength(dataType, shape)) {
                throw new Error("Unable to copy data to tensor with different size.");
              }
              this.activeUpload = new Uint8Array(await this.wrapper.read());
            }
            this.tensorManager.releaseTensor(this.wrapper);
          }
        }
        const usage = typeof MLTensorUsage == "undefined" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;
        this.wrapper = await this.tensorManager.getCachedTensor(
          sessionId,
          dataType,
          shape,
          usage,
          true,
          true,
          fallbackDataType
        );
        if (copyOld && this.activeUpload) {
          this.wrapper.write(this.activeUpload);
          this.activeUpload = void 0;
        }
        return this.wrapper.tensor;
      }
      upload(data) {
        let newData = data;
        if (this.wrapper) {
          if (this.wrapper.fallbackType) {
            if (this.wrapper.fallbackType === "int32") {
              newData = convertDataToInt32(data, this.wrapper.type);
              this.wrapper.setIsDataConverted(true);
            } else {
              throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);
            }
          }
          if (data.byteLength === this.wrapper.byteLength) {
            this.wrapper.write(newData);
            return;
          } else {
            LOG_DEBUG("verbose", () => "Data size does not match tensor size. Releasing tensor.");
            this.releaseTensor();
          }
        }
        if (this.activeUpload) {
          this.activeUpload.set(newData);
        } else {
          this.activeUpload = new Uint8Array(newData);
        }
      }
      async download(dstBuffer) {
        if (this.activeUpload) {
          const dstData = this.wrapper?.isDataConverted ? convertInt32ToData(this.activeUpload, this.wrapper?.type) : this.activeUpload;
          if (dstBuffer) {
            if (dstBuffer instanceof ArrayBuffer) {
              new Uint8Array(dstBuffer).set(dstData);
            } else {
              new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength).set(dstData);
            }
            return;
          } else {
            return dstData.buffer;
          }
        }
        if (!this.wrapper) {
          throw new Error("Tensor has not been created.");
        }
        if (!dstBuffer) {
          return this.wrapper.read();
        }
        return this.wrapper.read(dstBuffer);
      }
    };
    TensorManagerImpl = class {
      constructor(backend) {
        this.backend = backend;
        this.tensorTrackersById = /* @__PURE__ */ new Map();
        this.freeTensors = [];
        this.externalTensors = /* @__PURE__ */ new Set();
      }
      getMLContext(sessionId) {
        const context = this.backend.getMLContext(sessionId);
        if (!context) {
          throw new Error("MLContext not found for session.");
        }
        return context;
      }
      getMLOpSupportLimits(sessionId) {
        return this.backend.getMLOpSupportLimits(sessionId);
      }
      reserveTensorId() {
        const tensorId = createNewTensorId();
        this.tensorTrackersById.set(tensorId, new TensorIdTracker(this));
        return tensorId;
      }
      releaseTensorId(tensorId) {
        const tensorTracker = this.tensorTrackersById.get(tensorId);
        if (!tensorTracker) {
          return;
        }
        this.tensorTrackersById.delete(tensorId);
        if (tensorTracker.tensorWrapper) {
          this.releaseTensor(tensorTracker.tensorWrapper);
        }
      }
      async ensureTensor(sessionId, tensorId, dataType, shape, copyOld) {
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] TensorManager.ensureTensor {tensorId: ${tensorId}, dataType: ${dataType}, shape: ${shape}, copyOld: ${copyOld}}`
        );
        const tensor = this.tensorTrackersById.get(tensorId);
        if (!tensor) {
          throw new Error("Tensor not found.");
        }
        return tensor.ensureTensor(sessionId, dataType, shape, copyOld);
      }
      upload(tensorId, data) {
        const tensor = this.tensorTrackersById.get(tensorId);
        if (!tensor) {
          throw new Error("Tensor not found.");
        }
        tensor.upload(data);
      }
      async download(tensorId, dstBuffer) {
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] TensorManager.download {tensorId: ${tensorId}, dstBuffer: ${dstBuffer?.byteLength}}`
        );
        const tensorTracker = this.tensorTrackersById.get(tensorId);
        if (!tensorTracker) {
          throw new Error("Tensor not found.");
        }
        return tensorTracker.download(dstBuffer);
      }
      releaseTensorsForSession(sessionId) {
        for (const tensor of this.freeTensors) {
          if (tensor.sessionId === sessionId) {
            tensor.destroy();
          }
        }
        this.freeTensors = this.freeTensors.filter((tensor) => tensor.sessionId !== sessionId);
      }
      registerTensor(sessionId, mlTensor, dataType, shape) {
        const context = this.getMLContext(sessionId);
        const tensorId = createNewTensorId();
        const wrapper = new TensorWrapper({
          sessionId,
          context,
          tensor: mlTensor,
          dataType,
          shape
        });
        this.tensorTrackersById.set(tensorId, new TensorIdTracker(this, wrapper));
        this.externalTensors.add(wrapper);
        return tensorId;
      }
      /**
       * Get or create an MLTensor with the given data type and shape.
       */
      async getCachedTensor(sessionId, dataType, shape, usage, writable, readable, fallbackDataType) {
        const context = this.getMLContext(sessionId);
        for (const [index, tensor2] of this.freeTensors.entries()) {
          if (tensor2.canReuseTensor(context, dataType, shape)) {
            LOG_DEBUG(
              "verbose",
              () => `[WebNN] Reusing tensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}`
            );
            const wrapper = this.freeTensors.splice(index, 1)[0];
            wrapper.sessionId = sessionId;
            return wrapper;
          }
        }
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] MLContext.createTensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}}`
        );
        const tensor = await context.createTensor({
          dataType: fallbackDataType ?? dataType,
          // If fallback data type is provided, use it.
          shape,
          dimensions: shape,
          usage,
          writable,
          readable
        });
        return new TensorWrapper({ sessionId, context, tensor, dataType, shape, fallbackDataType });
      }
      /**
       * Release tensor for reuse unless external.
       */
      releaseTensor(tensorWrapper) {
        if (this.externalTensors.has(tensorWrapper)) {
          this.externalTensors.delete(tensorWrapper);
        }
        this.freeTensors.push(tensorWrapper);
      }
    };
    createTensorManager = (...args) => new TensorManagerImpl(...args);
  }
});

// web/lib/wasm/jsep/backend-webnn.ts
var onnxDataTypeToWebnnDataType, compareMLContextOptions, WebNNBackend;
var init_backend_webnn = __esm({
  "web/lib/wasm/jsep/backend-webnn.ts"() {
    "use strict";
    init_wasm_common();
    init_wasm_factory();
    init_tensor_view();
    init_tensor_manager();
    init_log();
    onnxDataTypeToWebnnDataType = /* @__PURE__ */ new Map([
      [1 /* float */, "float32"],
      [10 /* float16 */, "float16"],
      [6 /* int32 */, "int32"],
      [12 /* uint32 */, "uint32"],
      [7 /* int64 */, "int64"],
      [13 /* uint64 */, "uint64"],
      [22 /* int4 */, "int4"],
      [21 /* uint4 */, "uint4"],
      [3 /* int8 */, "int8"],
      [2 /* uint8 */, "uint8"],
      [9 /* bool */, "uint8"]
    ]);
    compareMLContextOptions = (a, b) => {
      if (a === b) {
        return true;
      }
      if (a === void 0 || b === void 0) {
        return false;
      }
      const aKeys = Object.keys(a).sort();
      const bKeys = Object.keys(b).sort();
      return aKeys.length === bKeys.length && aKeys.every((key, index) => key === bKeys[index] && a[key] === b[key]);
    };
    WebNNBackend = class {
      constructor(env3) {
        /**
         * Tensor managers for each session.
         */
        this.tensorManager = createTensorManager(this);
        /**
         * Maps from session id to MLContexts.
         */
        this.mlContextBySessionId = /* @__PURE__ */ new Map();
        /**
         * Maps from MLContext to session ids.
         */
        this.sessionIdsByMLContext = /* @__PURE__ */ new Map();
        /**
         * Cache of MLContexts.
         */
        this.mlContextCache = [];
        /**
         * Maps from session id to list of graph inputs.
         */
        this.sessionGraphInputs = /* @__PURE__ */ new Map();
        /**
         * Maps from session id to list of graph outputs.
         */
        this.sessionGraphOutputs = /* @__PURE__ */ new Map();
        /**
         * Temporary graph inputs for the current session.
         * These inputs will be registered when the session is created.
         */
        this.temporaryGraphInputs = [];
        /**
         * Temporary graph outputs for the current session.
         * These outputs will be registered when the session is created.
         */
        this.temporaryGraphOutputs = [];
        /**
         * Temporary tensors for the current session.
         */
        this.temporarySessionTensorIds = /* @__PURE__ */ new Map();
        /**
         * Maps from session id to MLOpSupportLimits.
         */
        this.mlOpSupportLimitsBySessionId = /* @__PURE__ */ new Map();
        configureLogger(env3.logLevel, !!env3.debug);
      }
      get currentSessionId() {
        if (this.activeSessionId === void 0) {
          throw new Error("No active session");
        }
        return this.activeSessionId;
      }
      onRunStart(sessionId) {
        LOG_DEBUG("verbose", () => `[WebNN] onRunStart {sessionId: ${sessionId}}`);
        this.activeSessionId = sessionId;
      }
      onRunEnd(sessionId) {
        LOG_DEBUG("verbose", () => `[WebNN] onRunEnd {sessionId: ${sessionId}}`);
        const tensorIds = this.temporarySessionTensorIds.get(sessionId);
        if (!tensorIds) {
          return;
        }
        for (const tensorId of tensorIds) {
          LOG_DEBUG("verbose", () => `[WebNN] releasing temporary tensor {tensorId: ${tensorId}}`);
          this.tensorManager.releaseTensorId(tensorId);
        }
        this.temporarySessionTensorIds.delete(sessionId);
        this.activeSessionId = void 0;
      }
      async createMLContext(optionsOrDevice) {
        if (optionsOrDevice instanceof GPUDevice) {
          const mlContextIndex2 = this.mlContextCache.findIndex((entry) => entry.gpuDevice === optionsOrDevice);
          if (mlContextIndex2 !== -1) {
            return this.mlContextCache[mlContextIndex2].mlContext;
          } else {
            const mlContext = await navigator.ml.createContext(optionsOrDevice);
            this.mlContextCache.push({ gpuDevice: optionsOrDevice, mlContext });
            return mlContext;
          }
        } else if (optionsOrDevice === void 0) {
          const mlContextIndex2 = this.mlContextCache.findIndex(
            (entry) => entry.options === void 0 && entry.gpuDevice === void 0
          );
          if (mlContextIndex2 !== -1) {
            return this.mlContextCache[mlContextIndex2].mlContext;
          } else {
            const mlContext = await navigator.ml.createContext();
            this.mlContextCache.push({ mlContext });
            return mlContext;
          }
        }
        const mlContextIndex = this.mlContextCache.findIndex(
          (entry) => compareMLContextOptions(entry.options, optionsOrDevice)
        );
        if (mlContextIndex !== -1) {
          return this.mlContextCache[mlContextIndex].mlContext;
        } else {
          const mlContext = await navigator.ml.createContext(optionsOrDevice);
          this.mlContextCache.push({ options: optionsOrDevice, mlContext });
          return mlContext;
        }
      }
      registerMLContext(sessionId, mlContext) {
        this.mlContextBySessionId.set(sessionId, mlContext);
        let sessionIds = this.sessionIdsByMLContext.get(mlContext);
        if (!sessionIds) {
          sessionIds = /* @__PURE__ */ new Set();
          this.sessionIdsByMLContext.set(mlContext, sessionIds);
        }
        sessionIds.add(sessionId);
        if (!this.mlOpSupportLimitsBySessionId.has(sessionId)) {
          this.mlOpSupportLimitsBySessionId.set(sessionId, mlContext.opSupportLimits());
        }
        if (this.temporaryGraphInputs.length > 0) {
          this.sessionGraphInputs.set(sessionId, this.temporaryGraphInputs);
          this.temporaryGraphInputs = [];
        }
        if (this.temporaryGraphOutputs.length > 0) {
          this.sessionGraphOutputs.set(sessionId, this.temporaryGraphOutputs);
          this.temporaryGraphOutputs = [];
        }
      }
      onReleaseSession(sessionId) {
        this.sessionGraphInputs.delete(sessionId);
        this.sessionGraphOutputs.delete(sessionId);
        const mlContext = this.mlContextBySessionId.get(sessionId);
        if (!mlContext) {
          return;
        }
        this.tensorManager.releaseTensorsForSession(sessionId);
        this.mlContextBySessionId.delete(sessionId);
        this.mlOpSupportLimitsBySessionId.delete(sessionId);
        const sessionIds = this.sessionIdsByMLContext.get(mlContext);
        sessionIds.delete(sessionId);
        if (sessionIds.size === 0) {
          this.sessionIdsByMLContext.delete(mlContext);
          const mlContextIndex = this.mlContextCache.findIndex((entry) => entry.mlContext === mlContext);
          if (mlContextIndex !== -1) {
            this.mlContextCache.splice(mlContextIndex, 1);
          }
        }
      }
      getMLContext(sessionId) {
        return this.mlContextBySessionId.get(sessionId);
      }
      getMLOpSupportLimits(sessionId) {
        return this.mlOpSupportLimitsBySessionId.get(sessionId);
      }
      reserveTensorId() {
        return this.tensorManager.reserveTensorId();
      }
      releaseTensorId(tensorId) {
        LOG_DEBUG("verbose", () => `[WebNN] releaseTensorId {tensorId: ${tensorId}}`);
        this.tensorManager.releaseTensorId(tensorId);
      }
      async ensureTensor(sessionId, tensorId, onnxDataType, dimensions, copyOld) {
        const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!webnnDataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        return this.tensorManager.ensureTensor(
          sessionId ?? this.currentSessionId,
          tensorId,
          webnnDataType,
          dimensions,
          copyOld
        );
      }
      async createTemporaryTensor(sessionId, onnxDataType, shape) {
        LOG_DEBUG("verbose", () => `[WebNN] createTemporaryTensor {onnxDataType: ${onnxDataType}, shape: ${shape}}`);
        const dataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!dataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        const tensorId = this.tensorManager.reserveTensorId();
        await this.tensorManager.ensureTensor(sessionId, tensorId, dataType, shape, false);
        const tensorIds = this.temporarySessionTensorIds.get(sessionId);
        if (!tensorIds) {
          this.temporarySessionTensorIds.set(sessionId, [tensorId]);
        } else {
          tensorIds.push(tensorId);
        }
        return tensorId;
      }
      uploadTensor(tensorId, data) {
        const wasm2 = getInstance();
        if (!wasm2.shouldTransferToMLTensor) {
          throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");
        }
        LOG_DEBUG("verbose", () => `[WebNN] uploadTensor {tensorId: ${tensorId}, data: ${data.byteLength}}`);
        this.tensorManager.upload(tensorId, data);
      }
      async downloadTensor(tensorId, dstBuffer) {
        return this.tensorManager.download(tensorId, dstBuffer);
      }
      createMLTensorDownloader(tensorId, type) {
        return async () => {
          const data = await this.tensorManager.download(tensorId);
          return createView(data, type);
        };
      }
      registerMLTensor(sessionId, tensor, onnxDataType, dimensions) {
        const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!webnnDataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        const id = this.tensorManager.registerTensor(sessionId, tensor, webnnDataType, dimensions);
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] registerMLTensor {tensor: ${tensor}, dataType: ${webnnDataType}, dimensions: ${dimensions}} -> {tensorId: ${id}}`
        );
        return id;
      }
      // Register a WebNN Constant operand from external data.
      registerMLConstant(externalFilePath, dataOffset, dataLength, builder, desc, mountedFiles, shouldConvertInt64ToInt32 = false) {
        if (!mountedFiles) {
          throw new Error("External mounted files are not available.");
        }
        let filePath = externalFilePath;
        if (externalFilePath.startsWith("./")) {
          filePath = externalFilePath.substring(2);
        }
        const fileData = mountedFiles.get(filePath);
        if (!fileData) {
          throw new Error(`File with name ${filePath} not found in preloaded files.`);
        }
        if (dataOffset + dataLength > fileData.byteLength) {
          throw new Error("Out of bounds: data offset and length exceed the external file data size.");
        }
        const buffer = fileData.slice(dataOffset, dataOffset + dataLength).buffer;
        let bufferView;
        switch (desc.dataType) {
          case "float32":
            bufferView = new Float32Array(buffer);
            break;
          case "float16":
            bufferView = typeof Float16Array !== "undefined" && Float16Array.from ? new Float16Array(buffer) : new Uint16Array(buffer);
            break;
          case "int32":
            bufferView = new Int32Array(buffer);
            break;
          case "uint32":
            bufferView = new Uint32Array(buffer);
            break;
          case "int64":
            if (shouldConvertInt64ToInt32) {
              const int32Buffer = convertDataToInt32(new Uint8Array(buffer), "int64");
              bufferView = new Int32Array(int32Buffer.buffer);
              desc.dataType = "int32";
            } else {
              bufferView = new BigInt64Array(buffer);
            }
            break;
          case "uint64":
            bufferView = new BigUint64Array(buffer);
            break;
          case "int8":
            bufferView = new Int8Array(buffer);
            break;
          case "int4":
          case "uint4":
          case "uint8":
            bufferView = new Uint8Array(buffer);
            break;
          default:
            throw new Error(`Unsupported data type: ${desc.dataType} in creating WebNN Constant from external data.`);
        }
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] registerMLConstant {dataType: ${desc.dataType}, shape: ${desc.shape}}} ${shouldConvertInt64ToInt32 ? "(Note: it was int64 data type and registered to int32 as workaround)" : ""}`
        );
        return builder.constant(desc, bufferView);
      }
      registerGraphInput(inputName) {
        this.temporaryGraphInputs.push(inputName);
      }
      registerGraphOutput(outputName) {
        this.temporaryGraphOutputs.push(outputName);
      }
      isGraphInput(sessionId, inputName) {
        const inputNames = this.sessionGraphInputs.get(sessionId);
        if (!inputNames) {
          return false;
        }
        return inputNames.includes(inputName);
      }
      isGraphOutput(sessionId, outputName) {
        const outputNames = this.sessionGraphOutputs.get(sessionId);
        if (!outputNames) {
          return false;
        }
        return outputNames.includes(outputName);
      }
      isGraphInputOutputTypeSupported(sessionId, type, isInput = true) {
        const dataType = onnxDataTypeToWebnnDataType.get(tensorDataTypeStringToEnum(type));
        const opLimits = this.mlOpSupportLimitsBySessionId.get(sessionId);
        if (typeof dataType === "undefined") {
          return false;
        }
        if (isInput) {
          return !!opLimits?.input.dataTypes.includes(dataType);
        } else {
          return !!opLimits?.output.dataTypes.includes(dataType);
        }
      }
      flush() {
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/types.ts
var init_types = __esm({
  "web/lib/wasm/jsep/webgpu/types.ts"() {
    "use strict";
  }
});

// web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
var init_gpu_data_manager = __esm({
  "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
    "use strict";
    init_log();
    init_types();
    bucketFreelist = /* @__PURE__ */ new Map([
      [64, 250],
      [128, 200],
      [256, 200],
      [512, 200],
      [2048, 230],
      [4096, 200],
      [8192, 50],
      [16384, 50],
      [32768, 50],
      [65536, 50],
      [131072, 50],
      [262144, 50],
      [524288, 50],
      [1048576, 50],
      [2097152, 30],
      [4194304, 20],
      [8388608, 10],
      [12582912, 10],
      [16777216, 10],
      [26214400, 15],
      [33554432, 22],
      [44236800, 2],
      [58982400, 6],
      // we don't want to cache the bucket sizes below but not caching them
      // results in some major performance hits for models like sd-turbo.
      [67108864, 6],
      [134217728, 6],
      [167772160, 6]
    ]);
    bucketArr = [];
    calcNormalizedBufferSize = (size) => Math.ceil(Number(size) / 16) * 16;
    calcBucketBufferSize = (size) => {
      for (let idx = 0; idx < bucketArr.length; idx++) {
        const sizeForBucket = bucketArr[idx];
        if (size <= sizeForBucket) {
          return sizeForBucket;
        }
      }
      return Math.ceil(size / 16) * 16;
    };
    guid = 1;
    createNewGpuDataId = () => guid++;
    downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
      const bufferSize = calcNormalizedBufferSize(originalSize);
      const gpuReadBuffer = backend.device.createBuffer(
        // eslint-disable-next-line no-bitwise
        { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
      );
      try {
        const commandEncoder = backend.getCommandEncoder();
        backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          gpuBuffer,
          0,
          gpuReadBuffer,
          0,
          bufferSize
        );
        backend.flush();
        await gpuReadBuffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = gpuReadBuffer.getMappedRange();
        if (getTargetBuffer) {
          const targetBuffer = getTargetBuffer();
          targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
          return targetBuffer;
        } else {
          return new Uint8Array(arrayBuffer.slice(0, originalSize));
        }
      } finally {
        gpuReadBuffer.destroy();
      }
    };
    GpuDataManagerImpl = class {
      constructor(backend) {
        this.backend = backend;
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.buffersPending = [];
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        for (const [key] of bucketFreelist) {
          bucketArr.push(key);
          this.freeBuffers.set(key, []);
          this.freeUniformBuffers.set(key, []);
        }
        this.sessionCount = 0;
      }
      upload(id, data) {
        const srcArrayBuffer = data.buffer;
        const srcOffset = data.byteOffset;
        const srcLength = data.byteLength;
        const size = calcNormalizedBufferSize(srcLength);
        const gpuDataCache = this.storageCache.get(id);
        if (!gpuDataCache) {
          throw new Error("gpu data for uploading does not exist");
        }
        if (Number(gpuDataCache.originalSize) !== srcLength) {
          throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
        }
        const gpuBufferForUploading = this.backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
        );
        const arrayBuffer = gpuBufferForUploading.getMappedRange();
        new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
        gpuBufferForUploading.unmap();
        const commandEncoder = this.backend.device.createCommandEncoder();
        commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
        this.backend.device.queue.submit([commandEncoder.finish()]);
        gpuBufferForUploading.destroy();
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
      }
      memcpy(sourceId, destinationId) {
        const sourceGpuDataCache = this.storageCache.get(sourceId);
        if (!sourceGpuDataCache) {
          throw new Error("source gpu data for memcpy does not exist");
        }
        const destinationGpuDataCache = this.storageCache.get(destinationId);
        if (!destinationGpuDataCache) {
          throw new Error("destination gpu data for memcpy does not exist");
        }
        if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
          throw new Error("inconsistent source and destination gpu data size");
        }
        const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
        const commandEncoder = this.backend.getCommandEncoder();
        this.backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          sourceGpuDataCache.gpuData.buffer,
          0,
          destinationGpuDataCache.gpuData.buffer,
          0,
          size
        );
      }
      registerExternalBuffer(buffer, originalSize, previous) {
        let id;
        if (previous) {
          id = previous[0];
          if (buffer === previous[1]) {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
            );
            return id;
          } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
            throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
          }
        } else {
          id = createNewGpuDataId();
        }
        this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
        LOG_DEBUG(
          "verbose",
          () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
        );
        return id;
      }
      unregisterExternalBuffer(id) {
        if (id !== void 0) {
          this.storageCache.delete(id);
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
        }
      }
      // eslint-disable-next-line no-bitwise
      create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
        const bufferSize = calcBucketBufferSize(size);
        let gpuBuffer;
        const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
        const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
        if (isStorage || isUniform) {
          const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
          const buffers = freeBuffers.get(bufferSize);
          if (!buffers) {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          } else {
            if (buffers.length > 0) {
              gpuBuffer = buffers.pop();
            } else {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            }
          }
        } else {
          gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
        }
        const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
        this.storageCache.set(gpuData.id, { gpuData, originalSize: Number(size) });
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
        return gpuData;
      }
      get(id) {
        return this.storageCache.get(id)?.gpuData;
      }
      release(idInput) {
        const id = typeof idInput === "bigint" ? Number(idInput) : idInput;
        const cachedData = this.storageCache.get(id);
        if (!cachedData) {
          if (this.storageCache.size === 0) {
            return 0;
          } else {
            throw new Error("releasing data does not exist");
          }
        }
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
        this.storageCache.delete(id);
        this.buffersPending.push(cachedData.gpuData.buffer);
        return cachedData.originalSize;
      }
      async download(id, getTargetBuffer) {
        const cachedData = this.storageCache.get(Number(id));
        if (!cachedData) {
          throw new Error("data does not exist");
        }
        await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
      }
      refreshPendingBuffers() {
        if (this.buffersPending.length === 0) {
          return;
        }
        if (this.backend.sessionStatus === "default") {
          for (const buffer of this.buffersPending) {
            const maxInFreeList = bucketFreelist.get(buffer.size);
            if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
              const freelist = this.freeBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
              const freelist = this.freeUniformBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else {
              buffer.destroy();
            }
          }
          this.buffersPending = [];
        } else {
          let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
          if (!capturedBuffers) {
            capturedBuffers = [];
            this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
          }
          for (const buffer of this.buffersPending) {
            capturedBuffers.push(buffer);
          }
          this.buffersPending = [];
        }
      }
      dispose() {
        this.freeBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.freeUniformBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache.forEach((storage) => {
          storage.gpuData.buffer.destroy();
        });
        this.capturedPendingBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
      }
      onCreateSession() {
        this.sessionCount += 1;
      }
      onReleaseSession(sessionId) {
        const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
        if (pendingBuffers) {
          pendingBuffers.forEach((buffer) => {
            buffer.destroy();
          });
          this.capturedPendingBuffers.delete(sessionId);
        }
        this.sessionCount -= 1;
        if (this.sessionCount === 0) {
          LOG_DEBUG("warning", () => "[WebGPU] Clearing webgpu buffer cache");
          this.storageCache.forEach((storage) => {
            storage.gpuData.buffer.destroy();
          });
          this.storageCache = /* @__PURE__ */ new Map();
        }
      }
    };
    createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
  }
});

// web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
var init_attribute_with_cache_key = __esm({
  "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
    "use strict";
    AttributeWithCacheKeyImpl = class {
      constructor(attribute) {
        Object.assign(this, attribute);
      }
      get cacheKey() {
        if (!this.key) {
          this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
        }
        return this.key;
      }
    };
    createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
  }
});

// web/lib/wasm/jsep/webgpu/ops/common.ts
var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, atomicOutputVariable, internalVariable, ShaderHelperImpl, createShaderHelper;
var init_common = __esm({
  "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    WORKGROUP_SIZE = 64;
    getWgslMappedType = (type, components) => {
      if (components === 3) {
        throw new Error("vec3 has same alignment as vec4, use vec4 instead");
      }
      switch (Number(type)) {
        case 10 /* float16 */:
          return components > 1 ? `vec${components}<f16>` : "f16";
        case 1 /* float */:
          return components > 1 ? `vec${components}<f32>` : "f32";
        case 6 /* int32 */:
          return components > 1 ? `vec${components}<i32>` : "i32";
        case 12 /* uint32 */:
          return components > 1 ? `vec${components}<u32>` : "u32";
        case 7 /* int64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "i32"];
        case 13 /* uint64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "u32"];
        case 9 /* bool */:
          if (components !== 4) {
            throw new Error("bool must be vec4");
          }
          return ["u32", "vec4<bool>"];
        case 22 /* int4 */:
          return "i32";
        case 21 /* uint4 */:
          return "u32";
        default:
          throw new Error(`Unknown data type: ${type}`);
      }
    };
    tensorTypeToWsglStorageType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[0];
    };
    tensorTypeToWsglValueType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[1];
    };
    createTensorShapeVariables = (...dims) => {
      const programUniforms = [];
      dims.forEach((dim) => {
        if (dim.length !== 0) {
          programUniforms.push(
            { type: 12 /* uint32 */, data: dim },
            { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
          );
        }
      });
      return programUniforms;
    };
    getMaxComponents = (size) => {
      if (size % 4 === 0) {
        return 4;
      } else if (size % 2 === 0) {
        return 2;
      }
      return 1;
    };
    fillVector = (dataType = "f32", components, value = "0") => {
      if (!components || components === 1) {
        return `${dataType}(${value})`;
      }
      return `vec${components}<${dataType}>(${value})`;
    };
    castToF32 = (dataType, components, value) => {
      if (dataType === "f32") {
        return value;
      }
      if (components === 1) {
        return `f32(${value})`;
      }
      return `vec${components}<f32>(${value})`;
    };
    sumVector = (name, components) => {
      if (components === 4) {
        return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
      } else if (components === 2) {
        return `(${name}.x + ${name}.y)`;
      } else if (components === 3) {
        return `(${name}.x + ${name}.y + ${name}.z)`;
      }
      return name;
    };
    getElementAt = (name, index, length, type) => {
      if (name.startsWith("uniforms.") && length > 4) {
        if (typeof index === "string") {
          if (type === "f16") {
            return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
          } else {
            return `${name}[(${index}) / 4][(${index}) % 4]`;
          }
        } else {
          if (type === "f16") {
            return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
          } else {
            return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
          }
        }
      } else {
        return length > 1 ? `${name}[${index}]` : name;
      }
    };
    createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
      const useUniform = typeof shapeOrRank === "number";
      const rank = useUniform ? shapeOrRank : shapeOrRank.length;
      const rankIdentity = [...new Array(rank).keys()];
      const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
      const mappedType = getWgslMappedType(tensorType, components);
      const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
      const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
      const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
      const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
      const implementationUsed = {
        offsetToIndices: false,
        indicesToOffset: false,
        broadcastedIndicesToOffset: false,
        set: false,
        setByIndices: false,
        get: false,
        getByIndices: false
      };
      const uniformPrefix = useUniform ? "uniforms." : "";
      const shape = `${uniformPrefix}${name}_shape`;
      const strides = `${uniformPrefix}${name}_strides`;
      let o2iSnippet = "";
      for (let i = 0; i < rank - 1; i++) {
        o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
      }
      o2iSnippet += `indices[${rank - 1}] = current;`;
      const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
      const offsetToIndices = (varOffset) => {
        implementationUsed.offsetToIndices = true;
        return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
      };
      const offsets = [];
      if (rank >= 2) {
        for (let i = rank - 1; i >= 0; i--) {
          offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
        }
      }
      const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
      const indicesToOffset = (varIndices) => {
        implementationUsed.indicesToOffset = true;
        return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
      };
      const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
      const indicesGet = (varIndices, idx) => {
        if (rank < 2) {
          return `${varIndices}`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}`;
        }
      };
      const indicesSet = (varIndices, idx, value) => {
        if (rank < 2) {
          return `${varIndices}=${value};`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}=${value};`;
        }
      };
      const broadcastedIndicesToOffsetImplementation = {};
      const broadcastedIndicesToOffset = (varIndices, output) => {
        implementationUsed.broadcastedIndicesToOffset = true;
        const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
        if (implKey in broadcastedIndicesToOffsetImplementation) {
          return `${implKey}(${varIndices})`;
        }
        const offsets2 = [];
        for (let i = rank - 1; i >= 0; i--) {
          const idx = output.indicesGet("outputIndices", i + output.rank - rank);
          offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
        }
        broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
        return `${implKey}(${varIndices})`;
      };
      const setByOffset = (offset, value) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]=${value};`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByOffset = (offset) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `i32(${name}[${offset}].x)`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `u32(${name}[${offset}].x)`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
      const getImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
      })();
      const get = (...indices2) => {
        if (indices2.length !== rank) {
          throw new Error(`indices length must be ${rank}`);
        }
        const normalizedIndices = indices2.map(normalizeDim).join(",");
        if (rank === 0) {
          return getByOffset("0u");
        } else if (rank === 1) {
          return getByOffset(normalizedIndices[0]);
        } else {
          implementationUsed.get = true;
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}(${normalizedIndices})`;
        }
      };
      const getByIndices = (varIndices) => {
        if (rank < 2) {
          return getByOffset(varIndices);
        } else {
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}ByIndices(${varIndices})`;
        }
      };
      const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
      const setImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
      })();
      const set = (...indicesAndValue) => {
        if (indicesAndValue.length !== rank + 1) {
          throw new Error(`indices length must be ${rank}`);
        }
        const value = indicesAndValue[rank];
        if (typeof value !== "string") {
          throw new Error("value must be string");
        }
        const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
        if (rank === 0) {
          return setByOffset("0u", value);
        } else if (rank === 1) {
          return setByOffset(normalizedIndices[0], value);
        } else {
          implementationUsed.set = true;
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}(${normalizedIndices}, ${value})`;
        }
      };
      const setByIndices = (varIndices, value) => {
        if (rank < 2) {
          return setByOffset(varIndices, value);
        } else {
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}ByIndices(${varIndices}, ${value});`;
        }
      };
      const impl = () => {
        const impls = [];
        let needShapeStrides = false;
        if (implementationUsed.offsetToIndices) {
          impls.push(offsetToIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.indicesToOffset) {
          impls.push(indicesToOffsetImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.broadcastedIndicesToOffset) {
          Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
          needShapeStrides = true;
        }
        if (implementationUsed.set) {
          impls.push(setImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.setByIndices) {
          impls.push(setByIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.get) {
          impls.push(getImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.getByIndices) {
          impls.push(getByIndicesImplementation);
          needShapeStrides = true;
        }
        if (!useUniform && needShapeStrides) {
          impls.unshift(
            `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
            `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
          );
        }
        return impls.join("\n");
      };
      return {
        impl,
        type,
        offsetToIndices,
        indicesToOffset,
        broadcastedIndicesToOffset,
        indices,
        indicesGet,
        indicesSet,
        set,
        setByOffset,
        setByIndices,
        get,
        getByOffset,
        getByIndices,
        // isVec4,
        usage,
        name,
        strides,
        shape,
        rank
      };
    };
    inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
    outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
    atomicOutputVariable = (name, type, shapeOrRank) => createIndicesHelper(name, type, shapeOrRank, "atomicOutput", 1);
    internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
    ShaderHelperImpl = class {
      constructor(normalizedDispatchGroup, limits) {
        this.normalizedDispatchGroup = normalizedDispatchGroup;
        this.limits = limits;
        this.internalVariables = [];
        this.variables = [];
        this.uniforms = [];
        this.variableIndex = 0;
      }
      guardAgainstOutOfBoundsWorkgroupSizes(size) {
        const sizeInCode = typeof size === "number" ? `${size}u` : size;
        return `if (global_idx >= ${sizeInCode}) { return; }`;
      }
      mainStart(workgroupSize = WORKGROUP_SIZE) {
        const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
        const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
        const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
        if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
          throw new Error(
            `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`
          );
        }
        if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
          throw new Error(
            `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`
          );
        }
        const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
        const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
        const globalIdxDefinition = is1DimensionDispatch ? `let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
        return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
      }
      appendVariableUniforms(variable) {
        if (variable.rank !== 0) {
          if (variable.shape.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
          if (variable.strides.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
        }
      }
      declareVariable(variable, bindingIndex) {
        if (variable.usage === "internal") {
          throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
        }
        this.variables.push(variable);
        this.appendVariableUniforms(variable);
        const access = variable.usage === "input" ? "read" : "read_write";
        const storageType = variable.usage === "atomicOutput" ? `atomic<i32>` : variable.type.storage;
        return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
      }
      declareVariables(...variables) {
        return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
      }
      registerInternalVariable(variable) {
        if (variable.usage !== "internal") {
          throw new Error(
            "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
          );
        }
        this.internalVariables.push(variable);
        this.appendVariableUniforms(variable);
      }
      registerInternalVariables(...variables) {
        variables.forEach((v) => this.registerInternalVariable(v));
        return this;
      }
      registerUniform(name, type, length = 1) {
        this.uniforms.push({ name, type, length });
        return this;
      }
      registerUniforms(additionalUniforms) {
        this.uniforms = this.uniforms.concat(additionalUniforms);
        return this;
      }
      uniformDeclaration() {
        if (this.uniforms.length === 0) {
          return "";
        }
        const uniformSnippets = [];
        for (const { name, type, length } of this.uniforms) {
          if (length && length > 4) {
            if (type === "f16") {
              uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
            } else {
              uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
            }
          } else {
            const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
            uniformSnippets.push(`${name}:${typeTemp}`);
          }
        }
        return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
      }
      /**
       * Get additional implementation that needs to be added to the shader source.
       */
      get additionalImplementations() {
        return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
      }
      /**
       * Get the variable info of the shader program.
       */
      get variablesInfo() {
        if (this.uniforms.length === 0) {
          return void 0;
        }
        const uniformWgslTypeToDataType = (type) => [12 /* uint32 */, 10 /* float16 */, 1 /* float */, 6 /* int32 */][["u32", "f16", "f32", "i32"].indexOf(type)];
        return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
      }
    };
    createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
  }
});

// web/lib/wasm/jsep/webgpu/ops/transpose.ts
var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, squeezeShape, isTransposeReshape, createTransposeProgramInfo, transpose, parseTransposeAttributes;
var init_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs = (inputs, perm) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Transpose requires 1 input.");
      }
      if (perm.length !== 0 && perm.length !== inputs[0].dims.length) {
        throw new Error(`perm size ${perm.length} does not match input rank ${inputs[0].dims.length}`);
      }
    };
    getAdjustedPerm = (inputRank, perm) => perm.length !== 0 ? perm : [...new Array(inputRank).keys()].reverse();
    getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
    permFunctionBody = (perm, rank, input, output) => {
      let reverseFunc = `fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`;
      for (let i = 0; i < rank; ++i) {
        reverseFunc += `a[${perm[i]}]=i[${i}];`;
      }
      return reverseFunc += "return a;}";
    };
    squeezeShape = (shape, adjustedPerm) => {
      const newShape = [];
      const newPerm = [];
      for (let i = 0; i < shape.length; ++i) {
        if (shape[i] !== 1) {
          newShape.push(shape[i]);
        }
        if (shape[adjustedPerm[i]] !== 1) {
          newPerm.push(adjustedPerm[i]);
        }
      }
      return { newShape, newPerm };
    };
    isTransposeReshape = (perm, shape) => {
      let lastPermutedAxis = 0;
      for (let i = 0; i < perm.length; ++i) {
        if (shape[perm[i]] === 1) {
          continue;
        }
        if (perm[i] < lastPermutedAxis) {
          return false;
        }
        lastPermutedAxis = perm[i];
      }
      return true;
    };
    createTransposeProgramInfo = (inputTensor, permAttr) => {
      const inputDataType = inputTensor.dataType;
      const inputRank = inputTensor.dims.length;
      const perm = getAdjustedPerm(inputRank, permAttr);
      const outputShape = getOutputShape(inputTensor.dims, perm);
      let newInputShape = inputTensor.dims;
      let newOutputShape = outputShape;
      const transposeAsReshape = inputRank < 2 || isTransposeReshape(perm, inputTensor.dims);
      let getShaderSource;
      if (transposeAsReshape) {
        getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", inputDataType, newInputShape, 4);
          const output = outputVariable("output", inputDataType, newOutputShape, 4);
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`;
        };
        return {
          name: "TransposeCopy",
          shaderCache: { inputDependencies: ["type"] },
          getRunData: () => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64 / 4
                /* components */
              ) },
              programUniforms: [{ type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) }]
            };
          },
          getShaderSource
        };
      }
      const { newShape, newPerm } = squeezeShape(inputTensor.dims, perm);
      const channelsLast = ShapeUtil.areEqual(newPerm, [2, 3, 1]);
      const channelsFirst = ShapeUtil.areEqual(newPerm, [3, 1, 2]);
      const useShared = newShape.length === 2 || channelsLast || channelsFirst;
      if (useShared) {
        newInputShape = channelsLast ? [newShape[0], newShape[1] * newShape[2]] : channelsFirst ? [newShape[0] * newShape[1], newShape[2]] : newShape;
        newOutputShape = [newInputShape[1], newInputShape[0]];
        const tileSize = 16;
        getShaderSource = (shaderHelper) => {
          const input = inputVariable("a", inputDataType, newInputShape.length);
          const output = outputVariable("output", inputDataType, newOutputShape.length);
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${output.type.value}, ${tileSize + 1}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let stride = (uniforms.output_shape[1] - 1) / ${tileSize} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${tileSize}u + local_id.x;
    let input_row = workgroup_id_x * ${tileSize}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${input.getByIndices(`${input.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${tileSize}u + local_id.x;
    let output_row = workgroup_id_y * ${tileSize}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${output.setByIndices(`${output.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
        };
        return {
          name: "TransposeShared",
          shaderCache: { inputDependencies: ["type"] },
          getRunData: () => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
              dispatchGroup: { x: Math.ceil(newOutputShape[1] / tileSize), y: Math.ceil(newOutputShape[0] / tileSize) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(newInputShape, newOutputShape)
              ]
            };
          },
          getShaderSource
        };
      }
      getShaderSource = (shaderHelper) => {
        const input = inputVariable("a", inputDataType, newInputShape.length);
        const output = outputVariable("output", inputDataType, newOutputShape.length);
        return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
      };
      return {
        name: "Transpose",
        shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
        getRunData: () => {
          const outputSize = ShapeUtil.size(outputShape);
          return {
            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(newInputShape, newOutputShape)
            ]
          };
        },
        getShaderSource
      };
    };
    transpose = (context, attributes) => {
      validateInputs(context.inputs, attributes.perm);
      context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
    };
    parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
var init_reduce_shared = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_reduce();
    init_transpose();
    reduceOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate * candidate",
      logSumExp: "bestValue + exp(candidate)",
      l1: "bestValue + abs(candidate)",
      l2: "bestValue + candidate * candidate",
      logSum: "bestValue + candidate"
    };
    reduceSharedOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate",
      logSumExp: "bestValue + candidate",
      l1: "bestValue + candidate",
      l2: "bestValue + candidate",
      logSum: "bestValue + candidate"
    };
    reduceInitValues = {
      max: "_A[offset]",
      min: "_A[offset]",
      mean: "0",
      sum: "0",
      prod: "1",
      sumSquare: "0",
      logSumExp: "0",
      l1: "0",
      l2: "0",
      logSum: "0"
    };
    reduceOutputValues = {
      max: "bestValue",
      min: "bestValue",
      sum: "bestValue",
      prod: "bestValue",
      sumSquare: "bestValue",
      logSumExp: "log(bestValue)",
      l1: "bestValue",
      l2: "sqrt(bestValue)",
      logSum: "log(bestValue)"
    };
    getInnerMostAxes = (numInnerAxes, rank) => {
      const res = [];
      for (let i = rank - numInnerAxes; i < rank; ++i) {
        res.push(i);
      }
      return res;
    };
    computeOutAndReduceShapes = (shape, axes) => {
      const outputShape = [];
      const rank = shape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputShape.push(shape[dim]);
        }
      }
      const reduceShape = axes.map((dim) => shape[dim]);
      return [outputShape, reduceShape];
    };
    expandShapeToKeepDim = (shape, axes) => {
      const rank = shape.length + axes.length;
      const expandShape = [];
      let shapeIdx = 0;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          expandShape.push(shape[shapeIdx++]);
        } else {
          expandShape.push(1);
        }
      }
      return expandShape;
    };
    areAxesInnerMostDims = (axes, rank) => {
      for (let i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
          return false;
        }
      }
      return true;
    };
    getAxesPermutation = (axes, rank) => {
      const res = [];
      if (!areAxesInnerMostDims(axes, rank)) {
        for (let i = 0; i < rank; ++i) {
          if (axes.indexOf(i) === -1) {
            res.push(i);
          }
        }
        axes.forEach((axis) => res.push(axis));
      }
      return res;
    };
    createReduceSharedProgramInfo = (name, cacheKey, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
      const inputShape = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const reduceSize = ShapeUtil.size(reduceShape);
      const input = inputVariable("_A", inputs[0].dataType, inputShape);
      const output = outputVariable("output", outputDataType, outputShape);
      let workgroupSize = 64;
      if (outputSize === 1) {
        workgroupSize = 256;
      }
      const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
      const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
        "outputIndex",
        `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
      )};
         }
        }`;
      return {
        name,
        // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
        shaderCache: { hint: `${cacheKey};${workgroupSize}`, inputDependencies: ["type"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: outputSize },
          programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
        })
      };
    };
    reduceCommon = (context, name, attributes, reduceType) => {
      const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
      let updatedAxes = updatedAttributes.axes;
      if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
        updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
      }
      const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
      let axes = normalizeAxes;
      let input = context.inputs[0];
      const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
      if (permutedAxes.length > 0) {
        input = context.compute(createTransposeProgramInfo(context.inputs[0], permutedAxes), {
          inputs: [0],
          outputs: [-1]
        })[0];
        axes = getInnerMostAxes(axes.length, input.dims.length);
      }
      const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
      let finalOutputShape = outputShape;
      if (updatedAttributes.keepDims) {
        finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
      }
      context.compute(
        createReduceSharedProgramInfo(
          name,
          updatedAttributes.cacheKey,
          [input],
          reduceType,
          context.inputs[0].dataType,
          finalOutputShape,
          reduceShape
        ),
        { inputs: [input] }
      );
    };
    reduceMeanShared = (context, attributes) => {
      reduceCommon(context, "ReduceMeanShared", attributes, "mean");
    };
    reduceL1Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL1Shared", attributes, "l1");
    };
    reduceL2Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL2Shared", attributes, "l2");
    };
    reduceLogSumExpShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
    };
    reduceMaxShared = (context, attributes) => {
      reduceCommon(context, "ReduceMaxShared", attributes, "max");
    };
    reduceMinShared = (context, attributes) => {
      reduceCommon(context, "ReduceMinShared", attributes, "min");
    };
    reduceProdShared = (context, attributes) => {
      reduceCommon(context, "ReduceProdShared", attributes, "prod");
    };
    reduceSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumShared", attributes, "sum");
    };
    reduceSumSquareShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
    };
    reduceLogSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce.ts
var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
var init_reduce = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    init_reduce_shared();
    validateInputs2 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("Reduce op requires 1 or 2 inputs.");
      }
      if (inputs.length === 2 && inputs[1].dims.length !== 1) {
        throw new Error("Invalid axes input dims.");
      }
    };
    noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
    createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
      const outputShape = [];
      const inputShape = inputs[0].dims;
      const inputRank = inputShape.length;
      const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
      const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
      inputShape.forEach((d, i) => {
        if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
          if (keepDims) {
            outputShape.push(1);
          }
        } else {
          outputShape.push(d);
        }
      });
      const outputRank = outputShape.length;
      const outputSize = ShapeUtil.size(outputShape);
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const input = inputVariable("_A", inputs[0].dataType, inputRank);
        const output = outputVariable("output", outputDataType, outputRank);
        const ops = reduceOp(input, output, axes);
        let reduceOps2 = ops[2];
        for (let k = 0, l = 0; k < inputRank; k++) {
          if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
            if (keepDims) {
              l++;
            }
            reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
          } else {
            idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
            l++;
          }
        }
        return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
      };
      return {
        name,
        shaderCache,
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            ...createTensorShapeVariables(inputShape, outputShape)
          ]
        })
      };
    };
    createReduceAttributesFromInputs = (inputs, attributes) => {
      const axes = [];
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
      }
      return createAttributeWithCacheKey({
        axes,
        keepDims: attributes.keepDims,
        noopWithEmptyAxes: attributes.noopWithEmptyAxes
      });
    };
    runReduceProgram = (context, name, attributes, reduceOp) => {
      const inputs = context.inputs;
      const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
      context.compute(
        createReduceProgramInfo(
          name,
          { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
          [inputs[0]],
          updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
          updatedAttributes.axes,
          inputs[0].dataType,
          updatedAttributes.keepDims,
          updatedAttributes.noopWithEmptyAxes
        ),
        { inputs: [0] }
      );
    };
    reduceLogSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
    };
    reduceL1Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += abs(${input.getByIndices("input_indices")});`,
        ""
      ];
      runReduceProgram(context, "ReduceL1", attributes, reduceOp);
    };
    reduceL2Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
        "value = sqrt(value);"
      ];
      runReduceProgram(context, "ReduceL2", attributes, reduceOp);
    };
    reduceLogSumExpNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += exp(${input.getByIndices("input_indices")});`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
    };
    reduceMaxNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(input.indicesSet("input_indices", k, 0));
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = max(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMax", attributes, reduceOp);
    };
    reduceMeanNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output, axes) => {
        let size = 1;
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            size *= context.inputs[0].dims[k];
          }
        }
        return [
          "var sum = f32(0);",
          "",
          `sum += f32(${input.getByIndices("input_indices")});`,
          `let value = ${output.type.value}(sum / ${size});`
        ];
      };
      runReduceProgram(context, "ReduceMean", attributes, reduceOp);
    };
    reduceMinNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = min(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMin", attributes, reduceOp);
    };
    reduceProdNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(1);`,
        "",
        `value *= ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceProd", attributes, reduceOp);
    };
    reduceSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceSum", attributes, reduceOp);
    };
    reduceSumSquareNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += t * t;`,
        ""
      ];
      runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
    };
    useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
      if (axes.length === 0) {
        return noopWithEmptyAxes;
      }
      let outputSize = 1;
      let reduceSize = 1;
      for (let dim = 0; dim < axes.length; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputSize *= shape[dim];
        } else {
          reduceSize *= shape[dim];
        }
      }
      return reduceSize < 32 && outputSize > 1024;
    };
    reduceMean = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMeanNaive(context, attributes);
      } else {
        reduceMeanShared(context, attributes);
      }
    };
    reduceL1 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL1Naive(context, attributes);
      } else {
        reduceL1Shared(context, attributes);
      }
    };
    reduceL2 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL2Naive(context, attributes);
      } else {
        reduceL2Shared(context, attributes);
      }
    };
    reduceLogSumExp = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumExpNaive(context, attributes);
      } else {
        reduceLogSumExpShared(context, attributes);
      }
    };
    reduceMax = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMaxNaive(context, attributes);
      } else {
        reduceMaxShared(context, attributes);
      }
    };
    reduceMin = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMinNaive(context, attributes);
      } else {
        reduceMinShared(context, attributes);
      }
    };
    reduceProd = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceProdNaive(context, attributes);
      } else {
        reduceProdShared(context, attributes);
      }
    };
    reduceSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumNaive(context, attributes);
      } else {
        reduceSumShared(context, attributes);
      }
    };
    reduceSumSquare = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumSquareNaive(context, attributes);
      } else {
        reduceSumSquareShared(context, attributes);
      }
    };
    reduceLogSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumNaive(context, attributes);
      } else {
        reduceLogSumShared(context, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/argminmax.ts
var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
var init_argminmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
    "use strict";
    init_wasm_common();
    init_attribute_with_cache_key();
    init_reduce();
    validateInputs3 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */) {
        throw new Error("Invalid input type.");
      }
    };
    argMin = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "ArgMin",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    argMax = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "argMax",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/attention.ts
var validateAttentionInputs, initVarStub, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
var init_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_types();
    init_common();
    validateAttentionInputs = (inputs, attributes) => {
      const input = inputs[0];
      const weights = inputs[1];
      const bias = inputs[2];
      const maskIndex = inputs[3];
      const past = inputs[4];
      const attentionBias = inputs[5];
      if (past && attentionBias) {
        throw new Error("Attention cannot have both past and attention_bias");
      }
      if (input.dims.length !== 3) {
        throw new Error('Input "input" must have 3 dimensions');
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[1];
      const inputHiddenSize = input.dims[2];
      if (bias.dims.length !== 1) {
        throw new Error('Input "bias" is expected to have 1 dimensions');
      }
      if (weights.dims.length !== 2) {
        throw new Error('Input "weights" is expected to have 2 dimensions');
      }
      if (weights.dims[0] !== inputHiddenSize) {
        throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
      }
      if (bias.dims[0] !== weights.dims[1]) {
        throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
      }
      let qHiddenSize = bias.dims[0] / 3;
      let kHiddenSize = qHiddenSize;
      let vHiddenSize = kHiddenSize;
      if (attributes.qkvHiddenSizes.length > 0) {
        if (attributes.qkvHiddenSizes.length !== 3) {
          throw new Error("qkv_hidden_sizes attribute should have 3 elements");
        }
        for (const sz of attributes.qkvHiddenSizes) {
          if (sz % attributes.numHeads !== 0) {
            throw new Error("qkv_hidden_sizes should be divisible by num_heads");
          }
        }
        qHiddenSize = attributes.qkvHiddenSizes[0];
        kHiddenSize = attributes.qkvHiddenSizes[1];
        vHiddenSize = attributes.qkvHiddenSizes[2];
      }
      const kvSequenceLength = sequenceLength;
      if (qHiddenSize !== kHiddenSize) {
        throw new Error("qkv_hidden_sizes first element should be same as the second");
      }
      if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
        throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
      }
      let pastSequenceLength = 0;
      if (past) {
        if (kHiddenSize !== vHiddenSize) {
          throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
        }
        if (past.dims.length !== 5) {
          throw new Error('Input "past" must have 5 dimensions');
        }
        if (past.dims[0] !== 2) {
          throw new Error('Input "past" first dimension must be 2');
        }
        if (past.dims[1] !== batchSize) {
          throw new Error('Input "past" second dimension must be batch_size');
        }
        if (past.dims[2] !== attributes.numHeads) {
          throw new Error('Input "past" third dimension must be num_heads');
        }
        if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
          throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
        }
        if (!attributes.pastPresentShareBuffer) {
          pastSequenceLength = past.dims[3];
        }
      }
      const totalSequenceLength = kvSequenceLength + pastSequenceLength;
      const maxSequenceLength = -1;
      const maskType = 0 /* none */;
      if (maskIndex) {
        throw new Error("Mask not supported");
      }
      if (past) {
        throw new Error("past is not supported");
      }
      if (attentionBias) {
        if (attentionBias.dims.length !== 4) {
          throw new Error('Input "attention_bias" must have 4 dimensions');
        }
        if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
          throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
        }
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize,
        hiddenSize: qHiddenSize,
        vHiddenSize,
        headSize: Math.floor(qHiddenSize / attributes.numHeads),
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias: false,
        passPastInKv: false,
        qkvFormat: 1 /* qkvBNSH */
      };
    };
    initVarStub = (seqLensInput, totalSequenceLengthInput, initPastSequenceLength) => {
      if (totalSequenceLengthInput && seqLensInput) {
        return `
      let total_sequence_length_input = u32(${totalSequenceLengthInput.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${seqLensInput?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `;
      } else {
        return `
    ${initPastSequenceLength ? "let past_sequence_length = uniforms.past_sequence_length" : ""};
    let present_sequence_length = total_sequence_length;
    `;
      }
    };
    createInPlaceSoftmaxProgramInfo = (input, batchSize, numHeads, pastSequenceLength, sequenceLength, totalSequenceLength, seqLens, totalSequenceLengthInput) => {
      const components = getMaxComponents(seqLens ? 1 : totalSequenceLength);
      let WG = 64;
      const totalSequenceLengthComp = totalSequenceLength / components;
      if (totalSequenceLengthComp < WG) {
        WG = 32;
      }
      const elementsPerThread = Math.ceil(totalSequenceLength / components / WG);
      const programUniforms = [
        { type: 12 /* uint32 */, data: batchSize },
        { type: 12 /* uint32 */, data: numHeads },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: sequenceLength },
        { type: 12 /* uint32 */, data: totalSequenceLengthComp },
        { type: 12 /* uint32 */, data: elementsPerThread }
      ];
      const dataType = tensorTypeToWsglStorageType(input.dataType, components);
      const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
      const inputDependencies = ["type"];
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const getShaderSource = (shaderHelper) => {
        const inputHelper = outputVariable("x", input.dataType, input.dims, components);
        const inputHelpers = [inputHelper];
        const seqLensInputHelper = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLensInputHelper) {
          inputHelpers.push(seqLensInputHelper);
        }
        const totalSequenceLengthInputHelper = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInputHelper) {
          inputHelpers.push(totalSequenceLengthInputHelper);
        }
        const elemValueType = tensorTypeToWsglValueType(input.dataType);
        const uniforms = [
          { name: "batch_size", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "sequence_length", type: "u32" },
          { name: "total_sequence_length", type: "u32" },
          { name: "elements_per_thread", type: "u32" }
        ];
        return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputHelpers)}
  ${shaderHelper.mainStart([WG, 1, 1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${initVarStub(seqLensInputHelper, totalSequenceLengthInputHelper, false)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${WG}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${seqLens ? "u32(past_sequence_length + workgroup_id.y + 1)" : "total_sequence_length"};
    var thread_max_vector = ${f32Type}(-3.4028234663852886e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "thread_max_vector";
            case 2:
              return "max(thread_max_vector.x, thread_max_vector.y)";
            case 4:
              return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var max_value =  f32(-3.4028234663852886e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "sum_vector";
            case 2:
              return "sum_vector.x + sum_vector.y";
            case 4:
              return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${inputHelper.type.value}(${elemValueType}(1.0) / ${elemValueType}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${seqLens ? `
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${inputHelper.type.value}(${elemValueType}(0));
        }` : ""};
  }`;
      };
      return {
        name: "AttentionProbsSoftmax",
        shaderCache: { hint: `${WG};${dataType};${components}`, inputDependencies },
        getShaderSource,
        getRunData: () => ({
          outputs: [],
          dispatchGroup: { x: 1, y: sequenceLength, z: batchSize * numHeads },
          programUniforms
        })
      };
    };
    createAttentionProbsProgramInfo = (outputCount, q, key, pastKey, attentionBias, parameters, pastSequenceLength, seqLens, totalSequenceLengthInput) => {
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
      const presentKey = outputCount > 1 && pastKey;
      const kvNumHeads = parameters.kvNumHeads ? parameters.kvNumHeads : parameters.numHeads;
      const presentKeyShape = presentKey ? [parameters.batchSize, kvNumHeads, totalSequenceLength, parameters.headSize] : void 0;
      const nReps = parameters.nReps ? parameters.nReps : 1;
      const alpha = parameters.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : parameters.scale;
      const components = getMaxComponents(parameters.headSize);
      const vectorizedHeadSize = parameters.headSize / components;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(totalSequenceLength / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: parameters.sequenceLength },
        { type: 12 /* uint32 */, data: vectorizedHeadSize },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 12 /* uint32 */, data: parameters.headSize },
        { type: 1 /* float */, data: alpha },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: parameters.kvSequenceLength },
        { type: 12 /* uint32 */, data: nReps }
      ];
      const feedPastKey = presentKey && pastKey && ShapeUtil.size(pastKey.dims) > 0;
      const inputDependencies = ["type", "type"];
      if (feedPastKey) {
        inputDependencies.push("type");
      }
      if (attentionBias) {
        inputDependencies.push("type");
      }
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
      if (presentKey) {
        outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const qInput = inputVariable("q", q.dataType, q.dims, components);
        const kInput = inputVariable("key", key.dataType, key.dims, components);
        const inputVars = [qInput, kInput];
        if (feedPastKey) {
          const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
          inputVars.push(pastKeyInput);
        }
        if (attentionBias) {
          inputVars.push(inputVariable("attention_bias", attentionBias.dataType, attentionBias.dims));
        }
        const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLensInputVariable) {
          inputVars.push(seqLensInputVariable);
        }
        const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInputVariable) {
          inputVars.push(totalSequenceLengthInputVariable);
        }
        const output = outputVariable("output", q.dataType, probsShape);
        const outputVars = [output];
        if (presentKey) {
          outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
        }
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" },
          { name: "n_reps", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
    let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${feedPastKey && presentKey ? "let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;" : ""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${presentKey ? "let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
          if (feedPastKey && presentKey) {
            return `
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
          } else {
            return `
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`;
          }
        })()}
      ${presentKey ? `if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }` : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
          switch (components) {
            case 1:
              return "value";
            case 2:
              return "value.x + value.y";
            case 4:
              return "value.x + value.y + value.z + value.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${attentionBias ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
      };
      return {
        name: "AttentionProbs",
        shaderCache: {
          hint: `${components};${attentionBias !== void 0};${pastKey !== void 0};${outputCount}`,
          inputDependencies
        },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    createVxAttentionScoreProgramInfo = (outputCount, probs, v, pastValue, params, pastSequenceLength, seqLens = void 0, totalSequenceLengthInput = void 0) => {
      const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
      const nReps = params.nReps ? params.nReps : 1;
      const repeatedVHiddenSize = params.vHiddenSize * nReps;
      const presentValue = outputCount > 1 && pastValue;
      const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
      const presentValueShape = presentValue ? [params.batchSize, kvNumHeads, totalSequenceLength, params.headSize] : void 0;
      const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(params.vHeadSize / TILE_SIZE),
        y: Math.ceil(params.sequenceLength / TILE_SIZE),
        z: params.batchSize * params.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: params.sequenceLength },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: params.vHeadSize },
        { type: 12 /* uint32 */, data: params.numHeads },
        { type: 12 /* uint32 */, data: params.headSize },
        { type: 12 /* uint32 */, data: repeatedVHiddenSize },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: params.kvSequenceLength },
        { type: 12 /* uint32 */, data: nReps }
      ];
      const feedPastValue = presentValue && pastValue && ShapeUtil.size(pastValue.dims) > 0;
      const inputDependencies = ["type", "type"];
      if (feedPastValue) {
        inputDependencies.push("type");
      }
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
      if (presentValue) {
        outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
        const vHelper = inputVariable("v", v.dataType, v.dims);
        const inputVars = [probsHelper, vHelper];
        if (feedPastValue) {
          inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
        }
        const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLens) {
          inputVars.push(seqLensInputVariable);
        }
        const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInput) {
          inputVars.push(totalSequenceLengthInputVariable);
        }
        const output = outputVariable("output", probs.dataType, outputShape);
        const outputVars = [output];
        if (presentValue) {
          outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
        }
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "v_hidden_size", type: "u32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" },
          { name: "n_reps", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileV: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
   let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${feedPastValue && presentValue ? "let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;" : ""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${presentValue ? "let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
          if (feedPastValue && presentValue) {
            return `
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `;
          } else {
            return `
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`;
          }
        })()}
        ${presentValue ? `
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }` : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
      };
      return {
        name: "AttentionScore",
        shaderCache: { hint: `${pastValue !== void 0};${outputCount}`, inputDependencies },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, attentionBiasInput, parameters, seqLens = void 0, totalSequenceLengthInput = void 0) => {
      const outputCount = Math.min(context.outputCount, 1 + (pastKey ? 1 : 0) + (pastValue ? 1 : 0));
      const pastSequenceLength = outputCount > 1 ? parameters.pastSequenceLength : 0;
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const attentionBias = attentionBiasInput && ShapeUtil.size(attentionBiasInput.dims) > 0 ? attentionBiasInput : void 0;
      const inputsK = [q, k];
      if (outputCount > 1 && pastKey && ShapeUtil.size(pastKey.dims) > 0) {
        inputsK.push(pastKey);
      }
      if (attentionBias) {
        inputsK.push(attentionBias);
      }
      if (seqLens) {
        inputsK.push(seqLens);
      }
      if (totalSequenceLengthInput) {
        inputsK.push(totalSequenceLengthInput);
      }
      const probs = context.compute(
        createAttentionProbsProgramInfo(
          outputCount,
          q,
          k,
          pastKey,
          attentionBias,
          parameters,
          pastSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        { inputs: inputsK, outputs: outputCount > 1 ? [-1, 1] : [-1] }
      )[0];
      context.compute(
        createInPlaceSoftmaxProgramInfo(
          probs,
          parameters.batchSize,
          parameters.numHeads,
          pastSequenceLength,
          parameters.sequenceLength,
          totalSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        { inputs: seqLens && totalSequenceLengthInput ? [probs, seqLens, totalSequenceLengthInput] : [probs], outputs: [] }
      );
      const inputsV = [probs, v];
      if (outputCount > 1 && pastValue && ShapeUtil.size(pastValue.dims) > 0) {
        inputsV.push(pastValue);
      }
      if (seqLens) {
        inputsV.push(seqLens);
      }
      if (totalSequenceLengthInput) {
        inputsV.push(totalSequenceLengthInput);
      }
      context.compute(
        createVxAttentionScoreProgramInfo(
          outputCount,
          probs,
          v,
          pastValue,
          parameters,
          pastSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        {
          inputs: inputsV,
          outputs: outputCount > 1 ? [0, 2] : [0]
        }
      );
    };
    prepare = (context, parameters) => {
      const outputShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, parameters.headSize];
      const M = parameters.sequenceLength;
      const K = parameters.inputHiddenSize;
      const N = parameters.headSize;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(parameters.headSize / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
      const programUniforms = [
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: K },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 12 /* uint32 */, data: parameters.headSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
        const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
        const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
        const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
        const dataType = input.type.storage;
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "ldb", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
      };
      return context.compute(
        {
          name: "AttentionPrepare",
          shaderCache: { inputDependencies: ["type", "type", "type"] },
          getRunData: () => ({
            outputs: [
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
            ],
            dispatchGroup: dispatch,
            programUniforms
          }),
          getShaderSource
        },
        { inputs, outputs: [-1, -1, -1] }
      );
    };
    attention = (context, attributes) => {
      const params = validateAttentionInputs(context.inputs, attributes);
      const [q, k, v] = prepare(context, params);
      return applyAttention(
        context,
        q,
        k,
        v,
        context.inputs[4],
        void 0,
        void 0,
        void 0,
        context.inputs[5],
        params
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
var init_batch_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs4 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 5) {
        throw new Error("BatchNormalization requires 5 inputs");
      }
      const checkShapeEqual = (actual, expected, message) => {
        const r = expected.length;
        if (r !== actual.length) {
          throw new Error(`${message}: num dimensions != ${r}`);
        }
        expected.forEach((v, i) => {
          if (v !== actual[i]) {
            throw new Error(`${message}: dim[${i}] do not match`);
          }
        });
      };
      if (inputs[0].dims.length > 1) {
        const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
        checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
        checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
        checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
        checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
      } else {
        checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
        checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
        checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
        checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
      }
    };
    createBatchNormInferenceProgramInfo = (inputs, attributes) => {
      const { epsilon, spatial, format } = attributes;
      const yShape = inputs[0].dims;
      const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
      const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
      const outputSize = ShapeUtil.size(yShape) / components;
      const useShapesUniforms = spatial;
      const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
      const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
      const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
      const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
      const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
      const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
      const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
      const calcCOffset = () => {
        let cOffset = "";
        if (spatial) {
          cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
        } else {
          if (format === "NCHW") {
            cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
          } else {
            cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
            for (let i = 1; i < scale.rank; i++) {
              cOffset += `cIndices[${i}] = outputIndices[${i}];`;
            }
            cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
          }
        }
        return cOffset;
      };
      const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BatchNormalization",
        shaderCache: {
          hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
          inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
        },
        getShaderSource: getInferenceModeShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: useShapesUniforms ? [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(yShape)] : [{ type: 12 /* uint32 */, data: outputSize }]
        })
      };
    };
    parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    batchNorm = (context, attributes) => {
      const { inputs, outputCount } = context;
      const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
      if (env2.webgpu.validateInputContent) {
        validateInputs4(inputs, updatedAttributes);
      }
      if (attributes.trainingMode) {
        throw new Error("BatchNormalization trainingMode is not supported yet.");
      } else {
        context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-add.ts
var validateInputs5, createBiasAddProgramInfo, biasAdd;
var init_bias_add = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
    "use strict";
    init_util();
    init_common();
    validateInputs5 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![320, 640, 1280].includes(inputs[0].dims[2])) {
        throw new Error("number of channels should be 320, 640 or 1280");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasAddProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims;
      const channels = inputs[0].dims[2];
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, outputShape, 4);
      const bias = inputVariable("bias", dataType, [channels], 4);
      const residual = inputVariable("residual", dataType, outputShape, 4);
      const output = outputVariable("output", dataType, outputShape, 4);
      const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BiasAdd",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasAdd = (context) => {
      validateInputs5(context.inputs);
      context.compute(createBiasAddProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/unary-op.ts
var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log, quickGeluImpl, quickGeluExpression, quickgelu;
var init_unary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation, additionalUniformsType) => {
      const vecSize = Math.ceil(datasize / 4);
      let expression = "";
      if (typeof funcCall === "string") {
        expression = `${funcCall}(a)`;
      } else {
        expression = funcCall("a");
      }
      const input = inputVariable("inputData", inputDataType, [vecSize], 4);
      const output = outputVariable("outputData", outputDataType, [vecSize], 4);
      const uniforms = [{ name: "vec_size", type: "u32" }];
      if (additionalUniformsType) {
        uniforms.push(...additionalUniformsType);
      }
      return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
    };
    createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType, additionalUniforms, additionalUniformsType) => {
      const programUniforms = [
        { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
      ];
      if (additionalUniforms) {
        programUniforms.push(...additionalUniforms);
      }
      return {
        name,
        shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
        getShaderSource: (shaderHelper) => createElementwiseProgramShader(
          shaderHelper,
          ShapeUtil.size(input.dims),
          input.dataType,
          outputDataType,
          funcCall,
          additionalImplementation,
          additionalUniformsType
        ),
        getRunData: (inputTensors) => ({
          outputs: [{ dims: input.dims, dataType: outputDataType }],
          dispatchGroup: {
            x: Math.ceil(
              ShapeUtil.size(inputTensors[0].dims) / 64 / 4
              /* vec size */
            )
          },
          programUniforms
        })
      };
    };
    abs = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
    };
    acos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
    };
    acosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
    };
    asin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
    };
    asinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
    };
    atan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
    };
    atanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
    };
    parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    cast = (context, attributes) => {
      let func;
      switch (attributes.to) {
        case 10 /* float16 */:
          func = "vec4<f16>";
          break;
        case 1 /* float */:
          func = "vec4<f32>";
          break;
        case 12 /* uint32 */:
          func = "vec4<u32>";
          break;
        case 6 /* int32 */:
          func = "vec4<i32>";
          break;
        case 9 /* bool */:
          func = "vec4<bool>";
          break;
        default:
          throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
      }
      context.compute(
        createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
      );
    };
    generateClipAttributesFromInputs = (inputs) => {
      let min;
      let max;
      const hasMin = inputs.length >= 2 && inputs[1].data !== 0;
      const hasMax = inputs.length >= 3 && inputs[2].data !== 0;
      switch (inputs[0].dataType) {
        case 1 /* float */:
          min = hasMin ? inputs[1].getFloat32Array()[0] : -34028234663852886e22;
          max = hasMax ? inputs[2].getFloat32Array()[0] : 34028234663852886e22;
          break;
        case 10 /* float16 */:
          min = hasMin ? inputs[1].getUint16Array()[0] : 64511;
          max = hasMax ? inputs[2].getUint16Array()[0] : 31743;
          break;
        default:
          throw new Error("Unsupport data type");
      }
      return createAttributeWithCacheKey({ min, max });
    };
    clip = (context, clipAttributes) => {
      const attributes = clipAttributes ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Clip",
          (a) => `clamp(${a}, vec4<${dataType}>(uniforms.min), vec4<${dataType}>(uniforms.max))`,
          void 0,
          attributes.cacheKey,
          void 0,
          [
            { type: context.inputs[0].dataType, data: attributes.min },
            { type: context.inputs[0].dataType, data: attributes.max }
          ],
          [
            { name: "min", type: dataType },
            { name: "max", type: dataType }
          ]
        ),
        { inputs: [0] }
      );
    };
    ceil = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
    };
    cos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
    };
    cosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
    };
    parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    elu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Elu",
          (a) => `elu_vf32(${a})`,
          `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
          attributes.cacheKey
        )
      );
    };
    erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
    erf = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
    };
    exp = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
    };
    floor = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
    };
    gelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Gelu",
          (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
          erfImpl(dataType)
        )
      );
    };
    leakyRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "LeakyRelu",
          (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
          `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
          attributes.cacheKey
        )
      );
    };
    not = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
    };
    neg = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
    };
    reciprocal = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
    };
    relu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Relu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
        )
      );
    };
    sigmoid = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
    };
    parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(
      attributes
    );
    hardSigmoid = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "HardSigmoid",
          (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
          void 0,
          attributes.cacheKey
        )
      );
    };
    sin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
    };
    sinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
    };
    sqrt = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
    };
    tan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
    };
    tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
    tanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
    };
    fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
    fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
    fastGelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "FastGelu",
          fastGeluExpression,
          fastGeluImpl(dataType),
          void 0,
          context.inputs[0].dataType
        )
      );
    };
    thresholdedRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "ThresholdedRelu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
          `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
          attributes.cacheKey
        )
      );
      return 0;
    };
    log = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
    };
    quickGeluImpl = (varType, alpha) => `
const alpha = vec4<${varType}>(${alpha});
const one = ${varType}(1.0);
const zero = ${varType}(0.0);

fn quick_gelu_impl(x: vec4<${varType}>) -> vec4<${varType}> {
  let v = x *alpha;
  var x1 : vec4<${varType}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`;
    quickGeluExpression = (x) => `quick_gelu_impl(${x})`;
    quickgelu = (context, attributes) => {
      const dType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "QuickGelu",
          quickGeluExpression,
          quickGeluImpl(dType, attributes.alpha),
          attributes.cacheKey,
          context.inputs[0].dataType
        )
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
var init_bias_split_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
    "use strict";
    init_util();
    init_common();
    init_unary_op();
    validateInputs6 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
        throw new Error("hidden state should be 2560, 5120 or 10240");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasSplitGeluProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims.slice();
      outputShape[2] = outputShape[2] / 2;
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
      const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
      const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
      const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
      return {
        name: "BiasSplitGelu",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasSplitGelu = (context) => {
      validateInputs6(context.inputs);
      context.compute(createBiasSplitGeluProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/binary-op.ts
var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
var init_binary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
      let expressionScalar;
      let expressionVector;
      if (typeof funcCall === "string") {
        expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
      } else if (typeof funcCall === "function") {
        expressionScalar = expressionVector = funcCall;
      } else {
        expressionScalar = funcCall.scalar;
        expressionVector = funcCall.vector;
      }
      const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("aData", typeA, dimsA.length, 4);
      const b = inputVariable("bData", typeB, dimsB.length, 4);
      let assignment;
      if (vectorize) {
        if (doBroadcast) {
          const isAOneElement = ShapeUtil.size(dimsA) === 1;
          const isBOneElement = ShapeUtil.size(dimsB) === 1;
          const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
          if (isAOneElement || isBOneElement) {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(
                isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
              )
            );
          } else {
            assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
              "global_idx",
              expressionVector(
                sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
              )
            )}
          `;
          }
        } else {
          assignment = output.setByOffset(
            "global_idx",
            expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
          );
        }
      } else {
        if (!doBroadcast) {
          throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
        }
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `aData[indexA${x}][componentA${x}]`;
          const expressionB = `bData[indexB${x}][componentB${x}]`;
          return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
      const aDims = a.dims.map(Number);
      const bDims = b.dims.map(Number);
      const isBroadcast = !ShapeUtil.areEqual(aDims, bDims);
      let outputShape = aDims;
      let outputSize = ShapeUtil.size(aDims);
      let vectorize = false;
      let sharedDimensionDivisibleBy4 = false;
      const cacheKeyAux = [isBroadcast];
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(aDims, bDims, false);
        if (!calculatedShape) {
          throw new Error("Can't perform binary op on the given tensors");
        }
        outputShape = calculatedShape.slice();
        outputSize = ShapeUtil.size(outputShape);
        const isAOneElement = ShapeUtil.size(aDims) === 1;
        const isBOneElement = ShapeUtil.size(bDims) === 1;
        const aLastDimDivisibleBy4 = aDims.length > 0 && aDims[aDims.length - 1] % 4 === 0;
        const bLastDimDivisibleBy4 = bDims.length > 0 && bDims[bDims.length - 1] % 4 === 0;
        cacheKeyAux.push(isAOneElement);
        cacheKeyAux.push(isBOneElement);
        cacheKeyAux.push(aLastDimDivisibleBy4);
        cacheKeyAux.push(bLastDimDivisibleBy4);
        let sharedDimension = 1;
        for (let i = 1; i < outputShape.length; i++) {
          const dimA = aDims[aDims.length - i];
          const dimB = bDims[bDims.length - i];
          if (dimA === dimB) {
            sharedDimension *= dimA;
          } else {
            break;
          }
        }
        if (sharedDimension % 4 === 0) {
          sharedDimensionDivisibleBy4 = true;
          vectorize = true;
        } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
          vectorize = true;
        }
      } else {
        vectorize = true;
      }
      cacheKeyAux.push(vectorize);
      return {
        name,
        shaderCache: {
          hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
          inputDependencies: ["rank", "rank"]
        },
        getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
          shaderHelper,
          aDims,
          bDims,
          outputShape,
          vectorize,
          isBroadcast,
          sharedDimensionDivisibleBy4,
          funcCall,
          a.dataType,
          b.dataType,
          outputDataType,
          additionalImplementation
        ),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* component size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
            ...createTensorShapeVariables(aDims, bDims, outputShape)
          ]
        })
      };
    };
    runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
      context.compute(
        createBinaryOpProgramInfo(
          name,
          cacheKey ?? "",
          context.inputs[0],
          context.inputs[1],
          funcCall,
          additionalImplementation,
          outputDataType
        )
      );
    };
    add = (context) => {
      runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
    };
    div = (context) => {
      runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
    };
    equal = (context) => {
      runBinaryOp(
        context,
        "Equal",
        { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    mul = (context) => {
      runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
    };
    pow = (context) => {
      const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
      const roundStr = type === "i32" ? "round" : "";
      runBinaryOp(
        context,
        "Pow",
        { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
        `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
      );
    };
    sub = (context) => {
      runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
    };
    greater = (context) => {
      runBinaryOp(
        context,
        "Greater",
        { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    less = (context) => {
      runBinaryOp(
        context,
        "Less",
        { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    greaterOrEqual = (context) => {
      runBinaryOp(
        context,
        "GreaterOrEqual",
        { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    lessOrEqual = (context) => {
      runBinaryOp(
        context,
        "LessOrEqual",
        { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/concat.ts
var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
var init_concat = __esm({
  "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs7 = (inputs, axis) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      const referenceIndex = 0;
      const referenceInput = inputs[referenceIndex];
      const inputType = referenceInput.dataType;
      const inputRank = referenceInput.dims.length;
      inputs.forEach((input, i) => {
        if (i === referenceIndex) {
          return;
        }
        if (input.dataType !== inputType) {
          throw new Error("input tensors should be one type");
        }
        if (input.dims.length !== inputRank) {
          throw new Error("input tensors should have the same shape");
        }
        input.dims.forEach((dim, i2) => {
          if (i2 !== axis && dim !== referenceInput.dims[i2]) {
            throw new Error("non concat dimensions must match");
          }
        });
      });
    };
    calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
    assignOutputData = (inputs, output) => {
      const numberOfTensors = inputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
        }
      }
      return codeLines.join("\n");
    };
    createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
      const outputSize = ShapeUtil.size(outputShape);
      const sizeInConcatAxis = new Array(inputs.length);
      const inputVars = new Array(inputs.length);
      let previousSum = 0;
      const inputDependencies = [];
      const inputRanks = [];
      const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
      for (let i = 0; i < inputs.length; ++i) {
        previousSum += inputs[i].dims[adjustedAxis];
        sizeInConcatAxis[i] = previousSum;
        inputRanks.push(inputs[i].dims.length);
        inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
        inputDependencies.push("rank");
        programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
      }
      for (let i = 0; i < inputs.length; ++i) {
        programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const output = outputVariable("output", dataType, outputShape.length);
      const indicesAxis = output.indicesGet("indices", adjustedAxis);
      const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
      const getShaderSource = (shaderHelper) => `

  ${(() => {
        shaderHelper.registerUniform("outputSize", "u32");
        for (let i = 0; i < inputs.length; i++) {
          shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
        }
        return shaderHelper.declareVariables(...inputVars, output);
      })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
      return {
        name: "Concat",
        shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    concat = (context, attributes) => {
      const inputs = context.inputs;
      const inputShape = inputs[0].dims;
      const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      validateInputs7(inputs, adjustedAxis);
      const outputShape = inputShape.slice();
      outputShape[adjustedAxis] = inputs.reduce(
        (sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0),
        0
      );
      const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
      context.compute(createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType), {
        inputs: nonEmptyInputs
      });
    };
    parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
var init_fuse_utils = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    getActivationSnippet = (attributes, valueType, baseType = "f32") => {
      switch (attributes.activation) {
        case "Relu":
          return `value = max(value, ${valueType}(0.0));`;
        case "Sigmoid":
          return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
        case "Clip":
          return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
        case "HardSigmoid":
          return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
        case "LeakyRelu":
          return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
        case "Tanh":
          return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
        case "":
          return "";
        // TODO: adding other activations that can be fused.
        default:
          throw new Error(`Unsupported activation ${attributes.activation}`);
      }
    };
    appendActivationUniformsData = (attributes, programUniform) => {
      if (attributes.activation === "Clip") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.clipMax },
          { type: 1 /* float */, data: attributes.clipMin }
        );
      } else if (attributes.activation === "HardSigmoid") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        );
      } else if (attributes.activation === "LeakyRelu") {
        programUniform.push({ type: 1 /* float */, data: attributes.alpha });
      }
    };
    appendActivationUniforms = (attributes, uniforms) => {
      if (attributes.activation === "Clip") {
        uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
      } else if (attributes.activation === "HardSigmoid") {
        uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
      } else if (attributes.activation === "LeakyRelu") {
        uniforms.push({ name: "alpha", type: "f32" });
      }
    };
    parseInternalActivationAttributes = (attributes) => {
      const activation = attributes?.activation || "";
      if (activation === "HardSigmoid") {
        const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
        return { activation, alpha, beta };
      } else if (activation === "Clip") {
        const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
        return { activation, clipMax, clipMin };
      } else if (activation === "LeakyRelu") {
        const [alpha] = attributes?.activation_params || [0.01];
        return { activation, alpha };
      }
      return { activation };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
var typeSnippet, biasSnippet;
var init_activation_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
    "use strict";
    typeSnippet = (component, dataType) => {
      switch (component) {
        case 1:
          return dataType;
        case 2:
          return `vec2<${dataType}>`;
        case 3:
          return `vec3<${dataType}>`;
        case 4:
          return `vec4<${dataType}>`;
        default:
          throw new Error(`${component}-component is not supported.`);
      }
    };
    biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
var utilFunctions;
var init_conv_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
    "use strict";
    utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts
var convertOutputBatchIndicesToInputBatchIndices, createNaiveMatmulProgramInfo;
var init_matmul_shaders = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    convertOutputBatchIndicesToInputBatchIndices = (targetIndicesName, inputVariable2, inputBatchRank, outputBatchRank, batchIndicesName) => {
      const extendingInputRank = outputBatchRank - inputBatchRank;
      return `
      ${Array.from({ length: inputBatchRank }).map(
        (_, i) => `
      if (${getElementAt(inputVariable2.shape, i, inputVariable2.rank)} != 1) {
        ${inputVariable2.indicesSet(targetIndicesName, i, getElementAt(batchIndicesName, i + extendingInputRank, outputBatchRank))}
      } else {
        ${inputVariable2.indicesSet(targetIndicesName, i, 0)}
      }`
      ).join("")}
`;
    };
    createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const M = aShape[aShape.length - 2];
      const N = bShape[bShape.length - 1];
      const K = aShape[aShape.length - 1];
      const components = getMaxComponents(N);
      const aComponents = getMaxComponents(K);
      const outputNumber = getMaxComponents(M);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const hasBias = inputs.length > 2;
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const outputShapeInShader = [batchSize, M, N];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
      const getShaderSource = (shaderHelper) => {
        const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
        const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
        const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const inputVariables = [a, b];
        let processBias = "";
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" }
        ];
        appendActivationUniforms(activationAttributes, uniforms);
        const calcResult = () => {
          let calcStr = `var a_data: ${a.type.value};`;
          for (let i = 0; i < aComponents; i++) {
            calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
          }
          for (let i = 0; i < outputNumber; i++) {
            calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
            for (let j = 0; j < aComponents; j++) {
              calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
            }
          }
          return calcStr;
        };
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}

    var a_indices: ${a.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("a_indices", a, a.rank - 2, batchDims.rank, "batch_indices")}
    ${a.indicesSet("a_indices", a.rank - 2, 0)}
    ${a.indicesSet("a_indices", a.rank - 1, 0)}
    let a_offset = ${a.indicesToOffset("a_indices")};

    var b_indices: ${b.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("b_indices", b, b.rank - 2, batchDims.rank, "batch_indices")}
    ${b.indicesSet("b_indices", b.rank - 2, 0)}
    ${b.indicesSet("b_indices", b.rank - 1, 0)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
      };
      return {
        name: "MatMulNaive",
        shaderCache: {
          hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
          inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
var init_matmul_packed_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    init_matmul_shaders();
    init_activation_util();
    writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      } else {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      }
    };
    calculateResultSnippet = (transposeA, innerElementSize) => {
      if (transposeA) {
        return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
      } else {
        return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
      }
    };
    makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
      const tileAOuter = workgroupSize[1] * workPerThread[1];
      const tileBOuter = workgroupSize[0] * workPerThread[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      const innerElementSize = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
        throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
      }
      return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
    };
    writeDataToSubASnippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      } else {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      }
    };
    readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
    makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
      const tileAOuter = workPerThread[1] * workgroupSize[1];
      const tileBOuter = workPerThread[0] * workgroupSize[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
        throw new Error(
          `tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`
        );
      }
      const rowPerThreadA = tileAHight / workgroupSize[1];
      const colPerThreadA = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
      return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;
    ${matmulSnippet}
  }
`;
    };
    matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, isChannelsLast = false) => {
      const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
      const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
      const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
        component,
        dataType
      )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${aVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
        "aIndices",
        aVariable,
        aVariable.rank - 2,
        batchVariable.rank,
        "batchIndices"
      )}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 2, "u32(row)")}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 1, "u32(colIn)")}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
        component,
        dataType
      )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${bVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
        "bIndices",
        bVariable,
        bVariable.rank - 2,
        batchVariable.rank,
        "batchIndices"
      )}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 2, "u32(row)")}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 1, "u32(colIn)")}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
      return source;
    };
    createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const outerDimsA = aShape.slice(0, -2);
      const outerDimsB = bShape.slice(0, -2);
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const dimAOuter = aShape[aShape.length - 2];
      const dimInner = aShape[aShape.length - 1];
      const dimBOuter = bShape[bShape.length - 1];
      const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const workgroupSize = [8, 8, 1];
      const dispatch = [
        Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
        Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
      ];
      const components = isVec4 ? 4 : 1;
      const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
      const aRank = aShapeTemp.length;
      const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
      const bRank = bShapeTemp.length;
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
      const inputDependencies = ["rank", "rank"];
      const hasBias = inputs.length > 2;
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const batchRank = outerDims.length;
        const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const A = inputVariable("a", inputs[0].dataType, aRank, components);
        const B = inputVariable("b", inputs[1].dataType, bRank, components);
        const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
        const inputVariables = [A, B];
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
        }
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" }
        ];
        appendActivationUniforms(activationAttributes, uniforms);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const declareFunctions = matMulReadWriteFnSource(
          components,
          hasBias,
          applyActivation,
          [batchDims, A, B, output],
          isChannelsLast
        );
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
      };
      return {
        name: "MatMul",
        shaderCache: {
          hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
var init_conv2d_mm_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_common();
    init_fuse_utils();
    init_activation_util();
    init_conv_util();
    init_matmul_packed_webgpu();
    conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
      const getXSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "resData = x[xIndex];";
          case 3:
            return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
          case 4:
            return "resData = x[xIndex / 4];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const getWSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
          case 4:
            return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
      const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
      const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
      const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
      const row = isChannelsLast ? "row" : "col";
      const col = isChannelsLast ? "col" : "row";
      const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
      const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
      const sampleW = isChannelsLast ? fitInner && fitBOuter ? getWSnippet(innerElementSizeW) : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);` : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);`;
      const resType = typeSnippet(innerElementSize, dataType);
      const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
      const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
      const applyActivation = getActivationSnippet(attributes, resType, dataType);
      const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
      return userCode;
    };
    createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads, squeezeOutputShapeFunction) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const batchSize = outputShape[0];
      const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
      const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
      const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
      const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
      const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
      const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
      const workGroupSize = [8, 8, 1];
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const dispatch = [
        Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
        Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
      ];
      LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
      const tileAOuter = workGroupSize[1] * elementsPerThread[1];
      const tileBOuter = workGroupSize[0] * elementsPerThread[0];
      const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
      const fitAOuter = dimAOuter % tileAOuter === 0;
      const fitBOuter = dimBOuter % tileBOuter === 0;
      const fitInner = dimInner % tileInner === 0;
      const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 6 /* int32 */, data: attributes.strides },
        { type: 6 /* int32 */, data: attributes.dilations }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" },
          { name: "pad", type: "i32", length: 2 },
          { name: "stride", type: "i32", length: 2 },
          { name: "dilation", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        const components = isVec4 ? 4 : 1;
        const t = tensorTypeToWsglStorageType(inputs[0].dataType);
        let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
        const x = inputVariable(
          "x",
          inputs[0].dataType,
          inputs[0].dims.length,
          innerElementSize === 3 ? 1 : innerElementSize
        );
        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
        const inputVariables = [x, w];
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
        }
        return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
          isChannelsLast,
          fitAOuter,
          fitBOuter,
          fitInner,
          hasBias,
          attributes,
          elementsSize[0],
          elementsSize[1],
          elementsSize[2],
          t
        )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
          elementsPerThread,
          workGroupSize,
          t,
          void 0,
          !isChannelsLast,
          tileInner,
          false,
          void 0,
          sequentialAccessByThreads
        )}`;
      };
      return {
        name: "Conv2DMatMul",
        shaderCache: {
          hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
var arrayProduct, parse3TupleParam, getEffectiveFilterSize, computeDefaultPad, computeOutputShape4D, get3DPadAndOutInfo, computeConv3DInfo, createConv3DNaiveProgramInfo;
var init_conv3d_naive_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_common();
    init_fuse_utils();
    init_activation_util();
    arrayProduct = (arr) => {
      let product = 1;
      for (let i = 0; i < arr.length; i++) {
        product *= arr[i];
      }
      return product;
    };
    parse3TupleParam = (param) => typeof param === "number" ? [param, param, param] : param;
    getEffectiveFilterSize = (filterSize, dilation) => {
      if (dilation <= 1) {
        return filterSize;
      }
      return filterSize + (filterSize - 1) * (dilation - 1);
    };
    computeDefaultPad = (inputShape, fieldSize, stride, dilation = 1) => {
      const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
      return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
    };
    computeOutputShape4D = (inShape, filterShape, outChannels, strides, zeroPad) => {
      if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
      }
      const outShape = [0, 0, 0, outChannels];
      for (let index = 0; index < 3; index++) {
        if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
          outShape[index] = Math.trunc((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1);
        }
      }
      return outShape;
    };
    get3DPadAndOutInfo = (pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth) => {
      let padInfo;
      let outDepth;
      let outHeight;
      let outWidth;
      if (pad2 === "VALID") {
        pad2 = 0;
      }
      if (typeof pad2 === "number") {
        padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, front: pad2, back: pad2 };
        const outShape = computeOutputShape4D(
          [inDepth, inHeight, inWidth, 1],
          [filterDepth, filterHeight, filterWidth],
          1,
          [strideDepth, strideHeight, strideWidth],
          pad2
        );
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (Array.isArray(pad2)) {
        if (!pad2.every((val, _, arr) => val === arr[0])) {
          throw Error(`Unsupported padding parameter: ${pad2}`);
        }
        padInfo = { top: pad2[0], bottom: pad2[1], left: pad2[2], right: pad2[3], front: pad2[4], back: pad2[5] };
        const outShape = computeOutputShape4D(
          [inDepth, inHeight, inWidth, 1],
          [filterDepth, filterHeight, filterWidth],
          1,
          [strideDepth, strideHeight, strideWidth],
          pad2[0]
        );
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (pad2 === "SAME_UPPER") {
        outDepth = Math.ceil(inDepth / strideDepth);
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        const front = Math.floor(padAlongDepth / 2);
        const back = padAlongDepth - front;
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = { top, bottom, left, right, front, back };
      } else {
        throw Error(`Unknown padding parameter: ${pad2}`);
      }
      return { padInfo, outDepth, outHeight, outWidth };
    };
    computeConv3DInfo = (inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast") => {
      let batchSize, inDepth, inHeight, inWidth, inChannels;
      if (dataFormat === "channelsLast") {
        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
      } else if (dataFormat === "channelsFirst") {
        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      const [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
      const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
      const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
      const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
      const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
      const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
      const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(
        pad2,
        inDepth,
        inHeight,
        inWidth,
        strideDepth,
        strideHeight,
        strideWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth
      );
      const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
      let outShape = [0, 0, 0, 0, 0];
      if (dataFormat === "channelsFirst") {
        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
      } else if (dataFormat === "channelsLast") {
        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
      }
      return {
        batchSize,
        dataFormat,
        inDepth,
        inHeight,
        inWidth,
        inChannels,
        outDepth,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideDepth,
        strideHeight,
        strideWidth,
        filterDepth,
        filterHeight,
        filterWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationDepth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
      };
    };
    createConv3DNaiveProgramInfo = (inputs, attributes, outputShape, filterDims, pads, dataFormat) => {
      const isChannelLast = dataFormat === "channelsLast";
      const inChannels = isChannelLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const isVec4 = false;
      const workGroupSize = [64, 1, 1];
      const dispatchLayout = { x: outputShape.map((_, i) => i) };
      const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map((d) => outputShape[d])) / workGroupSize[0]), 1, 1];
      LOG_DEBUG("verbose", () => `[conv3d_naive_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? isChannelLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: filterDims },
        { type: 12 /* uint32 */, data: pads },
        { type: 12 /* uint32 */, data: attributes.strides },
        { type: 12 /* uint32 */, data: attributes.dilations }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      const hasBias = inputs.length === 3;
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "filter_dims", type: "u32", length: filterDims.length },
          { name: "pads", type: "u32", length: pads.length },
          { name: "strides", type: "u32", length: attributes.strides.length },
          { name: "dilations", type: "u32", length: attributes.dilations.length }
        ];
        appendActivationUniforms(attributes, uniforms);
        const components = isVec4 ? 4 : 1;
        const t = tensorTypeToWsglStorageType(inputs[0].dataType);
        const x = inputVariable(
          "x",
          inputs[0].dataType,
          inputs[0].dims.length,
          innerElementSize === 3 ? 1 : innerElementSize
        );
        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
        const inputVariables = [x, w];
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        let declareFunctions = "";
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[${isChannelLast ? getElementAt("coords", 4, 5) : getElementAt("coords", 1, 5)}${isVec4 ? "/ 4" : ""}];
        }`;
        }
        const resType = typeSnippet(innerElementSize, t);
        const applyActivation = getActivationSnippet(attributes, resType, t);
        return `
            ${declareFunctions}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
          ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${output.offsetToIndices("global_idx")};
              let batch = ${getElementAt("coords", 0, x.rank)};
              let d2 = ${isChannelLast ? getElementAt("coords", x.rank - 1, x.rank) : getElementAt("coords", 1, x.rank)};
              let xFRCCorner = vec3<u32>(${isChannelLast ? getElementAt("coords", 1, x.rank) : getElementAt("coords", 2, x.rank)},
              ${isChannelLast ? getElementAt("coords", 2, x.rank) : getElementAt("coords", 3, x.rank)},
              ${isChannelLast ? getElementAt("coords", 3, x.rank) : getElementAt("coords", 4, x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${isChannelLast ? getElementAt("uniforms.x_shape", 1, x.rank) : getElementAt("uniforms.x_shape", 2, x.rank)};
              let xShapeZ = ${isChannelLast ? getElementAt("uniforms.x_shape", 2, x.rank) : getElementAt("uniforms.x_shape", 3, x.rank)};
              let xShapeW = ${isChannelLast ? getElementAt("uniforms.x_shape", 3, x.rank) : getElementAt("uniforms.x_shape", 4, x.rank)};
              let xShapeU = ${isChannelLast ? getElementAt("uniforms.x_shape", 4, x.rank) : getElementAt("uniforms.x_shape", 1, x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${isChannelLast ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${isChannelLast ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${isChannelLast ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${isChannelLast ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${hasBias ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${applyActivation}
              result[global_idx] = f32(value);
          }`;
      };
      return {
        name: "Conv3DNaive",
        shaderCache: { hint: `${attributes.cacheKey};${isChannelLast};${innerElementSize};${hasBias}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
var init_conv_grouped = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    createGroupedConvProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += b[output_channel];" : "";
      const xShape = inputs[0].dims;
      const wShape = inputs[1].dims;
      const isChannelLast = attributes.format === "NHWC";
      const outputChannels = isChannelLast ? outputShape[3] : outputShape[1];
      const outputChannelsPerGroup = outputChannels / attributes.group;
      const components = isChannelLast && outputChannelsPerGroup >= 4 ? getMaxComponents(outputChannels) : 1;
      const outputSize = ShapeUtil.size(outputShape) / components;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: attributes.dilations },
        { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(
        ...createTensorShapeVariables(xShape, [wShape[0], wShape[1], wShape[2], wShape[3] / components])
      );
      const inputDependencies = hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"];
      programUniforms.push(
        ...createTensorShapeVariables([outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components])
      );
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length);
        const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "dilations", type: "u32", length: attributes.dilations.length },
          { name: "strides", type: "u32", length: 2 },
          { name: "pads", type: "u32", length: 2 },
          { name: "output_channels_per_group", type: "u32" }
        ];
        appendActivationUniforms(attributes, uniforms);
        const calculateResult = isChannelLast ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${w.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${components} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${isChannelLast ? 2 : 1}];

    var value: ${output.type.value} = ${output.type.value}(0);
    ${calculateResult}
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
      };
      return {
        name: "GroupedConv",
        shaderCache: { hint: `${attributes.cacheKey}_${components}`, inputDependencies },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const components = getMaxComponents(outputShape[3]);
      const outputNumber = getMaxComponents(outputShape[2]);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
      const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
      const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
      const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
        const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
        }
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "i32", length: 2 },
          { name: "pads", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
      };
      return {
        name: "GroupedConv-Vectorize",
        shaderCache: {
          hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
          inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv.ts
var calculateOutputShape, weightTransposeAttribute, validateInputs8, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv3d, conv;
var init_conv = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
    "use strict";
    init_util();
    init_conv2d_mm_webgpu();
    init_conv3d_naive_webgpu();
    init_matmul_packed_webgpu();
    init_conv_grouped();
    init_fuse_utils();
    init_matmul_shaders();
    init_transpose();
    calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
      const batchSize = inputShape[0];
      const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
      const spatialRank = inputSpatialShape.length;
      const outChannels = kernelShape[0];
      const kernelSpatialShape = kernelShape.slice(2);
      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
      const outputShape = inputSpatialShapeWithPad.map(
        (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
      );
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      return outputShape;
    };
    weightTransposeAttribute = [2, 3, 1, 0];
    validateInputs8 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length > 5) {
        throw new Error("greater than 5D is not supported");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[1] * attributes.group;
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
    };
    getAdjustedConvAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (kernelShape.length < inputs[1].dims.length - 2) {
        kernelShape.push(...Array(inputs[1].dims.length - 2 - kernelShape.length).fill(0));
      }
      for (let i = 2; i < inputs[1].dims.length; ++i) {
        if (kernelShape[i - 2] === 0) {
          kernelShape[i - 2] = inputs[1].dims[i];
        }
      }
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPadsBasedOnAutoPad(
        inputs[0].dims,
        attributes.strides,
        attributes.dilations,
        kernelShape,
        pads,
        attributes.format === "NHWC",
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads });
      return newAttributes;
    };
    parseConvAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
      const dilations = attributes.dilations;
      const group = attributes.group;
      const kernelShape = attributes.kernel_shape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.w_is_const();
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    conv2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
      const isChannelsLast = attributes.format === "NHWC";
      const outputShape = calculateOutputShape(
        inputs[0].dims,
        inputs[1].dims,
        attributes.dilations,
        attributes.pads,
        attributes.strides,
        isChannelsLast
      );
      if (attributes.group !== 1) {
        const convInputs2 = [inputs[0]];
        if (isChannelsLast) {
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
            inputs: [1],
            outputs: [attributes.wIsConst ? -2 : -1]
          })[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          convInputs2.push(transposedWeight2);
        } else {
          convInputs2.push(inputs[1]);
        }
        if (inputs.length === 3) {
          convInputs2.push(inputs[2]);
        }
        const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
        if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
          context.compute(
            createGroupedConvVectorizeProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction),
            { inputs: convInputs2 }
          );
        } else {
          context.compute(createGroupedConvProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction), {
            inputs: convInputs2
          });
        }
        return;
      }
      const hasBias = inputs.length === 3;
      const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
      const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
      const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
      const weightHeight = inputs[1].dims[2];
      const weightWidth = inputs[1].dims[3];
      const outHeight = outputShape[isChannelsLast ? 1 : 2];
      const outWidth = outputShape[isChannelsLast ? 2 : 3];
      const outChannels = outputShape[isChannelsLast ? 3 : 1];
      const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
      if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
        const batch = outputShape[0];
        let xReshaped, wReshaped, matmulOutputShape;
        const matmulInputs = [];
        if (isChannelsLast) {
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
            inputs: [1],
            outputs: [attributes.wIsConst ? -2 : -1]
          })[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          if (sameSize) {
            const sharedDim = inputHeight * inputWidth * inputChannels;
            xReshaped = inputs[0].reshape([1, batch, sharedDim]);
            wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
            matmulOutputShape = [1, batch, outChannels];
          } else {
            xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
            wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
            matmulOutputShape = [batch, outHeight * outWidth, outChannels];
          }
          matmulInputs.push(xReshaped);
          matmulInputs.push(wReshaped);
        } else {
          xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
          wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
          matmulOutputShape = [batch, outChannels, outHeight * outWidth];
          matmulInputs.push(wReshaped);
          matmulInputs.push(xReshaped);
        }
        if (hasBias) {
          matmulInputs.push(inputs[2]);
        }
        const N = matmulOutputShape[2];
        const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(
            createNaiveMatmulProgramInfo(
              matmulInputs,
              attributes,
              outputShape,
              matmulOutputShape,
              isChannelsLast,
              squeezeOutputShapeFunction
            ),
            { inputs: matmulInputs }
          );
        } else {
          context.compute(
            createMatmulProgramInfo(
              matmulInputs,
              attributes,
              outputShape,
              matmulOutputShape,
              isChannelsLast,
              squeezeOutputShapeFunction
            ),
            { inputs: matmulInputs }
          );
        }
        return;
      }
      const sequentialAccessByThreads = (
        /* backend.adapterInfo.isIntel() */
        true
      );
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
        inputs: [1],
        outputs: [attributes.wIsConst ? -2 : -1]
      })[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convInputs = [inputs[0], transposedWeight];
      if (hasBias) {
        convInputs.push(inputs[2]);
      }
      const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
      const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
      const dimInner = weightHeight * weightWidth * inputChannels;
      context.compute(
        createConv2DMatMulProgramInfo(
          convInputs,
          attributes,
          outputShape,
          dimAOuter,
          dimBOuter,
          dimInner,
          hasBias,
          sequentialAccessByThreads,
          squeezeOutputShapeFunction
        ),
        { inputs: convInputs }
      );
    };
    conv1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
      const strides = [1].concat(attributes.strides);
      const dilations = [1].concat(attributes.dilations);
      const kernelShape = [1].concat(attributes.kernelShape);
      const adjustedAttributes = getAdjustedConvAttributes(
        { ...attributes, pads, strides, dilations, kernelShape },
        inputs
      );
      conv2d(
        context,
        inputs,
        adjustedAttributes,
        (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
      );
    };
    conv3d = (context, inputs, attributes) => {
      const format = attributes.format === "NHWC" ? "channelsLast" : "channelsFirst";
      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
      const pads = attributes.autoPad === "NOTSET" ? attributes.pads : attributes.autoPad;
      const convInfo = computeConv3DInfo(
        inputs[0].dims,
        inputs[1].dims,
        attributes.strides,
        attributes.dilations,
        pads,
        false,
        format
      );
      context.compute(
        createConv3DNaiveProgramInfo(
          inputs,
          adjustedAttributes,
          convInfo.outShape,
          [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth],
          [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left],
          format
        )
      );
    };
    conv = (context, attributes) => {
      validateInputs8(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        conv1d(context, attributes);
      } else if (context.inputs[0].dims.length === 5) {
        conv3d(context, context.inputs, attributes);
      } else {
        const adjustedAttributes = getAdjustedConvAttributes(attributes, context.inputs);
        conv2d(context, context.inputs, adjustedAttributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
var createConvTranspose2DProgramInfo;
var init_conv_backprop_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_common();
    createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const outputShape = attributes.outputShape;
      const isChannelsLast = attributes.format === "NHWC";
      const group = attributes.group;
      const wShape = inputs[1].dims;
      const inputChannelsPerGroup = wShape[2] / group;
      const outputChannelsPerGroup = wShape[3];
      const aComponents = isChannelsLast ? getMaxComponents(inputChannelsPerGroup) : 1;
      const packInputAs4 = isChannelsLast && outputChannelsPerGroup === 1 && inputChannelsPerGroup >= 4;
      const inputChannelsPerGroupInt = packInputAs4 ? Math.floor(inputChannelsPerGroup / 4) * 4 : Math.floor(inputChannelsPerGroup / aComponents) * aComponents;
      const inputChannelsRemainder = inputChannelsPerGroup - inputChannelsPerGroupInt;
      const components = isChannelsLast ? getMaxComponents(outputChannelsPerGroup) : 1;
      const bComponents = isChannelsLast ? outputChannelsPerGroup === 1 ? aComponents : components : 1;
      const outputSize = ShapeUtil.size(outputShape) / components;
      const dispatch = [Math.ceil(outputSize / 64), 1, 1];
      LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
      const inputDependencies = ["rank", "rank"];
      const strides = [attributes.strides[0], attributes.strides[1]];
      const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
      const dilations = [attributes.dilations[0], attributes.dilations[1]];
      const effectiveFilterDims = [
        filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
        filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
      ];
      const pads = [
        effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
        effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
      ];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: strides },
        { type: 12 /* uint32 */, data: filterDims },
        { type: 12 /* uint32 */, data: dilations },
        { type: 12 /* uint32 */, data: effectiveFilterDims },
        { type: 6 /* int32 */, data: pads },
        { type: 12 /* uint32 */, data: inputChannelsPerGroupInt },
        { type: 12 /* uint32 */, data: inputChannelsPerGroup },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
      ];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "u32", length: strides.length },
          { name: "filter_dims", type: "u32", length: filterDims.length },
          { name: "dilations", type: "u32", length: filterDims.length },
          { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
          { name: "pads", type: "i32", length: pads.length },
          { name: "input_channels_per_group_int", type: "u32" },
          { name: "input_channels_per_group", type: "u32" },
          { name: "output_channels_per_group", type: "u32" }
        ];
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, bComponents);
        const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, aComponents);
        const inputVariables = [dy, w];
        if (hasBias) {
          inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
        }
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        const calculateResult = () => {
          let calcStr = "";
          if (packInputAs4) {
            if (aComponents === 4) {
              calcStr += `
        let xValue = ${dy.getByOffset("x_offset")};
        let wValue = ${w.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`;
            } else if (aComponents === 2) {
              calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`;
            } else if (aComponents === 1) {
              calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}, ${dy.getByOffset("x_offset + 2u")}, ${dy.getByOffset("x_offset + 3u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}, ${w.getByOffset("w_offset + 2u")}, ${w.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`;
            }
          } else {
            calcStr += `
                  let xValue = ${isChannelsLast ? dy.getByOffset(
              `${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents}`
            ) : dy.get("batch", "inputChannel", "idyR", "idyC")};
        `;
            if (aComponents === 1) {
              calcStr += `
          let w_offset = ${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${w.getByOffset(`w_offset / ${bComponents}`)};
          dotProd = dotProd + xValue * wValue;`;
            } else {
              for (let c = 0; c < aComponents; c++) {
                calcStr += `
            let wValue${c} = ${w.getByOffset(`${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${c}, wOutChannel)`)} / ${bComponents}`)};
            dotProd = dotProd + xValue[${c}] * wValue${c};`;
              }
            }
          }
          return calcStr;
        };
        const calculateRemainder = () => {
          if (inputChannelsRemainder === 0) {
            return "";
          }
          if (!packInputAs4) {
            throw new Error(`packInputAs4 ${packInputAs4} is not true.`);
          }
          let calcStr = "";
          if (aComponents === 1) {
            calcStr += "dotProd = dotProd";
            for (let i = 0; i < inputChannelsRemainder; i++) {
              calcStr += `
            + ${dy.getByOffset(`x_offset + ${i}`)} * ${w.getByOffset(`w_offset + ${i}`)}`;
            }
            calcStr += ";";
          } else if (aComponents === 2) {
            if (inputChannelsRemainder !== 2) {
              throw new Error(`Invalid inputChannelsRemainder ${inputChannelsRemainder}.`);
            }
            calcStr += `
          let xValue = ${dy.getByOffset("x_offset")};
          let wValue = ${w.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`;
          }
          return calcStr;
        };
        const codeSnippet = `
            let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
            let batch = ${output.indicesGet("outputIndices", 0)};
            let d1 = ${output.indicesGet("outputIndices", channelDim)};
            let r = ${output.indicesGet("outputIndices", rowDim)};
            let c = ${output.indicesGet("outputIndices", colDim)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${output.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${packInputAs4 ? `
                var x_offset = ${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents};
                var w_offset = ${w.indicesToOffset(`${w.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${bComponents};
                  ` : ""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${packInputAs4 ? 4 : aComponents}) {
                  ${calculateResult()}
                  inputChannel = inputChannel + ${packInputAs4 ? 4 : aComponents};
                }
                ${calculateRemainder()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${hasBias ? ` + bias[d1 / ${components}]` : ""};
            ${output.setByOffset("global_idx", "value")};
          `;
        return `
    ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${codeSnippet}}`;
      };
      return {
        name: "ConvTranspose2D",
        shaderCache: {
          hint: `${attributes.cacheKey};${aComponents}${bComponents}${components}${packInputAs4}${inputChannelsRemainder}`,
          inputDependencies
        },
        getRunData: () => ({
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs9, convTranspose2d, convTranspose1d, convTranspose;
var init_conv_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
    "use strict";
    init_conv_backprop_webgpu();
    init_fuse_utils();
    init_transpose();
    computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
    distributePadding = (totalPad, autoPad, pads, head, tail) => {
      const smallPad = Math.floor(totalPad / 2);
      if (autoPad === "SAME_UPPER") {
        pads[head] = smallPad;
        pads[tail] = totalPad - smallPad;
      } else if (autoPad === "SAME_LOWER") {
        pads[head] = totalPad - smallPad;
        pads[tail] = smallPad;
      }
    };
    calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
      const spatialRank = inputShape.length - 2;
      const updateOutputShape = outputShape.length === 0;
      if (outputPadding.length < spatialRank) {
        outputPadding.push(...Array(spatialRank - outputPadding.length).fill(0));
      }
      const batchSize = inputShape[0];
      const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
      for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
        const inSize = inputShape[j];
        const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
        const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
        if (updateOutputShape) {
          outputShape.push(
            strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
          );
        }
      }
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
    };
    getAdjustedConvTransposeAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
        kernelShape.length = 0;
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const isChannelsLast = attributes.format === "NHWC";
      kernelShape.splice(0, 0, inputs[1].dims[0]);
      kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
      const pads = attributes.pads.slice();
      const outputShape = attributes.outputShape.slice();
      const outputPadding = attributes.outputPadding.slice();
      const inputShape = inputs[0].dims;
      let dilations = attributes.dilations.slice();
      if (dilations.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        dilations = new Array(spatialRank).fill(1);
      }
      let strides = attributes.strides.slice();
      if (strides.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        strides = new Array(spatialRank).fill(1);
      }
      calculateOutputShapeAndPads(
        inputShape,
        kernelShape,
        dilations,
        attributes.autoPad,
        attributes.group,
        pads,
        strides,
        isChannelsLast,
        outputPadding,
        outputShape
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
      return newAttributes;
    };
    parseConvTransposeAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
      const dilations = attributes.dilations;
      const group = attributes.group ?? 1;
      const kernelShape = attributes.kernelShape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.wIsConst();
      const outputPadding = attributes.outputPadding;
      const outputShape = attributes.outputShape;
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        outputPadding,
        outputShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    validateInputs9 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
        throw new Error("currently only support 2-dimensional conv");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[0];
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      const featureMaps = inputs[1].dims[1] * attributes.group;
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
      if (dilationsSet && attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
      if (stridesSet && attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
      if (padsSet && attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
        throw new Error(`output_padding should be ${spatialRank}D`);
      }
      const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
      if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
        throw new Error("invalid output shape");
      }
    };
    convTranspose2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], [2, 3, 0, 1]), {
        inputs: [1],
        outputs: [attributes.wIsConst ? -2 : -1]
      })[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convTransposeInputs = [inputs[0], transposedWeight];
      if (inputs.length === 3) {
        convTransposeInputs.push(inputs[2]);
      }
      context.compute(createConvTranspose2DProgramInfo(convTransposeInputs, attributes, squeezeOutputShapeFunction), {
        inputs: convTransposeInputs
      });
    };
    convTranspose1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      let kernelShape = attributes.kernelShape;
      if (kernelShape.length === 0 || kernelShape[0] === 0) {
        kernelShape = [context.inputs[1].dims[2]];
      }
      let dilations = attributes.dilations;
      if (dilations.length === 0 || dilations[0] === 0) {
        dilations = [1];
      }
      let strides = attributes.strides;
      if (strides.length === 0 || strides[0] === 0) {
        strides = [1];
      }
      let pads = attributes.pads;
      if (pads.length === 0) {
        pads = [0, 0];
      }
      pads = [0, pads[0], 0, pads[1]];
      strides = [1].concat(strides);
      dilations = [1].concat(dilations);
      kernelShape = [1].concat(kernelShape);
      let outputPadding = attributes.outputPadding;
      outputPadding = [0].concat(outputPadding);
      const adjustedAttributes = getAdjustedConvTransposeAttributes(
        { ...attributes, pads, strides, dilations, kernelShape, outputPadding },
        inputs
      );
      convTranspose2d(
        context,
        inputs,
        adjustedAttributes,
        (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
      );
    };
    convTranspose = (context, attributes) => {
      validateInputs9(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        convTranspose1d(context, attributes);
      } else {
        const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, context.inputs);
        convTranspose2d(context, context.inputs, adjustedAttributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/cumsum.ts
var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
var init_cumsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
      const outputSize = ShapeUtil.size(inputShape);
      const rank = inputShape.length;
      const input = inputVariable("input", inputType, rank);
      const output = outputVariable("output", inputType, rank);
      const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
      const axis = ShapeUtil.normalizeAxis(axisValue, rank);
      const getShaderSource = (shaderHelper) => {
        const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
        const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
        const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
        const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
        return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
      };
      return {
        name: "CumSum",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: inputShape, dataType: inputType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 12 /* uint32 */, data: axis },
            ...createTensorShapeVariables(inputShape, inputShape)
          ]
        }),
        getShaderSource
      };
    };
    cumsum = (context, attributes) => {
      const inputShape = context.inputs[0].dims;
      const inputType = context.inputs[0].dataType;
      const axis = context.inputs[1];
      context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
    };
    parseCumSumAttributes = (attributes) => {
      const exclusive = attributes.exclusive === 1;
      const reverse = attributes.reverse === 1;
      return createAttributeWithCacheKey({ exclusive, reverse });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
var validateInputs10, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
var init_depth_to_space = __esm({
  "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs10 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("DepthToSpace requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("DepthToSpace requires 4D input.");
      }
    };
    permFunctionBody2 = (perm, rank, input, output) => {
      const reverseFunc = [];
      reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
      for (let i = 0; i < rank; ++i) {
        reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
      }
      reverseFunc.push("return a;}");
      return reverseFunc.join("\n");
    };
    createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
      let n, h, w, c;
      let shape;
      let perm;
      const isChannelLast = attributes.format === "NHWC";
      const blocksize = attributes.blocksize;
      const isDCRmode = attributes.mode === "DCR";
      if (isChannelLast) {
        [n, h, w, c] = inputTensor.dims;
        shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
        perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
      } else {
        [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
        shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
        perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
      }
      const reshapedInputTensor = inputTensor.reshape(shape);
      const reshapedInputRank = reshapedInputTensor.dims.length;
      const inputDataType = inputTensor.dataType;
      const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
      const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
      return {
        name: "DepthToSpace",
        shaderCache: {
          hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`,
          inputDependencies: ["rank"]
        },
        getRunData: (inputs) => {
          const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
          const outputSize = ShapeUtil.size(outputShape);
          const shapeBeforePerm = reshapedInputTensor.dims;
          const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
          return {
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)
            ]
          };
        },
        getShaderSource
      };
    };
    depthToSpace = (context, attributes) => {
      validateInputs10(context.inputs);
      context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
    };
    parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
      blocksize: attributes.blocksize,
      mode: attributes.mode,
      format: attributes.format
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/einsum.ts
var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
var init_einsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    symbolPattern = "[a-zA-Z]|\\.\\.\\.";
    termPattern = "(" + symbolPattern + ")+";
    termPatternOnly = "^" + termPattern + "$";
    lhsPattern = "(" + termPattern + ",)*" + termPattern;
    lhsPatternOnly = "^" + lhsPattern + "$";
    EinsumTerm = class {
      constructor(inputIndex = -1) {
        this.symbolToIndices = /* @__PURE__ */ new Map();
        this.inputIndex = inputIndex;
      }
      // Add a symbol to the term
      addSymbol(symbol, index) {
        let value = this.symbolToIndices.get(symbol);
        if (value === void 0) {
          value = [index];
        } else {
          value.push(index);
        }
        this.symbolToIndices.set(symbol, value);
      }
      // -1 for output and 0, 1, 2, ... for inputs
    };
    EinsumEquation = class {
      constructor(inputs, equation) {
        this.equation = equation;
        this.hasEllipsis = false;
        this.symbolToInfo = /* @__PURE__ */ new Map();
        this.lhs = new Array();
        this.outputDims = [];
        let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
        if (!lhs.match(RegExp(lhsPatternOnly))) {
          throw new Error("Invalid LHS term");
        }
        const inputTerms = lhs.split(",");
        inputTerms.forEach((inputTerm, index) => {
          const dims = inputs[index].dims.slice();
          if (!inputTerm.match(RegExp(termPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const einsumTerm = this.processTerm(inputTerm, true, dims, index);
          this.lhs.push(einsumTerm);
        });
        if (rhs === "") {
          rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
        } else {
          if (!rhs.match(RegExp(termPattern))) {
            throw new Error("Invalid RHS");
          }
        }
        const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
        rhsSymbols?.forEach((symbol) => {
          if (symbol === "...") {
            this.outputDims = this.outputDims.concat(this.ellipsisDims);
          } else {
            const info = this.symbolToInfo.get(symbol);
            if (info === void 0) {
              throw new Error("Invalid RHS symbol");
            }
            this.outputDims.push(info.dimValue);
          }
        });
        this.rhs = this.processTerm(rhs, false, this.outputDims);
      }
      // End of EinsumEqation constructor
      // Add a symbol to the equation
      addSymbol(symbol, dimValue, inputIndex) {
        let info = this.symbolToInfo.get(symbol);
        if (info !== void 0) {
          if (info.dimValue !== dimValue && info.count !== 1) {
            throw new Error("Dimension mismatch");
          } else {
            info.count++;
            info.inputIndices.push(inputIndex);
          }
        } else {
          info = { count: 1, dimValue, inputIndices: [inputIndex] };
        }
        this.symbolToInfo.set(symbol, info);
      }
      // Process one input/output term
      processTerm(term, isInput, dims, index = -1) {
        const rank = dims.length;
        let ellipsis = false;
        let ellipsisDims = [];
        let nextDim = 0;
        if (!term.match(RegExp(termPatternOnly)) && !isInput && term !== "") {
          throw new Error("Invalid LHS term");
        }
        const indexSymbols = term.match(RegExp(symbolPattern, "g"));
        const einsumTerm = new EinsumTerm(index);
        indexSymbols?.forEach((symbol, i) => {
          if (symbol === "...") {
            if (ellipsis) {
              throw new Error("Only one ellipsis is allowed per input term");
            }
            ellipsis = true;
            const ellipsisDimLength = rank - indexSymbols.length + 1;
            if (ellipsisDimLength < 0) {
              throw new Error("Ellipsis out of bounds");
            }
            ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
            if (this.hasEllipsis) {
              if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                throw new Error("Ellipsis dimensions mismatch");
              }
            } else if (isInput) {
              this.hasEllipsis = true;
              this.ellipsisDims = ellipsisDims;
            } else {
              throw new Error("Ellipsis must be specified in the LHS");
            }
            for (let j = 0; j < ellipsisDims.length; j++) {
              const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
              einsumTerm.addSymbol(symbol2, i + j);
              this.addSymbol(symbol2, dims[nextDim++], index);
            }
          } else {
            einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
            this.addSymbol(symbol, dims[nextDim++], index);
          }
        });
        return einsumTerm;
      }
      // Output dimensions of the equation
    };
    appendMax = (name) => name + "_max";
    createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
      const ranks = inputShapes.map((dims) => dims.length);
      const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
      const outputSize = ShapeUtil.size(outputShape);
      const output = outputVariable("output", dataType, outputShape.length);
      const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter(
        (symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol)
      );
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const initProd = "var prod = 1.0;";
        const initSum = "var sum = 0.0;";
        const updateSum = "sum += prod;";
        const reduceOpsSetIndices = [];
        const reduceOpsLoopHeaders = [];
        const reduceOpsLoopFooters = [];
        const reduceOpCompute = [];
        const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
        einsumEquation.symbolToInfo.forEach((info, symbol) => {
          if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
            const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
            if (outputIndex !== void 0) {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    idxCopy.push(
                      `${inputVars[i].indicesSet(
                        `input${i}Indices`,
                        index,
                        output.indicesGet("outputIndices", outputIndex)
                      )}`
                    );
                  });
                }
              });
            }
          } else {
            einsumEquation.lhs.forEach((term, i) => {
              if (info.inputIndices.includes(i)) {
                const indices = term.symbolToIndices.get(symbol);
                if (indices === void 0) {
                  throw new Error("Invalid symbol error");
                }
                indices.forEach((index) => {
                  reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                });
                reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
              }
            });
            reduceOpsLoopHeaders.push(
              `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
            );
            reduceOpsLoopFooters.push("}");
          }
        });
        const reduceOps2 = isReduceOpsWithoutLoop ? [
          ...idxCopy,
          `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
        ] : [
          ...idxCopy,
          initSum,
          ...reduceOpsLoopHeaders,
          ...reduceOpsSetIndices,
          initProd,
          ...reduceOpCompute,
          updateSum,
          ...reduceOpsLoopFooters
        ];
        return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
      };
      return {
        name: "Einsum",
        shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
        getRunData: () => {
          const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map((symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 }));
          programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
          const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
          programUniforms.push(...createTensorShapeVariables(outputShape));
          return {
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          };
        },
        getShaderSource
      };
    };
    einsum = (context, attributes) => {
      const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
      const outputShape = einsumEquation.outputDims;
      const inputShapes = context.inputs.map((input, _) => input.dims);
      context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
    };
    parseEinsumAttributes = (attributes) => {
      const equation = attributes.equation.replace(/\s+/g, "");
      return createAttributeWithCacheKey({ equation });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/expand.ts
var validateInputs11, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
var init_expand = __esm({
  "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs11 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Expand requires 2 input.");
      }
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
      let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
      for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
        if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
          throw new Error("Expand requires shape to be broadcastable to input");
        }
      }
    };
    getAdjustedShape = (shape1, shape2) => {
      const diff = shape1.length - shape2.length;
      const shape = [];
      for (let i = 0; i < diff; ++i) {
        shape.push(shape1[i]);
      }
      for (let i = 0; i < shape2.length; ++i) {
        shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
      }
      return shape;
    };
    calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
    createExpandProgramInfo = (inputs) => {
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      const outputShape = calculateOutputShape2(inputShape, shape);
      const dataType = inputs[0].dataType;
      const isBoolOrScalar = dataType === 9 /* bool */ || ShapeUtil.size(inputShape) === 1;
      const iComponents = dataType === 9 /* bool */ ? 4 : inputShape.length > 0 && inputShape[inputShape.length - 1] % 4 === 0 ? 4 : 1;
      const components = isBoolOrScalar ? 4 : outputShape.length > 0 && outputShape[outputShape.length - 1] % 4 === 0 ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", dataType, inputShape.length, iComponents);
        const output = outputVariable("output", dataType, outputShape.length, components);
        let assignment;
        if (dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
        } else {
          assignment = `
        let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        let data = ${output.type.value}(${input.getByOffset(`inputOffset / ${iComponents}`)});
        ${output.setByOffset("global_idx", "data")}
      }`;
        }
        return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        ...createTensorShapeVariables(inputShape, outputShape)
      ];
      return {
        name: "Expand",
        shaderCache: { hint: `${outputShape.length};${iComponents}${components}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    expand = (context) => {
      validateInputs11(context.inputs);
      context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
var createFastGeluProgramInfo, fastGelu2;
var init_fast_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_unary_op();
    createFastGeluProgramInfo = (inputTensors) => {
      const dataType = inputTensors[0].dataType;
      const outputSize = ShapeUtil.size(inputTensors[0].dims);
      const biasLength = ShapeUtil.size(inputTensors[1].dims);
      const useVec4 = biasLength % 4 === 0;
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", dataType, [1], 4);
        const bias = inputVariable("bias", dataType, [1], 4);
        const y = outputVariable("y", dataType, [1], 4);
        const uniforms = [
          { name: "output_vec_size", type: "u32" },
          { name: "bias_size", type: "u32" }
        ];
        const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
        const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
        return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
      };
      return {
        name: "FastGeluWithBias",
        shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
        getShaderSource,
        getRunData: (inputs) => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) },
            { type: 12 /* uint32 */, data: biasLength }
          ],
          dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
        })
      };
    };
    fastGelu2 = (context) => {
      if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
        fastGelu(context);
      } else {
        context.compute(createFastGeluProgramInfo(context.inputs));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather.ts
var validateInputs12, createGatherProgramInfo, parseGatherAttributes, gather;
var init_gather = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs12 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Gather requires 2 inputs.");
      }
    };
    createGatherProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const inputRank = inputShape.length;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const outputShape = inputShape.slice(0);
      outputShape.splice(axis, 1, ...indicesShape);
      const axisDimLimit = inputShape[axis];
      const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
        const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
        const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
        const calcDataIndices = (x) => {
          const indicesRank = indicesShape.length;
          let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
          for (let i = 0; i < indicesRank; i++) {
            calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
          }
          calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
          for (let i = 0, j = 0; i < inputRank; i++) {
            if (i === axis) {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
              j += indicesRank;
            } else {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
              j++;
            }
          }
          return calcStr;
        };
        let assignment;
        if (inputs[0].dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
        } else {
          assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
        }
        return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
      };
      return {
        name: "Gather",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gather = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs12(inputs);
      context.compute(createGatherProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-nd.ts
var computeSliceOffsets, gatherND, parseGatherNDAttributes;
var init_gather_nd = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-nd.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    computeSliceOffsets = (context, indicesData, sizesFromSliceDimsData, batchDims, inputDims, numSlices, numSlicesPerBatch, inputBatchStride, numSliceDims) => {
      const programUniforms = [
        { type: 12 /* uint32 */, data: numSlices },
        { type: 12 /* uint32 */, data: batchDims },
        { type: 12 /* uint32 */, data: inputDims },
        { type: 12 /* uint32 */, data: sizesFromSliceDimsData },
        { type: 12 /* uint32 */, data: numSlicesPerBatch },
        { type: 12 /* uint32 */, data: inputBatchStride },
        { type: 12 /* uint32 */, data: numSliceDims }
      ];
      const outputShape = [numSlices];
      programUniforms.push(...createTensorShapeVariables(indicesData.dims, outputShape));
      const getShaderSource = (shaderHelper) => {
        const indices = inputVariable("indices_data", indicesData.dataType, indicesData.dims.length);
        const output = outputVariable("input_slice_offsets_data", 12 /* uint32 */, 1, 1);
        const variables = [indices, output];
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "batch_dims", type: "u32" },
          { name: "input_dims", type: "u32", length: inputDims.length },
          { name: "sizes_from_slice_dims_data", type: "u32", length: sizesFromSliceDimsData.length },
          { name: "num_slices_per_batch", type: "u32" },
          { name: "input_batch_stride", type: "u32" },
          { name: "num_slice_dims", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${inputDims.length === 1 ? "index += i32(uniforms.input_dims);" : "index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${sizesFromSliceDimsData.length === 1 ? "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);" : "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`;
      };
      return context.compute(
        {
          name: "computeSliceOffsets",
          shaderCache: { hint: `${inputDims.length}_${sizesFromSliceDimsData.length}`, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: context.inputs[1].dataType }],
            dispatchGroup: { x: Math.ceil(numSlices / 64) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [indicesData], outputs: [-1] }
      )[0];
    };
    gatherND = (context, attributes) => {
      const inputs = context.inputs;
      const inputShape = inputs[0].dims;
      const inputType = inputs[0].dataType;
      const indicesShape = inputs[1].dims;
      const numSliceDims = indicesShape[indicesShape.length - 1];
      const numSlices = ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1);
      const sliceSize = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims + numSliceDims);
      const numBatches = ShapeUtil.sizeToDimension(inputShape, attributes.batchDims);
      const inputBatchStride = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims);
      const numSlicesPerBatch = numSlices / numBatches;
      const sizesFromSliceDims = new Array(numSliceDims);
      let runningProduct = sliceSize;
      for (let i = 0; i < numSliceDims; ++i) {
        sizesFromSliceDims[numSliceDims - 1 - i] = runningProduct;
        runningProduct *= inputShape[attributes.batchDims + numSliceDims - 1 - i];
      }
      const inputSliceOffsets = computeSliceOffsets(
        context,
        inputs[1],
        sizesFromSliceDims,
        attributes.batchDims,
        inputShape,
        numSlices,
        numSlicesPerBatch,
        inputBatchStride,
        numSliceDims
      );
      const lastIndicesDimension = attributes.batchDims + numSliceDims;
      if (lastIndicesDimension > inputShape.length) {
        throw new Error("last dimension of indices must not be larger than rank of input tensor");
      }
      const outputShape = indicesShape.slice(0, -1).concat(inputShape.slice(lastIndicesDimension));
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: sliceSize },
        ...createTensorShapeVariables(inputs[0].dims, inputSliceOffsets.dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
        const indices = inputVariable("slice_offsets", 12 /* uint32 */, inputSliceOffsets.dims.length);
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        return `
          ${shaderHelper.registerUniform("output_size", "u32").registerUniform("slice_size", "u32").declareVariables(input, indices, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`;
      };
      context.compute(
        {
          name: "GatherND",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [inputs[0], inputSliceOffsets] }
      );
    };
    parseGatherNDAttributes = (attributes) => {
      const batchDims = attributes.batch_dims;
      return {
        batchDims,
        cacheKey: ""
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts
var validateInputs13, createGatherBlockQuantizedProgramInfo, gatherBlockQuantized, parseGatherBlockQuantizedAttributes;
var init_gather_block_quantized = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs13 = (inputs, attributes) => {
      if (inputs.length < 3 || inputs.length > 4) {
        throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
      }
      const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputs[0].dims.length);
      const blockSize = attributes.blockSize;
      const data = inputs[0];
      const scales = inputs[2];
      const zeroPoint = inputs.length === 4 ? inputs[3] : void 0;
      if (scales.dims.length !== data.dims.length || !data.dims.map((d, i) => i === quantizeAxis ? Math.ceil(d / blockSize) === scales.dims[i] : d === scales.dims[i]).reduce((a, b) => a && b, true)) {
        throw new Error(
          "Scales must have the same rank as the input tensor and the dims should match except on gatherAxis."
        );
      }
      if (zeroPoint) {
        if (zeroPoint.dataType !== data.dataType) {
          throw new Error("Zero point must have the same data type as the input tensor.");
        }
        if (zeroPoint.dims.length !== scales.dims.length || !zeroPoint.dims.map((d, i) => d === scales.dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error(
            "Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis."
          );
        }
      }
    };
    createGatherBlockQuantizedProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const inputRank = inputShape.length;
      const gatherAxis = ShapeUtil.normalizeAxis(attributes.gatherAxis, inputRank);
      const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputRank);
      const outputShape = inputShape.slice(0);
      outputShape.splice(gatherAxis, 1, ...indicesShape);
      const outputSize = ShapeUtil.size(outputShape);
      const outputType = inputs[2].dataType;
      const inputType = inputs[0].dataType;
      const isSigned = inputType === 22 /* int4 */;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: quantizeAxis },
        { type: 12 /* uint32 */, data: gatherAxis },
        { type: 12 /* uint32 */, data: attributes.blockSize },
        ...createTensorShapeVariables(...inputs.map((input, _) => input.dims), outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
        const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const zeroPoint = inputs.length > 3 ? inputVariable("zeroPoint", inputs[3].dataType, inputs[3].dims.length) : void 0;
        const output = outputVariable("output", outputType, outputShape.length);
        const inputVariables = [data, indices, scales];
        if (zeroPoint) {
          inputVariables.push(zeroPoint);
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "quantize_axis", type: "u32" },
          { name: "gather_axis", type: "u32" },
          { name: "block_size", type: "u32" }
        ];
        return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
        let output_indices = ${output.offsetToIndices("global_idx")};
        var indices_indices = ${indices.type.indices}(0);
        ${(() => {
          if (indicesShape.length > 1) {
            return `
          for (var i: u32 = 0; i < ${indicesShape.length}; i++) {
            let index = ${output.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${indices.indicesSet("indices_indices", "i", "index")};
          }`;
          } else {
            return `indices_indices = ${output.indicesGet("output_indices", "uniforms.gather_axis")};`;
          }
        })()};
        var data_indices = ${data.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${output.indicesGet("output_indices", "i")};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${indices.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${inputShape[gatherAxis]};
        }
        ${data.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${outputShape.length}; i++) {
          let index = ${output.indicesGet("output_indices", `i + ${indicesShape.length} - 1`)};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${data.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${data.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${scales.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${scales.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${scales.getByIndices("scale_indices")};
        ${(() => {
          if (!zeroPoint) {
            return "var zero_point = 0";
          } else {
            return `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${zeroPoint.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${zeroPoint.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`;
          }
        })()};
        let dequantized_data = ${tensorTypeToWsglValueType(outputType)}(quantized_data - zero_point) * scale;
        ${output.setByOffset("global_idx", "dequantized_data")};
    }`;
      };
      return {
        name: "GatherBlockQuantized",
        shaderCache: {
          hint: `${attributes.cacheKey};${inputs.filter((_, i) => i !== 1).map((input) => input.dims.join("_")).join(";")}`,
          inputDependencies: Array.from({ length: inputs.length }, (_v, _i) => "rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    gatherBlockQuantized = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs13(inputs, attributes);
      context.compute(createGatherBlockQuantizedProgramInfo(context.inputs, attributes));
    };
    parseGatherBlockQuantizedAttributes = (attributes) => createAttributeWithCacheKey({
      blockSize: attributes.blockSize,
      gatherAxis: attributes.gatherAxis,
      quantizeAxis: attributes.quantizeAxis
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
var validateInputs14, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
var init_gather_elements = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs14 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("GatherElements requires 2 inputs.");
      }
      if (inputs[0].dims.length < 1) {
        throw new Error("GatherElements requires that the data input be rank >= 1.");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
      }
    };
    createGatherElementsProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputOutputDataType = inputs[0].dataType;
      const inputRank = inputShape.length;
      const indicesShape = inputs[1].dims;
      const indicesDataType = inputs[1].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const axisDimLimit = inputShape[axis];
      const outputShape = indicesShape.slice(0);
      const outputSize = ShapeUtil.size(outputShape);
      const input = inputVariable("input", inputOutputDataType, inputRank);
      const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
      const output = outputVariable("output", inputOutputDataType, outputShape.length);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis }
      ];
      programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
      const inputDependencies = ["rank", "rank"];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
      return {
        name: "GatherElements",
        shaderCache: { inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gatherElements = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs14(inputs);
      context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gemm.ts
var validateInputs15, createGemmProgramInfo, parseGemmAttributes, gemm;
var init_gemm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs15 = (inputs) => {
      if (!inputs) {
        throw new Error("Input is missing");
      }
      if (inputs.length < 2 || inputs.length > 3) {
        throw new Error("Invaid input number.");
      }
      if (inputs.length === 3 && inputs[2].dims.length > 2) {
        throw new Error("Invalid input shape of C");
      }
      if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
        throw new Error("Input types are mismatched");
      }
    };
    createGemmProgramInfo = (inputs, attributes) => {
      const aShape = inputs[0].dims.slice();
      const bShape = inputs[1].dims.slice();
      const [M, N, K] = GemmUtil.getShapeOfGemmResult(
        aShape,
        attributes.transA,
        bShape,
        attributes.transB,
        inputs.length === 3 ? inputs[2].dims : void 0
      );
      const outputShape = [M, N];
      if (!outputShape) {
        throw new Error("Can't use gemm on the given tensors");
      }
      const tileSize = 16;
      const numTileN = Math.ceil(N / tileSize);
      const numTileM = Math.ceil(M / tileSize);
      const useShared = true;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: useShared ? numTileN : outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K },
        { type: 1 /* float */, data: attributes.alpha },
        { type: 1 /* float */, data: attributes.beta }
      ];
      const inputDependencies = ["type", "type"];
      if (inputs.length === 3) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        let line = "";
        if (attributes.transA && attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
        } else if (attributes.transA && !attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
        } else if (!attributes.transA && attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
        } else if (!attributes.transA && !attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
        }
        const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
        const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
        const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
        const dataType = a.type.value;
        let c = null;
        const variables = [a, b];
        if (inputs.length === 3) {
          c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
          variables.push(c);
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        variables.push(output);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "beta", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
          if (c != null) {
            return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
          }
          return "";
        })()}
    output[global_idx] = value;
  }`;
      };
      const getShaderSourceShared = (shaderHelper) => {
        const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
        const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
        let c = null;
        const variables = [a, b];
        if (inputs.length === 3) {
          c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
          variables.push(c);
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        variables.push(output);
        const uniforms = [
          { name: "num_tile_n", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "beta", type: "f32" }
        ];
        let calcResult = "";
        let fillWorkgroupMemory = "";
        if (attributes.transA && attributes.transB) {
          fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[k][local_id.y] * tile_b[local_id.x][k];`;
        } else if (attributes.transA && !attributes.transB) {
          fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[k][local_id.y] * tile_b[k][local_id.x];`;
        } else if (!attributes.transA && attributes.transB) {
          fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[local_id.y][k] * tile_b[local_id.x][k];`;
        } else if (!attributes.transA && !attributes.transB) {
          fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[local_id.y][k] * tile_b[k][local_id.x];`;
        }
        const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  var<workgroup> tile_a: array<array<${a.type.storage}, ${tileSize}>, ${tileSize}>;
  var<workgroup> tile_b: array<array<${b.type.storage}, ${tileSize}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${tileSize};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${tileSize};
    let num_tiles = (uniforms.K - 1) / ${tileSize} + 1;
    var k_start = 0u;
    var value = ${output.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${fillWorkgroupMemory}
      k_start = k_start + ${tileSize};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${tileSize}; k++) {
        ${calcResult}
      }
      workgroupBarrier();
    }

    ${calculateAlpha}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${(() => {
          if (c != null) {
            return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${output.type.value}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
          }
          return "";
        })()}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`;
      };
      if (useShared) {
        return {
          name: "GemmShared",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: numTileN * numTileM },
            programUniforms
          }),
          getShaderSource: getShaderSourceShared
        };
      }
      return {
        name: "Gemm",
        shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGemmAttributes = (attributes) => {
      const transA = attributes.transA;
      const transB = attributes.transB;
      const alpha = attributes.alpha;
      const beta = attributes.beta;
      return {
        transA,
        transB,
        alpha,
        beta,
        cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}`
      };
    };
    gemm = (context, attributes) => {
      validateInputs15(context.inputs);
      context.compute(createGemmProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/grid-sample.ts
var idxN, idxC, idxH, idxW, validateInputs16, gsGetCubicCoeffs, gsBicubicInterpolate, gsDenormalize, gsReflect, pixelAtGrid, computePixel, createGridSampleProgramInfo, gridSample, parseGridSampleAttributes;
var init_grid_sample = __esm({
  "web/lib/wasm/jsep/webgpu/ops/grid-sample.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    [idxN, idxC, idxH, idxW] = [0, 1, 2, 3];
    validateInputs16 = (inputs) => {
      if (inputs[0].dims.length !== 4) {
        throw new Error("only 4-D tensor is supported.");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("input dimensions must be equal to grid dimensions");
      }
      if (inputs[0].dims.length - 2 !== inputs[1].dims[inputs[1].dims.length - 1]) {
        throw new Error(`last dimension of grid must be equal to ${inputs[0].dims.length - 2}`);
      }
      if (inputs[0].dims[0] !== inputs[1].dims[0]) {
        throw new Error("grid batch size must match input batch size");
      }
    };
    gsGetCubicCoeffs = `
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`;
    gsBicubicInterpolate = (dataType) => `
  fn gs_bicubic_interpolate(p: mat4x4<${dataType}>, x: f32, y: f32) -> ${dataType} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${dataType}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`;
    gsDenormalize = (attributes) => `
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${attributes.alignCorners === 0 ? `
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    ` : `
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`;
    gsReflect = (attributes) => `
  ${attributes.paddingMode === "reflection" ? `
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }` : ""}
`;
    pixelAtGrid = (input, dataType, attributes) => `
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${dataType} {
     var pixel = ${dataType}(0);
     var indices = vec4<u32>(0);
     indices[${idxN}] = batch;
     indices[${idxC}] = channel;` + (() => {
      switch (attributes.paddingMode) {
        case "zeros":
          return `
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${idxH}] = u32(r);
            indices[${idxW}] = u32(c);
          } else {
            return ${dataType}(0);
          }
        `;
        case "border":
          return `
          indices[${idxH}] = u32(clamp(r, 0, H - 1));
          indices[${idxW}] = u32(clamp(c, 0, W - 1));
        `;
        case "reflection":
          return `
          indices[${idxH}] = gs_reflect(r, border[1], border[3]);
          indices[${idxW}] = gs_reflect(c, border[0], border[2]);
        `;
        default:
          throw new Error(`padding mode ${attributes.paddingMode} is not supported`);
      }
    })() + `
    return ${input.getByIndices("indices")};
  }
`;
    computePixel = (output, dataType, attributes) => (() => {
      switch (attributes.mode) {
        case "nearest":
          return `
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${idxN}], indices[${idxC}], border);
        `;
        case "bilinear":
          return `
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);

          let dx2 = ${dataType}(f32(x2) - x);
          let dx1 = ${dataType}(x - f32(x1));
          let dy2 = ${dataType}(f32(y2) - y);
          let dy1 = ${dataType}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;
        case "bicubic":
          return `
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${dataType}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;
        default:
          throw new Error(`mode ${attributes.mode} is not supported`);
      }
    })() + `${output.setByOffset("global_idx", "result")}`;
    createGridSampleProgramInfo = (inputs, attributes) => {
      const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length);
      const gridShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2]];
      const grid = inputVariable("grid", inputs[1].dataType, gridShape.length, 2);
      let outputShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[1].dims[1], inputs[1].dims[2]];
      if (attributes.format === "NHWC") {
        outputShape = [inputs[0].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[0].dims[3]];
        [idxN, idxC, idxH, idxW] = [0, 3, 1, 2];
      }
      const output = outputVariable("output", inputs[0].dataType, outputShape.length);
      const dataType = x.type.value;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        ...createTensorShapeVariables(inputs[0].dims, gridShape, outputShape)
      ];
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(x, grid, output)}
  ${gsGetCubicCoeffs}
  ${gsBicubicInterpolate(dataType)}
  ${gsDenormalize(attributes)}
  ${gsReflect(attributes)}
  ${pixelAtGrid(x, dataType, attributes)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${idxH}]);
      let W_in = i32(uniforms.x_shape[${idxW}]);

      ${attributes.alignCorners === 0 ? `
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      ` : `
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${output.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${idxN}], indices[${idxH}], indices[${idxW}]);
      let nxy = ${grid.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${computePixel(output, dataType, attributes)}
  }`;
      return {
        name: "GridSample",
        shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies: ["type", "type"] },
        getRunData: (inputs2) => {
          const outputSize2 = ShapeUtil.size(outputShape);
          return {
            outputs: [{ dims: outputShape, dataType: inputs2[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize2 / 64
              /* workgroup size */
            ) },
            programUniforms
          };
        },
        getShaderSource
      };
    };
    gridSample = (context, attributes) => {
      validateInputs16(context.inputs);
      context.compute(createGridSampleProgramInfo(context.inputs, attributes));
    };
    parseGridSampleAttributes = (attributes) => createAttributeWithCacheKey({
      alignCorners: attributes.align_corners,
      mode: attributes.mode,
      paddingMode: attributes.padding_mode,
      format: attributes.format
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
var getInput, validateInputs17, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
var init_multihead_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_types();
    init_attention();
    init_common();
    init_transpose();
    getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 ? inputs[i] : void 0;
    validateInputs17 = (inputs, attributes) => {
      const query = inputs[0];
      const key = getInput(inputs, 1);
      const value = getInput(inputs, 2);
      const bias = getInput(inputs, 3);
      const keyPaddingMask = getInput(inputs, 4);
      const attentionBias = getInput(inputs, 5);
      const pastKey = getInput(inputs, 6);
      const pastValue = getInput(inputs, 7);
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      const hiddenSize = query.dims.length === 3 ? query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      let maxSequenceLength = 0;
      const headSize = Math.floor(hiddenSize / attributes.numHeads);
      if (pastKey && pastValue && ShapeUtil.size(pastKey.dims) && ShapeUtil.size(pastValue.dims)) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
          throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
          throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastKey.dims[2] !== pastValue.dims[2]) {
          throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        pastSequenceLength = pastKey.dims[2];
        maxSequenceLength = pastKey.dims[2];
      } else if (pastKey && ShapeUtil.size(pastKey.dims) || pastValue && ShapeUtil.size(pastValue.dims)) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat;
      if (key && ShapeUtil.size(key.dims) > 0) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (key.dims[2] !== query.dims[2]) {
            throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
          }
          qkvFormat = 2 /* qkvBSNH */;
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          qkvFormat = 5 /* qKvBSNHxBSN2H */;
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          qkvFormat = 0 /* unknown */;
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
        }
        if (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      if (bias && ShapeUtil.size(bias.dims) > 0) {
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimension');
        }
        if (key) {
          if (key.dims.length === 5 && key.dims[3] === 2) {
            throw new Error("bias is not allowed for packed kv.");
          }
        }
      }
      const totalSequenceLength = pastSequenceLength + kvSequenceLength;
      let maskType = 0 /* none */;
      if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
        maskType = 8 /* maskUnknown */;
        const maskDims = keyPaddingMask.dims;
        if (maskDims.length === 1) {
          if (maskDims[0] === batchSize) {
            maskType = 1 /* mask1dKeySeqLen */;
          } else if (maskDims[0] === 3 * batchSize + 2) {
            maskType = 3 /* mask1DKeySeqLenStart */;
          }
        } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === totalSequenceLength) {
          maskType = 5 /* mask2dKeyPadding */;
        }
        if (maskType === 8 /* maskUnknown */) {
          throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)');
        }
        throw new Error("Mask not supported");
      }
      let passPastInKv = false;
      let vHiddenSize = hiddenSize;
      if (value && ShapeUtil.size(value.dims) > 0) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const broadcastResPosBias = false;
      if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
        throw new Error("Key padding mask is not supported");
      }
      if (attentionBias && ShapeUtil.size(attentionBias.dims) > 0) {
        if (attentionBias.dims.length !== 4) {
          throw new Error('Input "attention_bias" is expected to have 4 dimensions');
        }
        if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
          throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
        }
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat
      };
    };
    parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
    weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
      const outputShape = [batchSize, sequenceLength, hiddenSize];
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: biasOffset },
        { type: 12 /* uint32 */, data: hiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
        const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
        const biasInput = inputVariable("bias", bias.dataType, outputShape);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "bias_offset", type: "u32" },
          { name: "hidden_size", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
      };
      return context.compute(
        {
          name: "MultiHeadAttentionAddBias",
          shaderCache: { inputDependencies: ["type", "type"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [qkv, bias], outputs: [-1] }
      )[0];
    };
    maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
      let reshapedInput = input;
      if (!(bias && ShapeUtil.size(bias.dims) > 0)) {
        if (input.dims.length === 3) {
          reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
        }
        if (numHeads === 1 || sequenceLength === 1) {
          return reshapedInput;
        }
        return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
          inputs: [reshapedInput],
          outputs: [-1]
        })[0];
      } else {
        if (sequenceLength === 1) {
          throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
        } else {
          reshapedInput = addBiasTranspose(
            context,
            input,
            bias,
            batchSize,
            sequenceLength,
            numHeads * headSize,
            biasOffset
          );
          reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
          if (numHeads === 1 || sequenceLength === 1) {
            return reshapedInput;
          }
          return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        }
      }
    };
    multiHeadAttention = (context, attributes) => {
      const params = validateInputs17(context.inputs, attributes);
      const query = context.inputs[0];
      const key = getInput(context.inputs, 1);
      const value = getInput(context.inputs, 2);
      const bias = getInput(context.inputs, 3);
      const keyPaddingMask = getInput(context.inputs, 4);
      const attentionBias = getInput(context.inputs, 5);
      const pastKey = getInput(context.inputs, 6);
      const pastValue = getInput(context.inputs, 7);
      if (query.dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (key?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        query,
        bias,
        0
      );
      if (kvBNSH) {
        return applyAttention(context, Q, key, value, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
      }
      if (!key || !value) {
        throw new Error("key and value must be provided");
      }
      const K = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.headSize,
        key,
        bias,
        params.hiddenSize
      );
      const V = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.vHeadSize,
        value,
        bias,
        2 * params.hiddenSize
      );
      applyAttention(context, Q, K, V, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/split.ts
var validateInputs18, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
var init_split = __esm({
  "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs18 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
    };
    createSplitAttributesFromInputs = (inputs, attributes) => {
      const splitSizes = [];
      let numOutputs = attributes.numOutputs;
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
        numOutputs = splitSizes.length;
      }
      return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
    };
    calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
    writeBufferDataImpl = (outputs) => {
      const numberOfTensors = outputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
        }
      }
      return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
    };
    createSplitProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const dataType = inputs[0].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const outputs = new Array(attributes.numOutputs);
      const input = inputVariable("input", dataType, inputShape.length);
      const sizeInSplitAxis = new Array(attributes.numOutputs);
      const outputsTensorInfo = [];
      const outputShapes = [];
      let previousSum = 0;
      const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
      for (let i = 0; i < attributes.numOutputs; i++) {
        previousSum += attributes.splitSizes[i];
        sizeInSplitAxis[i] = previousSum;
        const outputShape = inputShape.slice();
        outputShape[axis] = attributes.splitSizes[i];
        outputShapes.push(outputShape);
        outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
        outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
      }
      programUniforms.push(
        { type: 12 /* uint32 */, data: sizeInSplitAxis },
        ...createTensorShapeVariables(inputShape, ...outputShapes)
      );
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
      return {
        name: "Split",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: outputsTensorInfo,
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    split = (context, attributes) => {
      validateInputs18(context.inputs);
      const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
      context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSplitAttributes = (attributes) => {
      const axis = attributes.axis;
      const splitSizes = attributes.splitSizes;
      const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
      if (numOutputs !== splitSizes.length) {
        throw new Error("numOutputs and splitSizes length must be equal");
      }
      return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
var validateInputs19, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
var init_rotary_embedding = __esm({
  "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs19 = (inputs, attributes) => {
      const [input, positionIds, cosCache, sinCache] = inputs;
      const { numHeads, rotaryEmbeddingDim } = attributes;
      if (input.dims.length !== 3 && input.dims.length !== 4) {
        throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
      }
      if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
        throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
      }
      if (cosCache.dims.length !== 2) {
        throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
      }
      if (sinCache.dims.length !== 2) {
        throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
      }
      if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
        throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
      }
      if (rotaryEmbeddingDim > 0 && numHeads === 0) {
        throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[input.dims.length - 2];
      const maxSequenceLength = cosCache.dims[0];
      const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
      const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
      if (rotaryEmbeddingDim > headSize) {
        throw new Error("rotary_embedding_dim must be less than or equal to head_size");
      }
      if (positionIds.dims.length === 2) {
        if (batchSize !== positionIds.dims[0]) {
          throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
        }
        if (sequenceLength !== positionIds.dims[1]) {
          throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
        }
      }
      if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
        throw new Error(
          `Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`
        );
      }
      if (sequenceLength > maxSequenceLength) {
        throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
      }
    };
    createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
      const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
      const batchSize = inputs[0].dims[0];
      const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
      const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
      const hiddenSize = batchStride / sequenceLength;
      const halfRotaryEmbeddingDim = inputs[2].dims[1];
      const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
      const globalShape = new Array(
        batchSize,
        sequenceLength,
        hiddenSize / headSize,
        headSize - halfRotaryEmbeddingDim
      );
      const globalStrides = ShapeUtil.computeStrides(globalShape);
      const programUniforms = [
        { type: 1 /* float */, data: scale },
        { type: 12 /* uint32 */, data: globalShape },
        { type: 12 /* uint32 */, data: globalStrides },
        // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
        // i.e. BSNH
        ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
        ...inputs[0].dims.length === 4 ? new Array({
          type: 12 /* uint32 */,
          data: [batchStride, headSize, sequenceLength * headSize, 1]
        }) : [],
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
      ];
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
        const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
        const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
        const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
        shaderHelper.registerUniforms([
          { name: "scale", type: "f32" },
          { name: "global_shape", type: "u32", length: globalShape.length },
          { name: "global_strides", type: "u32", length: globalStrides.length },
          { name: "input_output_strides", type: "u32", length: globalStrides.length }
        ]);
        return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
      };
      return {
        name: "RotaryEmbedding",
        shaderCache: {
          hint: createAttributeWithCacheKey({
            interleaved
          }).cacheKey,
          inputDependencies: ["rank", "rank", "rank", "rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
          programUniforms
        })
      };
    };
    rotaryEmbedding = (context, attributes) => {
      validateInputs19(context.inputs, attributes);
      context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
var validateInputs20, weightTransposeAttribute3, maybeTransposeToBNSH, generatePositionIdsProgramInfo, groupQueryAttention;
var init_group_query_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_wasm_common();
    init_attention();
    init_multihead_attention();
    init_split();
    init_transpose();
    init_rotary_embedding();
    init_common();
    validateInputs20 = (inputs, attributes) => {
      if (attributes.doRotary && inputs.length <= 7) {
        throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");
      }
      const query = inputs[0];
      const key = inputs[1];
      const value = inputs[2];
      const pastKey = inputs[3];
      const pastValue = inputs[4];
      if (attributes.doRotary !== 0 && inputs.length <= 7) {
        throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");
      }
      if (attributes.localWindowSize !== -1) {
        throw new Error("Local attention is not supported");
      }
      if (attributes.softcap !== 0) {
        throw new Error("Softcap is not supported");
      }
      if (attributes.rotaryInterleaved !== 0) {
        throw new Error("Rotary interleaved is not supported");
      }
      if (attributes.smoothSoftmax) {
        throw new Error("Smooth softmax is not supported");
      }
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const dmmhaPacking = false;
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      let hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      const packedQKV = !key || key.dims.length === 0;
      const headSize = !packedQKV ? Math.floor(hiddenSize / attributes.numHeads) : Math.floor(hiddenSize / (attributes.numHeads + 2 * attributes.kvNumHeads));
      if (packedQKV) {
        hiddenSize = headSize * attributes.numHeads;
      }
      const hasPastKey = pastKey && pastKey.dims.length !== 0;
      const hasPastValue = pastValue && pastValue.dims.length !== 0;
      const isPastkvBSNH = hasPastKey && pastKey.dims.length === 4 && pastKey.dims[0] === batchSize && pastKey.dims[1] !== attributes.kvNumHeads && pastKey.dims[2] === attributes.kvNumHeads && pastKey.dims[3] === headSize;
      if (isPastkvBSNH) {
        throw new Error("BSNH pastKey/pastValue is not supported");
      }
      if (hasPastKey && hasPastValue) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        pastSequenceLength = pastKey.dims[2];
      } else if (hasPastKey || hasPastValue) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat = 1 /* qkvBNSH */;
      if (key && key.dims.length > 0) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (query.dims[2] % key.dims[2] !== 0) {
            throw new Error('Dimension 2 of "query" should be a multiple of "key"');
          }
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
        }
        if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      const maskType = 0 /* none */;
      let passPastInKv = false;
      let vHiddenSize = attributes.kvNumHeads ? headSize * attributes.kvNumHeads : hiddenSize;
      if (value && value.dims.length > 0) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const seqlLens = inputs.length > 4 ? inputs[5] : void 0;
      if (seqlLens && seqlLens.dims.length !== 1 && seqlLens.dims[0] !== batchSize) {
        throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');
      }
      const totalSequenceLength = -1;
      const maxSequenceLength = -1;
      const broadcastResPosBias = false;
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
        numHeads: attributes.numHeads,
        kvNumHeads: attributes.kvNumHeads,
        nReps: attributes.numHeads / attributes.kvNumHeads,
        pastPresentShareBuffer: false,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat
      };
    };
    weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    maybeTransposeToBNSH = (context, input, params) => {
      let reshapedInput = input;
      const numHeads = params.kvNumHeads;
      if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
        reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
        reshapedInput = context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm), {
          inputs: [reshapedInput],
          outputs: [-1]
        })[0];
      }
      return reshapedInput;
    };
    generatePositionIdsProgramInfo = (batchSize, sequenceLength, seqLens, totalSeqLen) => {
      const outputDataType = 7 /* int64 */;
      const inputDependencies = ["type", "type"];
      const outputShape = [batchSize * sequenceLength];
      const outputSize = batchSize * sequenceLength;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: sequenceLength },
        { type: 12 /* uint32 */, data: batchSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const seqLensInputHelper = inputVariable("seq_lens", seqLens.dataType, seqLens.dims);
        const totalSeqLenInputHelper = inputVariable("total_seq_lens", totalSeqLen.dataType, totalSeqLen.dims);
        const positionIdsHelper = outputVariable("pos_ids", outputDataType, outputShape);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "sequence_length", type: "u32" },
          { name: "batch_size", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(seqLensInputHelper, totalSeqLenInputHelper, positionIdsHelper)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${totalSeqLenInputHelper.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${seqLensInputHelper.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${positionIdsHelper.setByOffset("global_idx", "seqlen")}
    };
  }
  `;
      };
      return {
        name: "GeneratePositionIds",
        shaderCache: { hint: `${batchSize};${sequenceLength}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    groupQueryAttention = (context, attributes) => {
      const params = validateInputs20(context.inputs, attributes);
      if (context.inputs[0].dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (context.inputs[1]?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const q = context.inputs[0];
      const k = context.inputs[1] && context.inputs[1].dims.length > 0 ? context.inputs[1] : void 0;
      const v = context.inputs[2] && context.inputs[2].dims.length > 0 ? context.inputs[2] : void 0;
      const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
      const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
      const seqLens = context.inputs.length > 4 ? context.inputs[5] : void 0;
      const totalSequenceLengthInput = context.inputs.length > 5 ? context.inputs[6] : void 0;
      const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
      const splitAttributes = createAttributeWithCacheKey({
        axis: 2,
        numOutputs: 3,
        splitSizes: [params.numHeads * params.headSize, kvNumHeads * params.headSize, kvNumHeads * params.headSize]
      });
      const [query, key, value] = !k && !v ? context.compute(createSplitProgramInfo([q], splitAttributes), { inputs: [q], outputs: [-1, -1, -1] }) : [q, k, v];
      let qRotary;
      let kRotary;
      if (attributes.doRotary) {
        const posIds = context.compute(
          generatePositionIdsProgramInfo(params.batchSize, params.sequenceLength, seqLens, totalSequenceLengthInput),
          { inputs: [seqLens, totalSequenceLengthInput], outputs: [-1] }
        )[0];
        const cosCache = context.inputs[7];
        const sinCache = context.inputs[8];
        const qRotaryEmbeddingAttributes = createAttributeWithCacheKey({
          interleaved: attributes.rotaryInterleaved !== 0,
          numHeads: params.numHeads,
          rotaryEmbeddingDim: 0,
          scale: attributes.scale
        });
        const inputs = [query, posIds, cosCache, sinCache];
        const outputs = [-1];
        qRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, qRotaryEmbeddingAttributes), {
          inputs,
          outputs
        })[0];
        inputs.splice(0, 1, key);
        const kRotaryEmbeddingAttributes = createAttributeWithCacheKey({
          interleaved: attributes.rotaryInterleaved !== 0,
          numHeads: params.kvNumHeads,
          rotaryEmbeddingDim: 0,
          scale: attributes.scale
        });
        kRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, kRotaryEmbeddingAttributes), {
          inputs,
          outputs
        })[0];
      }
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        attributes.doRotary ? qRotary : query,
        void 0,
        0
      );
      const K = maybeTransposeToBNSH(context, attributes.doRotary ? kRotary : key, params);
      const V = maybeTransposeToBNSH(context, value, params);
      applyAttention(
        context,
        Q,
        K,
        V,
        void 0,
        void 0,
        pastKey,
        pastValue,
        void 0,
        params,
        seqLens,
        totalSequenceLengthInput
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
var computeChannelScaleShift, createInstanceNormProgramInfo, createInstanceNormNHWCProgramInfo, instanceNorm;
var init_instance_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_transpose();
    init_common();
    computeChannelScaleShift = (context, input, scale, bias, n, h, c, epsilon) => {
      const components = getMaxComponents(h);
      const f32Type = components === 1 ? "f32" : `vec${components}f`;
      const wgType = components === 1 ? "vec2f" : `mat2x${components}f`;
      const unitsOfWork = n * c;
      let workgroupSize = 64;
      if (unitsOfWork === 1) {
        workgroupSize = 256;
      }
      const inputShape = [n, c, h / components];
      const outputShape = [n, c, 2];
      const inputDependencies = ["rank", "type", "type"];
      const programUniforms = [];
      programUniforms.push(...createTensorShapeVariables(inputShape, outputShape));
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", input.dataType, 3, components);
        const s = inputVariable("scale", scale.dataType, scale.dims);
        const b = inputVariable("bias", bias.dataType, bias.dims);
        const output = outputVariable("output", 1 /* float */, 3, 2);
        const variables = [x, s, b, output];
        return `
  var<workgroup> workgroup_shared : array<${wgType}, ${workgroupSize}>;
  const workgroup_size = ${workgroupSize}u;
  ${shaderHelper.declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${f32Type}(0);
    var squared_sum = ${f32Type}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${f32Type}(${x.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${wgType}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${sumVector("workgroup_shared[0][0]", components)} / f32(hight * ${components});
      let squared_sum_final = ${sumVector("workgroup_shared[0][1]", components)} / f32(hight * ${components});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${epsilon}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
      };
      return context.compute(
        {
          name: "InstanceNormComputeChannelScaleShift",
          // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
          shaderCache: { hint: `${components};${epsilon};${workgroupSize}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: 1 /* float */ }],
            dispatchGroup: { x: unitsOfWork },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [input, scale, bias], outputs: [-1] }
      )[0];
    };
    createInstanceNormProgramInfo = (context, inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const axis = 2;
      const N = xShape[0];
      const C = xShape[1];
      const H = ShapeUtil.sizeFromDimension(xShape, axis);
      const components = getMaxComponents(H);
      const outputSize = ShapeUtil.size(outputShape) / components;
      const channelScaleShift = computeChannelScaleShift(
        context,
        inputs[0],
        inputs[1],
        inputs[2],
        N,
        H,
        C,
        attributes.epsilon
      );
      const inputShape = [N, C, H / components];
      const scaleShape = [N, C];
      const inputDependencies = ["type", "none"];
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
        const scale = inputVariable("scale_shift", 1 /* float */, scaleShape.length, 2);
        const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
        const variables = [x, scale, output];
        return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(...variables)}
  ${shaderHelper.mainStart()}
  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${output.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${scale.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${x.getByOffset("global_idx")} * ${output.type.value}(scale_shift.x) + ${output.type.value}(scale_shift.y);
      ${output.setByOffset("global_idx", "value")};
  }`;
      };
      context.compute(
        {
          name: "InstanceNormalization",
          shaderCache: { hint: `${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputShape, scaleShape, inputShape)
            ]
          }),
          getShaderSource
        },
        { inputs: [inputs[0], channelScaleShift] }
      );
    };
    createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const N = xShape[0];
      const C = xShape[xShape.length - 1];
      const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
      const components = getMaxComponents(C);
      const outputSize = ShapeUtil.size(outputShape) / components;
      const programUniforms = [
        { type: 12 /* uint32 */, data: H },
        { type: 12 /* uint32 */, data: Math.floor(C / components) }
      ];
      const inputDependencies = ["type", "type"];
      let needTranspose = false;
      const transposedXPerm = [0, xShape.length - 1];
      for (let i = 0; i < xShape.length - 2; i++) {
        needTranspose = needTranspose || xShape[i + 1] !== 1;
        transposedXPerm.push(i + 1);
      }
      needTranspose = needTranspose && xShape[xShape.length - 1] !== 1;
      const transposedX = needTranspose ? context.compute(createTransposeProgramInfo(context.inputs[0], transposedXPerm), {
        inputs: [context.inputs[0]],
        outputs: [-1]
      })[0] : context.inputs[0].reshape(Array.from({ length: xShape.length }, (_, i) => xShape[transposedXPerm[i]]));
      const channelScaleShift = computeChannelScaleShift(
        context,
        transposedX,
        inputs[1],
        inputs[2],
        N,
        H,
        C,
        attributes.epsilon
      );
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const scaleType = components === 1 ? "vec2f" : `mat${components}x2f`;
        const scaleData = (num) => {
          const index = num === 0 ? "x" : "y";
          const f32Type = components === 1 ? "f32" : `vec${components}f`;
          switch (components) {
            case 1:
              return `${dataType}(${f32Type}(scale.${index}))`;
            case 2:
              return `vec2<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}))`;
            case 4:
              return `vec4<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}, scale[2].${index}, scale[3].${index}))`;
            default:
              throw new Error(`Not supported compoents ${components}`);
          }
        };
        const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
        const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
        return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${scaleData(0)}, ${scaleData(1)});
  }`;
      };
      context.compute(
        {
          name: "InstanceNormalizationNHWC",
          shaderCache: { hint: `${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [inputs[0], channelScaleShift] }
      );
    };
    instanceNorm = (context, attributes) => {
      if (attributes.format === "NHWC") {
        createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
      } else {
        createInstanceNormProgramInfo(context, context.inputs, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
var validateInputs21, createLayerNormProgramInfo, layerNorm;
var init_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs21 = (inputs) => {
      if (!inputs || inputs.length < 2) {
        throw new Error("layerNorm requires at least 2 inputs.");
      }
    };
    createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
      const simplified = attributes.simplified;
      const xShape = inputs[0].dims;
      const scale = inputs[1];
      const bias = !simplified && inputs[2];
      const outputShape = xShape;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
      const normCount = ShapeUtil.sizeToDimension(xShape, axis);
      const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
      const scaleSize = ShapeUtil.size(scale.dims);
      const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
      if (scaleSize !== normSize || bias && biasSize !== normSize) {
        throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
      }
      const meanInvStdDevDim = [];
      for (let i = 0; i < xShape.length; ++i) {
        if (i < axis) {
          meanInvStdDevDim.push(xShape[i]);
        } else {
          meanInvStdDevDim.push(1);
        }
      }
      const components = getMaxComponents(normSize);
      const inputDependencies = ["type", "type"];
      const programUniforms = [
        { type: 12 /* uint32 */, data: normCount },
        { type: 1 /* float */, data: normSize },
        { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      if (bias) {
        inputDependencies.push("type");
      }
      const hasMeanDataOutput = outputCount > 1;
      const hasInvStdOutput = outputCount > 2;
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("scale", scale.dataType, scale.dims, components)
        ];
        if (bias) {
          variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanDataOutput) {
          variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        const uniforms = [
          { name: "norm_count", type: "u32" },
          { name: "norm_size", type: "f32" },
          { name: "norm_size_vectorized", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (hasMeanDataOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (hasInvStdOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      return {
        name: "LayerNormalization",
        shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
        getRunData: () => ({
          outputs,
          dispatchGroup: { x: Math.ceil(
            normCount / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    layerNorm = (context, attributes) => {
      validateInputs21(context.inputs);
      context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmul.ts
var validateInputs22, matMul;
var init_matmul = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
    "use strict";
    init_util();
    init_matmul_shaders();
    init_matmul_packed_webgpu();
    validateInputs22 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("MatMul requires 2 inputs.");
      }
      if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
        throw new Error("shared dimension does not match.");
      }
    };
    matMul = (context) => {
      validateInputs22(context.inputs);
      const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
      if (!outputShape) {
        throw new Error("Can't use matmul on the given tensors");
      }
      const N = outputShape[outputShape.length - 1];
      const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
      if (N < 8 && K < 8) {
        context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
      } else {
        const M = outputShape[outputShape.length - 2];
        const batchA = ShapeUtil.size(context.inputs[0].dims.slice(0, -2));
        const batchB = ShapeUtil.size(context.inputs[1].dims.slice(0, -2));
        if (batchA !== 1 && M === 1 && batchB === 1) {
          const reshapedA = context.inputs[0].reshape([1, batchA, K]);
          const reshapedB = context.inputs[1].reshape([1, K, N]);
          const matmulOutputShape = [1, batchA, N];
          const matmulInputs = [reshapedA, reshapedB];
          context.compute(createMatmulProgramInfo(matmulInputs, { activation: "" }, outputShape, matmulOutputShape), {
            inputs: matmulInputs
          });
        } else {
          context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        }
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
var validateInputs23, createMatMulNBitsProgramInfo, createMatMulNBitsBlockSize32ProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
var init_matmulnbits = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs23 = (inputs, attributes) => {
      if (inputs.length < 3 || inputs.length > 4) {
        throw new Error("MatMulNBits requires 3 or 4 inputs");
      }
      const a = inputs[0];
      const aRank = a.dims.length;
      if (a.dims[aRank - 1] !== attributes.k) {
        throw new Error("The last dim of input shape does not match the k value");
      }
      const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
      const blobSize = attributes.blockSize / 8 * attributes.bits;
      const b = inputs[1];
      if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
        throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
      }
      const scales = inputs[2];
      const scalesShape = scales.dims;
      if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
        throw new Error("scales input size error.");
      }
      if (inputs.length === 4) {
        const zeroPoints = inputs[3];
        const zeroPointsShape = zeroPoints.dims;
        const expectedZeroPointsSize = attributes.n * (attributes.bits === 8 ? nBlocksPerCol : Math.floor((nBlocksPerCol * attributes.bits + 7) / 8));
        if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
          throw new Error("zeroPoints input size error.");
        }
      }
    };
    createMatMulNBitsProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const aRank = inputShape.length;
      const dimAOuter = inputShape[aRank - 2];
      const dimInner = attributes.k;
      const dimBOuter = attributes.n;
      const batchDims = inputShape.slice(0, aRank - 2);
      const batchSize = ShapeUtil.size(batchDims);
      const blobSize = inputs[1].dims[2];
      const blobSizeInWords = blobSize / 4;
      const dataType = inputs[0].dataType;
      const aComponents = getMaxComponents(attributes.k);
      const bComponents = getMaxComponents(blobSizeInWords);
      const components = getMaxComponents(dimBOuter);
      const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
      const outputNumber = dimAOuter > 1 && dimBOuter / components % 2 === 0 ? 2 : 1;
      const dispatchSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const workgroupSize = 64;
      const programUniforms = [];
      const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
      const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
      bShape.splice(-1, 1, blobSizeInWords / bComponents);
      programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
      programUniforms.push(...createTensorShapeVariables(bShape));
      programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      if (inputs.length === 4) {
        programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
      }
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const inputRank = inputShapeTemp.length;
        const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
        const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const inputVariables = [a, b, scales];
        const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
        if (zeroPoints) {
          inputVariables.push(zeroPoints);
        }
        const outputRank = outputShapeTemp.length;
        const output = outputVariable("output", inputs[0].dataType, outputRank, components);
        const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
        const qDqDataType = (() => {
          switch (aComponents) {
            case 1:
              return `array<${dataType2}, 8>`;
            case 2:
              return `mat4x2<${dataType2}>`;
            case 4:
              return `mat2x4<${dataType2}>`;
            default:
              throw new Error(`${aComponents}-component is not supported.`);
          }
        })();
        const valuesPerWord = Math.floor(32 / attributes.bits);
        const passesPerWord = Math.floor(valuesPerWord / 8);
        const processOneWord = () => {
          let calcStr = "";
          for (let pass = 0; pass < passesPerWord; pass++) {
            const lowerShift = pass * attributes.bits * 4;
            const upperShift = lowerShift + attributes.bits;
            calcStr += `
          // reuse a data (pass ${pass})
            var input_offset${pass > 0 ? pass : ""} = ${pass === 0 ? a.indicesToOffset(`${a.type.indices}(batch, row, word_offset)`) : `input_offset`};
            var a_data${pass > 0 ? pass : ""}: ${qDqDataType};
            for (var j${pass > 0 ? pass : ""}: u32 = 0; j${pass > 0 ? pass : ""} < ${8 / aComponents}; j${pass > 0 ? pass : ""}++) {
              a_data${pass > 0 ? pass : ""}[j${pass > 0 ? pass : ""}] = ${a.getByOffset(`input_offset${pass > 0 ? pass : ""}`)};
              input_offset${pass > 0 ? pass : ""}++;
            }
          `;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            b_value = ${bComponents === 1 ? `b${c}_data` : `b${c}_data[i]`};
            ${attributes.bits === 2 ? `{
              let half_word = b_value >> ${pass * 16}u;
              let byte_lo = half_word & 0xFFu;
              let byte_hi = (half_word >> 8u) & 0xFFu;
              let spread_word = (byte_lo & 0xFu) | ((byte_lo >> 4u) << 8u) | ((byte_hi & 0xFu) << 16u) | ((byte_hi >> 4u) << 24u);
              b_value_lower = unpack4xU8(spread_word & b_mask);
              b_value_upper = unpack4xU8((spread_word >> 2u) & b_mask);
            }` : `b_value_lower = unpack4xU8((b_value >> ${lowerShift}u) & b_mask);
            b_value_upper = unpack4xU8((b_value >> ${upperShift}u) & b_mask);`}
            b_quantized_values = ${qDqDataType}(${Array.from(
                { length: 4 },
                (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
              ).join(", ")});
            b_dequantized_values = ${(() => {
                if (aComponents === 1) {
                  return `${qDqDataType}(${Array.from(
                    { length: 8 },
                    (_, i) => `(b_quantized_values[${i}] - ${zeroPoints ? `zero_point${c}` : "zero_point"}) * scale${c}`
                  ).join(", ")});`;
                } else {
                  return `(b_quantized_values - ${qDqDataType}(${Array(8).fill(`${zeroPoints ? `zero_point${c}` : "zero_point"}`).join(",")})) * scale${c};`;
                }
              })()};
            workgroup_shared[local_id.x * ${outputNumber} + ${Math.floor(c / components)}]${components > 1 ? `[${c % components}]` : ""} += ${Array.from(
                { length: 8 / aComponents },
                (_, i) => `${aComponents === 1 ? `a_data${pass > 0 ? pass : ""}[${i}] * b_dequantized_values[${i}]` : `dot(a_data${pass > 0 ? pass : ""}[${i}], b_dequantized_values[${i}])`}`
              ).join(" + ")};
          `;
            }
          }
          return calcStr;
        };
        const prepareScaleAndZeroPoint = () => {
          let calcStr = `
            var col_index = col * ${components};
            ${zeroPoints ? `
            let zero_point_values_per_byte: u32 = ${Math.floor(8 / attributes.bits)}u;
            let zero_point_bytes_per_col = (nBlocksPerCol + zero_point_values_per_byte - 1u) / zero_point_values_per_byte;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_sub_offset: u32 = block % zero_point_values_per_byte;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is ${Math.pow(2, attributes.bits - 1)} for unsigned ${attributes.bits}-bit quantization.
            let zero_point = ${dataType2}(${Math.pow(2, attributes.bits - 1).toFixed(1)});`}
            `;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            let scale${c} = ${scales.getByOffset(`col_index * nBlocksPerCol + block`)};
            ${zeroPoints ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block / zero_point_values_per_byte);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_sub_offset * ${attributes.bits}u);
            zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${c} = ${dataType2}((zero_point_word) & ${attributes.bits === 2 ? "0x3u" : "0xFu"});` : ""}
            col_index += 1;`;
          }
          return calcStr;
        };
        const prepareBData = () => {
          let calcStr = `col_index = col * ${components};`;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            let b${c}_data = ${b.getByIndices(`${b.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
          }
          calcStr += `
            var b_value: u32;
            let b_mask: u32 = ${attributes.bits === 2 ? "0x03030303u" : "0x0F0F0F0Fu"};
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${qDqDataType};
            var b_dequantized_values: ${qDqDataType};`;
          return calcStr;
        };
        return `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${outputNumber * workgroupSize}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupSize, 1, 1])}
          let output_indices = ${output.offsetToIndices(`(global_idx / ${workgroupSize}) * ${outputNumber}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${workgroupSize}) {
            //process one block
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            ${prepareScaleAndZeroPoint()}
            for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
              ${prepareBData()}
              for (var i: u32 = 0; i < ${bComponents}; i++) {
                ${processOneWord()}
                word_offset += ${valuesPerWord / aComponents};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${outputNumber}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${workgroupSize}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${outputNumber};
            }
            ${output.setByIndices(`${output.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
      };
      return {
        name: "MatMulNBits",
        shaderCache: {
          hint: `${attributes.blockSize};${attributes.bits};${aComponents};${bComponents};${components};${outputNumber};${workgroupSize}`,
          inputDependencies: Array(inputs.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: dispatchSize },
          programUniforms
        }),
        getShaderSource
      };
    };
    createMatMulNBitsBlockSize32ProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const aRank = inputShape.length;
      const dimAOuter = inputShape[aRank - 2];
      const dimInner = attributes.k;
      const dimBOuter = attributes.n;
      const batchDims = inputShape.slice(0, aRank - 2);
      const batchSize = ShapeUtil.size(batchDims);
      const blobSize = inputs[1].dims[2];
      const blobSizeInWords = blobSize / 4;
      const dataType = inputs[0].dataType;
      const aComponents = getMaxComponents(attributes.k);
      const bComponents = getMaxComponents(blobSizeInWords);
      const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
      const workgroupSize = 128;
      const workgroupY = dimBOuter % 8 === 0 ? 8 : dimBOuter % 4 === 0 ? 4 : 1;
      const workgroupX = workgroupSize / workgroupY;
      const valuesPerWordBs32 = Math.floor(32 / attributes.bits);
      const tileSize = workgroupX * bComponents * valuesPerWordBs32;
      const aLengthPerTile = tileSize / aComponents;
      const blocksPerTile = tileSize / attributes.blockSize;
      const dispatchSize = ShapeUtil.size(outputShape) / workgroupY;
      const programUniforms = [];
      const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
      const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
      bShape.splice(-1, 1, blobSizeInWords / bComponents);
      programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
      programUniforms.push(...createTensorShapeVariables(bShape));
      programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      if (inputs.length === 4) {
        programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
      }
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter];
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const inputRank = inputShapeTemp.length;
        const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
        const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const inputVariables = [a, b, scales];
        const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
        if (zeroPoints) {
          inputVariables.push(zeroPoints);
        }
        const outputRank = outputShapeTemp.length;
        const output = outputVariable("output", inputs[0].dataType, outputRank);
        const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
        const readA = () => {
          switch (aComponents) {
            case 1:
              return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;
            case 2:
              return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;
            case 4:
              return `
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;
            default:
              throw new Error(`${aComponents}-component is not supported.`);
          }
        };
        return `
        var<workgroup> sub_a: array<${a.type.value}, ${aLengthPerTile}>;
        var<workgroup> inter_results: array<array<${output.type.value}, ${workgroupX}>, ${workgroupY}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupX, workgroupY, 1])}
          let output_indices = ${output.offsetToIndices(`workgroup_index * ${workgroupY}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${blocksPerTile} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${aLengthPerTile};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${aLengthPerTile}; a_offset += ${workgroupSize})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${a.getByIndices(`${a.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${a.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${blocksPerTile} + local_id.x;
            ${zeroPoints ? `
            let zero_point_values_per_byte: u32 = ${Math.floor(8 / attributes.bits)}u;
            let zero_point_bytes_per_col = (n_blocks_per_col + zero_point_values_per_byte - 1u) / zero_point_values_per_byte;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block / zero_point_values_per_byte);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_sub_offset: u32 = block % zero_point_values_per_byte;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_sub_offset * ${attributes.bits}u);
            let zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${dataType2}((zero_point_word) & ${attributes.bits === 2 ? "0x3u" : "0xFu"});` : `
            // The default zero point is ${Math.pow(2, attributes.bits - 1)} for unsigned ${attributes.bits}-bit quantization.
            let zero_point = ${dataType2}(${Math.pow(2, attributes.bits - 1).toFixed(1)});`}
            let scale = ${scales.getByOffset(`b_row * n_blocks_per_col + block`)};
            let b_data = ${b.getByIndices(`${b.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${attributes.blockSize / aComponents};
            for (var i: u32 = 0; i < ${bComponents}; i++) {
              let b_value = ${bComponents === 1 ? `b_data` : `b_data[i]`};
              ${(() => {
          const passesPerWordBs32 = Math.floor(valuesPerWordBs32 / 8);
          let code = "";
          for (let pass = 0; pass < passesPerWordBs32; pass++) {
            const lowerShift = pass * attributes.bits * 4;
            const upperShift = lowerShift + attributes.bits;
            code += `
              ${readA()}
              {${attributes.bits === 2 ? `
                let half_word = b_value >> ${pass * 16}u;
                let byte_lo = half_word & 0xFFu;
                let byte_hi = (half_word >> 8u) & 0xFFu;
                let spread_word = (byte_lo & 0xFu) | ((byte_lo >> 4u) << 8u) | ((byte_hi & 0xFu) << 16u) | ((byte_hi >> 4u) << 24u);
                let b_value_lower = unpack4xU8(spread_word & 0x03030303u);
                let b_value_upper = unpack4xU8((spread_word >> 2u) & 0x03030303u);` : `
                let b_value_lower = unpack4xU8((b_value >> ${lowerShift}u) & 0x0F0F0F0Fu);
                let b_value_upper = unpack4xU8((b_value >> ${upperShift}u) & 0x0F0F0F0Fu);`}
                let b_quantized_values = mat2x4<${dataType2}>(${Array.from(
              { length: 4 },
              (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
            ).join(", ")});
                let b_dequantized_values = (b_quantized_values - mat2x4<${dataType2}>(${Array(8).fill("zero_point").join(",")})) * scale;
                inter_results[local_id.y][local_id.x] += ${Array.from(
              { length: 2 },
              (_, i) => `${`dot(a_data${i}, b_dequantized_values[${i}])`}`
            ).join(" + ")};
              }
              word_offset += ${8 / aComponents};`;
          }
          return code;
        })()}
            }
            workgroupBarrier();
          }

          if (local_idx < ${workgroupY}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            for (var b = 0u; b < ${workgroupX}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${output.setByIndices(`${output.type.indices}(batch, row, col + local_idx)`, "output_value")}
            }
          }
        }`;
      };
      return {
        name: "BlockwiseMatMulNBits32",
        shaderCache: {
          hint: `${attributes.blockSize};${aComponents};${bComponents};${workgroupX};${workgroupY}`,
          inputDependencies: Array(inputs.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: dispatchSize },
          programUniforms
        }),
        getShaderSource
      };
    };
    matMulNBits = (context, attributes) => {
      validateInputs23(context.inputs, attributes);
      if (attributes.blockSize === 32 && context.adapterInfo.isVendor("intel") && context.adapterInfo.isArchitecture("gen-12lp")) {
        context.compute(createMatMulNBitsBlockSize32ProgramInfo(context.inputs, attributes));
      } else {
        context.compute(createMatMulNBitsProgramInfo(context.inputs, attributes));
      }
    };
    parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/pad.ts
var validateInputs24, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
var init_pad = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs24 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("Too few inputs");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
        throw new Error("Input type must be float or float16.");
      }
      if (inputs.length >= 2) {
        let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
        if (inputs.length === 4) {
          validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
        }
        if (!validPads) {
          throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
        }
      }
    };
    getPadConstant = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
      }
      return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
    };
    getPadReflect = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadEdge = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadWrap = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadSnippet = (output, inputRank, attributes) => {
      switch (attributes.mode) {
        case 0:
          return getPadConstant(output, inputRank, attributes.pads.length);
        case 1:
          return getPadReflect(output, inputRank, attributes.pads.length);
        case 2:
          return getPadEdge(output, inputRank, attributes.pads.length);
        case 3:
          return getPadWrap(output, inputRank, attributes.pads.length);
        default:
          throw new Error("Invalid mode");
      }
    };
    createPadProgramInfo = (inputs, attributes) => {
      const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
      const inputDims = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: attributes.pads }
      ];
      const isValueFromInput = inputs.length >= 3 && inputs[2].data;
      if (attributes.mode === 0) {
        programUniforms.push({ type: isValueFromInput ? inputs[2].dataType : 1 /* float */, data: attributes.value });
      }
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
      const inputDependencies = ["rank"];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("x", inputs[0].dataType, inputDims.length);
        const dataType = input.type.value;
        const padSnippet = getPadSnippet(output, inputDims.length, attributes);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "pads", type: "i32", length: attributes.pads.length }
        ];
        if (attributes.mode === 0) {
          uniforms.push({ name: "constant_value", type: isValueFromInput ? dataType : "f32" });
        }
        return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
      };
      return {
        name: "Pad",
        shaderCache: { hint: `${attributes.mode}${isValueFromInput}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createPadAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const bigInt64Pads = inputs[1].getBigInt64Array();
        const value = inputs.length >= 3 && inputs[2].data ? inputs[2].dataType === 10 /* float16 */ ? inputs[2].getUint16Array()[0] : inputs[2].getFloat32Array()[0] : 0;
        const inputRank = inputs[0].dims.length;
        const updatePads = new Int32Array(2 * inputRank).fill(0);
        if (inputs.length >= 4) {
          const axes = inputs[3].getBigInt64Array();
          for (let i = 0; i < axes.length; i++) {
            updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
            updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
          }
        } else {
          bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
        }
        const pads = [];
        updatePads.forEach((v) => pads.push(v));
        return { mode: attributes.mode, value, pads };
      } else {
        return attributes;
      }
    };
    pad = (context, attributes) => {
      validateInputs24(context.inputs);
      const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
      context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/pool.ts
var validateInputs25, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
var init_pool = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_common();
    validateInputs25 = (inputs) => {
      if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
        throw new Error("Pool ops requires 1 input.");
      }
    };
    getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inputShapeAsChannelFirst = input.dims.slice();
      if (isChannelsLast) {
        inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
      }
      const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
      const kernelShape = attributes.kernelShape.slice();
      const strides = attributes.strides.slice();
      const dilations = hasDilations ? attributes.dilations.slice() : [];
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
      const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
        isGlobalOperator,
        inputShapeAsChannelFirst,
        strides,
        dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      if (hasDilations) {
        Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
      } else {
        Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
      }
      const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
      outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
      return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
    };
    getUniformAndPadInfo = (outputShape, attributes) => {
      const isChannelsLast = attributes.format === "NHWC";
      const outputSize = ShapeUtil.size(outputShape);
      const kernelSize = ShapeUtil.size(attributes.kernelShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: kernelSize }
      ];
      const uniforms = [
        { name: "outputSize", type: "u32" },
        { name: "kernelSize", type: "u32" }
      ];
      if (attributes.kernelShape.length <= 2) {
        const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
        const sw = attributes.strides[attributes.strides.length - 1];
        const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
        const pwEnd = attributes.pads[attributes.pads.length - 1];
        const pwStartEndNotZero = !!(pwStart + pwEnd);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kw },
          { type: 12 /* uint32 */, data: sw },
          { type: 12 /* uint32 */, data: pwStart },
          { type: 12 /* uint32 */, data: pwEnd }
        );
        uniforms.push(
          { name: "kw", type: "u32" },
          { name: "sw", type: "u32" },
          { name: "pwStart", type: "u32" },
          { name: "pwEnd", type: "u32" }
        );
        let phStartEndNotZero = false;
        if (attributes.kernelShape.length === 2) {
          const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
          const sh = attributes.strides[attributes.strides.length - 2];
          const phStart = attributes.pads[attributes.pads.length / 2 - 2];
          const phEnd = attributes.pads[attributes.pads.length - 2];
          phStartEndNotZero = !!(phStart + phEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kh },
            { type: 12 /* uint32 */, data: sh },
            { type: 12 /* uint32 */, data: phStart },
            { type: 12 /* uint32 */, data: phEnd }
          );
          uniforms.push(
            { name: "kh", type: "u32" },
            { name: "sh", type: "u32" },
            { name: "phStart", type: "u32" },
            { name: "phEnd", type: "u32" }
          );
        }
        return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kernelStrides },
          { type: 12 /* uint32 */, data: attributes.pads },
          { type: 12 /* uint32 */, data: attributes.strides }
        );
        uniforms.push(
          { name: "kernelStrides", type: "u32", length: kernelStrides.length },
          { name: "pads", type: "u32", length: attributes.pads.length },
          { name: "strides", type: "u32", length: attributes.strides.length }
        );
        const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
        return [programUniforms, uniforms, !!hasPads, false, false];
      }
    };
    generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
      const isChannelsLast = attributes.format === "NHWC";
      const dataType = x.type.value;
      const output = outputVariable("output", x.type.tensor, outputShapeRank);
      if (attributes.kernelShape.length <= 2) {
        let codeW = "";
        let codeH = "";
        let codeHEnd = "";
        const dimIdxW = rank - (isChannelsLast ? 2 : 1);
        if (pwStartEndNotZero) {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        } else {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        }
        if (attributes.kernelShape.length === 2) {
          const dimIdxH = rank - (isChannelsLast ? 3 : 2);
          if (phStartEndNotZero) {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
          } else {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
          }
          codeHEnd = `
              }
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const stridesRank = attributes.kernelShape.length;
        const padsRank = attributes.pads.length;
        let padCode = "";
        if (hasPads) {
          padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
        } else {
          padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt(
          "uniforms.strides",
          `j - ${rank - stridesRank}u`,
          stridesRank
        )}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      }
    };
    createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
    createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
    createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
    parsePoolCommonAttributes = (attributes) => ({
      format: attributes.format,
      autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
      ceilMode: attributes.ceil_mode,
      kernelShape: attributes.kernel_shape,
      strides: attributes.strides,
      pads: attributes.pads
    });
    createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
        input,
        attributes,
        isGlobalOperator
      );
      const x = inputVariable("x", input.dataType, input.dims.length);
      const dataType = x.type.value;
      const op1 = "value += x_val;";
      let op2 = "";
      if (adjustedAttributes.countIncludePad) {
        op2 += `value /= ${dataType}(uniforms.kernelSize);`;
      } else {
        op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
      }
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
        outputShape,
        adjustedAttributes
      );
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      const inputDependencies = ["rank"];
      return {
        name,
        shaderCache: {
          hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          0,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    parseAveragePoolAttributes = (attributes) => {
      const countIncludePad = attributes.count_include_pad === 0 ? false : true;
      const attr = parsePoolCommonAttributes(attributes);
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
      }
      const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
      return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
    };
    averagePool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
    };
    globalPoolAttributes = {
      autoPad: "",
      ceilMode: 0,
      countIncludePad: false,
      kernelShape: [],
      strides: [],
      pads: [],
      storageOrder: 0,
      dilations: []
    };
    parseGlobalAveragePoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalAveragePool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
    };
    createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
        input,
        attributes,
        isGlobalOperator
      );
      const op1 = `
      value = max(x_val, value);
    `;
      const op2 = "";
      const x = inputVariable("x", input.dataType, input.dims.length);
      const inputDependencies = ["rank"];
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
        outputShape,
        adjustedAttributes
      );
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      return {
        name,
        shaderCache: {
          hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          input.dataType === 10 /* float16 */ ? -65504 : -1e5,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    maxPool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
    };
    parseMaxPoolAttributes = (attributes) => {
      const storageOrder = attributes.storage_order;
      const dilations = attributes.dilations;
      const attr = parsePoolCommonAttributes(attributes);
      if (storageOrder !== 0) {
        throw new Error("column major storage order is not yet supported for MaxPool");
      }
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
      }
      const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
      return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
    };
    parseGlobalMaxPoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalMaxPool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts
var validateInputs26, createDequantizeLinearProgramInfo, dequantizeLinear, parseDequantizeLinearAttributes;
var init_quantize_linear = __esm({
  "web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs26 = (inputs, attributes) => {
      if (inputs.length < 2 || inputs.length > 3) {
        throw new Error("DequantizeLinear requires 2 or 3 inputs.");
      }
      if (inputs.length === 3 && inputs[1].dims === inputs[2].dims) {
        throw new Error("x-scale and x-zero-point must have the same shape.");
      }
      if (inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
        throw new Error("x and x-zero-point must have the same data type.");
      }
      if (inputs[0].dataType === 6 /* int32 */ && inputs.length > 2) {
        throw new Error("In the case of dequantizing int32 there is no zero point.");
      }
      if (inputs[1].dims.length !== 0 && inputs[1].dims.length !== 1 && inputs[1].dims.length !== inputs[0].dims.length) {
        throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
      }
      if (inputs.length > 2) {
        if (inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("x and x-zero-point must have the same data type.");
        }
        if (inputs[1].dims.length !== inputs[2].dims.length) {
          throw new Error("scale and zero-point inputs must have the same rank.");
        }
        if (!inputs[1].dims.map((d, i) => d === inputs[2].dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error("scale and zero-point inputs must have the same shape.");
        }
      }
      if (attributes.blockSize > 0) {
        if (inputs[1].dims.length === 0 || inputs[1].dims.length === 1 && inputs[1].dims[0] === 1) {
          throw new Error("blockSize must be set only for block quantization.");
        }
        if (!inputs[1].dims.map((d, i) => i === attributes.axis || d === inputs[0].dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
        }
        if (inputs[1].dims.length !== inputs[0].dims.length) {
          throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
        }
        const dI = inputs[0].dims[attributes.axis];
        const si = inputs[1].dims[attributes.axis];
        if (attributes.blockSize < Math.ceil(dI / si) || attributes.blockSize > Math.ceil(dI / (si - 1) - 1)) {
          throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
        }
      }
    };
    createDequantizeLinearProgramInfo = (inputs, attributes) => {
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
      const inputType = inputs[0].dataType;
      const isSigned = inputType === 3 /* int8 */;
      const outputShape = inputs[0].dims;
      const dataType = inputs[1].dataType;
      const outputSize = ShapeUtil.size(outputShape);
      const isPacked = inputType === 3 /* int8 */ || inputType === 2 /* uint8 */;
      const inputShape = isPacked ? [Math.ceil(ShapeUtil.size(inputs[0].dims) / 4)] : inputs[0].dims;
      const scaleShape = inputs[1].dims;
      const zeroPointInput = inputs.length > 2 ? inputs[2] : void 0;
      const zeroPointShape = zeroPointInput ? isPacked ? [Math.ceil(ShapeUtil.size(zeroPointInput.dims) / 4)] : zeroPointInput.dims : void 0;
      const perLayerQuantization = scaleShape.length === 0 || scaleShape.length === 1 && scaleShape[0] === 1;
      const perAxisQuantization = perLayerQuantization === false && scaleShape.length === 1;
      const maxComponents = getMaxComponents(outputSize);
      const useComponents = perLayerQuantization && (!isPacked || maxComponents === 4);
      const components = useComponents ? maxComponents : 1;
      const inputComponent = useComponents && !isPacked ? maxComponents : 1;
      const input = inputVariable("input", isPacked ? 12 /* uint32 */ : inputType, inputShape.length, inputComponent);
      const scale = inputVariable("scale", dataType, scaleShape.length);
      const zeroPoint = zeroPointInput ? inputVariable("zero_point", isPacked ? 12 /* uint32 */ : inputType, zeroPointShape.length) : void 0;
      const output = outputVariable("output", dataType, outputShape.length, components);
      const inputVariables = [input, scale];
      if (zeroPoint) {
        inputVariables.push(zeroPoint);
      }
      const inputShapes = [inputShape, scaleShape];
      if (zeroPointInput) {
        inputShapes.push(zeroPointShape);
      }
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize / components },
        { type: 12 /* uint32 */, data: axis },
        { type: 12 /* uint32 */, data: attributes.blockSize },
        ...createTensorShapeVariables(...inputShapes, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "axis", type: "u32" },
          { name: "block_size", type: "u32" }
        ];
        return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${output.offsetToIndices("global_idx")};

          // Set input x
          ${(() => {
          if (isPacked) {
            return `
            let input = ${input.getByOffset("global_idx / 4")};
            let x_vec = ${isSigned ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${components === 1 ? "x_vec[global_idx % 4]" : "x_vec"};`;
          } else {
            return `let x_value = ${input.getByOffset("global_idx")};`;
          }
        })()};

          // Set scale input
          ${(() => {
          if (perLayerQuantization) {
            return `let scale_value= ${scale.getByOffset("0")}`;
          } else if (perAxisQuantization) {
            return `
            let scale_index = ${output.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${scale.getByOffset("scale_index")};`;
          } else {
            return `
            var scale_indices: ${scale.type.indices} = output_indices;
            let index = ${scale.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${scale.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${scale.getByIndices("scale_indices")};`;
          }
        })()};

          // Set zero-point input
          ${(() => {
          if (zeroPoint) {
            if (perLayerQuantization) {
              if (isPacked) {
                return `
                let zero_point_input = ${zeroPoint.getByOffset("0")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`;
              } else {
                return `let zero_point_value = ${zeroPoint.getByOffset("0")}`;
              }
            } else if (perAxisQuantization) {
              if (isPacked) {
                return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`;
              } else {
                return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${zeroPoint.getByOffset("zero_point_index")};`;
              }
            } else {
              if (isPacked) {
                return `
                let zero_point_offset = ${scale.indicesToOffset("scale_indices")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`;
              } else {
                return `let zero_point_value = ${zeroPoint.getByIndices("scale_indices")};`;
              }
            }
          } else {
            return `let zero_point_value = ${isPacked ? isSigned ? "i32" : "u32" : input.type.value}(0);`;
          }
        })()};
      // Compute and write output
      ${output.setByOffset("global_idx", `${output.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
      };
      return {
        name: "DequantizeLinear",
        shaderCache: {
          hint: attributes.cacheKey,
          inputDependencies: zeroPoint ? ["rank", "rank", "rank"] : ["rank", "rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(outputSize / components / 64), y: 1, z: 1 },
          programUniforms
        })
      };
    };
    dequantizeLinear = (context, attributes) => {
      validateInputs26(context.inputs, attributes);
      context.compute(createDequantizeLinearProgramInfo(context.inputs, attributes));
    };
    parseDequantizeLinearAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis, blockSize: attributes.blockSize });
  }
});

// web/lib/wasm/jsep/webgpu/ops/range.ts
var validateInputsContent, createRangeProgramInfo, range;
var init_range = __esm({
  "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_common();
    validateInputsContent = (start, limit, delta) => {
      const sameStartLimit = start === limit;
      const increasingRangeNegativeStep = start < limit && delta < 0;
      const decreasingRangePositiveStep = start > limit && delta > 0;
      if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
        throw new Error("Range these inputs' contents are invalid.");
      }
    };
    createRangeProgramInfo = (start, limit, delta, dataType) => {
      const numElements = Math.abs(Math.ceil((limit - start) / delta));
      const outputShape = [numElements];
      const outputSize = numElements;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: dataType, data: start },
        { type: dataType, data: delta },
        ...createTensorShapeVariables(outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", dataType, outputShape.length);
        const wgslType = output.type.value;
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "start", type: wgslType },
          { name: "delta", type: wgslType }
        ];
        return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
      };
      return {
        name: "Range",
        shaderCache: { hint: `${dataType}` },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    range = (context) => {
      let start = 0;
      let limit = 0;
      let delta = 0;
      if (context.inputs[0].dataType === 6 /* int32 */) {
        start = context.inputs[0].getInt32Array()[0];
        limit = context.inputs[1].getInt32Array()[0];
        delta = context.inputs[2].getInt32Array()[0];
      } else if (context.inputs[0].dataType === 1 /* float */) {
        start = context.inputs[0].getFloat32Array()[0];
        limit = context.inputs[1].getFloat32Array()[0];
        delta = context.inputs[2].getFloat32Array()[0];
      }
      if (env2.webgpu.validateInputContent) {
        validateInputsContent(start, limit, delta);
      }
      context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts
var atomicReductionSnippet, createScatterNDProgramInfo, parseScatterNDAttributes, scatterND;
var init_scatter_nd = __esm({
  "web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    atomicReductionSnippet = (reduction, ptr, v, type) => {
      if (reduction !== "none" && type !== "i32" && type !== "u32" && type !== "f32") {
        throw new Error(`Input ${type} is not supported with reduction ${reduction}.`);
      }
      const floatStart = `{
                var oldValue = 0;
                loop {
                  let newValueF32 =`;
      const floatEnd = `;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${ptr}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;
      switch (reduction) {
        case "none":
          return `${ptr}=${v};`;
        case "add":
          if (type === "i32" || type === "u32") {
            return `atomicAdd(&${ptr}, bitcast<${type}>(${v}));`;
          } else {
            return `
              ${floatStart}bitcast<${type}>(oldValue) + (${v})${floatEnd}`;
          }
        case "max":
          if (type === "i32" || type === "u32") {
            return `atomicMax(&${ptr}, bitcast<${type}>(${v}));`;
          } else {
            return `
                ${floatStart}max(bitcast<f32>(oldValue), (${v}))${floatEnd}`;
          }
        case "min":
          if (type === "i32" || type === "u32") {
            return `atomicMin(&${ptr}, bitcast<${type}>(${v}));`;
          } else {
            return `${floatStart}min(bitcast<${type}>(oldValue), (${v}))${floatEnd}`;
          }
        case "mul":
          return `${floatStart}(bitcast<${type}>(oldValue) * (${v}))${floatEnd}`;
        default:
          throw new Error(`Reduction ${reduction} is not supported.`);
      }
    };
    createScatterNDProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const outputShape = inputShape;
      const components = 1;
      const outputSize = Math.ceil(ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1) / components);
      const lastIndexDimension = indicesShape[indicesShape.length - 1];
      const numUpdatesElements = ShapeUtil.sizeFromDimension(inputShape, lastIndexDimension);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: lastIndexDimension },
        { type: 12 /* uint32 */, data: numUpdatesElements },
        ...createTensorShapeVariables(inputs[1].dims, inputs[2].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const indices = inputVariable("indices", inputs[1].dataType, inputs[1].dims.length);
        const updates = inputVariable("updates", inputs[2].dataType, inputs[2].dims.length, components);
        const output = attributes.reduction !== "none" && attributes.reduction !== "" ? atomicOutputVariable("output", inputs[0].dataType, outputShape.length) : outputVariable("output", inputs[0].dataType, outputShape.length, components);
        return `
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("last_index_dimension", "u32").registerUniform("num_updates_elements", "u32").declareVariables(indices, updates, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${inputs[0].dims.length === 1 ? `
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;` : `
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${atomicReductionSnippet(
          attributes.reduction,
          "output[data_offset + i]",
          "value",
          output.type.value
        )}
  }

      }`;
      };
      return {
        name: "ScatterND",
        shaderCache: {
          hint: `${attributes.cacheKey}_${attributes.reduction}`,
          inputDependencies: ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseScatterNDAttributes = (attributes) => createAttributeWithCacheKey({ reduction: attributes.reduction });
    scatterND = (context, attributes) => {
      context.compute(createScatterNDProgramInfo(context.inputs, attributes), {
        inputs: [context.inputs[1], context.inputs[2]],
        outputs: []
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/resize.ts
var validateScales, updateScales, validateInputs27, getSafeIntegerDivision, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
var init_resize = __esm({
  "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateScales = (scales, attributes) => {
      scales.every(
        (value) => value > 0 || (() => {
          throw new Error("Resize requires scales input values to be positive");
        })
      );
      if (scales.length > 0) {
        if (attributes.mode === "linear") {
          if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
            throw new Error(
              `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
            );
          }
        } else if (attributes.mode === "cubic") {
          if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
            throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
          }
        }
      }
    };
    updateScales = (scales, axes, rank) => {
      axes.every(
        (value) => value >= 0 && value < rank || (() => {
          throw new Error("Resize requires axes input values to be positive and less than rank");
        })
      );
      const newScales = new Array(rank).fill(1);
      axes.forEach((value, index) => newScales[value] = scales[index]);
      return newScales;
    };
    validateInputs27 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
      const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
      const rank = inputs[0].dims.length;
      if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
        inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
      } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
        throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
      }
      if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length === 1 && inputs[scalesInputIndex].dims[0] > 0) {
        inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
        if (scales.length !== 0 && scales.length !== rank && opsetVersion >= 18 && scales.length !== attributes.axes.length) {
          throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
        }
        validateScales(scales, attributes);
        if (attributes.axes.length > 0) {
          updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
        }
      }
      if (sizesInputIndex > 0 && inputs.length > sizesInputIndex && inputs[sizesInputIndex].dims.length === 1 && inputs[sizesInputIndex].dims[0] > 0) {
        inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
        if (sizes.length !== 0 && sizes.length !== rank && opsetVersion >= 18 && sizes.length !== attributes.axes.length) {
          throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
        }
      }
      if (attributes.axes.length > 0) {
        if (scales.length !== 0 && scales.length !== attributes.axes.length) {
          throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
        }
        if (sizes.length !== 0 && sizes.length !== attributes.axes.length) {
          throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
        }
      }
      if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
        throw new Error("Resize requires only of scales or sizes to be specified");
      }
    };
    getSafeIntegerDivision = (a, b, c, dType) => `
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${a}) * (${b});
  let whole = ${dType}(big / (${c}));
  let fract = ${dType}(big % (${c})) / ${dType}(${c});
  return whole + fract;
`;
    getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
      switch (coordinateTransferMode) {
        case "asymmetric":
          return `
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${dType}(xResized) / ${dType}(xScale);
          } else {
            ${getSafeIntegerDivision("xResized", "lengthOriginal", "lengthResized", dType)}
          }
        `;
        case "pytorch_half_pixel":
          return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
        case "tf_half_pixel_for_nn":
          return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
        case "align_corners":
          return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${getSafeIntegerDivision("xResized", "lengthOriginal - 1", "lengthResized - 1", dType)}
                  }`;
        case "tf_crop_and_resize":
          return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
        case "half_pixel_symmetric":
          return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        case "half_pixel":
          return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        default:
          throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
      }
    })() + "}";
    getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
      switch (nearestMode) {
        case "round_prefer_ceil":
          return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
        case "floor":
          return "return floor(xOriginal);";
        case "ceil":
          return "return ceil(xOriginal);";
        case "round_prefer_floor":
          return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
        case "simple":
        default:
          if (opsetVersion < 11) {
            return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
          }
          throw new Error(`Nearest mode ${nearestMode} is not supported`);
      }
    })() + "}";
    updateRoI = (roi, axes, rank) => {
      const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
      const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
      if (axes.length > 0) {
        axes.forEach((v, i) => {
          roiTmp[v] = roiLocal[i];
          roiTmp[i + rank] = roiLocal[axes.length + i];
        });
        return roiTmp;
      }
      return roiLocal;
    };
    initOutputShape = (inputShape, scales, sizes, axes) => {
      let outputShape = [];
      if (sizes.length > 0) {
        if (axes.length > 0) {
          inputShape.forEach((v) => outputShape.push(v));
          if (Math.max(...axes) > inputShape.length) {
            throw new Error("axes is out of bound");
          }
          axes.forEach((v, i) => outputShape[v] = sizes[i]);
        } else {
          sizes.forEach((v) => outputShape.push(v));
        }
      } else {
        if (scales.length === 0) {
          throw new Error("Resize requires either scales or sizes.");
        } else {
          outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
        }
      }
      return outputShape;
    };
    adjustOutputShape = (inputShape, scales, attributes) => {
      const scaleInPolicy = (() => {
        switch (attributes.keepAspectRatioPolicy) {
          case "not_larger":
            return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
          case "not_smaller":
            return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
          default:
            throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
        }
      })();
      scales.fill(1, 0, scales.length);
      const adjustedOutputShape = inputShape.slice();
      if (attributes.axes.length > 0) {
        attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
        attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
      } else {
        scales.fill(scaleInPolicy, 0, scales.length);
        adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
      }
      return adjustedOutputShape;
    };
    calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
    calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", "input_index")}
      }
      return input_indices;
    }`;
    checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
    setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
    bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
    };
    bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
      const is2D = inputShape.length === 2;
      const isNchw = true;
      const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
      const dType = input.type.value;
      const createCubicInterpolationFunction = (idx) => {
        const direction = idx === heightIdx ? "row" : "col";
        return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
          if (excludeOutside) {
            return `coefs[i + 1] = 0.0;
                        continue;`;
          } else if (useExtrapolation) {
            return `return ${extrapolationValue};`;
          } else {
            return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
          }
        })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
      };
      return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
    };
    trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
    };
    createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
      const inputShape = inputTensor.dims;
      const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
      let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
      let scales = scalesInput.slice();
      if (scalesInput.length === 0) {
        scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
        if (attributes.keepAspectRatioPolicy !== "stretch") {
          outputShape = adjustOutputShape(inputShape, scales, attributes);
        }
      }
      const output = outputVariable("output", inputTensor.dataType, outputShape.length);
      const input = inputVariable("input", inputTensor.dataType, inputShape.length);
      const outputSize = ShapeUtil.size(outputShape);
      const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
      const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
      const extrapolationValue = attributes.extrapolationValue;
      const dataType = input.type.value;
      const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
              input,
              output,
              inputShape,
              outputShape,
              scales.length,
              roi.length,
              useExtrapolation
            )};
              `;
          case "linear":
            return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else if (inputShape.length === 3 || inputShape.length === 5) {
                return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else {
                throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
              }
            })()};
            `;
          case "cubic":
            return `
            ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bicubicInterpolation(
                  input,
                  output,
                  inputShape,
                  outputShape,
                  scales,
                  roi,
                  attributes.cubicCoeffA,
                  useExtrapolation,
                  attributes.extrapolationValue,
                  attributes.excludeOutside
                )}`;
              } else {
                throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
              }
            })()};
            `;
          default:
            throw Error("Invalid resize mode");
        }
      })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
          case "linear":
            return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
          case "cubic":
            return "output[global_idx] = bicubicInterpolation(output_indices);";
          default:
            throw Error(`Unsupported resize mode: ${attributes.mode}`);
        }
      })()};
`}
      }`;
      return {
        name: "Resize",
        shaderCache: {
          hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? attributes.mode === "cubic" ? scales : scales.length : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${attributes.mode === "nearest" ? inputShape.length : inputShape}`,
          inputDependencies: ["rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 1 /* float */, data: scales },
            { type: 1 /* float */, data: roi },
            ...createTensorShapeVariables(inputShape, outputShape)
          ]
        })
      };
    };
    getOpsetVersionFromCustomDataBuffer = (context) => {
      const customDataBuffer = context.customDataBuffer;
      const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
      const opsetVersion = customDataBuffer32[0];
      return opsetVersion;
    };
    resize = (context, attributes) => {
      const scales = [];
      const sizes = [];
      const roi = [];
      const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
      if (attributes.antialias !== 0) {
        throw Error("Only default value (0) for Antialias attribute is supported");
      }
      validateInputs27(context.inputs, attributes, opsetVersion, scales, sizes, roi);
      context.compute(createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi), {
        inputs: [0]
      });
    };
    parseResizeAttributes = (attributes) => {
      const antialias = attributes.antialias;
      const axes = attributes.axes;
      const coordinateTransformMode = attributes.coordinateTransformMode;
      const cubicCoeffA = attributes.cubicCoeffA;
      const excludeOutside = attributes.excludeOutside !== 0;
      const extrapolationValue = attributes.extrapolationValue;
      const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
      const mode = attributes.mode;
      const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
      return createAttributeWithCacheKey({
        antialias,
        axes,
        coordinateTransformMode,
        cubicCoeffA,
        excludeOutside,
        extrapolationValue,
        keepAspectRatioPolicy,
        mode,
        nearestMode
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
var validateInputs28, createSkipLayerNormProgramInfo, skipLayerNorm;
var init_skip_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs28 = (inputs) => {
      if (!inputs || inputs.length < 3) {
        throw new Error("layerNorm requires at least 3 inputs.");
      }
      const input = inputs[0];
      const skip = inputs[1];
      const gamma = inputs[2];
      if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
        throw new Error("All inputs must have the same data type");
      }
      if (input.dims.length !== 3 && input.dims.length !== 2) {
        throw new Error("Input must be 2D or 3D");
      }
      if (skip.dims.length !== 3 && skip.dims.length !== 2) {
        throw new Error("Skip must be 2D or 3D");
      }
      const hiddenSize = input.dims[input.dims.length - 1];
      const sequenceLength = input.dims[input.dims.length - 2];
      if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
        throw new Error("Skip must have the same hidden size as input");
      }
      if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
        throw new Error("Skip must have the same sequence length as input");
      }
      if (gamma.dims.length !== 1) {
        throw new Error("Gamma must be 1D");
      }
      if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
        throw new Error("Gamma must have the same hidden size as input");
      }
      if (inputs.length > 3) {
        const beta = inputs[3];
        if (beta.dims.length !== 1) {
          throw new Error("Beta must be 1D");
        }
        if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
          throw new Error("Beta must have the same hidden size as input");
        }
      }
      if (inputs.length > 4) {
        const bias = inputs[4];
        if (bias.dims.length !== 1) {
          throw new Error("Bias must be 1D");
        }
        if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
          throw new Error("Bias must have the same hidden size as input");
        }
      }
    };
    createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
      const simplified = attributes.simplified;
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const outputShape = inputShape;
      const outputSize = inputSize;
      const hiddenSize = inputShape.slice(-1)[0];
      const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
      const hasBetaInput = !simplified && inputs.length > 3;
      const hasBiasInput = inputs.length > 4;
      const hasMeanOutput = isTraining && outputCount > 1;
      const hasInvStdDevOutput = isTraining && outputCount > 2;
      const hasInputSkipBiasSumOutput = outputCount > 3;
      const workgroupSize = 64;
      const components = getMaxComponents(hiddenSize);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: components },
        { type: 12 /* uint32 */, data: hiddenSize },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      const getShaderSource = (shaderHelper) => {
        const uniformsArray = [
          { name: "output_size", type: "u32" },
          { name: "components", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
          inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
        ];
        if (hasBetaInput) {
          variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
        }
        if (hasBiasInput) {
          variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanOutput) {
          variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdDevOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInputSkipBiasSumOutput) {
          variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
        }
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
        return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([workgroupSize, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (outputCount > 1) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 2) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 3) {
        outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
      }
      return {
        name: "SkipLayerNormalization",
        shaderCache: {
          hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
          inputDependencies: inputs.map((_input, _index) => "type")
        },
        getShaderSource,
        getRunData: () => ({
          outputs,
          dispatchGroup: {
            x: Math.ceil(outputSize / hiddenSize)
          },
          programUniforms
        })
      };
    };
    skipLayerNorm = (context, attributes) => {
      const isTraining = false;
      validateInputs28(context.inputs);
      const outputs = [0];
      if (context.outputCount > 1) {
        outputs.push(isTraining ? 1 : -3);
      }
      if (context.outputCount > 2) {
        outputs.push(isTraining ? 2 : -3);
      }
      if (context.outputCount > 3) {
        outputs.push(3);
      }
      context.compute(createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining), {
        outputs
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/slice.ts
var validateInputs29, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
var init_slice = __esm({
  "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs29 = (inputs, attributes) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      if (attributes.axes.length !== 0) {
        if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
          throw new Error("axes, starts and ends must have the same length");
        }
      } else if (attributes.starts.length !== attributes.ends.length) {
        throw new Error("starts and ends must have the same length");
      }
      inputs.slice(1).forEach((_, idx) => {
        if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      });
    };
    readInput = (inputs, idx) => {
      const input = [];
      if (inputs.length > idx) {
        if (inputs[idx].dataType === 7 /* int64 */) {
          inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
        } else if (inputs[idx].dataType === 6 /* int32 */) {
          inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
        } else {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      }
      return input;
    };
    createSliceAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const starts = readInput(inputs, 1);
        const ends = readInput(inputs, 2);
        let axes = readInput(inputs, 3);
        if (axes.length === 0) {
          axes = [...Array(inputs[0].dims.length).keys()];
        }
        return createAttributeWithCacheKey({ starts, ends, axes });
      } else {
        return attributes;
      }
    };
    fixStartEndValues = (value, index, inputShape, axes, steps) => {
      let newValue = value;
      if (value < 0) {
        newValue += inputShape[axes[index]];
      }
      if (steps[index] < 0) {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
      } else {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
      }
    };
    calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length - 1}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
    createSliceProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
      let steps = readInput(inputs, 4);
      steps.forEach(
        (step) => step !== 0 || (() => {
          throw new Error("step cannot be 0");
        })
      );
      if (steps.length === 0) {
        steps = Array(axes.length).fill(1);
      }
      const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
      const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
      if (axes.length !== starts.length || axes.length !== ends.length) {
        throw new Error("start, ends and axes should have the same number of elements");
      }
      if (axes.length !== inputShape.length) {
        for (let i = 0; i < inputShape.length; ++i) {
          if (!axes.includes(i)) {
            starts.splice(i, 0, 0);
            ends.splice(i, 0, inputShape[i]);
            steps.splice(i, 0, 1);
          }
        }
      }
      const signs = steps.map((step) => Math.sign(step));
      steps.forEach((step, i, array) => {
        if (step < 0) {
          const numSteps = (ends[i] - starts[i]) / step;
          const newEnd = starts[i];
          const newStart = newEnd + numSteps * steps[i];
          starts[i] = newStart;
          ends[i] = newEnd;
          array[i] = -step;
        }
      });
      const outputShape = inputShape.slice(0);
      axes.forEach((axis, _) => {
        outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
      });
      const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
      const output = outputVariable("output", inputs[0].dataType, outputShape.length);
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
      const outputSize = ShapeUtil.size(outputShape);
      const uniforms = [
        { name: "outputSize", type: "u32" },
        { name: "starts", type: "u32", length: starts.length },
        { name: "signs", type: "i32", length: signs.length },
        { name: "steps", type: "u32", length: steps.length }
      ];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: starts },
        { type: 6 /* int32 */, data: signs },
        { type: 12 /* uint32 */, data: steps },
        ...createTensorShapeVariables(inputs[0].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
      return {
        name: "Slice",
        shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [outputTensorInfo],
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    slice = (context, attributes) => {
      validateInputs29(context.inputs, attributes);
      const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
      context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSliceAttributes = (attributes) => {
      const starts = attributes.starts;
      const ends = attributes.ends;
      const axes = attributes.axes;
      return createAttributeWithCacheKey({ starts, ends, axes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/softmax.ts
var validateInputs30, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
var init_softmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_transpose();
    init_common();
    validateInputs30 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Softmax op requires 1 input.");
      }
    };
    createSoftmaxProgramInfo = (context, attributes) => {
      const input = context.inputs[0];
      const inputShape = input.dims;
      const outputSize = ShapeUtil.size(inputShape);
      const inputRank = inputShape.length;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const isTransposeRequired = axis < inputShape.length - 1;
      let transposedInput;
      let perm = [];
      if (isTransposeRequired) {
        perm = Array.from({ length: inputRank }, (_, i) => i);
        perm[axis] = inputRank - 1;
        perm[inputRank - 1] = axis;
        transposedInput = context.compute(createTransposeProgramInfo(input, perm), {
          inputs: [input],
          outputs: [-1]
        })[0];
      } else {
        transposedInput = input;
      }
      const transposedInputShape = transposedInput.dims;
      const cols = transposedInputShape[inputRank - 1];
      const rows = outputSize / cols;
      const components = getMaxComponents(cols);
      const packedCols = cols / components;
      let WG = 64;
      if (rows === 1) {
        WG = 256;
      }
      const maxVector = (name, components2) => {
        if (components2 === 4) {
          return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
        } else if (components2 === 2) {
          return `max(${name}.x, ${name}.y)`;
        } else if (components2 === 3) {
          return `max(max(${name}.x, ${name}.y), ${name}.z)`;
        }
        return name;
      };
      const x = inputVariable("x", transposedInput.dataType, transposedInput.dims, components);
      const output = outputVariable("result", transposedInput.dataType, transposedInput.dims, components);
      const valueType = x.type.value;
      const threadMaxDecl = tensorTypeToWsglStorageType(transposedInput.dataType) === "f32" ? `var threadMax = ${valueType}(-3.4028234663852886e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
      const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart(WG)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${valueType}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`;
      const result = context.compute(
        {
          name: "Softmax",
          // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
          shaderCache: { hint: `${components};${WG}`, inputDependencies: ["type"] },
          getRunData: () => ({
            outputs: [{ dims: transposedInputShape, dataType: transposedInput.dataType }],
            dispatchGroup: { x: rows },
            programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
          }),
          getShaderSource
        },
        {
          inputs: [transposedInput],
          outputs: [isTransposeRequired ? -1 : 0]
        }
      )[0];
      if (isTransposeRequired) {
        context.compute(createTransposeProgramInfo(result, perm), {
          inputs: [result]
        });
      }
    };
    softmax = (context, attributes) => {
      validateInputs30(context.inputs);
      createSoftmaxProgramInfo(context, attributes);
    };
    parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/tile.ts
var getRepeats, validateInputs31, getOutputShape2, createTileProgramInfo, tile;
var init_tile = __esm({
  "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
    validateInputs31 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Tile requires 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
        throw new Error("Tile only support float, float16, int32, and uint32 data types");
      }
      if (inputs[1].dataType !== 7 /* int64 */) {
        throw new Error("Tile `repeats` input should be of int64 data type");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("Tile `repeats` input should be 1-D");
      }
      const repeats = getRepeats(inputs[1]);
      if (repeats.length !== inputs[0].dims.length) {
        throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
      }
    };
    getOutputShape2 = (inputShape, repeats) => {
      const outputShape = [];
      for (let i = 0; i < inputShape.length; ++i) {
        outputShape.push(inputShape[i] * repeats[i]);
      }
      return outputShape;
    };
    createTileProgramInfo = (inputs, shape) => {
      const inputShape = inputs[0].dims;
      const repeats = shape == null ? getRepeats(inputs[1]) : shape;
      const outputShape = getOutputShape2(inputShape, repeats);
      const outputSize = ShapeUtil.size(outputShape);
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, inputShape.length);
      const output = outputVariable("output", dataType, outputShape.length);
      const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
      return {
        name: "Tile",
        shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            ...createTensorShapeVariables(inputs[0].dims, outputShape)
          ]
        }),
        getShaderSource
      };
    };
    tile = (context) => {
      validateInputs31(context.inputs);
      context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/where.ts
var createWhereOpProgramShader, createWhereOpProgramInfo, where;
var init_where = __esm({
  "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
      const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
      const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
      const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
      let assignment;
      const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
      if (!isBroadcast) {
        assignment = output.setByOffset(
          "global_idx",
          expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
        );
      } else {
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `a_data[index_a${x}][component_a${x}]`;
          const expressionB = `b_data[index_b${x}][component_b${x}]`;
          const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
          return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createWhereOpProgramInfo = (inputs) => {
      const dimsA = inputs[1].dims;
      const dimsB = inputs[2].dims;
      const dimsC = inputs[0].dims;
      const outputDataType = inputs[1].dataType;
      const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
      let outputShape = dimsA;
      let outputSize = ShapeUtil.size(dimsA);
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
        if (!calculatedShape) {
          throw new Error("Can't perform where op on the given tensors");
        }
        outputShape = calculatedShape;
        outputSize = ShapeUtil.size(outputShape);
      }
      const vecSize = Math.ceil(outputSize / 4);
      return {
        name: "Where",
        shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
        getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* vec size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: vecSize },
            ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)
          ]
        })
      };
    };
    where = (context) => {
      context.compute(createWhereOpProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
var WEBGPU_OP_RESOLVE_RULES;
var init_op_resolve_rules = __esm({
  "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
    "use strict";
    init_argminmax();
    init_attention();
    init_batch_norm();
    init_bias_add();
    init_bias_split_gelu();
    init_binary_op();
    init_concat();
    init_conv();
    init_conv_transpose();
    init_cumsum();
    init_depth_to_space();
    init_einsum();
    init_expand();
    init_fast_gelu();
    init_gather();
    init_gather_nd();
    init_gather_block_quantized();
    init_gather_elements();
    init_gemm();
    init_grid_sample();
    init_group_query_attention();
    init_instance_norm();
    init_layer_norm();
    init_matmul();
    init_matmulnbits();
    init_multihead_attention();
    init_pad();
    init_pool();
    init_quantize_linear();
    init_range();
    init_scatter_nd();
    init_reduce();
    init_resize();
    init_rotary_embedding();
    init_skip_layer_norm();
    init_slice();
    init_softmax();
    init_split();
    init_tile();
    init_transpose();
    init_unary_op();
    init_where();
    WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
      ["Abs", [abs]],
      ["Acos", [acos]],
      ["Acosh", [acosh]],
      ["Add", [add]],
      ["ArgMax", [argMax, parseArgMinMaxAttributes]],
      ["ArgMin", [argMin, parseArgMinMaxAttributes]],
      ["Asin", [asin]],
      ["Asinh", [asinh]],
      ["Atan", [atan]],
      ["Atanh", [atanh]],
      ["Attention", [attention]],
      // TODO: support new attributes for AveragePool-10
      ["AveragePool", [averagePool, parseAveragePoolAttributes]],
      ["BatchNormalization", [batchNorm]],
      ["BiasAdd", [biasAdd]],
      ["BiasSplitGelu", [biasSplitGelu]],
      ["Cast", [cast, parseCastAttributes]],
      ["Ceil", [ceil]],
      ["Clip", [clip]],
      ["Concat", [concat, parseConcatAttributes]],
      ["Conv", [conv, parseConvAttributes]],
      ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
      ["Cos", [cos]],
      ["Cosh", [cosh]],
      ["CumSum", [cumsum, parseCumSumAttributes]],
      ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
      ["DequantizeLinear", [dequantizeLinear, parseDequantizeLinearAttributes]],
      ["Div", [div]],
      ["Einsum", [einsum, parseEinsumAttributes]],
      ["Elu", [elu, parseAlphaAttributes]],
      ["Equal", [equal]],
      ["Erf", [erf]],
      ["Exp", [exp]],
      ["Expand", [expand]],
      ["FastGelu", [fastGelu2]],
      ["Floor", [floor]],
      ["FusedConv", [conv, parseConvAttributes]],
      ["Gather", [gather, parseGatherAttributes]],
      ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
      ["GatherBlockQuantized", [gatherBlockQuantized, parseGatherBlockQuantizedAttributes]],
      ["GatherND", [gatherND, parseGatherNDAttributes]],
      ["Gelu", [gelu]],
      ["Gemm", [gemm, parseGemmAttributes]],
      ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
      ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
      ["Greater", [greater]],
      ["GreaterOrEqual", [greaterOrEqual]],
      ["GridSample", [gridSample, parseGridSampleAttributes]],
      ["GroupQueryAttention", [groupQueryAttention]],
      ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
      ["InstanceNormalization", [instanceNorm]],
      ["LayerNormalization", [layerNorm]],
      ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
      ["Less", [less]],
      ["LessOrEqual", [lessOrEqual]],
      ["Log", [log]],
      ["MatMul", [matMul]],
      ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
      // TODO: support new attributes for MaxPool-8 and MaxPool-10
      ["MaxPool", [maxPool, parseMaxPoolAttributes]],
      ["Mul", [mul]],
      ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
      ["Neg", [neg]],
      ["Not", [not]],
      ["Pad", [pad]],
      ["Pow", [pow]],
      ["QuickGelu", [quickgelu, parseAlphaAttributes]],
      ["Range", [range]],
      ["Reciprocal", [reciprocal]],
      ["ReduceMin", [reduceMin]],
      ["ReduceMean", [reduceMean]],
      ["ReduceMax", [reduceMax]],
      ["ReduceSum", [reduceSum]],
      ["ReduceProd", [reduceProd]],
      ["ReduceL1", [reduceL1]],
      ["ReduceL2", [reduceL2]],
      ["ReduceLogSum", [reduceLogSum]],
      ["ReduceLogSumExp", [reduceLogSumExp]],
      ["ReduceSumSquare", [reduceSumSquare]],
      ["Relu", [relu]],
      ["Resize", [resize, parseResizeAttributes]],
      ["RotaryEmbedding", [rotaryEmbedding]],
      ["ScatterND", [scatterND, parseScatterNDAttributes]],
      ["Sigmoid", [sigmoid]],
      ["Sin", [sin]],
      ["Sinh", [sinh]],
      ["Slice", [slice, parseSliceAttributes]],
      ["SkipLayerNormalization", [skipLayerNorm]],
      ["Split", [split, parseSplitAttributes]],
      ["Sqrt", [sqrt]],
      ["Softmax", [softmax, parseSoftmaxAttributes]],
      ["Sub", [sub]],
      ["Tan", [tan]],
      ["Tanh", [tanh]],
      ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
      ["Tile", [tile]],
      ["Transpose", [transpose, parseTransposeAttributes]],
      ["Where", [where]]
    ]);
  }
});

// web/lib/wasm/jsep/webgpu/program-manager.ts
var ProgramManager;
var init_program_manager = __esm({
  "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
    "use strict";
    init_esm();
    init_log();
    init_common();
    ProgramManager = class {
      constructor(backend) {
        this.backend = backend;
        this.repo = /* @__PURE__ */ new Map();
        this.attributesBound = false;
      }
      getArtifact(key) {
        return this.repo.get(key);
      }
      setArtifact(key, artifact) {
        this.repo.set(key, artifact);
      }
      run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
        TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
        const device = this.backend.device;
        const computePassEncoder = this.backend.getComputePassEncoder();
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
        const entries = [];
        for (const input of inputs) {
          entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
        }
        for (const output of outputs) {
          entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
        }
        if (uniformBufferBinding) {
          entries.push({ binding: entries.length, resource: uniformBufferBinding });
        }
        const bindGroup = device.createBindGroup({
          layout: buildArtifact.computePipeline.getBindGroupLayout(0),
          entries,
          label: buildArtifact.programInfo.name
        });
        if (this.backend.sessionStatus === "capturing") {
          const commandInfo = {
            kernelId: this.backend.currentKernelId,
            computePipeline: buildArtifact.computePipeline,
            bindGroup,
            dispatchGroup
          };
          const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
          sessionCommandList.push(commandInfo);
        }
        computePassEncoder.setPipeline(buildArtifact.computePipeline);
        computePassEncoder.setBindGroup(0, bindGroup);
        computePassEncoder.dispatchWorkgroups(...dispatchGroup);
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
        this.backend.pendingDispatchNumber++;
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
          this.backend.endComputePass();
        }
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
          this.backend.flush();
        }
        TRACE_FUNC_END(buildArtifact.programInfo.name);
      }
      dispose() {
      }
      build(programInfo, normalizedDispatchGroupSize) {
        TRACE_FUNC_BEGIN(programInfo.name);
        const device = this.backend.device;
        const enableDirectives = [];
        const extensionsInfo = [
          { feature: "shader-f16", extension: "f16" },
          { feature: "subgroups", extension: "subgroups" }
        ];
        extensionsInfo.forEach((info) => {
          if (device.features.has(info.feature)) {
            enableDirectives.push(`enable ${info.extension};`);
          }
        });
        const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
        const userCode = programInfo.getShaderSource(shaderHelper);
        const code = `${enableDirectives.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
        const shaderModule = device.createShaderModule({ code, label: programInfo.name });
        LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
        const computePipeline = device.createComputePipeline({
          compute: { module: shaderModule, entryPoint: "main" },
          layout: "auto",
          label: programInfo.name
        });
        TRACE_FUNC_END(programInfo.name);
        return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
      }
      normalizeDispatchGroupSize(dispatchGroup) {
        const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
        const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
        const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
        const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
        if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
          return [x, y, z];
        }
        const size = x * y * z;
        let dispatchAverage = Math.ceil(Math.sqrt(size));
        if (dispatchAverage > limitPerDimension) {
          dispatchAverage = Math.ceil(Math.cbrt(size));
          if (dispatchAverage > limitPerDimension) {
            throw new Error("Total dispatch size exceeds WebGPU maximum.");
          }
          return [dispatchAverage, dispatchAverage, dispatchAverage];
        } else {
          return [dispatchAverage, dispatchAverage, 1];
        }
      }
    };
  }
});

// web/lib/wasm/jsep/backend-webgpu.ts
var backend_webgpu_exports = {};
__export(backend_webgpu_exports, {
  WebGpuBackend: () => WebGpuBackend
});
var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
var init_backend_webgpu = __esm({
  "web/lib/wasm/jsep/backend-webgpu.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_log();
    init_tensor_view();
    init_gpu_data_manager();
    init_op_resolve_rules();
    init_program_manager();
    getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
      if (inputDependencies.length !== inputTensors.length) {
        throw new Error(
          `inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`
        );
      }
      const inputInfos = [];
      for (let i = 0; i < inputTensors.length; ++i) {
        const type = inputTensors[i].dataType;
        switch (inputDependencies[i]) {
          case "none": {
            inputInfos.push("");
            break;
          }
          case "type": {
            inputInfos.push(`${type}`);
            break;
          }
          case "rank": {
            const rank = inputTensors[i].dims.length;
            inputInfos.push(`${type};${rank}`);
            break;
          }
          case "dims": {
            const dims = inputTensors[i].dims.join(",");
            inputInfos.push(`${type};${dims}`);
            break;
          }
          default:
            throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
        }
      }
      return inputInfos.join("|");
    };
    getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
      let key = programInfo.name;
      if (programInfo.shaderCache?.hint) {
        key += "[" + programInfo.shaderCache.hint + "]";
      }
      key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
        inputTensors,
        programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
      )}`;
      return key;
    };
    AdapterInfoImpl = class {
      constructor(adapterInfo) {
        if (adapterInfo) {
          this.architecture = adapterInfo.architecture;
          this.vendor = adapterInfo.vendor;
        }
      }
      isArchitecture(architecture) {
        return this.architecture === architecture;
      }
      isVendor(vendor) {
        return this.vendor === vendor;
      }
    };
    WebGpuBackend = class {
      constructor() {
        /**
         * representing the session ID of which is currently being run.
         * `null` means no session is being run.
         * only valid when session.run is executed.
         */
        this.currentSessionId = null;
        /**
         * representing the kernel ID of which is currently being computed (CPU code perspective).
         * `null` means no kernel is being computed.
         * only one kernel can be computed at a moment.
         */
        this.currentKernelId = null;
        this.commandEncoder = null;
        this.computePassEncoder = null;
        this.maxDispatchNumber = 16;
        this.pendingDispatchNumber = 0;
        // info of kernels pending submission for a single batch
        this.pendingKernels = [];
        // queryReadBuffer -> pendingKernels mapping for all the batches
        this.pendingQueries = /* @__PURE__ */ new Map();
        this.sessionStatus = "default";
        /**
         * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
         */
        this.capturedCommandList = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> PendingKernelInfo[] mapping for profiling.
         */
        this.capturedPendingKernels = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
         */
        this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
      }
      /**
       * get the custom data of the current kernel
       */
      get currentKernelCustomData() {
        if (this.currentKernelId === null) {
          throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
        }
        let data = this.kernelCustomData.get(this.currentKernelId);
        if (!data) {
          data = {};
          this.kernelCustomData.set(this.currentKernelId, data);
        }
        return data;
      }
      async initialize(env3, adapter) {
        this.env = env3;
        const requiredFeatures = [];
        const deviceDescriptor = {
          requiredLimits: {
            maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
            maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
            maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
            maxBufferSize: adapter.limits.maxBufferSize,
            maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
          },
          requiredFeatures
        };
        const requireFeatureIfAvailable = (feature) => adapter.features.has(feature) && requiredFeatures.push(feature) && true;
        if (!requireFeatureIfAvailable("chromium-experimental-timestamp-query-inside-passes")) {
          requireFeatureIfAvailable("timestamp-query");
        }
        requireFeatureIfAvailable("shader-f16");
        requireFeatureIfAvailable("subgroups");
        this.device = await adapter.requestDevice(deviceDescriptor);
        this.adapterInfo = new AdapterInfoImpl(adapter.info || await adapter.requestAdapterInfo());
        this.gpuDataManager = createGpuDataManager(this);
        this.programManager = new ProgramManager(this);
        this.kernels = /* @__PURE__ */ new Map();
        this.kernelPersistentData = /* @__PURE__ */ new Map();
        this.kernelCustomData = /* @__PURE__ */ new Map();
        configureLogger(env3.logLevel, !!env3.debug);
        this.device.onuncapturederror = (ev) => {
          if (ev.error instanceof GPUValidationError) {
            console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
          }
        };
        Object.defineProperty(this.env.webgpu, "device", {
          value: this.device,
          writable: false,
          enumerable: true,
          configurable: false
        });
        Object.defineProperty(this.env.webgpu, "adapter", {
          value: adapter,
          writable: false,
          enumerable: true,
          configurable: false
        });
        this.setQueryType();
      }
      dispose() {
        if (typeof this.querySet !== "undefined") {
          this.querySet.destroy();
        }
        this.gpuDataManager.dispose();
      }
      getCommandEncoder() {
        if (!this.commandEncoder) {
          this.commandEncoder = this.device.createCommandEncoder();
        }
        return this.commandEncoder;
      }
      getComputePassEncoder() {
        if (!this.computePassEncoder) {
          const commandEncoder = this.getCommandEncoder();
          const computePassDescriptor = {};
          if (this.queryType === "at-passes") {
            computePassDescriptor.timestampWrites = {
              querySet: this.querySet,
              beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
              endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
            };
          }
          this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
        }
        return this.computePassEncoder;
      }
      endComputePass() {
        if (this.computePassEncoder) {
          this.computePassEncoder.end();
          this.computePassEncoder = null;
        }
      }
      flush() {
        if (!this.commandEncoder) {
          return;
        }
        TRACE_FUNC_BEGIN();
        this.endComputePass();
        let queryReadBuffer;
        if (this.queryType !== "none") {
          this.commandEncoder.resolveQuerySet(
            this.querySet,
            0,
            this.pendingDispatchNumber * 2,
            this.queryResolveBuffer,
            0
          );
          queryReadBuffer = this.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
          );
          this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
          this.pendingKernels = [];
          this.commandEncoder.copyBufferToBuffer(
            this.queryResolveBuffer,
            0,
            queryReadBuffer,
            0,
            this.pendingDispatchNumber * 2 * 8
          );
        }
        this.device.queue.submit([this.commandEncoder.finish()]);
        this.gpuDataManager.refreshPendingBuffers();
        this.commandEncoder = null;
        this.pendingDispatchNumber = 0;
        if (this.queryType !== "none") {
          void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
            const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
            const pendingKernels = this.pendingQueries.get(queryReadBuffer);
            for (let i = 0; i < mappedData.length / 2; i++) {
              const pendingKernelInfo = pendingKernels[i];
              const kernelId = pendingKernelInfo.kernelId;
              const kernelInfo = this.kernels.get(kernelId);
              const kernelType = kernelInfo.kernelType;
              const kernelName = kernelInfo.kernelName;
              const programName = pendingKernelInfo.programName;
              const inputTensorViews = pendingKernelInfo.inputTensorViews;
              const outputTensorViews = pendingKernelInfo.outputTensorViews;
              const startTimeU64 = mappedData[i * 2];
              const endTimeU64 = mappedData[i * 2 + 1];
              if (typeof this.queryTimeBase === "undefined") {
                this.queryTimeBase = startTimeU64;
              }
              const startTime = Number(startTimeU64 - this.queryTimeBase);
              const endTime = Number(endTimeU64 - this.queryTimeBase);
              if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                throw new RangeError("incorrect timestamp range");
              }
              if (this.env.webgpu.profiling?.ondata) {
                this.env.webgpu.profiling.ondata({
                  version: 1,
                  inputsMetadata: inputTensorViews.map((value) => ({
                    dims: value.dims,
                    dataType: tensorDataTypeEnumToString(value.dataType)
                  })),
                  outputsMetadata: outputTensorViews.map((value) => ({
                    dims: value.dims,
                    dataType: tensorDataTypeEnumToString(value.dataType)
                  })),
                  kernelId,
                  kernelType,
                  kernelName,
                  programName,
                  startTime,
                  endTime
                });
              } else {
                let inputShapes = "";
                inputTensorViews.forEach((value, i2) => {
                  inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                let outputShapes = "";
                outputTensorViews.forEach((value, i2) => {
                  outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                console.log(
                  `[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}start time: ${startTime} ns, execution time: ${endTime - startTime} ns`
                );
              }
              TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
            }
            queryReadBuffer.unmap();
            this.pendingQueries.delete(queryReadBuffer);
          });
        }
        TRACE_FUNC_END();
      }
      /**
       * run a WebGPU program.
       * @param program a ProgramInfo instance
       * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
       * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
       * index to the kernel's output.
       * @param createKernelOutput a callback function that create a value to kernel's output with the given index
       * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
       * or persistent (owned by the current kernel)
       * @returns a TensorView array representing the result.
       */
      run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
        TRACE_FUNC_BEGIN(program.name);
        const inputDatas = [];
        for (let i = 0; i < inputTensorViews.length; ++i) {
          const data = inputTensorViews[i].data;
          if (data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(data);
          if (!gpuData) {
            throw new Error(`no GPU data for input: ${data}`);
          }
          inputDatas.push(gpuData);
        }
        const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
        const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
        if (validatedOutputIndices.length !== outputs.length) {
          throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
        }
        const outputTensorViews = [];
        const outputDatas = [];
        for (let i = 0; i < outputs.length; ++i) {
          if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
            throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
          }
          if (validatedOutputIndices[i] === -3) {
            continue;
          }
          const isTemporary = validatedOutputIndices[i] === -1;
          const isPersistent = validatedOutputIndices[i] === -2;
          const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
          outputTensorViews.push(tensorView);
          if (tensorView.data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(tensorView.data);
          if (!gpuData) {
            throw new Error(`no GPU data for output: ${tensorView.data}`);
          }
          if (isTemporary) {
            this.temporaryData.push(gpuData);
          }
          if (isPersistent) {
            let persistentData = this.kernelPersistentData.get(this.currentKernelId);
            if (!persistentData) {
              persistentData = [];
              this.kernelPersistentData.set(this.currentKernelId, persistentData);
            }
            persistentData.push(gpuData);
          }
          outputDatas.push(gpuData);
        }
        if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
          if (outputDatas.length === 0) {
            TRACE_FUNC_END(program.name);
            return outputTensorViews;
          }
          throw new Error(
            `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
          );
        }
        let uniformBufferBinding;
        if (programUniforms) {
          let currentOffset = 0;
          const offsets = [];
          programUniforms.forEach((v) => {
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (data.length === 0) {
              return;
            }
            const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
            let sizeOfVecOrMat;
            let baseAlignment;
            if (v.type === 10 /* float16 */) {
              baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
              sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
            } else {
              baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
              sizeOfVecOrMat = 16;
            }
            currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
            offsets.push(currentOffset);
            const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
            currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
          });
          const maxAlignmentOfField = 16;
          currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
          const arrayBuffer = new ArrayBuffer(currentOffset);
          programUniforms.forEach((v, i) => {
            const offset = offsets[i];
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (v.type === 6 /* int32 */) {
              new Int32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 12 /* uint32 */) {
              new Uint32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 10 /* float16 */) {
              new Uint16Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 1 /* float */) {
              new Float32Array(arrayBuffer, offset, data.length).set(data);
            } else {
              throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
            }
          });
          const uniformBufferData = (
            // eslint-disable-next-line no-bitwise
            this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
          );
          this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
          this.gpuDataManager.release(uniformBufferData.id);
          uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
        }
        const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
        const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
        const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
        let artifact = this.programManager.getArtifact(key);
        if (!artifact) {
          artifact = this.programManager.build(program, normalizedDispatchGroup);
          this.programManager.setArtifact(key, artifact);
          LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
        }
        if (programUniforms && artifact.uniformVariablesInfo) {
          if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
            throw new Error(
              `Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`
            );
          }
          for (let i = 0; i < programUniforms.length; i++) {
            const uniform = programUniforms[i];
            const actualType = uniform.type;
            const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
            const [type, length] = artifact.uniformVariablesInfo[i];
            if (actualType !== type || actualLength !== length) {
              throw new Error(
                `Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`
              );
            }
          }
        }
        LOG_DEBUG(
          "info",
          () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
        );
        if (this.queryType !== "none" || this.sessionStatus === "capturing") {
          const pendingKernelInfo = {
            kernelId: this.currentKernelId,
            programName: artifact.programInfo.name,
            inputTensorViews,
            outputTensorViews
          };
          this.pendingKernels.push(pendingKernelInfo);
          if (this.sessionStatus === "capturing") {
            const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
            sessionPendingKernels.push(pendingKernelInfo);
          }
        }
        this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
        TRACE_FUNC_END(program.name);
        return outputTensorViews;
      }
      upload(gpuDataId, data) {
        this.gpuDataManager.upload(gpuDataId, data);
      }
      memcpy(src, dst) {
        this.gpuDataManager.memcpy(src, dst);
      }
      async download(gpuDataId, getTargetBuffer) {
        await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
      }
      alloc(size) {
        return this.gpuDataManager.create(size).id;
      }
      free(ptr) {
        return this.gpuDataManager.release(ptr);
      }
      createKernel(kernelType, kernelId, attribute, kernelName) {
        const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
        if (!op) {
          throw new Error(`kernel not implemented: ${kernelType}`);
        }
        const kernelInfo = {
          kernelType,
          kernelName,
          kernelEntry: op[0],
          attributes: [op[1], attribute]
        };
        this.kernels.set(kernelId, kernelInfo);
      }
      releaseKernel(kernelId) {
        const persistentData = this.kernelPersistentData.get(kernelId);
        if (persistentData) {
          for (const data of persistentData) {
            this.gpuDataManager.release(data.id);
          }
          this.kernelPersistentData.delete(kernelId);
        }
        this.kernelCustomData.delete(kernelId);
        this.kernels.delete(kernelId);
      }
      computeKernel(kernelId, context, errors) {
        const kernel = this.kernels.get(kernelId);
        if (!kernel) {
          throw new Error(`kernel not created: ${kernelId}`);
        }
        const kernelType = kernel.kernelType;
        const kernelName = kernel.kernelName;
        const kernelEntry = kernel.kernelEntry;
        const attributes = kernel.attributes;
        if (this.currentKernelId !== null) {
          throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
        }
        this.currentKernelId = kernelId;
        if (attributes[0]) {
          attributes[1] = attributes[0](attributes[1]);
          attributes[0] = void 0;
        }
        LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
        const useErrorScope = this.env.debug;
        this.temporaryData = [];
        try {
          if (useErrorScope) {
            this.device.pushErrorScope("validation");
          }
          kernelEntry(context, attributes[1]);
          return 0;
        } catch (e) {
          errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
          return 1;
        } finally {
          if (useErrorScope) {
            errors.push(
              this.device.popErrorScope().then(
                (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
              )
            );
          }
          for (const data of this.temporaryData) {
            this.gpuDataManager.release(data.id);
          }
          this.temporaryData = [];
          this.currentKernelId = null;
        }
      }
      // #region external buffer
      registerBuffer(sessionId, index, buffer, size) {
        let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (!sessionInputOutputMapping) {
          sessionInputOutputMapping = /* @__PURE__ */ new Map();
          this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
        }
        const previousBuffer = sessionInputOutputMapping.get(index);
        const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer);
        sessionInputOutputMapping.set(index, [id, buffer]);
        return id;
      }
      unregisterBuffers(sessionId) {
        const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (sessionInputOutputMapping) {
          sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[0]));
          this.sessionExternalDataMapping.delete(sessionId);
        }
      }
      getBuffer(gpuDataId) {
        const gpuData = this.gpuDataManager.get(gpuDataId);
        if (!gpuData) {
          throw new Error(`no GPU data for buffer: ${gpuDataId}`);
        }
        return gpuData.buffer;
      }
      createDownloader(gpuBuffer, size, type) {
        return async () => {
          const data = await downloadGpuData(this, gpuBuffer, size);
          return createView(data.buffer, type);
        };
      }
      // #endregion
      writeTimestamp(index) {
        if (this.queryType !== "inside-passes") {
          return;
        }
        this.computePassEncoder.writeTimestamp(this.querySet, index);
      }
      setQueryType() {
        this.queryType = "none";
        if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
          if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
            this.queryType = "inside-passes";
          } else if (this.device.features.has("timestamp-query")) {
            this.queryType = "at-passes";
          }
          if (this.queryType !== "none" && typeof this.querySet === "undefined") {
            this.querySet = this.device.createQuerySet({
              type: "timestamp",
              count: this.maxDispatchNumber * 2
            });
            this.queryResolveBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
            );
          }
        }
      }
      captureBegin() {
        LOG_DEBUG("info", "captureBegin");
        if (!this.capturedCommandList.get(this.currentSessionId)) {
          this.capturedCommandList.set(this.currentSessionId, []);
        }
        if (!this.capturedPendingKernels.get(this.currentSessionId)) {
          this.capturedPendingKernels.set(this.currentSessionId, []);
        }
        this.flush();
        this.sessionStatus = "capturing";
      }
      captureEnd() {
        LOG_DEBUG("info", "captureEnd");
        this.flush();
        this.sessionStatus = "default";
      }
      replay() {
        LOG_DEBUG("info", "replay");
        this.sessionStatus = "replaying";
        const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
        const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
        const length = sessionCommandList.length;
        this.pendingKernels = [];
        for (let i = 0; i < length; i++) {
          const computePassEncoder = this.getComputePassEncoder();
          const command = sessionCommandList[i];
          this.writeTimestamp(this.pendingDispatchNumber * 2);
          computePassEncoder.setPipeline(command.computePipeline);
          computePassEncoder.setBindGroup(0, command.bindGroup);
          computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
          this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
          this.pendingDispatchNumber++;
          if (this.queryType !== "none") {
            this.pendingKernels.push(sessionPendingKernels[i]);
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
            this.endComputePass();
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
            this.flush();
          }
        }
        this.flush();
        this.sessionStatus = "default";
      }
      onCreateSession() {
        this.gpuDataManager.onCreateSession();
      }
      onReleaseSession(sessionId) {
        this.unregisterBuffers(sessionId);
        if (this.capturedCommandList.has(sessionId)) {
          this.capturedCommandList.delete(sessionId);
        }
        if (this.capturedPendingKernels.has(sessionId)) {
          this.capturedPendingKernels.delete(sessionId);
        }
        this.gpuDataManager.onReleaseSession(sessionId);
      }
      onRunStart(sessionId) {
        this.currentSessionId = sessionId;
        this.setQueryType();
      }
    };
  }
});

// web/lib/wasm/jsep/init.ts
var init_exports = {};
__export(init_exports, {
  init: () => init
});
var TensorViewImpl, ComputeContextImpl, init;
var init_init = __esm({
  "web/lib/wasm/jsep/init.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_backend_webnn();
    TensorViewImpl = class _TensorViewImpl {
      constructor(module, dataType, data, dims) {
        this.module = module;
        this.dataType = dataType;
        this.data = data;
        this.dims = dims;
      }
      getFloat32Array() {
        if (this.dataType !== 1 /* float */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getBigInt64Array() {
        if (this.dataType !== 7 /* int64 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getInt32Array() {
        if (this.dataType !== 6 /* int32 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getUint16Array() {
        if (this.dataType !== 10 /* float16 */ && this.dataType !== 4 /* uint16 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Uint16Array() : new Uint16Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      reshape(newDims) {
        if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
          throw new Error("Invalid new shape");
        }
        return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
      }
    };
    ComputeContextImpl = class {
      constructor(module, backend, contextDataOffset) {
        this.module = module;
        this.backend = backend;
        this.customDataOffset = 0;
        this.customDataSize = 0;
        this.adapterInfo = backend.adapterInfo;
        const ptrSize = module.PTR_SIZE;
        let dataIndex = contextDataOffset / module.PTR_SIZE;
        const type = ptrSize === 4 ? "i32" : "i64";
        this.opKernelContext = Number(module.getValue(ptrSize * dataIndex++, type));
        const inputCount = Number(module.getValue(ptrSize * dataIndex++, type));
        this.outputCount = Number(module.getValue(ptrSize * dataIndex++, type));
        this.customDataOffset = Number(module.getValue(ptrSize * dataIndex++, "*"));
        this.customDataSize = Number(module.getValue(ptrSize * dataIndex++, type));
        const inputs = [];
        for (let i = 0; i < inputCount; i++) {
          const dataType = Number(module.getValue(ptrSize * dataIndex++, type));
          const data = Number(module.getValue(ptrSize * dataIndex++, "*"));
          const dim = Number(module.getValue(ptrSize * dataIndex++, type));
          const dims = [];
          for (let d = 0; d < dim; d++) {
            dims.push(Number(module.getValue(ptrSize * dataIndex++, type)));
          }
          inputs.push(new TensorViewImpl(module, dataType, data, dims));
        }
        this.inputs = inputs;
      }
      get kernelCustomData() {
        return this.backend.currentKernelCustomData;
      }
      get customDataBuffer() {
        return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
      }
      compute(program, inputsOutputsMapping) {
        const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
        const outputIndices = inputsOutputsMapping?.outputs ?? [];
        const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
        const createTemporaryOutput = (dataType, dims) => {
          const bufferSize = calculateTensorSizeInBytes(dataType, dims);
          if (!bufferSize) {
            throw new Error(`Unsupported data type: ${dataType}`);
          }
          const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
          return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
        };
        return this.backend.run(
          program,
          mappedInputs,
          outputIndices,
          createKernelOutput,
          createTemporaryOutput,
          this.outputCount
        );
      }
      output(index, dims) {
        const stack = this.module.stackSave();
        try {
          const ptrSize = this.module.PTR_SIZE;
          const type = ptrSize === 4 ? "i32" : "i64";
          const data = this.module.stackAlloc(
            (1 + dims.length) * ptrSize
            /* sizeof(size_t) */
          );
          this.module.setValue(data, dims.length, type);
          for (let i = 0; i < dims.length; i++) {
            this.module.setValue(data + ptrSize * (i + 1), dims[i], type);
          }
          return this.module._JsepOutput(this.opKernelContext, index, data);
        } catch (e) {
          throw new Error(
            `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
          );
        } finally {
          this.module.stackRestore(stack);
        }
      }
    };
    init = async (name, module, env3, gpuAdapter) => {
      const jsepInit = module.jsepInit;
      if (!jsepInit) {
        throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
      }
      if (name === "webgpu") {
        const webGpuBackendImpl = (init_backend_webgpu(), __toCommonJS(backend_webgpu_exports)).WebGpuBackend;
        const backend = new webGpuBackendImpl();
        await backend.initialize(env3, gpuAdapter);
        jsepInit("webgpu", [
          // backend
          backend,
          // jsepAlloc()
          (size) => backend.alloc(Number(size)),
          // jsepFree()
          (ptr) => backend.free(ptr),
          // jsepCopy(src, dst, size, isSourceGpu)
          (src, dst, size, isSourceGpu = false) => {
            if (isSourceGpu) {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyGpuToGpu: src=${Number(src)}, dst=${Number(dst)}, size=${Number(size)}`
              );
              backend.memcpy(Number(src), Number(dst));
            } else {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(src)}, gpuDataId=${Number(dst)}, size=${Number(size)}`
              );
              const data = module.HEAPU8.subarray(Number(src >>> 0), Number(src >>> 0) + Number(size));
              backend.upload(Number(dst), data);
            }
          },
          // jsepCopyAsync(src, dst, size)
          async (gpuDataId, dataOffset, size) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
            );
            await backend.download(
              Number(gpuDataId),
              () => module.HEAPU8.subarray(Number(dataOffset) >>> 0, Number(dataOffset + size) >>> 0)
            );
          },
          // jsepCreateKernel
          (kernelType, kernelId, attribute) => backend.createKernel(
            kernelType,
            Number(kernelId),
            attribute,
            module.UTF8ToString(module._JsepGetNodeName(Number(kernelId)))
          ),
          // jsepReleaseKernel
          (kernel) => backend.releaseKernel(kernel),
          // jsepRun
          (kernel, contextDataOffset, sessionHandle, errors) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
            );
            const context = new ComputeContextImpl(module, backend, Number(contextDataOffset));
            return backend.computeKernel(Number(kernel), context, errors);
          },
          // jsepCaptureBegin
          () => backend.captureBegin(),
          // jsepCaptureEnd
          () => backend.captureEnd(),
          // jsepReplay
          () => backend.replay()
        ]);
      } else {
        const backend = new WebNNBackend(env3);
        jsepInit("webnn", [
          backend,
          // webnnReserveTensorId
          () => backend.reserveTensorId(),
          // webnnReleaseTensorId
          (tensorId) => backend.releaseTensorId(tensorId),
          // webnnEnsureTensor
          async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
          // webnnUploadTensor
          (tensorId, data) => {
            backend.uploadTensor(tensorId, data);
          },
          // webnnDownloadTensor
          async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
          // webnnRegisterMLContext
          (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
          // webnnEnableTraceEvent
          !!env3.trace
        ]);
      }
    };
  }
});

// web/lib/wasm/wasm-core-impl.ts
var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, getSessionInputOutputMetadata, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
var init_wasm_core_impl = __esm({
  "web/lib/wasm/wasm-core-impl.ts"() {
    "use strict";
    init_esm();
    init_run_options();
    init_session_options();
    init_wasm_common();
    init_wasm_factory();
    init_wasm_utils();
    init_wasm_utils_load_file();
    initOrt = (numThreads, loggingLevel) => {
      const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
      if (errorCode !== 0) {
        checkLastError("Can't initialize onnxruntime.");
      }
    };
    initRuntime = async (env3) => {
      initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
    };
    initEp = async (env3, epName) => {
      getInstance().asyncInit?.();
      let webgpuAdapter = env3.webgpu.adapter;
      if (epName === "webgpu") {
        if (typeof navigator === "undefined" || !navigator.gpu) {
          throw new Error("WebGPU is not supported in current environment");
        }
        if (!webgpuAdapter) {
          const powerPreference = env3.webgpu.powerPreference;
          if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
            throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
          }
          const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
          if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
            throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
          }
          webgpuAdapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
          if (!webgpuAdapter) {
            throw new Error(
              'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
            );
          }
        } else {
          if (typeof webgpuAdapter.limits !== "object" || typeof webgpuAdapter.features !== "object" || typeof webgpuAdapter.requestDevice !== "function") {
            throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
          }
        }
      }
      if (epName === "webnn") {
        if (typeof navigator === "undefined" || !navigator.ml) {
          throw new Error("WebNN is not supported in current environment");
        }
      }
      if (true) {
        const initJsep = (init_init(), __toCommonJS(init_exports)).init;
        if (epName === "webgpu") {
          await initJsep("webgpu", getInstance(), env3, webgpuAdapter);
        }
        if (epName === "webnn") {
          await initJsep("webnn", getInstance(), env3);
        }
      } else {
        if (false) {
          getInstance().webgpuInit((device) => {
            env3.webgpu.device = device;
          });
        }
        if (epName === "webnn") {
          const backend = new null.WebNNBackend(env3);
          getInstance().webnnInit([
            backend,
            // webnnReserveTensorId
            () => backend.reserveTensorId(),
            // webnnReleaseTensorId,
            (tensorId) => backend.releaseTensorId(tensorId),
            // webnnEnsureTensor
            async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
            // webnnUploadTensor
            (tensorId, data) => {
              backend.uploadTensor(tensorId, data);
            },
            // webnnDownloadTensor
            async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
            // webnnRegisterMLContext
            (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
            // webnnEnableTraceEvent
            !!env3.trace
          ]);
        }
      }
    };
    activeSessions = /* @__PURE__ */ new Map();
    getSessionInputOutputCount = (sessionHandle) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const ptrSize = wasm2.PTR_SIZE;
        const dataOffset = wasm2.stackAlloc(2 * ptrSize);
        const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + ptrSize);
        if (errorCode !== 0) {
          checkLastError("Can't get session input/output count.");
        }
        const type = ptrSize === 4 ? "i32" : "i64";
        return [Number(wasm2.getValue(dataOffset, type)), Number(wasm2.getValue(dataOffset + ptrSize, type))];
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    getSessionInputOutputMetadata = (sessionHandle, index) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      let metadataOffset = 0;
      try {
        const ptrSize = wasm2.PTR_SIZE;
        const dataOffset = wasm2.stackAlloc(2 * ptrSize);
        const errorCode = wasm2._OrtGetInputOutputMetadata(sessionHandle, index, dataOffset, dataOffset + ptrSize);
        if (errorCode !== 0) {
          checkLastError("Can't get session input/output metadata.");
        }
        const nameOffset = Number(wasm2.getValue(dataOffset, "*"));
        metadataOffset = Number(wasm2.getValue(dataOffset + ptrSize, "*"));
        const elementType = wasm2.HEAP32[metadataOffset / 4];
        if (elementType === 0) {
          return [nameOffset, 0];
        }
        const dimsCount = wasm2.HEAPU32[metadataOffset / 4 + 1];
        const dims = [];
        for (let i = 0; i < dimsCount; i++) {
          const symbolicDimNameOffset = Number(wasm2.getValue(metadataOffset + 8 + i * ptrSize, "*"));
          dims.push(
            symbolicDimNameOffset !== 0 ? wasm2.UTF8ToString(symbolicDimNameOffset) : Number(wasm2.getValue(metadataOffset + 8 + (i + dimsCount) * ptrSize, "*"))
          );
        }
        return [nameOffset, elementType, dims];
      } finally {
        wasm2.stackRestore(stack);
        if (metadataOffset !== 0) {
          wasm2._OrtFree(metadataOffset);
        }
      }
    };
    copyFromExternalBuffer = (model) => {
      const wasm2 = getInstance();
      const modelDataOffset = wasm2._malloc(model.byteLength);
      if (modelDataOffset === 0) {
        throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
      }
      wasm2.HEAPU8.set(model, modelDataOffset);
      return [modelDataOffset, model.byteLength];
    };
    createSession = async (modelData, options) => {
      let modelDataOffset, modelDataLength;
      const wasm2 = getInstance();
      if (Array.isArray(modelData)) {
        [modelDataOffset, modelDataLength] = modelData;
      } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
        [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
      } else {
        [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
      }
      let sessionHandle = 0;
      let sessionOptionsHandle = 0;
      let ioBindingHandle = 0;
      let allocs = [];
      const inputNamesUTF8Encoded = [];
      const outputNamesUTF8Encoded = [];
      try {
        [sessionOptionsHandle, allocs] = await setSessionOptions(options);
        if (options?.externalData && wasm2.mountExternalData) {
          const loadingPromises = [];
          for (const file of options.externalData) {
            const path = typeof file === "string" ? file : file.path;
            loadingPromises.push(
              loadFile(typeof file === "string" ? file : file.data).then((data) => {
                wasm2.mountExternalData(path, data);
              })
            );
          }
          await Promise.all(loadingPromises);
        }
        for (const provider of options?.executionProviders ?? []) {
          const providerName = typeof provider === "string" ? provider : provider.name;
          if (providerName === "webnn") {
            wasm2.shouldTransferToMLTensor = false;
            if (typeof provider !== "string") {
              const webnnOptions = provider;
              const context = webnnOptions?.context;
              const gpuDevice = webnnOptions?.gpuDevice;
              const deviceType = webnnOptions?.deviceType;
              const powerPreference = webnnOptions?.powerPreference;
              if (context) {
                wasm2.currentContext = context;
              } else if (gpuDevice) {
                wasm2.currentContext = await wasm2.webnnCreateMLContext(gpuDevice);
              } else {
                wasm2.currentContext = await wasm2.webnnCreateMLContext({ deviceType, powerPreference });
              }
            } else {
              wasm2.currentContext = await wasm2.webnnCreateMLContext();
            }
            break;
          }
        }
        sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
        wasm2.webgpuOnCreateSession?.(sessionHandle);
        if (sessionHandle === 0) {
          checkLastError("Can't create a session.");
        }
        wasm2.jsepOnCreateSession?.();
        if (wasm2.currentContext) {
          wasm2.webnnRegisterMLContext(sessionHandle, wasm2.currentContext);
          wasm2.currentContext = void 0;
          wasm2.shouldTransferToMLTensor = true;
        }
        const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
        const enableGraphCapture = !!options?.enableGraphCapture;
        const inputNames = [];
        const outputNames = [];
        const inputMetadata = [];
        const outputMetadata = [];
        const outputPreferredLocations = [];
        for (let i = 0; i < inputCount; i++) {
          const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i);
          if (nameOffset === 0) {
            checkLastError("Can't get an input name.");
          }
          inputNamesUTF8Encoded.push(nameOffset);
          const name = wasm2.UTF8ToString(nameOffset);
          inputNames.push(name);
          inputMetadata.push(
            elementType === 0 ? { name, isTensor: false } : { name, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
          );
        }
        for (let i = 0; i < outputCount; i++) {
          const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i + inputCount);
          if (nameOffset === 0) {
            checkLastError("Can't get an output name.");
          }
          outputNamesUTF8Encoded.push(nameOffset);
          const nameString = wasm2.UTF8ToString(nameOffset);
          outputNames.push(nameString);
          outputMetadata.push(
            elementType === 0 ? { name: nameString, isTensor: false } : { name: nameString, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
          );
          if (true) {
            if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
              outputPreferredLocations.push("gpu-buffer");
              continue;
            }
            const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
            const isGraphOutput = wasm2.webnnIsGraphOutput;
            if (location2 === "cpu" && isGraphOutput && isGraphOutput(sessionHandle, nameString)) {
              outputPreferredLocations.push("ml-tensor-cpu-output");
              continue;
            }
            if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer" && location2 !== "ml-tensor") {
              throw new Error(`Not supported preferred output location: ${location2}.`);
            }
            if (enableGraphCapture && location2 !== "gpu-buffer") {
              throw new Error(
                `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
              );
            }
            outputPreferredLocations.push(location2);
          }
        }
        let bindingState = null;
        if (outputPreferredLocations.some((l) => l === "gpu-buffer" || l === "ml-tensor" || l === "ml-tensor-cpu-output")) {
          ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
          if (ioBindingHandle === 0) {
            checkLastError("Can't create IO binding.");
          }
          bindingState = {
            handle: ioBindingHandle,
            outputPreferredLocations,
            outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => l === "ml-tensor-cpu-output" ? "ml-tensor" : l).map((l) => dataLocationStringToEnum(l))
          };
        }
        activeSessions.set(sessionHandle, [
          sessionHandle,
          inputNamesUTF8Encoded,
          outputNamesUTF8Encoded,
          bindingState,
          enableGraphCapture,
          false
        ]);
        return [sessionHandle, inputNames, outputNames, inputMetadata, outputMetadata];
      } catch (e) {
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        if (ioBindingHandle !== 0) {
          if (wasm2._OrtReleaseBinding(ioBindingHandle) !== 0) {
            checkLastError("Can't release IO binding.");
          }
        }
        if (sessionHandle !== 0) {
          if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
            checkLastError("Can't release session.");
          }
        }
        throw e;
      } finally {
        wasm2._free(modelDataOffset);
        if (sessionOptionsHandle !== 0) {
          if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
            checkLastError("Can't release session options.");
          }
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        wasm2.unmountExternalData?.();
      }
    };
    releaseSession = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot release session. invalid session id: ${sessionId}`);
      }
      const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
      if (ioBindingState) {
        if (enableGraphCapture) {
          if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
            checkLastError("Can't clear bound outputs.");
          }
        }
        if (wasm2._OrtReleaseBinding(ioBindingState.handle) !== 0) {
          checkLastError("Can't release IO binding.");
        }
      }
      wasm2.jsepOnReleaseSession?.(sessionId);
      wasm2.webnnOnReleaseSession?.(sessionId);
      wasm2.webgpuOnReleaseSession?.(sessionId);
      inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
        checkLastError("Can't release session.");
      }
      activeSessions.delete(sessionId);
    };
    prepareInputOutputTensor = async (tensor, tensorHandles, allocs, sessionId, tensorNameUTF8Encoded, index, enableGraphCapture = false) => {
      if (!tensor) {
        tensorHandles.push(0);
        return;
      }
      const wasm2 = getInstance();
      const ptrSize = wasm2.PTR_SIZE;
      const dataType = tensor[0];
      const dims = tensor[1];
      const location2 = tensor[3];
      let actualLocation = location2;
      let rawData;
      let dataByteLength;
      if (dataType === "string" && (location2 === "gpu-buffer" || location2 === "ml-tensor")) {
        throw new Error("String tensor is not supported on GPU.");
      }
      if (enableGraphCapture && location2 !== "gpu-buffer") {
        throw new Error(
          `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
        );
      }
      if (location2 === "gpu-buffer") {
        const gpuBuffer = tensor[2].gpuBuffer;
        dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
        if (false) {
          const registerBuffer = wasm2.webgpuRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(gpuBuffer, sessionId);
        } else {
          const registerBuffer = wasm2.jsepRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
        }
      } else if (location2 === "ml-tensor") {
        const mlTensor = tensor[2].mlTensor;
        dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
        const registerMLTensor = wasm2.webnnRegisterMLTensor;
        if (!registerMLTensor) {
          throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
        }
        rawData = registerMLTensor(sessionId, mlTensor, tensorDataTypeStringToEnum(dataType), dims);
      } else {
        const data = tensor[2];
        if (Array.isArray(data)) {
          dataByteLength = ptrSize * data.length;
          rawData = wasm2._malloc(dataByteLength);
          allocs.push(rawData);
          for (let i = 0; i < data.length; i++) {
            if (typeof data[i] !== "string") {
              throw new TypeError(`tensor data at index ${i} is not a string`);
            }
            wasm2.setValue(rawData + i * ptrSize, allocWasmString(data[i], allocs), "*");
          }
        } else {
          const isGraphInput = wasm2.webnnIsGraphInput;
          const isGraphOutput = wasm2.webnnIsGraphOutput;
          if (dataType !== "string" && isGraphInput && isGraphOutput) {
            const tensorName = wasm2.UTF8ToString(tensorNameUTF8Encoded);
            if (isGraphInput(sessionId, tensorName) || isGraphOutput(sessionId, tensorName)) {
              const dataTypeEnum = tensorDataTypeStringToEnum(dataType);
              dataByteLength = calculateTensorSizeInBytes(dataTypeEnum, dims);
              actualLocation = "ml-tensor";
              const createTemporaryTensor = wasm2.webnnCreateTemporaryTensor;
              const uploadTensor = wasm2.webnnUploadTensor;
              if (!createTemporaryTensor || !uploadTensor) {
                throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
              }
              const tensorId = await createTemporaryTensor(sessionId, dataTypeEnum, dims);
              uploadTensor(tensorId, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
              rawData = tensorId;
            } else {
              dataByteLength = data.byteLength;
              rawData = wasm2._malloc(dataByteLength);
              allocs.push(rawData);
              wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
            }
          } else {
            dataByteLength = data.byteLength;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
          }
        }
      }
      const stack = wasm2.stackSave();
      const dimsOffset = wasm2.stackAlloc(4 * dims.length);
      try {
        dims.forEach((d, index2) => wasm2.setValue(dimsOffset + index2 * ptrSize, d, ptrSize === 4 ? "i32" : "i64"));
        const tensor2 = wasm2._OrtCreateTensor(
          tensorDataTypeStringToEnum(dataType),
          rawData,
          dataByteLength,
          dimsOffset,
          dims.length,
          dataLocationStringToEnum(actualLocation)
        );
        if (tensor2 === 0) {
          checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
        }
        tensorHandles.push(tensor2);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
      const wasm2 = getInstance();
      const ptrSize = wasm2.PTR_SIZE;
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
      }
      const sessionHandle = session[0];
      const inputNamesUTF8Encoded = session[1];
      const outputNamesUTF8Encoded = session[2];
      const ioBindingState = session[3];
      const enableGraphCapture = session[4];
      const inputOutputBound = session[5];
      const inputCount = inputIndices.length;
      const outputCount = outputIndices.length;
      let runOptionsHandle = 0;
      let runOptionsAllocs = [];
      const inputTensorHandles = [];
      const outputTensorHandles = [];
      const inputOutputAllocs = [];
      const preAllocatedOutputs = [];
      const beforeRunStack = wasm2.stackSave();
      const inputValuesOffset = wasm2.stackAlloc(inputCount * ptrSize);
      const inputNamesOffset = wasm2.stackAlloc(inputCount * ptrSize);
      const outputValuesOffset = wasm2.stackAlloc(outputCount * ptrSize);
      const outputNamesOffset = wasm2.stackAlloc(outputCount * ptrSize);
      try {
        [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
        TRACE_EVENT_BEGIN("wasm prepareInputOutputTensor");
        for (let i = 0; i < inputCount; i++) {
          await prepareInputOutputTensor(
            inputTensors[i],
            inputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputNamesUTF8Encoded[inputIndices[i]],
            inputIndices[i],
            enableGraphCapture
          );
        }
        for (let i = 0; i < outputCount; i++) {
          await prepareInputOutputTensor(
            outputTensors[i],
            outputTensorHandles,
            inputOutputAllocs,
            sessionId,
            outputNamesUTF8Encoded[outputIndices[i]],
            inputCount + outputIndices[i],
            enableGraphCapture
          );
        }
        TRACE_EVENT_END("wasm prepareInputOutputTensor");
        for (let i = 0; i < inputCount; i++) {
          wasm2.setValue(inputValuesOffset + i * ptrSize, inputTensorHandles[i], "*");
          wasm2.setValue(inputNamesOffset + i * ptrSize, inputNamesUTF8Encoded[inputIndices[i]], "*");
        }
        for (let i = 0; i < outputCount; i++) {
          wasm2.setValue(outputValuesOffset + i * ptrSize, outputTensorHandles[i], "*");
          wasm2.setValue(outputNamesOffset + i * ptrSize, outputNamesUTF8Encoded[outputIndices[i]], "*");
        }
        if (ioBindingState && !inputOutputBound) {
          const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
          if (inputNamesUTF8Encoded.length !== inputCount) {
            throw new Error(
              `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
            );
          }
          TRACE_EVENT_BEGIN("wasm bindInputsOutputs");
          for (let i = 0; i < inputCount; i++) {
            const index = inputIndices[i];
            const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
            if (errorCode2 !== 0) {
              checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
            }
          }
          for (let i = 0; i < outputCount; i++) {
            const index = outputIndices[i];
            const location2 = outputTensors[i]?.[3];
            if (location2) {
              preAllocatedOutputs.push(outputTensorHandles[i]);
              const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
              }
            } else {
              const errorCode2 = wasm2._OrtBindOutput(
                handle,
                outputNamesUTF8Encoded[index],
                0,
                outputPreferredLocationsEncoded[index]
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
              }
            }
          }
          TRACE_EVENT_END("wasm bindInputsOutputs");
          activeSessions.set(sessionId, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            ioBindingState,
            enableGraphCapture,
            true
          ]);
        }
        wasm2.jsepOnRunStart?.(sessionHandle);
        wasm2.webnnOnRunStart?.(sessionHandle);
        let errorCode;
        if (ioBindingState) {
          errorCode = await wasm2._OrtRunWithBinding(
            sessionHandle,
            ioBindingState.handle,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        } else {
          errorCode = await wasm2._OrtRun(
            sessionHandle,
            inputNamesOffset,
            inputValuesOffset,
            inputCount,
            outputNamesOffset,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        }
        if (errorCode !== 0) {
          checkLastError("failed to call OrtRun().");
        }
        const output = [];
        const outputPromises = [];
        TRACE_EVENT_BEGIN("wasm ProcessOutputTensor");
        for (let i = 0; i < outputCount; i++) {
          const tensor = Number(wasm2.getValue(outputValuesOffset + i * ptrSize, "*"));
          if (tensor === outputTensorHandles[i] || preAllocatedOutputs.includes(outputTensorHandles[i])) {
            output.push(outputTensors[i]);
            if (tensor !== outputTensorHandles[i]) {
              if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                checkLastError("Can't release tensor.");
              }
            }
            continue;
          }
          const beforeGetTensorDataStack = wasm2.stackSave();
          const tensorDataOffset = wasm2.stackAlloc(4 * ptrSize);
          let keepOutputTensor = false;
          let type, dataOffset = 0;
          try {
            const errorCode2 = wasm2._OrtGetTensorData(
              tensor,
              tensorDataOffset,
              tensorDataOffset + ptrSize,
              tensorDataOffset + 2 * ptrSize,
              tensorDataOffset + 3 * ptrSize
            );
            if (errorCode2 !== 0) {
              checkLastError(`Can't access output tensor data on index ${i}.`);
            }
            const valueType = ptrSize === 4 ? "i32" : "i64";
            const dataType = Number(wasm2.getValue(tensorDataOffset, valueType));
            dataOffset = wasm2.getValue(tensorDataOffset + ptrSize, "*");
            const dimsOffset = wasm2.getValue(tensorDataOffset + ptrSize * 2, "*");
            const dimsLength = Number(wasm2.getValue(tensorDataOffset + ptrSize * 3, valueType));
            const dims = [];
            for (let i2 = 0; i2 < dimsLength; i2++) {
              dims.push(Number(wasm2.getValue(dimsOffset + i2 * ptrSize, valueType)));
            }
            if (wasm2._OrtFree(dimsOffset) !== 0) {
              checkLastError("Can't free memory for tensor dims.");
            }
            const size = dims.reduce((a, b) => a * b, 1);
            type = tensorDataTypeEnumToString(dataType);
            const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
            if (type === "string") {
              if (preferredLocation === "gpu-buffer" || preferredLocation === "ml-tensor") {
                throw new Error("String tensor is not supported on GPU.");
              }
              const stringData = [];
              for (let i2 = 0; i2 < size; i2++) {
                const offset = wasm2.getValue(dataOffset + i2 * ptrSize, "*");
                const nextOffset = wasm2.getValue(dataOffset + (i2 + 1) * ptrSize, "*");
                const maxBytesToRead = i2 === size - 1 ? void 0 : nextOffset - offset;
                stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
              }
              output.push([type, dims, stringData, "cpu"]);
            } else {
              if (preferredLocation === "gpu-buffer" && size > 0) {
                const getBuffer = false ? wasm2.webgpuGetBuffer : wasm2.jsepGetBuffer;
                if (!getBuffer) {
                  throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                }
                const gpuBuffer = getBuffer(dataOffset);
                const bufferSize = calculateTensorSizeInBytes(dataType, size);
                if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                keepOutputTensor = true;
                if (false) {
                  wasm2.webgpuRegisterBuffer(gpuBuffer, sessionId, dataOffset);
                  const downloadDataFunction = wasm2.webgpuCreateDownloader(gpuBuffer, bufferSize, sessionId);
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: async () => {
                        const arrayBuffer = await downloadDataFunction();
                        const data = new (tensorTypeToTypedArrayConstructor(type))(arrayBuffer);
                        return data;
                      },
                      dispose: () => {
                        if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                          checkLastError("Can't release tensor.");
                        }
                      }
                    },
                    "gpu-buffer"
                  ]);
                } else {
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: wasm2.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                      dispose: () => {
                        if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                          checkLastError("Can't release tensor.");
                        }
                      }
                    },
                    "gpu-buffer"
                  ]);
                }
              } else if (preferredLocation === "ml-tensor" && size > 0) {
                const ensureTensor = wasm2.webnnEnsureTensor;
                const isGraphInputOutputTypeSupported = wasm2.webnnIsGraphInputOutputTypeSupported;
                if (!ensureTensor || !isGraphInputOutputTypeSupported) {
                  throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                }
                const tensorSize = calculateTensorSizeInBytes(dataType, size);
                if (tensorSize === void 0 || !isMLTensorSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                if (!isGraphInputOutputTypeSupported(sessionId, type, false)) {
                  throw new Error(
                    `preferredLocation "ml-tensor" for ${type} output is not supported by current WebNN Context.`
                  );
                }
                const mlTensor = await ensureTensor(sessionId, dataOffset, dataType, dims, false);
                keepOutputTensor = true;
                output.push([
                  type,
                  dims,
                  {
                    mlTensor,
                    download: wasm2.webnnCreateMLTensorDownloader(dataOffset, type),
                    dispose: () => {
                      wasm2.webnnReleaseTensorId(dataOffset);
                      wasm2._OrtReleaseTensor(tensor);
                    }
                  },
                  "ml-tensor"
                ]);
              } else if (preferredLocation === "ml-tensor-cpu-output" && size > 0) {
                const data = wasm2.webnnCreateMLTensorDownloader(dataOffset, type)();
                const index = output.length;
                keepOutputTensor = true;
                outputPromises.push(
                  (async () => {
                    const result = [index, await data];
                    wasm2.webnnReleaseTensorId(dataOffset);
                    wasm2._OrtReleaseTensor(tensor);
                    return result;
                  })()
                );
                output.push([type, dims, [], "cpu"]);
              } else {
                const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                const data = new typedArrayConstructor(size);
                new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                  wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                );
                output.push([type, dims, data, "cpu"]);
              }
            }
          } finally {
            wasm2.stackRestore(beforeGetTensorDataStack);
            if (type === "string" && dataOffset) {
              wasm2._free(dataOffset);
            }
            if (!keepOutputTensor) {
              wasm2._OrtReleaseTensor(tensor);
            }
          }
        }
        if (ioBindingState && !enableGraphCapture) {
          if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
            checkLastError("Can't clear bound outputs.");
          }
          activeSessions.set(sessionId, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            ioBindingState,
            enableGraphCapture,
            false
          ]);
        }
        for (const [index, data] of await Promise.all(outputPromises)) {
          output[index][2] = data;
        }
        TRACE_EVENT_END("wasm ProcessOutputTensor");
        return output;
      } finally {
        wasm2.webnnOnRunEnd?.(sessionHandle);
        wasm2.stackRestore(beforeRunStack);
        if (false) {
          inputTensors.forEach((t) => {
            if (t && t[3] === "gpu-buffer") {
              wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
            }
          });
          outputTensors.forEach((t) => {
            if (t && t[3] === "gpu-buffer") {
              wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
            }
          });
        }
        inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        inputOutputAllocs.forEach((p) => wasm2._free(p));
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        runOptionsAllocs.forEach((p) => wasm2._free(p));
      }
    };
    endProfiling = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error("invalid session id");
      }
      const sessionHandle = session[0];
      const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
      if (profileFileName === 0) {
        checkLastError("Can't get an profile file name.");
      }
      wasm2._OrtFree(profileFileName);
    };
    extractTransferableBuffers = (tensors) => {
      const buffers = [];
      for (const tensor of tensors) {
        const data = tensor[2];
        if (!Array.isArray(data) && "buffer" in data) {
          buffers.push(data.buffer);
        }
      }
      return buffers;
    };
  }
});

// web/lib/wasm/proxy-wrapper.ts
var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
var init_proxy_wrapper = __esm({
  "web/lib/wasm/proxy-wrapper.ts"() {
    "use strict";
    init_esm();
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
    initializing2 = false;
    initialized2 = false;
    aborted2 = false;
    queuedCallbacks = /* @__PURE__ */ new Map();
    enqueueCallbacks = (type, callbacks) => {
      const queue = queuedCallbacks.get(type);
      if (queue) {
        queue.push(callbacks);
      } else {
        queuedCallbacks.set(type, [callbacks]);
      }
    };
    ensureWorker = () => {
      if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
        throw new Error("worker not ready");
      }
    };
    onProxyWorkerMessage = (ev) => {
      switch (ev.data.type) {
        case "init-wasm":
          initializing2 = false;
          if (ev.data.err) {
            aborted2 = true;
            initWasmCallbacks[1](ev.data.err);
          } else {
            initialized2 = true;
            initWasmCallbacks[0]();
          }
          if (temporaryObjectUrl) {
            URL.revokeObjectURL(temporaryObjectUrl);
            temporaryObjectUrl = void 0;
          }
          break;
        case "init-ep":
        case "copy-from":
        case "create":
        case "release":
        case "run":
        case "end-profiling": {
          const callbacks = queuedCallbacks.get(ev.data.type);
          if (ev.data.err) {
            callbacks.shift()[1](ev.data.err);
          } else {
            callbacks.shift()[0](ev.data.out);
          }
          break;
        }
        default:
      }
    };
    initializeWebAssemblyAndOrtRuntime = async () => {
      if (initialized2) {
        return;
      }
      if (initializing2) {
        throw new Error("multiple calls to 'initWasm()' detected.");
      }
      if (aborted2) {
        throw new Error("previous call to 'initWasm()' failed.");
      }
      initializing2 = true;
      if (isProxy()) {
        return new Promise((resolve, reject) => {
          proxyWorker?.terminate();
          void importProxyWorker().then(([objectUrl, worker]) => {
            try {
              proxyWorker = worker;
              proxyWorker.onerror = (ev) => reject(ev);
              proxyWorker.onmessage = onProxyWorkerMessage;
              initWasmCallbacks = [resolve, reject];
              const message = { type: "init-wasm", in: env2 };
              if (!message.in.wasm.wasmPaths && objectUrl) {
                const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
                if (inferredWasmPathPrefix) {
                  message.in.wasm.wasmPaths = inferredWasmPathPrefix;
                }
              }
              if (false) {
                message.in.wasm.wasmPaths = {
                  wasm: true ? new URL("ort-wasm-simd-threaded.jsep.wasm", import.meta.url).href : false ? new URL("ort-wasm-simd-threaded.jspi.wasm", import.meta.url).href : false ? new URL("ort-wasm-simd-threaded.asyncify.wasm", import.meta.url).href : new URL("ort-wasm-simd-threaded.wasm", import.meta.url).href
                };
              }
              proxyWorker.postMessage(message);
              temporaryObjectUrl = objectUrl;
            } catch (e) {
              reject(e);
            }
          }, reject);
        });
      } else {
        try {
          await initializeWebAssembly(env2.wasm);
          await initRuntime(env2);
          initialized2 = true;
        } catch (e) {
          aborted2 = true;
          throw e;
        } finally {
          initializing2 = false;
        }
      }
    };
    initializeOrtEp = async (epName) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("init-ep", [resolve, reject]);
          const message = { type: "init-ep", in: { epName, env: env2 } };
          proxyWorker.postMessage(message);
        });
      } else {
        await initEp(env2, epName);
      }
    };
    copyFromExternalBuffer2 = async (buffer) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("copy-from", [resolve, reject]);
          const message = { type: "copy-from", in: { buffer } };
          proxyWorker.postMessage(message, [buffer.buffer]);
        });
      } else {
        return copyFromExternalBuffer(buffer);
      }
    };
    createSession2 = async (model, options) => {
      if (isProxy()) {
        if (options?.preferredOutputLocation) {
          throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("create", [resolve, reject]);
          const message = { type: "create", in: { model, options: { ...options } } };
          const transferable = [];
          if (model instanceof Uint8Array) {
            transferable.push(model.buffer);
          }
          proxyWorker.postMessage(message, transferable);
        });
      } else {
        return createSession(model, options);
      }
    };
    releaseSession2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("release", [resolve, reject]);
          const message = { type: "release", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        releaseSession(sessionId);
      }
    };
    run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
      if (isProxy()) {
        if (inputs.some((t) => t[3] !== "cpu")) {
          throw new Error("input tensor on GPU is not supported for proxy.");
        }
        if (outputs.some((t) => t)) {
          throw new Error("pre-allocated output tensor is not supported for proxy.");
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("run", [resolve, reject]);
          const serializableInputs = inputs;
          const message = {
            type: "run",
            in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
          };
          proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
        });
      } else {
        return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
      }
    };
    endProfiling2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("end-profiling", [resolve, reject]);
          const message = { type: "end-profiling", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        endProfiling(sessionId);
      }
    };
  }
});

// web/lib/wasm/session-handler-inference.ts
var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
var init_session_handler_inference = __esm({
  "web/lib/wasm/session-handler-inference.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_wasm_common();
    init_wasm_utils_env();
    init_wasm_utils_load_file();
    encodeTensorMetadata = (tensor, getName) => {
      switch (tensor.location) {
        case "cpu":
          return [tensor.type, tensor.dims, tensor.data, "cpu"];
        case "gpu-buffer":
          return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
        case "ml-tensor":
          return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, "ml-tensor"];
        default:
          throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
      }
    };
    decodeTensorMetadata = (tensor) => {
      switch (tensor[3]) {
        case "cpu":
          return new Tensor2(tensor[0], tensor[2], tensor[1]);
        case "gpu-buffer": {
          const dataType = tensor[0];
          if (!isGpuBufferSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
          }
          const { gpuBuffer, download, dispose } = tensor[2];
          return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
        }
        case "ml-tensor": {
          const dataType = tensor[0];
          if (!isMLTensorSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);
          }
          const { mlTensor, download, dispose } = tensor[2];
          return Tensor2.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });
        }
        default:
          throw new Error(`invalid data location: ${tensor[3]}`);
      }
    };
    OnnxruntimeWebAssemblySessionHandler = class {
      async fetchModelAndCopyToWasmMemory(path) {
        return copyFromExternalBuffer2(await loadFile(path));
      }
      async loadModel(pathOrBuffer, options) {
        TRACE_FUNC_BEGIN();
        let model;
        if (typeof pathOrBuffer === "string") {
          if (isNode) {
            model = await loadFile(pathOrBuffer);
          } else {
            model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
          }
        } else {
          model = pathOrBuffer;
        }
        [this.sessionId, this.inputNames, this.outputNames, this.inputMetadata, this.outputMetadata] = await createSession2(
          model,
          options
        );
        TRACE_FUNC_END();
      }
      async dispose() {
        return releaseSession2(this.sessionId);
      }
      async run(feeds, fetches, options) {
        TRACE_FUNC_BEGIN();
        const inputArray = [];
        const inputIndices = [];
        Object.entries(feeds).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.inputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid input '${name}'`);
          }
          inputArray.push(tensor);
          inputIndices.push(index);
        });
        const outputArray = [];
        const outputIndices = [];
        Object.entries(fetches).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.outputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid output '${name}'`);
          }
          outputArray.push(tensor);
          outputIndices.push(index);
        });
        const inputs = inputArray.map(
          (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
        );
        const outputs = outputArray.map(
          (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
        );
        const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
        const resultMap = {};
        for (let i = 0; i < results.length; i++) {
          resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
        }
        TRACE_FUNC_END();
        return resultMap;
      }
      startProfiling() {
      }
      endProfiling() {
        void endProfiling2(this.sessionId);
      }
    };
  }
});

// web/lib/backend-wasm.ts
var backend_wasm_exports = {};
__export(backend_wasm_exports, {
  OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
  initializeFlags: () => initializeFlags,
  wasmBackend: () => wasmBackend
});
var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
var init_backend_wasm = __esm({
  "web/lib/backend-wasm.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_session_handler_inference();
    initializeFlags = () => {
      if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
        env2.wasm.initTimeout = 0;
      }
      const simd = env2.wasm.simd;
      if (typeof simd !== "boolean" && simd !== void 0 && simd !== "fixed" && simd !== "relaxed") {
        console.warn(
          `Property "env.wasm.simd" is set to unknown value "${simd}". Reset it to \`false\` and ignore SIMD feature checking.`
        );
        env2.wasm.simd = false;
      }
      if (typeof env2.wasm.proxy !== "boolean") {
        env2.wasm.proxy = false;
      }
      if (typeof env2.wasm.trace !== "boolean") {
        env2.wasm.trace = false;
      }
      if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          env2.wasm.numThreads = 1;
        } else {
          const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
          env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
        }
      }
    };
    OnnxruntimeWebAssemblyBackend = class {
      /**
       * This function initializes the WebAssembly backend.
       *
       * This function will be called only once for each backend name. It will be called the first time when
       * `ort.InferenceSession.create()` is called with a registered backend name.
       *
       * @param backendName - the registered backend name.
       */
      async init(backendName) {
        initializeFlags();
        await initializeWebAssemblyAndOrtRuntime();
        await initializeOrtEp(backendName);
      }
      async createInferenceSessionHandler(pathOrBuffer, options) {
        const handler = new OnnxruntimeWebAssemblySessionHandler();
        await handler.loadModel(pathOrBuffer, options);
        return handler;
      }
    };
    wasmBackend = new OnnxruntimeWebAssemblyBackend();
  }
});

// web/lib/index.ts
init_esm();
init_esm();
init_esm();

// web/lib/version.ts
var version2 = "1.25.0-dev.20260212-1a71a5f46e";

// web/lib/index.ts
var index_default = esm_exports;
if (false) {
  const onnxjsBackend = null.onnxjsBackend;
  registerBackend("webgl", onnxjsBackend, -10);
}
if (false) {
  throw new Error(
    "The current build is specified to enable both JSEP and WebGPU EP. This is not a valid configuration. JSEP and WebGPU EPs cannot be enabled at the same time."
  );
}
if (false) {
  throw new Error(
    "The current build is specified to enable WebNN EP without JSEP or WebGPU EP. This is not a valid configuration. WebNN EP requires either JSEP or WebGPU EP to be enabled."
  );
}
if (true) {
  const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
  if (true) {
    registerBackend("webgpu", wasmBackend2, 5);
  }
  if (true) {
    registerBackend("webnn", wasmBackend2, 5);
  }
  registerBackend("cpu", wasmBackend2, 10);
  registerBackend("wasm", wasmBackend2, 10);
}
Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
export {
  InferenceSession2 as InferenceSession,
  TRACE,
  TRACE_EVENT_BEGIN,
  TRACE_EVENT_END,
  TRACE_FUNC_BEGIN,
  TRACE_FUNC_END,
  Tensor2 as Tensor,
  index_default as default,
  env2 as env,
  registerBackend
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmRleC50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWVudi50cyIsICIuLi9saWIvd2FzbS9wcm94eS13b3JrZXIvbWFpbi50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50cyIsICIuLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy50cyIsICIuLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb21tb24udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1sb2FkLWZpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC9sb2cudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJubi90ZW5zb3ItbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL2JhY2tlbmQtd2Vibm4udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbW1vbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2Utc2hhcmVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2FyZ21pbm1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYXR0ZW50aW9uLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iYXRjaC1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLWFkZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdW5hcnktb3AudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpYXMtc3BsaXQtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmluYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb25jYXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9hY3RpdmF0aW9uX3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL21hdG11bC1zaGFkZXJzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl9iYWNrcHJvcF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYtdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jdW1zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9laW5zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2V4cGFuZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZmFzdC1nZWx1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dhdGhlci1uZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWJsb2NrLXF1YW50aXplZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWVsZW1lbnRzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nZW1tLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9ncmlkLXNhbXBsZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbXVsdGloZWFkLWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc3BsaXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JvdGFyeS1lbWJlZGRpbmcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvaW5zdGFuY2Utbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbWF0bXVsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWxuYml0cy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcGFkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9wb29sLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9xdWFudGl6ZS1saW5lYXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JhbmdlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zY2F0dGVyLW5kLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZXNpemUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NraXAtbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc2xpY2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NvZnRtYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3doZXJlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvYmFja2VuZC13ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC9pbml0LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29yZS1pbXBsLnRzIiwgIi4uL2xpYi93YXNtL3Byb3h5LXdyYXBwZXIudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZS50cyIsICIuLi9saWIvYmFja2VuZC13YXNtLnRzIiwgIi4uL2xpYi9pbmRleC50cyIsICIuLi9saWIvdmVyc2lvbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuXG5pbnRlcmZhY2UgQmFja2VuZEluZm8ge1xuICBiYWNrZW5kOiBCYWNrZW5kO1xuICBwcmlvcml0eTogbnVtYmVyO1xuXG4gIGluaXRQcm9taXNlPzogUHJvbWlzZTx2b2lkPjtcbiAgaW5pdGlhbGl6ZWQ/OiBib29sZWFuO1xuICBhYm9ydGVkPzogYm9vbGVhbjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmNvbnN0IGJhY2tlbmRzOiBNYXA8c3RyaW5nLCBCYWNrZW5kSW5mbz4gPSBuZXcgTWFwKCk7XG5jb25zdCBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHk6IHN0cmluZ1tdID0gW107XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgYXMgYSBrZXkgdG8gbG9va3VwIGFzIGFuIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAqIEBwYXJhbSBiYWNrZW5kIC0gdGhlIGJhY2tlbmQgb2JqZWN0LlxuICogQHBhcmFtIHByaW9yaXR5IC0gYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBwcmlvcml0eSBvZiB0aGUgYmFja2VuZC4gSGlnaGVyIG51bWJlciBtZWFucyBoaWdoZXIgcHJpb3JpdHkuIGlmIHByaW9yaXR5XG4gKiA8IDAsIGl0IHdpbGwgYmUgY29uc2lkZXJlZCBhcyBhICdiZXRhJyB2ZXJzaW9uIGFuZCB3aWxsIG5vdCBiZSB1c2VkIGFzIGEgZmFsbGJhY2sgYmFja2VuZCBieSBkZWZhdWx0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQmFja2VuZCA9IChuYW1lOiBzdHJpbmcsIGJhY2tlbmQ6IEJhY2tlbmQsIHByaW9yaXR5OiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKGJhY2tlbmQgJiYgdHlwZW9mIGJhY2tlbmQuaW5pdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYmFja2VuZC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGN1cnJlbnRCYWNrZW5kID0gYmFja2VuZHMuZ2V0KG5hbWUpO1xuICAgIGlmIChjdXJyZW50QmFja2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZW5kcy5zZXQobmFtZSwgeyBiYWNrZW5kLCBwcmlvcml0eSB9KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID4gcHJpb3JpdHkpIHtcbiAgICAgIC8vIHNhbWUgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4gc2tpcCByZWdpc3RlcmF0aW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPT09IHByaW9yaXR5KSB7XG4gICAgICBpZiAoY3VycmVudEJhY2tlbmQuYmFja2VuZCAhPT0gYmFja2VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByaW9yaXR5ID49IDApIHtcbiAgICAgIGNvbnN0IGkgPSBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmFja2VuZHMuZ2V0KGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eVtpXSkhLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSB2YWxpZCBiYWNrZW5kJyk7XG59O1xuXG4vKipcbiAqIFRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYmFja2VuZC5cbiAqIEByZXR1cm5zIHRoZSBiYWNrZW5kIGluc3RhbmNlIGlmIHJlc29sdmVkIGFuZCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHksIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgZmFpbGVkLlxuICovXG5jb25zdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQgPSBhc3luYyAoYmFja2VuZE5hbWU6IHN0cmluZyk6IFByb21pc2U8QmFja2VuZCB8IHN0cmluZz4gPT4ge1xuICBjb25zdCBiYWNrZW5kSW5mbyA9IGJhY2tlbmRzLmdldChiYWNrZW5kTmFtZSk7XG4gIGlmICghYmFja2VuZEluZm8pIHtcbiAgICByZXR1cm4gJ2JhY2tlbmQgbm90IGZvdW5kLic7XG4gIH1cblxuICBpZiAoYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgfSBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc0luaXRpYWxpemluZyA9ICEhYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uaW5pdFByb21pc2UgPSBiYWNrZW5kSW5mby5iYWNrZW5kLmluaXQoYmFja2VuZE5hbWUpO1xuICAgICAgfVxuICAgICAgYXdhaXQgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgIGJhY2tlbmRJbmZvLmVycm9yID0gYCR7ZX1gO1xuICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5lcnJvciE7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVzb2x2ZSBleGVjdXRpb24gcHJvdmlkZXJzIGZyb20gdGhlIHNwZWNpZmljIHNlc3Npb24gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiBhbiBpbml0aWFsaXplZCBiYWNrZW5kIGluc3RhbmNlIGFuZCBhIHNlc3Npb24gb3B0aW9ucyBvYmplY3Qgd2l0aFxuICogZmlsdGVyZWQgRVAgbGlzdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyA9IGFzeW5jIChcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbik6IFByb21pc2U8W2JhY2tlbmQ6IEJhY2tlbmQsIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnNdPiA9PiB7XG4gIC8vIGV4dHJhY3QgYmFja2VuZCBoaW50cyBmcm9tIHNlc3Npb24gb3B0aW9uc1xuICBjb25zdCBlcHMgPSBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyB8fCBbXTtcbiAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcCgoaSkgPT4gKHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpKTtcbiAgY29uc3QgYmFja2VuZE5hbWVzID0gYmFja2VuZEhpbnRzLmxlbmd0aCA9PT0gMCA/IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eSA6IGJhY2tlbmRIaW50cztcblxuICAvLyB0cnkgdG8gcmVzb2x2ZSBhbmQgaW5pdGlhbGl6ZSBhbGwgcmVxdWVzdGVkIGJhY2tlbmRzXG4gIGxldCBiYWNrZW5kOiBCYWNrZW5kIHwgdW5kZWZpbmVkO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgYXZhaWxhYmxlQmFja2VuZE5hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3QgYmFja2VuZE5hbWUgb2YgYmFja2VuZE5hbWVzKSB7XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IGF3YWl0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlUmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JzLnB1c2goeyBuYW1lOiBiYWNrZW5kTmFtZSwgZXJyOiByZXNvbHZlUmVzdWx0IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWJhY2tlbmQpIHtcbiAgICAgICAgYmFja2VuZCA9IHJlc29sdmVSZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoYmFja2VuZCA9PT0gcmVzb2x2ZVJlc3VsdCkge1xuICAgICAgICBhdmFpbGFibGVCYWNrZW5kTmFtZXMuYWRkKGJhY2tlbmROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBubyBiYWNrZW5kIGlzIGF2YWlsYWJsZSwgdGhyb3cgZXJyb3IuXG4gIGlmICghYmFja2VuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtlcnJvcnMubWFwKChlKSA9PiBgWyR7ZS5uYW1lfV0gJHtlLmVycn1gKS5qb2luKCcsICcpfWApO1xuICB9XG5cbiAgLy8gZm9yIGVhY2ggZXhwbGljaXRseSByZXF1ZXN0ZWQgYmFja2VuZCwgaWYgaXQncyBub3QgYXZhaWxhYmxlLCBvdXRwdXQgd2FybmluZyBtZXNzYWdlLlxuICBmb3IgKGNvbnN0IHsgbmFtZSwgZXJyIH0gb2YgZXJyb3JzKSB7XG4gICAgaWYgKGJhY2tlbmRIaW50cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYHJlbW92aW5nIHJlcXVlc3RlZCBleGVjdXRpb24gcHJvdmlkZXIgXCIke25hbWV9XCIgZnJvbSBzZXNzaW9uIG9wdGlvbnMgYmVjYXVzZSBpdCBpcyBub3QgYXZhaWxhYmxlOiAke2Vycn1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBmaWx0ZXJlZEVwcyA9IGVwcy5maWx0ZXIoKGkpID0+IGF2YWlsYWJsZUJhY2tlbmROYW1lcy5oYXModHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuXG4gIHJldHVybiBbXG4gICAgYmFja2VuZCxcbiAgICBuZXcgUHJveHkob3B0aW9ucywge1xuICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSAnZXhlY3V0aW9uUHJvdmlkZXJzJykge1xuICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEVwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH0sXG4gICAgfSksXG4gIF07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUgfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcbiAgdHlwZSBSZXR1cm5UeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgcmVhZG9ubHkgaW5wdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XG4gIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGFuIGluZmVyZW5jZSBzZXNzaW9uLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciBleHRlbmRzIFNlc3Npb25IYW5kbGVyIHtcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZDtcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgcnVuKFxuICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcbn1cblxuZXhwb3J0IHsgcmVnaXN0ZXJCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXG4vLyBEbyBub3QgbW9kaWZ5IGZpbGUgY29udGVudCBtYW51YWxseS5cblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4yNC4wLWRldi4yMDI1MTExNi1iMzllMTQ0MzIyJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnLi9lbnYuanMnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5cbnR5cGUgTG9nTGV2ZWxUeXBlID0gRW52Wydsb2dMZXZlbCddO1xuXG5sZXQgbG9nTGV2ZWxWYWx1ZTogUmVxdWlyZWQ8TG9nTGV2ZWxUeXBlPiA9ICd3YXJuaW5nJztcblxuZXhwb3J0IGNvbnN0IGVudjogRW52ID0ge1xuICB3YXNtOiB7fSBhcyBFbnYuV2ViQXNzZW1ibHlGbGFncyxcbiAgd2ViZ2w6IHt9IGFzIEVudi5XZWJHTEZsYWdzLFxuICB3ZWJncHU6IHt9IGFzIEVudi5XZWJHcHVGbGFncyxcbiAgdmVyc2lvbnM6IHsgY29tbW9uOiB2ZXJzaW9uIH0sXG5cbiAgc2V0IGxvZ0xldmVsKHZhbHVlOiBMb2dMZXZlbFR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGxvZ0xldmVsVmFsdWUgPSB2YWx1ZTtcbiAgfSxcbiAgZ2V0IGxvZ0xldmVsKCk6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4ge1xuICAgIHJldHVybiBsb2dMZXZlbFZhbHVlO1xuICB9LFxufTtcblxuLy8gc2V0IHByb3BlcnR5ICdsb2dMZXZlbCcgc28gdGhhdCB0aGV5IGNhbiBiZSBjb3JyZWN0bHkgdHJhbnNmZXJyZWQgdG8gd29ya2VyIGJ5IGBwb3N0TWVzc2FnZSgpYC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYsICdsb2dMZXZlbCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52IGFzIGVudkltcGwgfSBmcm9tICcuL2Vudi1pbXBsLmpzJztcbmltcG9ydCB7IFRyeUdldEdsb2JhbFR5cGUgfSBmcm9tICcuL3R5cGUtaGVscGVyLmpzJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVudiB7XG4gIGV4cG9ydCB0eXBlIFdhc21QYXRoUHJlZml4ID0gc3RyaW5nO1xuICBleHBvcnQgaW50ZXJmYWNlIFdhc21GaWxlUGF0aHMge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIG92ZXJyaWRlIHBhdGggZm9yIHRoZSBtYWluIC53YXNtIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLndhc20gZmlsZSBpczpcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21gIGZvciBkZWZhdWx0IGJ1aWxkXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21gIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS53YXNtYCBmb3IgV2ViR1BVIGJ1aWxkIHdpdGggQXN5bmNpZnkgKHdpdGggV2ViTk4pXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc3BpLndhc21gIGZvciBXZWJHUFUgYnVpbGQgd2l0aCBKU1BJIHN1cHBvcnQgKHdpdGggV2ViTk4pXG4gICAgICovXG4gICAgd2FzbT86IFVSTCB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLm1qcyBmaWxlIGlzOlxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS5tanNgIGZvciBXZWJHUFUgYnVpbGQgd2l0aCBBc3luY2lmeSAod2l0aCBXZWJOTilcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzcGkubWpzYCBmb3IgV2ViR1BVIGJ1aWxkIHdpdGggSlNQSSBzdXBwb3J0ICh3aXRoIFdlYk5OKVxuICAgICAqL1xuICAgIG1qcz86IFVSTCB8IHN0cmluZztcbiAgfVxuICBleHBvcnQgdHlwZSBXYXNtUHJlZml4T3JGaWxlUGF0aHMgPSBXYXNtUGF0aFByZWZpeCB8IFdhc21GaWxlUGF0aHM7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELlxuICAgICAqXG4gICAgICogT05OWCBSdW50aW1lIHdpbGwgcGVyZm9ybSBmZWF0dXJlIGRldGVjdGlvbiBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eS4gU3BlY2lmaWNhbGx5LCB3aGVuIHRoZSB2YWx1ZSBpc1xuICAgICAqIHNldCB0bzpcbiAgICAgKiAtIGB1bmRlZmluZWRgLCBgdHJ1ZWAgb3IgYFwiZml4ZWRcImA6IHdpbGwgY2hlY2sgYXZhaWxhYmlsaXR5IG9mIEZpeGVkLXdpZHRoIFNJTUQuXG4gICAgICogLSBgXCJyZWxheGVkXCJgOiB3aWxsIGNoZWNrIGF2YWlsYWJpbGl0eSBvZiBSZWxheGVkIFNJTUQuXG4gICAgICogLSBgZmFsc2VgOiB3aWxsIG5vdCBwZXJmb3JtIFNJTUQgZmVhdHVyZSBjaGVja2luZy5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCBtYWtlIE9OTlggUnVudGltZSB0byBzd2l0Y2ggdG8gdGhlIGNvcnJlc3BvbmRpbmcgcnVudGltZSBhdXRvbWF0aWNhbGx5LiBVc2VyIG5lZWRcbiAgICAgKiB0byBzZXQgYHdhc21QYXRoc2Agb3IgYHdhc21CaW5hcnlgIHByb3BlcnR5IHRvIGxvYWQgdGhlIGNvcnJlc3BvbmRpbmcgcnVudGltZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSB3aGVuIFdlYkFzc2VtYmx5IFNJTUQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWBcbiAgICAgKi9cbiAgICBzaW1kPzogYm9vbGVhbiB8ICdmaXhlZCcgfCAncmVsYXhlZCc7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZW5hYmxlIHRyYWNlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVudi50cmFjZWAgaW5zdGVhZC4gSWYgYGVudi50cmFjZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICB0cmFjZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IGEgbnVtYmVyIHNwZWNpZnlpbmcgdGhlIHRpbWVvdXQgZm9yIGluaXRpYWxpemF0aW9uIG9mIFdlYkFzc2VtYmx5IGJhY2tlbmQsIGluIG1pbGxpc2Vjb25kcy4gQSB6ZXJvXG4gICAgICogdmFsdWUgaW5kaWNhdGVzIG5vIHRpbWVvdXQgaXMgc2V0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBpbml0VGltZW91dD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGN1c3RvbSBVUkwgcHJlZml4IHRvIHRoZSAud2FzbS8ubWpzIGZpbGVzLCBvciBhbiBvYmplY3Qgb2Ygb3ZlcnJpZGVzIGZvciBib3RoIC53YXNtLy5tanMgZmlsZS4gVGhlIG92ZXJyaWRlXG4gICAgICogcGF0aCBzaG91bGQgYmUgYW4gYWJzb2x1dGUgcGF0aC5cbiAgICAgKi9cbiAgICB3YXNtUGF0aHM/OiBXYXNtUHJlZml4T3JGaWxlUGF0aHM7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjdXN0b20gYnVmZmVyIHdoaWNoIGNvbnRhaW5zIHRoZSBXZWJBc3NlbWJseSBiaW5hcnkuIElmIHRoaXMgcHJvcGVydHkgaXMgc2V0LCB0aGUgYHdhc21QYXRoc2AgcHJvcGVydHkgd2lsbFxuICAgICAqIGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgd2FzbUJpbmFyeT86IEFycmF5QnVmZmVyTGlrZSB8IFVpbnQ4QXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gcHJveHkgdGhlIGV4ZWN1dGlvbiBvZiBtYWluIHRocmVhZCB0byBhIHdvcmtlciB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBwcm94eT86IGJvb2xlYW47XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdMRmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIFdlYkdMIENvbnRleHQgSUQgKHdlYmdsIG9yIHdlYmdsMikuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAnd2ViZ2wyJ2BcbiAgICAgKi9cbiAgICBjb250ZXh0SWQ/OiAnd2ViZ2wnIHwgJ3dlYmdsMic7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgKi9cbiAgICByZWFkb25seSBjb250ZXh0OiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgbWF4aW11bSBiYXRjaCBzaXplIGZvciBtYXRtdWwuIDAgbWVhbnMgdG8gZGlzYWJsZSBiYXRjaGluZy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgbWF0bXVsTWF4QmF0Y2hTaXplPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHRleHR1cmUgY2FjaGUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCdmdWxsJ2BcbiAgICAgKi9cbiAgICB0ZXh0dXJlQ2FjaGVNb2RlPzogJ2luaXRpYWxpemVyT25seScgfCAnZnVsbCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcGFja2VkIHRleHR1cmUgbW9kZVxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgcGFjaz86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB3aGV0aGVyIGVuYWJsZSBhc3luYyBkb3dubG9hZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIGFzeW5jPzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGEge1xuICAgIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICAgIGRhdGFUeXBlOiBzdHJpbmc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVQcm9maWxpbmdEYXRhVjEge1xuICAgIHZlcnNpb246IDE7XG4gICAgaW5wdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XG4gICAgb3V0cHV0c01ldGFkYXRhOiByZWFkb25seSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YVtdO1xuICAgIGtlcm5lbElkOiBudW1iZXI7XG4gICAga2VybmVsVHlwZTogc3RyaW5nO1xuICAgIGtlcm5lbE5hbWU6IHN0cmluZztcbiAgICBwcm9ncmFtTmFtZTogc3RyaW5nO1xuICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgIGVuZFRpbWU6IG51bWJlcjtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFdlYkdwdVByb2ZpbGluZ0RhdGEgPSBXZWJHcHVQcm9maWxpbmdEYXRhVjE7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIG1vZGUuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGluc3RlYWQuIElmIGBlbnYud2ViZ3B1LnByb2ZpbGluZy5tb2RlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZVxuICAgICAqIGlnbm9yZWQuXG4gICAgICovXG4gICAgcHJvZmlsaW5nTW9kZT86ICdvZmYnIHwgJ2RlZmF1bHQnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIHByb2ZpbGluZzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnIHwgJ2RlZmF1bHQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBnZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgcHJvZmlsaW5nIGRhdGEgaXMgcmVjZWl2ZWQuIElmIG5vdCBzZXQsIHRoZSBwcm9maWxpbmcgZGF0YSB3aWxsIGJlXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXG4gICAgICAgKi9cbiAgICAgIG9uZGF0YT86IChkYXRhOiBXZWJHcHVQcm9maWxpbmdEYXRhKSA9PiB2b2lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcG93ZXIgcHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIENyZWF0ZSB5b3VyIG93biBHUFVBZGFwdGVyLCB1c2UgaXQgdG8gY3JlYXRlIGEgR1BVRGV2aWNlIGluc3RhbmNlIGFuZCBzZXQge0BsaW5rIGRldmljZX0gcHJvcGVydHkgaWZcbiAgICAgKiB5b3Ugd2FudCB0byB1c2UgYSBzcGVjaWZpYyBwb3dlciBwcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIHBvd2VyUHJlZmVyZW5jZT86ICdsb3ctcG93ZXInIHwgJ2hpZ2gtcGVyZm9ybWFuY2UnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGZvcmNlIGZhbGxiYWNrIGFkYXB0ZXIgZmxhZy5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIENyZWF0ZSB5b3VyIG93biBHUFVBZGFwdGVyLCB1c2UgaXQgdG8gY3JlYXRlIGEgR1BVRGV2aWNlIGluc3RhbmNlIGFuZCBzZXQge0BsaW5rIGRldmljZX0gcHJvcGVydHkgaWZcbiAgICAgKiB5b3Ugd2FudCB0byB1c2UgYSBzcGVjaWZpYyBmYWxsYmFjayBvcHRpb24uXG4gICAgICovXG4gICAgZm9yY2VGYWxsYmFja0FkYXB0ZXI/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIGdldCBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZVxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdXNlIHdpdGggVHlwZVNjcmlwdCwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBgR1BVQWRhcHRlcmAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIEl0IGlzIG5vIGxvbmdlciByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBwcm9wZXJ0eS4gVGhlIGxhdGVzdCBXZWJHUFUgc3BlYyBhZGRzIGBHUFVEZXZpY2UuYWRhcHRlckluZm9gXG4gICAgICogKGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJncHUvI2RvbS1ncHVkZXZpY2UtYWRhcHRlcmluZm8pLCB3aGljaCBhbGxvd3MgdG8gZ2V0IHRoZSBhZGFwdGVyIGluZm9ybWF0aW9uIGZyb20gdGhlXG4gICAgICogZGV2aWNlLiBXaGVuIGl0J3MgYXZhaWxhYmxlLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNldC9nZXQgdGhlIHtAbGluayBhZGFwdGVyfSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBhZGFwdGVyOiBUcnlHZXRHbG9iYWxUeXBlPCdHUFVBZGFwdGVyJz47XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgR1BVIGRldmljZSBmb3IgV2ViR1BVLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIDMgdmFsaWQgc2NlbmFyaW9zIG9mIGFjY2Vzc2luZyB0aGlzIHByb3BlcnR5OlxuICAgICAqIC0gU2V0IGEgdmFsdWUgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmUgdXNlZCBieSB0aGUgV2ViR1BVIGJhY2tlbmRcbiAgICAgKiB0byBwZXJmb3JtIGNhbGN1bGF0aW9ucy4gSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGBHUFVEZXZpY2VgIG9iamVjdCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICogLSBHZXQgdGhlIHZhbHVlIGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoaXMgd2lsbCB0cnkgdG8gY3JlYXRlIGEgbmV3IEdQVURldmljZVxuICAgICAqIGluc3RhbmNlLiBSZXR1cm5zIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgdG8gYSBgR1BVRGV2aWNlYCBvYmplY3QuXG4gICAgICogLSBHZXQgdGhlIHZhbHVlIGFmdGVyIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gUmV0dXJucyBhIHJlc29sdmVkIGBQcm9taXNlYCB0byB0aGVcbiAgICAgKiBgR1BVRGV2aWNlYCBvYmplY3QgdXNlZCBieSB0aGUgV2ViR1BVIGJhY2tlbmQuXG4gICAgICovXG4gICAgZ2V0IGRldmljZSgpOiBQcm9taXNlPFRyeUdldEdsb2JhbFR5cGU8J0dQVURldmljZSc+PjtcbiAgICBzZXQgZGV2aWNlKHZhbHVlOiBUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPik7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB3aGV0aGVyIHZhbGlkYXRlIGlucHV0IGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUlucHV0Q29udGVudD86IGJvb2xlYW47XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbnYge1xuICAvKipcbiAgICogc2V0IHRoZSBzZXZlcml0eSBsZXZlbCBmb3IgbG9nZ2luZy5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgJ3dhcm5pbmcnYFxuICAgKi9cbiAgbG9nTGV2ZWw/OiAndmVyYm9zZScgfCAnaW5mbycgfCAnd2FybmluZycgfCAnZXJyb3InIHwgJ2ZhdGFsJztcblxuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciBydW4gaW4gZGVidWcgbW9kZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICBkZWJ1Zz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBlbmFibGUgdHJhY2UuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKi9cbiAgdHJhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBHZXQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBwYWNrYWdlLlxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvbnM6IHtcbiAgICByZWFkb25seSBjb21tb246IHN0cmluZztcbiAgICByZWFkb25seSB3ZWI/OiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgbm9kZT86IHN0cmluZztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgcmVhZG9ubHkgJ3JlYWN0LW5hdGl2ZSc/OiBzdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViQXNzZW1ibHlcbiAgICovXG4gIHJlYWRvbmx5IHdhc206IEVudi5XZWJBc3NlbWJseUZsYWdzO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkdMXG4gICAqL1xuICByZWFkb25seSB3ZWJnbDogRW52LldlYkdMRmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR1BVXG4gICAqL1xuICByZWFkb25seSB3ZWJncHU6IEVudi5XZWJHcHVGbGFncztcblxuICBbbmFtZTogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgYXMgYSBnbG9iYWwgc2luZ2xldG9uLlxuICovXG5leHBvcnQgY29uc3QgZW52OiBFbnYgPSBlbnZJbXBsO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9EYXRhVVJMKClcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclRvRGF0YVVSTCA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjYW52YXMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykgOiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICBjYW52YXMud2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgY2FudmFzLmhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhc1xuICAgIHwgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gICAgfCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICB8IG51bGw7XG5cbiAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InO1xuXG4gICAgY29uc3Qgbm9ybSA9IG9wdGlvbnM/Lm5vcm07XG4gICAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9ybS5tZWFuID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgMF07XG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1NZWFuWzNdID0gbm9ybS5tZWFuWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG5vcm0uYmlhcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSxcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMixcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gLTE7XG5cbiAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IFIgPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxuICAgICAgICBjb25zdCBHID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07IC8vIEcgdmFsdWVcbiAgICAgICAgY29uc3QgQiA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAvLyBCIHZhbHVlXG4gICAgICAgIGNvbnN0IEEgPSBhVGVuc29yUG9pbnRlciA9PT0gLTEgPyAyNTUgOiAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgLy8gQSB2YWx1ZVxuXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgUiArICcsJyArIEcgKyAnLCcgKyBCICsgJywnICsgQSArICcpJztcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxSZWN0KGosIGksIDEsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3RvRGF0YVVSTCcgaW4gY2FudmFzKSB7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0ltYWdlRGF0YSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0ltYWdlRGF0YSA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSA9PiB7XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9XG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpXG4gICAgICA6IChuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTtcbiAgbGV0IGltYWdlOiBJbWFnZURhdGE7XG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCBjaGFubmVsczogbnVtYmVyO1xuICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMV07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzFdO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcblxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhblswXSwgbm9ybS5tZWFuWzFdLCBub3JtLm1lYW5bMl0sIDI1NV07XG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1NZWFuWzNdID0gbm9ybS5tZWFuWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG5vcm0uYmlhcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcbiAgICAgICAgKGNoYW5uZWxzID09PSAzICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCJyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ0JHUicpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgIGNvbnN0IHN0ZXAgPSA0O1xuICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCxcbiAgICAgIGdJbWFnZVBvaW50ZXIgPSAxLFxuICAgICAgYkltYWdlUG9pbnRlciA9IDIsXG4gICAgICBhSW1hZ2VQb2ludGVyID0gMztcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXG4gICAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH1cblxuICAgIGltYWdlID0gcGl4ZWxzMkRDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGZvciAoXG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBpIDwgaGVpZ2h0ICogd2lkdGg7XG4gICAgICBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGkrK1xuICAgICkge1xuICAgICAgaW1hZ2UuZGF0YVtySW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2dJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07IC8vIEcgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYkltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1syXSkgKiBub3JtTWVhblsyXTsgLy8gQiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVthSW1hZ2VQb2ludGVyXSA9XG4gICAgICAgIGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG4gIHJldHVybiBpbWFnZTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIE9wdGlvbnNEaW1lbnNpb25zLFxuICBPcHRpb25zRm9ybWF0LFxuICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXG4gIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMsXG4gIFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnMsXG4gIFRlbnNvckZyb21UZXh0dXJlT3B0aW9ucyxcbiAgVGVuc29yRnJvbVVybE9wdGlvbnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgYXMgVGVuc29ySW50ZXJmYWNlIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5pbnRlcmZhY2UgQnVmZmVyVG9UZW5zb3JPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXG4gICAgT3B0aW9uc0Zvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0IHt9XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSBpbWFnZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gRXh0cmFjdGVkIGltYWdlIGJ1ZmZlciBkYXRhIC0gYXNzdW1pbmcgUkdCQSBmb3JtYXRcbiAqIEBwYXJhbSBpbWFnZUZvcm1hdCAtIGlucHV0IGltYWdlIGNvbmZpZ3VyYXRpb24gLSByZXF1aXJlZCBjb25maWd1cmF0aW9ucyBoZWlnaHQsIHdpZHRoLCBmb3JtYXRcbiAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvVGVuc29yID0gKGJ1ZmZlcjogVWludDhDbGFtcGVkQXJyYXkgfCB1bmRlZmluZWQsIG9wdGlvbnM6IEJ1ZmZlclRvVGVuc29yT3B0aW9ucyk6IFRlbnNvciA9PiB7XG4gIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIGlmIChvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgIHRocm93IG5ldyBFcnJvcignTkhXQyBUZW5zb3IgbGF5b3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgbm9ybSA9IG9wdGlvbnMubm9ybSA/PyB7IG1lYW46IDI1NSwgYmlhczogMCB9O1xuICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG4gIGlmICh0eXBlb2Ygbm9ybS5tZWFuID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gIH0gZWxzZSB7XG4gICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuIVswXSwgbm9ybS5tZWFuIVsxXSwgbm9ybS5tZWFuIVsyXSwgbm9ybS5tZWFuIVszXSA/PyAyNTVdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgfSBlbHNlIHtcbiAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMhWzBdLCBub3JtLmJpYXMhWzFdLCBub3JtLmJpYXMhWzJdLCBub3JtLmJpYXMhWzNdID8/IDBdO1xuICB9XG5cbiAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCQSc7XG4gIC8vIGRlZmF1bHQgdmFsdWUgaXMgUkdCQSBzaW5jZSBpbWFnZWRhdGEgYW5kIEhUTUxJbWFnZUVsZW1lbnQgdXNlcyBpdFxuXG4gIGNvbnN0IG91dHB1dGZvcm1hdCA9XG4gICAgb3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZW5zb3JGb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcbiAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gIGNvbnN0IGZsb2F0MzJEYXRhID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDQpIDogbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiAzKTtcblxuICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgbGV0IHN0ZXAgPSA0LFxuICAgIHJJbWFnZVBvaW50ZXIgPSAwLFxuICAgIGdJbWFnZVBvaW50ZXIgPSAxLFxuICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxuICAgIGFJbWFnZVBvaW50ZXIgPSAzO1xuICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxuICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMixcbiAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgIHN0ZXAgPSAzO1xuICAgIHJJbWFnZVBvaW50ZXIgPSAwO1xuICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xuICAgIGJJbWFnZVBvaW50ZXIgPSAyO1xuICAgIGFJbWFnZVBvaW50ZXIgPSAtMTtcbiAgfVxuXG4gIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBvdXRwdXQgdGVuc29yIGZvcm1hdFxuICBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnQkdSJykge1xuICAgIGJUZW5zb3JQb2ludGVyID0gMDtcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICByVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gIH1cblxuICBmb3IgKFxuICAgIGxldCBpID0gMDtcbiAgICBpIDwgc3RyaWRlO1xuICAgIGkrKywgckltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwXG4gICkge1xuICAgIGZsb2F0MzJEYXRhW3JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltySW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzBdKSAvIG5vcm1NZWFuWzBdO1xuICAgIGZsb2F0MzJEYXRhW2dUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltnSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzFdKSAvIG5vcm1NZWFuWzFdO1xuICAgIGZsb2F0MzJEYXRhW2JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltiSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzJdKSAvIG5vcm1NZWFuWzJdO1xuICAgIGlmIChhVGVuc29yUG9pbnRlciAhPT0gLTEgJiYgYUltYWdlUG9pbnRlciAhPT0gLTEpIHtcbiAgICAgIGZsb2F0MzJEYXRhW2FUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlclthSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzNdKSAvIG5vcm1NZWFuWzNdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZsb2F0MzJBcnJheSAtPiBvcnQuVGVuc29yXG4gIGNvbnN0IG91dHB1dFRlbnNvciA9XG4gICAgb3V0cHV0Zm9ybWF0ID09PSAnUkdCQSdcbiAgICAgID8gbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgNCwgaGVpZ2h0LCB3aWR0aF0pXG4gICAgICA6IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDMsIGhlaWdodCwgd2lkdGhdKTtcbiAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21JbWFnZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUltYWdlID0gYXN5bmMgKFxuICBpbWFnZTogSW1hZ2VEYXRhIHwgSFRNTEltYWdlRWxlbWVudCB8IEltYWdlQml0bWFwIHwgc3RyaW5nLFxuICBvcHRpb25zPzpcbiAgICB8IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXG4gICAgfCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbVVybE9wdGlvbnMsXG4pOiBQcm9taXNlPFRlbnNvcj4gPT4ge1xuICAvLyBjaGVja2luZyB0aGUgdHlwZSBvZiBpbWFnZSBvYmplY3RcbiAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICBjb25zdCBpc0ltYWdlRGF0YUVsZSA9IHR5cGVvZiBJbWFnZURhdGEgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhO1xuICBjb25zdCBpc0ltYWdlQml0bWFwID0gdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwO1xuICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZyc7XG5cbiAgbGV0IGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkO1xuICBsZXQgYnVmZmVyVG9UZW5zb3JPcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuXG4gIGNvbnN0IGNyZWF0ZUNhbnZhcyA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjcmVhdGVDYW52YXNDb250ZXh0ID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBPZmZzY3JlZW5DYW52YXMpID0+IHtcbiAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0gZWxzZSBpZiAoY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8vIGZpbGxpbmcgYW5kIGNoZWNraW5nIGltYWdlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICBpZiAoaXNIVE1MSW1hZ2VFbGUpIHtcbiAgICAvLyBIVE1MSW1hZ2VFbGVtZW50IC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IGlzIFJHQkEgYnkgZGVmYXVsdFxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBsZXQgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgbGV0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZURhdGFFbGUpIHtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmZvcm1hdCA9ICdSR0JBJztcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuXG4gICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dCh0ZW1wQ2FudmFzKTtcblxuICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ltYWdlQml0bWFwKSB7XG4gICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG5cbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICByZXR1cm4gYnVmZmVyVG9UZW5zb3IoZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcbiAgICAgIGlmICghaW1hZ2UgfHwgIWNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIG5ld0ltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICBuZXdJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgIG5ld0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gbmV3SW1hZ2Uud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdJbWFnZS5oZWlnaHQ7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG5ld0ltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBpbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgIHJlc29sdmUoYnVmZmVyVG9UZW5zb3IoaW1nLmRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gIH1cblxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tVGV4dHVyZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbVRleHR1cmUgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5UZXh0dXJlRGF0YVR5cGVzPihcbiAgdGV4dHVyZTogVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlLFxuICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xuICAvLyBBbHdheXMgYXNzdW1lIFJHQkFGMzIuIFRPRE86IHN1cHBvcnQgZGlmZmVyZW50IHRleHR1cmUgZm9ybWF0XG4gIGNvbnN0IGRpbXMgPSBbMSwgaGVpZ2h0LCB3aWR0aCwgNF07XG4gIHJldHVybiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICd0ZXh0dXJlJywgdHlwZTogJ2Zsb2F0MzInLCB0ZXh0dXJlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21HcHVCdWZmZXIoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21HcHVCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICBncHVCdWZmZXI6IFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJUeXBlLFxuICBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPixcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHsgZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsIHR5cGU6IGRhdGFUeXBlID8/ICdmbG9hdDMyJywgZ3B1QnVmZmVyLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21NTFRlbnNvcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbU1MVGVuc29yID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuTUxUZW5zb3JEYXRhVHlwZXM+KFxuICBtbFRlbnNvcjogVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbU1MVGVuc29yT3B0aW9uczxUPixcbik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHsgZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnbWwtdGVuc29yJywgdHlwZTogZGF0YVR5cGUgPz8gJ2Zsb2F0MzInLCBtbFRlbnNvciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tUGlubmVkQnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgdHlwZTogVCxcbiAgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sXG4gIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbik6IFRlbnNvciA9PiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICdjcHUtcGlubmVkJywgdHlwZSwgZGF0YTogYnVmZmVyLCBkaW1zOiBkaW1zID8/IFtidWZmZXIubGVuZ3RoXSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzID1cbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3I7XG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5ID0gSW5zdGFuY2VUeXBlPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+O1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgPSBuZXcgTWFwPHN0cmluZywgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycz4oW1xuICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxuICBbJ3VpbnQ4JywgVWludDhBcnJheV0sXG4gIFsnaW50OCcsIEludDhBcnJheV0sXG4gIFsndWludDE2JywgVWludDE2QXJyYXldLFxuICBbJ2ludDE2JywgSW50MTZBcnJheV0sXG4gIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgWydib29sJywgVWludDhBcnJheV0sXG4gIFsnZmxvYXQ2NCcsIEZsb2F0NjRBcnJheV0sXG4gIFsndWludDMyJywgVWludDMyQXJyYXldLFxuICBbJ2ludDQnLCBVaW50OEFycmF5XSxcbiAgWyd1aW50NCcsIFVpbnQ4QXJyYXldLFxuXSk7XG5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCA9IG5ldyBNYXA8U3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycywgVGVuc29yLlR5cGU+KFtcbiAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcbiAgW1VpbnQ4QXJyYXksICd1aW50OCddLFxuICBbSW50OEFycmF5LCAnaW50OCddLFxuICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcbiAgW0ludDE2QXJyYXksICdpbnQxNiddLFxuICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXG4gIFtVaW50MzJBcnJheSwgJ3VpbnQzMiddLFxuXSk7XG5cbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludC9GbG9hdDE2QXJyYXkgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50L0Zsb2F0MTZBcnJheVxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxubGV0IGlzVHlwZWRBcnJheUNoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja1R5cGVkQXJyYXkgPSAoKSA9PiB7XG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xuICAgIGlzVHlwZWRBcnJheUNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdJbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBGbG9hdDE2QXJyYXkgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLkZsb2F0MTZBcnJheTtcbiAgICBjb25zdCBpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tO1xuXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2ludDY0JywgQmlnSW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdJbnQ2NEFycmF5LCAnaW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEZsb2F0MTZBcnJheSwgJ2Zsb2F0MTYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBVaW50MTZBcnJheSk7XG4gICAgfVxuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgTUxUZW5zb3JDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ21sLXRlbnNvcicsXG4gICAgICAgIG1sVGVuc29yOiB0ZW5zb3IubWxUZW5zb3IsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgdGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YSB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7XG4gIHRlbnNvckZyb21HcHVCdWZmZXIsXG4gIHRlbnNvckZyb21JbWFnZSxcbiAgdGVuc29yRnJvbU1MVGVuc29yLFxuICB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLFxuICB0ZW5zb3JGcm9tVGV4dHVyZSxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS1pbXBsLmpzJztcbmltcG9ydCB7XG4gIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcbiAgVGVuc29yRnJvbU1MVGVuc29yT3B0aW9ucyxcbiAgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLFxuICBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcbiAgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1xuICBjaGVja1R5cGVkQXJyYXksXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXksXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXG59IGZyb20gJy4vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGUgfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8vIHR5cGUgYWxpYXNlcyBmb3IgdGhvc2UgZXhwb3J0ZWQgZnJvbSBUZW5zb3IgaW50ZXJmYWNlXG5cbnR5cGUgVGVuc29yVHlwZSA9IFRlbnNvckludGVyZmFjZS5UeXBlO1xudHlwZSBUZW5zb3JEYXRhVHlwZSA9IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZTtcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcbnR5cGUgVGVuc29yVGV4dHVyZVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGU7XG50eXBlIFRlbnNvckdwdUJ1ZmZlclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZTtcbnR5cGUgVGVuc29yTUxUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZTtcblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW5zb3IgaW1wbGVtZW50cyBUZW5zb3JJbnRlcmZhY2Uge1xuICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IFRlbnNvclR5cGUsXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuIFR5cGUgaXMgaW5mZXJyZWQgZnJvbSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIHBpbm5lZCBDUFUgZGF0YSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnY3B1LXBpbm5lZCcuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR0wgdGV4dHVyZSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2dwdS1idWZmZXInLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViTk4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ21sLXRlbnNvcicuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYXJnMDpcbiAgICAgIHwgVGVuc29yVHlwZVxuICAgICAgfCBUZW5zb3JEYXRhVHlwZVxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxuICAgICAgfCByZWFkb25seSBzdHJpbmdbXVxuICAgICAgfCByZWFkb25seSBib29sZWFuW11cbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNcbiAgICAgIHwgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBhcmcyPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSAhPT0gJ2Zsb2F0MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ2NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmXG4gICAgICAgICAgICB0eXBlICE9PSAnYm9vbCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ0J1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gTUxUZW5zb3JgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tbFRlbnNvckRhdGEgPSBhcmcwLm1sVGVuc29yO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIG9mIGxvY2F0aW9uICdjcHUnXG4gICAgICAvL1xuICAgICAgbGV0IGRhdGE6IFRlbnNvckRhdGFUeXBlO1xuICAgICAgbGV0IG1heWJlRGltczogdHlwZW9mIGFyZzEgfCB0eXBlb2YgYXJnMjtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XG4gICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBudW1lcmljIHRlbnNvclxuICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBpZiAoKGFyZzAgPT09ICdmbG9hdDE2JyAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5KSB8fCBhcmcwID09PSAndWludDQnIHx8IGFyZzAgPT09ICdpbnQ0Jykge1xuICAgICAgICAgICAgICAvLyAtICdmbG9hdDE2JzpcbiAgICAgICAgICAgICAgLy8gICBXaGVuIG5vIEZsb2F0MTZBcnJheSBwb2x5ZmlsbCBpcyB1c2VkLCB3ZSBjYW5ub3QgY3JlYXRlICdmbG9hdDE2JyB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vICAgVGhyb3cgZXJyb3IgaGVyZSBiZWNhdXNlIHdoZW4gdXNlciB0cnkgdG8gdXNlIG51bWJlciBhcnJheSBhcyBkYXRhLFxuICAgICAgICAgICAgICAvLyAgIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcbiAgICAgICAgICAgICAgLy8gICBVaW50MTZBcnJheS5mcm9tKGFyZzEpIHdoaWNoIGdlbmVyYXRlcyB3cm9uZyBkYXRhLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAtICd1aW50NCcgYW5kICdpbnQ0JzpcbiAgICAgICAgICAgICAgLy8gICBVaW50OEFycmF5LmZyb20oYXJnMSkgd2lsbCBnZW5lcmF0ZSB3cm9uZyBkYXRhIGZvciAndWludDQnIGFuZCAnaW50NCcgdGVuc29yLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBDcmVhdGluZyBhICR7YXJnMH0gdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgJHt0eXBlZEFycmF5Q29uc3RydWN0b3IubmFtZX0gYXMgZGF0YS5gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XG4gICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgICAgIC8vIDEuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB0eXBlIG9mICdBcnJheS5pc0FycmF5KCknIGRvZXMgbm90IHdvcmsgd2l0aCByZWFkb25seSBhcnJheXMuXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXG4gICAgICAgICAgICAgIC8vIDIuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB1bmlvbiB0eXBlIG9mICcoQmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IpLmZyb20oKSdcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlciBtYXBGbi5cbiAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cbiAgICAgICAgICAgICAgLy8gdHlwZS5cblxuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBiaWdpbnRbXVwiIGhlcmUuXG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEsIEJpZ0ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXVwiIGhlcmUuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3VpbnQ4Jykge1xuICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gJ2Zsb2F0MTYnICYmIGFyZzEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgIT09IFVpbnQxNkFycmF5KSB7XG4gICAgICAgICAgICAvLyB3aGVuIEZsb2F0MTZBcnJheSBpcyBhdmFpbGFibGUgYW5kIGRhdGEgaXMgb2YgdHlwZSBVaW50MTZBcnJheS5cbiAgICAgICAgICAgIC8vIFdlIGFsbG93IFVpbnQxNkFycmF5IHRvIGJlIHBhc3NlZCBpbiBhcyBkYXRhIGZvciAnZmxvYXQxNicgdGVuc29yIHVudGlsIEZsb2F0MTZBcnJheSBpcyBnZW5lcmFsbHlcbiAgICAgICAgICAgIC8vIHN1cHBvcnRlZCBpbiBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZGF0YSA9IG5ldyAoZ2xvYmFsVGhpcyBhcyBhbnkpLkZsb2F0MTZBcnJheShhcmcxLmJ1ZmZlciwgYXJnMS5ieXRlT2Zmc2V0LCBhcmcxLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHt0eXBlfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3RvcihkYXRhLCAuLi4pXG4gICAgICAgIC8vXG4gICAgICAgIG1heWJlRGltcyA9IGFyZzE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgLy8gb25seSBib29sZWFuW10gYW5kIHN0cmluZ1tdIGlzIHN1cHBvcnRlZFxuICAgICAgICAgIGlmIChhcmcwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudFR5cGUgPSB0eXBlb2YgYXJnMFswXTtcbiAgICAgICAgICBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2Jvb2wnO1xuICAgICAgICAgICAgLy8gJ2FyZzAnIGlzIG9mIHR5cGUgJ2Jvb2xlYW5bXScuIFVpbnQ4QXJyYXkuZnJvbShib29sZWFuW10pIGFjdHVhbGx5IHdvcmtzLCBidXQgdHlwZXNjcmlwdCB0aGlua3MgdGhpcyBpc1xuICAgICAgICAgICAgLy8gd3JvbmcgdHlwZS4gV2UgdXNlICdhcyBhbnknIHRvIG1ha2UgaXQgaGFwcHkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwIGFzIGFueVtdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtmaXJzdEVsZW1lbnRUeXBlfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICAgICAgdHlwZSA9ICd1aW50OCc7XG4gICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgY29uc3QgbWFwcGVkVHlwZSA9IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuZ2V0KFxuICAgICAgICAgICAgYXJnMC5jb25zdHJ1Y3RvciBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG1hcHBlZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgPSBtYXBwZWRUeXBlO1xuICAgICAgICAgIGRhdGEgPSBhcmcwIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHlwZSBhbmQgZGF0YSBpcyBwcm9jZXNzZWQsIG5vdyBwcm9jZXNzaW5nIGRpbXNcbiAgICAgIGlmIChtYXliZURpbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgbWF5YmVEaW1zID0gW2RhdGEubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWF5YmVEaW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZW5zb3IncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXlcIik7XG4gICAgICB9XG4gICAgICBkaW1zID0gbWF5YmVEaW1zIGFzIHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGNoZWNrIG9uIGRpbXNcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAvLyBpZiBkYXRhIGlzIG9uIENQVSwgY2hlY2sgd2hldGhlciBkYXRhIGxlbmd0aCBtYXRjaGVzIHRlbnNvciBzaXplXG4gICAgaWYgKHRoaXMuY3B1RGF0YSAmJiBzaXplICE9PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICBpZiAoKHR5cGUgPT09ICd1aW50NCcgfHwgdHlwZSA9PT0gJ2ludDQnKSAmJiBNYXRoLmNlaWwoc2l6ZSAvIDIpID09PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGZvciAodSlpbnQ0LCB0aGUgZGF0YSBsZW5ndGggaXMgaGFsZiBvZiB0aGUgdGVuc29yIHNpemUuIFNvIHdlIGNoZWNrIHRoaXMgc3BlY2lhbCBjYXNlIHdoZW4gc2l6ZSBpcyBvZGQuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gZmFjdG9yeVxuICBzdGF0aWMgYXN5bmMgZnJvbUltYWdlKFxuICAgIGltYWdlOiBJbWFnZURhdGEgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSW1hZ2VCaXRtYXAgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86XG4gICAgICB8IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXG4gICAgICB8IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zXG4gICAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgICAgIHwgVGVuc29yRnJvbVVybE9wdGlvbnMsXG4gICk6IFByb21pc2U8VGVuc29ySW50ZXJmYWNlPiB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21JbWFnZShpbWFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5UZXh0dXJlRGF0YVR5cGVzPihcbiAgICB0ZXh0dXJlOiBUZW5zb3JUZXh0dXJlVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXG4gICk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21UZXh0dXJlKHRleHR1cmUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgIGdwdUJ1ZmZlcjogVGVuc29yR3B1QnVmZmVyVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPixcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21NTFRlbnNvcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcbiAgICBtbFRlbnNvcjogVGVuc29yTUxUZW5zb3JUeXBlLFxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VD4sXG4gICk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21NTFRlbnNvcihtbFRlbnNvciwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkNwdVBpbm5lZERhdGFUeXBlcz4oXG4gICAgdHlwZTogVCxcbiAgICBidWZmZXI6IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZU1hcFtUXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKTtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGNvbnZlcnNpb25zXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRlbnNvclRvRGF0YVVSTCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRvSW1hZ2VEYXRhKG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEge1xuICAgIHJldHVybiB0ZW5zb3JUb0ltYWdlRGF0YSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwdWJsaWMgZmllbGRzXG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB0eXBlOiBUZW5zb3JUeXBlO1xuICByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByaXZhdGUgZmllbGRzXG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRhdGFMb2NhdGlvbjogVGVuc29yRGF0YUxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIGRhdGEgb24gQ1BVLCBpZiBsb2NhdGlvbiBpcyAnY3B1JyBvciAnY3B1LXBpbm5lZCcuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgY3B1RGF0YT86IFRlbnNvckRhdGFUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgdGV4dHVyZSB3aGVuIGxvY2F0aW9uIGlzICd0ZXh0dXJlJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVUZXh0dXJlRGF0YT86IFRlbnNvclRleHR1cmVUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgR1BVIGJ1ZmZlciB3aGVuIGxvY2F0aW9uIGlzICdncHUtYnVmZmVyJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVCdWZmZXJEYXRhPzogVGVuc29yR3B1QnVmZmVyVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSB1bmRlcmx5aW5nIFdlYk5OIE1MVGVuc29yIHdoZW4gbG9jYXRpb24gaXMgJ21sLXRlbnNvcicuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgbWxUZW5zb3JEYXRhPzogVGVuc29yTUxUZW5zb3JUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZG93bmxvYWRlciBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIHByaXZhdGUgZG93bmxvYWRlcj8oKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT47XG5cbiAgLyoqXG4gICAqIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgaXMgYmVpbmcgZG93bmxvYWRlZCBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGlzRG93bmxvYWRpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZGlzcG9zZXIgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwb3Nlcj8oKTogdm9pZDtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvcGVydGllc1xuICBnZXQgZGF0YSgpOiBUZW5zb3JEYXRhVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5jcHVEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcbiAgICAgICAgICAnb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LicsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcHVEYXRhO1xuICB9XG5cbiAgZ2V0IGxvY2F0aW9uKCk6IFRlbnNvckRhdGFMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9uO1xuICB9XG5cbiAgZ2V0IHRleHR1cmUoKTogVGVuc29yVGV4dHVyZVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1VGV4dHVyZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhO1xuICB9XG5cbiAgZ2V0IGdwdUJ1ZmZlcigpOiBUZW5zb3JHcHVCdWZmZXJUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XG4gIH1cblxuICBnZXQgbWxUZW5zb3IoKTogVGVuc29yTUxUZW5zb3JUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLm1sVGVuc29yRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1sVGVuc29yRGF0YTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRob2RzXG5cbiAgYXN5bmMgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvckRhdGFUeXBlPiB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIHN3aXRjaCAodGhpcy5kYXRhTG9jYXRpb24pIHtcbiAgICAgIGNhc2UgJ2NwdSc6XG4gICAgICBjYXNlICdjcHUtcGlubmVkJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgIGlmICghdGhpcy5kb3dubG9hZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VyKCk7XG4gICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmNwdURhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdUJ1ZmZlckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tbFRlbnNvckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ25vbmUnO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gdGVuc29yIHV0aWxpdGllc1xuICBwcml2YXRlIGVuc3VyZVZhbGlkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRhdGFMb2NhdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcmVzaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICh0aGlzLmRvd25sb2FkZXIgfHwgdGhpcy5kaXNwb3Nlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGVuc29yUmVzaGFwZSh0aGlzLCBkaW1zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvckZhY3RvcnkgfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQgeyBUeXBlZFRlbnNvclV0aWxzIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMuanMnO1xuaW1wb3J0IHsgVHJ5R2V0R2xvYmFsVHlwZSB9IGZyb20gJy4vdHlwZS1oZWxwZXIuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbi8qKlxuICogcmVwcmVzZW50IGEgYmFzaWMgdGVuc29yIHdpdGggc3BlY2lmaWVkIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZS5cbiAqL1xuaW50ZXJmYWNlIFR5cGVkVGVuc29yQmFzZTxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogVDtcbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIENQVSAoZWcuIGl0J3MgaW4gdGhlIGZvcm0gb2YgV2ViR0wgdGV4dHVyZSBvciBXZWJHUFUgYnVmZmVyKSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb247XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdMIHRleHR1cmUgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR0wgdGV4dHVyZSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR1BVIGJ1ZmZlciwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYk5OIE1MVGVuc29yIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3QgaW4gYSBXZWJOTiBNTFRlbnNvciwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBtbFRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZTtcblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBDUFUsIHJldHVybnMgdGhlIGRhdGEgaW1tZWRpYXRlbHkuXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgZG93bmxvYWRzIHRoZSBkYXRhIGFuZCByZXR1cm5zIHRoZSBwcm9taXNlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVsZWFzZURhdGEgLSB3aGV0aGVyIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVLiBJZ25vcmUgaWYgZGF0YSBpcyBhbHJlYWR5IG9uIENQVS5cbiAgICovXG4gIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGVNYXBbVF0+O1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZW1vdmUgaXRzIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBHUFUsIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVLlxuICAgKlxuICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIHRoZSB0ZW5zb3IgaXMgY29uc2lkZXJlZCBubyBsb25nZXIgdmFsaWQuIEl0cyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnbm9uZScuXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUZW5zb3Ige1xuICBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheTtcbiAgICB1aW50ODogVWludDhBcnJheTtcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XG4gICAgdWludDE2OiBVaW50MTZBcnJheTtcbiAgICBpbnQxNjogSW50MTZBcnJheTtcbiAgICBpbnQzMjogSW50MzJBcnJheTtcbiAgICBpbnQ2NDogQmlnSW50NjRBcnJheTtcbiAgICBzdHJpbmc6IHN0cmluZ1tdO1xuICAgIGJvb2w6IFVpbnQ4QXJyYXk7XG4gICAgZmxvYXQxNjogVWludDE2QXJyYXk7IC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXk7XG4gICAgdWludDMyOiBVaW50MzJBcnJheTtcbiAgICB1aW50NjQ6IEJpZ1VpbnQ2NEFycmF5O1xuICAgIC8vIGNvbXBsZXg2NDogbmV2ZXI7XG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XG4gICAgLy8gYmZsb2F0MTY6IG5ldmVyO1xuICAgIHVpbnQ0OiBVaW50OEFycmF5O1xuICAgIGludDQ6IEludDhBcnJheTtcbiAgfVxuXG4gIGludGVyZmFjZSBFbGVtZW50VHlwZU1hcCB7XG4gICAgZmxvYXQzMjogbnVtYmVyO1xuICAgIHVpbnQ4OiBudW1iZXI7XG4gICAgaW50ODogbnVtYmVyO1xuICAgIHVpbnQxNjogbnVtYmVyO1xuICAgIGludDE2OiBudW1iZXI7XG4gICAgaW50MzI6IG51bWJlcjtcbiAgICBpbnQ2NDogYmlnaW50O1xuICAgIHN0cmluZzogc3RyaW5nO1xuICAgIGJvb2w6IGJvb2xlYW47XG4gICAgZmxvYXQxNjogbnVtYmVyOyAvLyBLZWVwIHVzaW5nIFVpbnQxNkFycmF5IHVudGlsIHdlIGhhdmUgYSBjb25jcmV0ZSBzb2x1dGlvbiBmb3IgZmxvYXQgMTYuXG4gICAgZmxvYXQ2NDogbnVtYmVyO1xuICAgIHVpbnQzMjogbnVtYmVyO1xuICAgIHVpbnQ2NDogYmlnaW50O1xuICAgIC8vIGNvbXBsZXg2NDogbmV2ZXI7XG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XG4gICAgLy8gYmZsb2F0MTY6IG5ldmVyO1xuICAgIHVpbnQ0OiBudW1iZXI7XG4gICAgaW50NDogbnVtYmVyO1xuICB9XG5cbiAgdHlwZSBEYXRhVHlwZSA9IERhdGFUeXBlTWFwW1R5cGVdO1xuICB0eXBlIEVsZW1lbnRUeXBlID0gRWxlbWVudFR5cGVNYXBbVHlwZV07XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHBpbm5lZCBDUFUgYnVmZmVyXG4gICAqL1xuICBleHBvcnQgdHlwZSBDcHVQaW5uZWREYXRhVHlwZXMgPSBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz47XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVUeXBlID0gV2ViR0xUZXh0dXJlO1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXG4gICAqL1xuICBleHBvcnQgdHlwZSBUZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInO1xuXG4gIHR5cGUgR3B1QnVmZmVyVHlwZUZhbGxiYWNrID0geyBzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCcgfTtcbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIEdwdUJ1ZmZlclR5cGUgPSBUcnlHZXRHbG9iYWxUeXBlPCdHUFVCdWZmZXInLCBHcHVCdWZmZXJUeXBlRmFsbGJhY2s+O1xuXG4gIHR5cGUgTUxUZW5zb3JUeXBlRmFsbGJhY2sgPSB7IGRlc3Ryb3koKTogdm9pZCB9O1xuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViTk4gTUxUZW5zb3JcbiAgICpcbiAgICogVGhlIHNwZWNpZmljYXRpb24gZm9yIFdlYk5OJ3MgTUxUZW5zb3IgaXMgY3VycmVudGx5IGluIGZsdXguXG4gICAqL1xuICBleHBvcnQgdHlwZSBNTFRlbnNvclR5cGUgPSBUcnlHZXRHbG9iYWxUeXBlPCdNTFRlbnNvcicsIE1MVGVuc29yVHlwZUZhbGxiYWNrPjtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyRGF0YVR5cGVzID0gJ2Zsb2F0MzInIHwgJ2Zsb2F0MTYnIHwgJ2ludDMyJyB8ICdpbnQ2NCcgfCAndWludDMyJyB8ICd1aW50OCcgfCAnYm9vbCc7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBNTFRlbnNvckRhdGFUeXBlcyA9XG4gICAgfCAnZmxvYXQzMidcbiAgICB8ICdmbG9hdDE2J1xuICAgIHwgJ2ludDgnXG4gICAgfCAndWludDgnXG4gICAgfCAnaW50MzInXG4gICAgfCAndWludDMyJ1xuICAgIHwgJ2ludDY0J1xuICAgIHwgJ3VpbnQ2NCdcbiAgICB8ICdib29sJ1xuICAgIHwgJ3VpbnQ0J1xuICAgIHwgJ2ludDQnO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnQgd2hlcmUgdGhlIHRlbnNvciBkYXRhIGlzIHN0b3JlZFxuICAgKi9cbiAgZXhwb3J0IHR5cGUgRGF0YUxvY2F0aW9uID0gJ25vbmUnIHwgJ2NwdScgfCAnY3B1LXBpbm5lZCcgfCAndGV4dHVyZScgfCAnZ3B1LWJ1ZmZlcicgfCAnbWwtdGVuc29yJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHRoZSBkYXRhIHR5cGUgb2YgYSB0ZW5zb3JcbiAgICovXG4gIGV4cG9ydCB0eXBlIFR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUeXBlZFRlbnNvcjxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IGV4dGVuZHMgVHlwZWRUZW5zb3JCYXNlPFQ+LCBUeXBlZFRlbnNvclV0aWxzPFQ+IHt9XG4vKipcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvciBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUZW5zb3IuVHlwZT4sIFR5cGVkVGVuc29yVXRpbHM8VGVuc29yLlR5cGU+IHt9XG5cbi8qKlxuICogdHlwZSBUZW5zb3JDb25zdHJ1Y3RvciBkZWZpbmVzIHRoZSBjb25zdHJ1Y3RvcnMgb2YgJ1RlbnNvcicgdG8gY3JlYXRlIENQVSB0ZW5zb3IgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckNvbnN0cnVjdG9yIGV4dGVuZHMgVGVuc29yRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIHNwZWNpZnkgZWxlbWVudCB0eXBlXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXSB8IHJlYWRvbmx5IHN0cmluZ1tdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8J3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9vbCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6ICdib29sJyxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Jvb2wnXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPCdib29sJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gYSBVaW50OENsYW1wZWRBcnJheSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAodHlwZTogJ3VpbnQ4JywgZGF0YTogVWludDhDbGFtcGVkQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgNjQtYml0IGludGVnZXIgdHlwZWQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IDxUIGV4dGVuZHMgJ3VpbnQ2NCcgfCAnaW50NjQnPihcbiAgICB0eXBlOiBULFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSB8IHJlYWRvbmx5IGJpZ2ludFtdIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjxUPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IG51bWVyaWMgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IDxUIGV4dGVuZHMgRXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZycgfCAnYm9vbCcgfCAndWludDY0JyB8ICdpbnQ2NCc+PihcbiAgICB0eXBlOiBULFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSB8IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBpbmZlciBlbGVtZW50IHR5cGVzXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBmbG9hdDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBGbG9hdDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDhBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDhDbGFtcGVkQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBVaW50MTZBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQxNic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEludDE2QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQxNic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEJpZ0ludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ2NCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiByZWFkb25seSBzdHJpbmdbXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3N0cmluZyc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgYm9vbCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogcmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogRmxvYXQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQ2NCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBVaW50MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBCaWdVaW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ2NCc+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBmYWxsIGJhY2sgdG8gbm9uLWdlbmVyaWMgdGVuc29yIHR5cGUgZGVjbGFyYXRpb25cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoXG4gICAgdHlwZTogVGVuc29yLlR5cGUsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJpZ2ludFtdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVGVuc29yO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFRlbnNvci5EYXRhVHlwZSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yO1xuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBUZW5zb3IgPSBUZW5zb3JJbXBsIGFzIFRlbnNvckNvbnN0cnVjdG9yO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuL2Vudi1pbXBsLmpzJztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRSA9IChkZXZpY2VUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLnRpbWVTdGFtcChgJHtkZXZpY2VUeXBlfTo6T1JUOjoke2xhYmVsfWApO1xufTtcblxuY29uc3QgVFJBQ0VfRlVOQyA9IChtc2c6IHN0cmluZywgZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpIHx8IFtdO1xuICBsZXQgaGFzVHJhY2VGdW5jID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzVHJhY2VGdW5jICYmICFzdGFja1tpXS5pbmNsdWRlcygnVFJBQ0VfRlVOQycpKSB7XG4gICAgICBsZXQgbGFiZWwgPSBgRlVOQ18ke21zZ306OiR7c3RhY2tbaV0udHJpbSgpLnNwbGl0KCcgJylbMV19YDtcbiAgICAgIGlmIChleHRyYU1zZykge1xuICAgICAgICBsYWJlbCArPSBgOjoke2V4dHJhTXNnfWA7XG4gICAgICB9XG4gICAgICBUUkFDRSgnQ1BVJywgbGFiZWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgaGFzVHJhY2VGdW5jID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19CRUdJTiA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFRSQUNFX0ZVTkMoJ0JFR0lOJywgZXh0cmFNc2cpO1xufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRV9GVU5DX0VORCA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFRSQUNFX0ZVTkMoJ0VORCcsIGV4dHJhTXNnKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRVZFTlRfQkVHSU4gPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLnRpbWUoYE9SVDo6JHtleHRyYU1zZ31gKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRVZFTlRfRU5EID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS50aW1lRW5kKGBPUlQ6OiR7ZXh0cmFNc2d9YCk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZSB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5ELCBUUkFDRV9FVkVOVF9CRUdJTiwgVFJBQ0VfRVZFTlRfRU5EIH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIFRSQUNFX0VWRU5UX0JFR0lOKCdJbmZlcmVuY2VTZXNzaW9uLnJ1bicpO1xuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRVZFTlRfRU5EKCdJbmZlcmVuY2VTZXNzaW9uLnJ1bicpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgYXN5bmMgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUocGF0aDogc3RyaW5nLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKFxuICAgIGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLFxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgICBieXRlTGVuZ3RoPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoXG4gICAgYXJnMDogc3RyaW5nIHwgQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheSxcbiAgICBhcmcxPzogU2Vzc2lvbk9wdGlvbnMgfCBudW1iZXIsXG4gICAgYXJnMj86IG51bWJlcixcbiAgICBhcmczPzogU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUnKTtcbiAgICAvLyBlaXRoZXIgbG9hZCBmcm9tIGEgZmlsZSBvciBidWZmZXJcbiAgICBsZXQgZmlsZVBhdGhPclVpbnQ4QXJyYXk6IHN0cmluZyB8IFVpbnQ4QXJyYXk7XG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXG4gICAgKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICBieXRlT2Zmc2V0ID0gYXJnMTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlT2Zmc2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzI7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSAncGF0aCcgb3IgJ2J1ZmZlcicuXCIpO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgYmFja2VuZCwgdXBkYXRlIHNlc3Npb24gb3B0aW9ucyB3aXRoIHZhbGlkYXRlZCBFUHMsIGFuZCBjcmVhdGUgc2Vzc2lvbiBoYW5kbGVyXG4gICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQcyk7XG4gICAgVFJBQ0VfRVZFTlRfRU5EKCdJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZScpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIG5ldyBJbmZlcmVuY2VTZXNzaW9uKGhhbmRsZXIpO1xuICB9XG5cbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCk7XG4gIH1cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKTtcbiAgfVxuXG4gIGdldCBpbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IG91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgZ2V0IGlucHV0TWV0YWRhdGEoKTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5WYWx1ZU1ldGFkYXRhW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXRNZXRhZGF0YTtcbiAgfVxuXG4gIGdldCBvdXRwdXRNZXRhZGF0YSgpOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlZhbHVlTWV0YWRhdGFbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXRNZXRhZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xuaW1wb3J0IHsgT25ueE1vZGVsT3B0aW9ucyB9IGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUsIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgdHlwZSB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRyeUdldEdsb2JhbFR5cGUgfSBmcm9tICcuL3R5cGUtaGVscGVyLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gaW5wdXQvb3V0cHV0IHR5cGVzXG5cbiAgdHlwZSBPbm54VmFsdWVNYXBUeXBlID0geyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG4gIHR5cGUgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlID0geyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbCB9O1xuXG4gIC8qKlxuICAgKiBBIGZlZWRzIChtb2RlbCBpbnB1dHMpIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBGZWVkc1R5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8qKlxuICAgKiBBIGZldGNoZXMgKG1vZGVsIG91dHB1dHMpIGNvdWxkIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAtIE9taXR0ZWQuIFVzZSBtb2RlbCdzIG91dHB1dCBuYW1lcyBkZWZpbml0aW9uLlxuICAgKiAtIEFuIGFycmF5IG9mIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBvdXRwdXQgbmFtZXMuXG4gICAqIC0gQW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgb3IgbnVsbCBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya1xuICAgKiBkaWZmZXJlbnQgZnJvbSBpbnB1dCBhcmd1bWVudCwgaW4gb3V0cHV0LCBPbm54VmFsdWUgaXMgb3B0aW9uYWwuIElmIGFuIE9ubnhWYWx1ZSBpcyBwcmVzZW50IGl0IHdpbGwgYmVcbiAgICogdXNlZCBhcyBhIHByZS1hbGxvY2F0ZWQgdmFsdWUgYnkgdGhlIGluZmVyZW5jZSBlbmdpbmU7IGlmIG9taXR0ZWQsIGluZmVyZW5jZSBlbmdpbmUgd2lsbCBhbGxvY2F0ZSBidWZmZXJcbiAgICogaW50ZXJuYWxseS5cbiAgICovXG4gIHR5cGUgRmV0Y2hlc1R5cGUgPSByZWFkb25seSBzdHJpbmdbXSB8IE51bGxhYmxlT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBpbmZlcmVuY2luZyByZXR1cm4gdHlwZSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICB0eXBlIFJldHVyblR5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHNlc3Npb24gb3B0aW9uc1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBjb25maWd1cmF0aW9ucyBmb3Igc2Vzc2lvbiBiZWhhdmlvci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbk9wdGlvbnMgZXh0ZW5kcyBPbm54TW9kZWxPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEFuIGV4ZWN1dGlvbiBwcm92aWRlciBvcHRpb24gY2FuIGJlIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIG5hbWUgb2YgdGhlIGV4ZWN1dGlvbiBwcm92aWRlcixcbiAgICAgKiBvciBhbiBvYmplY3Qgb2YgY29ycmVzcG9uZGluZyB0eXBlLlxuICAgICAqL1xuICAgIGV4ZWN1dGlvblByb3ZpZGVycz86IHJlYWRvbmx5IEV4ZWN1dGlvblByb3ZpZGVyQ29uZmlnW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50cmEgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRyYU9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlciBPUCB0aHJlYWRzIG51bWJlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGludGVyT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGZyZWVEaW1lbnNpb25PdmVycmlkZXM/OiB7IHJlYWRvbmx5IFtkaW1lbnNpb25OYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpbWl6YXRpb24gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD86ICdkaXNhYmxlZCcgfCAnYmFzaWMnIHwgJ2V4dGVuZGVkJyB8ICdsYXlvdXQnIHwgJ2FsbCc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBDUFUgbWVtb3J5IGFyZW5hLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZUNwdU1lbUFyZW5hPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIG1lbW9yeSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGVuYWJsZU1lbVBhdHRlcm4/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZXhlY3V0aW9uTW9kZT86ICdzZXF1ZW50aWFsJyB8ICdwYXJhbGxlbCc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgbW9kZWwgZmlsZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzZXR0aW5nIGlzIHNwZWNpZmllZCwgdGhlIG9wdGltaXplZCBtb2RlbCB3aWxsIGJlIGR1bXBlZC4gSW4gYnJvd3NlciwgYSBibG9iIHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIHdpdGggYSBwb3AtdXAgd2luZG93LlxuICAgICAqL1xuICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGg/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIGVuYWJsZVByb2ZpbGluZz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBGaWxlIHByZWZpeCBmb3IgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgZnV0dXJlIHVzZS5cbiAgICAgKi9cbiAgICBwcm9maWxlRmlsZVByZWZpeD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBJRC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dJZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMCB8IDEgfCAyIHwgMyB8IDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHJpbmcgYXMgYSBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBmb3IgYWxsIG91dHB1dHMsIG9yIGFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgYVxuICAgICAqIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIFdlYiBmb3IgV2ViR0wgYW5kIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj86IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB8IHsgcmVhZG9ubHkgW291dHB1dE5hbWU6IHN0cmluZ106IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgZ3JhcGggY2FwdHVyZS5cbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHUFUgRVAuXG4gICAgICovXG4gICAgZW5hYmxlR3JhcGhDYXB0dXJlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIGNvbmZpZ3VyYXRpb25zIGZvciBhIHNlc3Npb24uIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9zZXNzaW9uL1xuICAgICAqIG9ubnhydW50aW1lX3Nlc3Npb25fb3B0aW9uc19jb25maWdfa2V5cy5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIHNlc3Npb246IHtcbiAgICAgKiAgICAgc2V0X2Rlbm9ybWFsX2FzX3plcm86IFwiMVwiLFxuICAgICAqICAgICBkaXNhYmxlX3ByZXBhY2tpbmc6IFwiMVwiXG4gICAgICogICB9LFxuICAgICAqICAgb3B0aW1pemF0aW9uOiB7XG4gICAgICogICAgIGVuYWJsZV9nZWx1X2FwcHJveGltYXRpb246IFwiMVwiXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjcmVnaW9uIGV4ZWN1dGlvbiBwcm92aWRlcnNcblxuICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBiYWNrZW5kcyB0byBzdXBwb3J0IGV4ZWN1dGlvbiBwcm92aWRlcnM6XG4gIC8vIEJhY2tlbmQgTm9kZS5qcyBiaW5kaW5nOiBzdXBwb3J0cyAnY3B1JywgJ2RtbCcgKHdpbjMyKSwgJ2NvcmVtbCcgKG1hY09TKSBhbmQgJ2N1ZGEnIChsaW51eCkuXG4gIC8vIEJhY2tlbmQgV2ViQXNzZW1ibHk6IHN1cHBvcnRzICdjcHUnLCAnd2FzbScsICd3ZWJncHUnIGFuZCAnd2Vibm4nLlxuICAvLyBCYWNrZW5kIE9OTlguanM6IHN1cHBvcnRzICd3ZWJnbCcuXG4gIC8vIEJhY2tlbmQgUmVhY3QgTmF0aXZlOiBzdXBwb3J0cyAnY3B1JywgJ3hubnBhY2snLCAnY29yZW1sJyAoaU9TKSwgJ25uYXBpJyAoQW5kcm9pZCkuXG4gIGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcCB7XG4gICAgY29yZW1sOiBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBjcHU6IENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGN1ZGE6IEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBkbWw6IERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIG5uYXBpOiBObmFwaUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHRlbnNvcnJ0OiBUZW5zb3JSdEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdhc206IFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ2w6IFdlYkdMRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ3B1OiBXZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJubjogV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBxbm46IFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHhubnBhY2s6IFhubnBhY2tFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgfVxuXG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJOYW1lID0ga2V5b2YgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXA7XG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJDb25maWcgPVxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXBbRXhlY3V0aW9uUHJvdmlkZXJOYW1lXVxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25cbiAgICB8IEV4ZWN1dGlvblByb3ZpZGVyTmFtZVxuICAgIHwgc3RyaW5nO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjcHUnO1xuICAgIHVzZUFyZW5hPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY3VkYSc7XG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBEbWxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnZG1sJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3RlbnNvcnJ0JztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dhc20nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2ViZ2wnO1xuICAgIC8vIFRPRE86IGFkZCBmbGFnc1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd4bm5wYWNrJztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJncHUnO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgcHJlZmVycmVkIGxheW91dCB3aGVuIHJ1bm5pbmcgbGF5b3V0IHNlbnNpdGl2ZSBvcGVyYXRvcnMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAnTkNIVydcbiAgICAgKi9cbiAgICBwcmVmZXJyZWRMYXlvdXQ/OiAnTkNIVycgfCAnTkhXQyc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgbGlzdCBvZiBub2RlIG5hbWVzIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIG9uIENQVSBldmVuIHdoZW4gV2ViR1BVIEVQIGlzIHVzZWQuXG4gICAgICovXG4gICAgZm9yY2VDcHVOb2RlTmFtZXM/OiByZWFkb25seSBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHZhbGlkYXRpb24gbW9kZSBmb3IgV2ViR1BVIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICAgKiAtICdkaXNhYmxlZCc6IERpc2FibGUgYWxsIHZhbGlkYXRpb24uXG4gICAgICogV2hlbiB1c2VkIGluIE5vZGUuanMsIGRpc2FibGUgdmFsaWRhdGlvbiBtYXkgY2F1c2UgcHJvY2VzcyBjcmFzaCBpZiBXZWJHUFUgZXJyb3JzIG9jY3VyLiBCZSBjYXV0aW91cyB3aGVuIHVzaW5nXG4gICAgICogdGhpcyBtb2RlLlxuICAgICAqIFdoZW4gdXNlZCBpbiB3ZWIsIHRoaXMgbW9kZSBpcyBlcXVpdmFsZW50IHRvICd3Z3B1T25seScuXG4gICAgICogLSAnd2dwdU9ubHknOiBQZXJmb3JtIFdlYkdQVSBpbnRlcm5hbCB2YWxpZGF0aW9uIG9ubHkuXG4gICAgICogLSAnYmFzaWMnOiBQZXJmb3JtIGJhc2ljIHZhbGlkYXRpb24gaW5jbHVkaW5nIFdlYkdQVSBpbnRlcm5hbCB2YWxpZGF0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IG1vZGUuXG4gICAgICogLSAnZnVsbCc6IFBlcmZvcm0gZnVsbCB2YWxpZGF0aW9uLiBUaGlzIG1vZGUgbWF5IGhhdmUgcGVyZm9ybWFuY2UgaW1wYWN0LiBVc2UgaXQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgJ2Jhc2ljJ1xuICAgICAqL1xuICAgIHZhbGlkYXRpb25Nb2RlPzogJ2Rpc2FibGVkJyB8ICd3Z3B1T25seScgfCAnYmFzaWMnIHwgJ2Z1bGwnO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBhbiBvcHRpb25hbCBXZWJHUFUgZGV2aWNlIHRvIGJlIHVzZWQgYnkgdGhlIFdlYkdQVSBleGVjdXRpb24gcHJvdmlkZXIuXG4gICAgICovXG4gICAgZGV2aWNlPzogVHJ5R2V0R2xvYmFsVHlwZTwnR1BVRGV2aWNlJz47XG4gIH1cblxuICAvLyAjcmVnaW9uIFdlYk5OIG9wdGlvbnNcblxuICBpbnRlcmZhY2UgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUgZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYm5uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgV2ViTk4gTUxDb250ZXh0LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZGljdGRlZi1tbGNvbnRleHRvcHRpb25zXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OQ29udGV4dE9wdGlvbnMge1xuICAgIGRldmljZVR5cGU/OiAnY3B1JyB8ICdncHUnIHwgJ25wdSc7XG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcbiAgICBwb3dlclByZWZlcmVuY2U/OiAnZGVmYXVsdCcgfCAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRob3V0IE1MQ29udGV4dC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dCBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lLCBXZWJOTkNvbnRleHRPcHRpb25zIHtcbiAgICBjb250ZXh0PzogbmV2ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQuXG4gICAqXG4gICAqIFdoZW4gTUxDb250ZXh0IGlzIHByb3ZpZGVkLCB0aGUgZGV2aWNlVHlwZSBpcyBhbHNvIHJlcXVpcmVkIHNvIHRoYXQgdGhlIFdlYk5OIEVQIGNhbiBkZXRlcm1pbmUgdGhlIHByZWZlcnJlZFxuICAgKiBjaGFubmVsIGxheW91dC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RvbS1tbC1jcmVhdGVjb250ZXh0XG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dpdGhNTENvbnRleHRcbiAgICBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lLFxuICAgICAgT21pdDxXZWJOTkNvbnRleHRPcHRpb25zLCAnZGV2aWNlVHlwZSc+LFxuICAgICAgUmVxdWlyZWQ8UGljazxXZWJOTkNvbnRleHRPcHRpb25zLCAnZGV2aWNlVHlwZSc+PiB7XG4gICAgY29udGV4dDogVHJ5R2V0R2xvYmFsVHlwZTwnTUxDb250ZXh0Jz47XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQgd2hpY2ggaXMgY3JlYXRlZCBmcm9tIEdQVURldmljZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RvbS1tbC1jcmVhdGVjb250ZXh0LWdwdWRldmljZVxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXZWJHcHUgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSB7XG4gICAgY29udGV4dDogVHJ5R2V0R2xvYmFsVHlwZTwnTUxDb250ZXh0Jz47XG4gICAgZ3B1RGV2aWNlOiBUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPjtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIuXG4gICAqL1xuICBleHBvcnQgdHlwZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uID1cbiAgICB8IFdlYk5OT3B0aW9uc1dpdGhvdXRNTENvbnRleHRcbiAgICB8IFdlYk5OT3B0aW9uc1dpdGhNTENvbnRleHRcbiAgICB8IFdlYk5OT3B0aW9uc1dlYkdwdTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgZXhwb3J0IGludGVyZmFjZSBRbm5FeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAncW5uJztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBRTk4gYmFja2VuZCB0eXBlLiBFLmcuLCAnY3B1JyBvciAnaHRwJy5cbiAgICAgKiBNdXR1YWxseSBleGNsdXNpdmUgd2l0aCBgYmFja2VuZFBhdGhgLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgJ2h0cCdcbiAgICAgKi9cbiAgICBiYWNrZW5kVHlwZT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGEgcGF0aCB0byB0aGUgUU5OIGJhY2tlbmQgbGlicmFyeS5cbiAgICAgKiBNdXR1YWxseSBleGNsdXNpdmUgd2l0aCBgYmFja2VuZFR5cGVgLlxuICAgICAqL1xuICAgIGJhY2tlbmRQYXRoPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBlbmFibGUgSFRQIEZQMTYgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZUZwMTZQcmVjaXNpb24/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29yZU1MRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NvcmVtbCc7XG4gICAgLyoqXG4gICAgICogVGhlIGJpdCBmbGFncyBmb3IgQ29yZU1MIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIENPUkVNTF9GTEFHX1VTRV9DUFVfT05MWSA9IDB4MDAxXG4gICAgICogQ09SRU1MX0ZMQUdfRU5BQkxFX09OX1NVQkdSQVBIID0gMHgwMDJcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0VOQUJMRV9ERVZJQ0VfV0lUSF9BTkUgPSAweDAwNFxuICAgICAqIENPUkVNTF9GTEFHX09OTFlfQUxMT1dfU1RBVElDX0lOUFVUX1NIQVBFUyA9IDB4MDA4XG4gICAgICogQ09SRU1MX0ZMQUdfQ1JFQVRFX01MUFJPR1JBTSA9IDB4MDEwXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9BTkRfR1BVID0gMHgwMjBcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBpbmNsdWRlL29ubnhydW50aW1lL2NvcmUvcHJvdmlkZXJzL2NvcmVtbC9jb3JlbWxfcHJvdmlkZXJfZmFjdG9yeS5oIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZsYWcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZykuXG4gICAgICovXG4gICAgY29yZU1sRmxhZ3M/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIHVzZSBDUFUgb25seSBpbiBDb3JlTUwgRVAuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgdXNlQ1BVT25seT86IGJvb2xlYW47XG4gICAgdXNlQ1BVQW5kR1BVPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHdoZXRoZXIgdG8gZW5hYmxlIENvcmVNTCBFUCBvbiBzdWJncmFwaC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBlbmFibGVPblN1YmdyYXBoPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHdoZXRoZXIgdG8gb25seSBlbmFibGUgQ29yZU1MIEVQIGZvciBBcHBsZSBkZXZpY2VzIHdpdGggQU5FIChBcHBsZSBOZXVyYWwgRW5naW5lKS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBvbmx5RW5hYmxlRGV2aWNlV2l0aEFORT86IGJvb2xlYW47XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBObmFwaUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdubmFwaSc7XG4gICAgdXNlRlAxNj86IGJvb2xlYW47XG4gICAgdXNlTkNIVz86IGJvb2xlYW47XG4gICAgY3B1RGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGNwdU9ubHk/OiBib29sZWFuO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBydW4gb3B0aW9uc1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBjb25maWd1cmF0aW9ucyBmb3IgaW5mZXJlbmNlIHJ1biBiZWhhdmlvclxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBSdW5PcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBMb2cgc2V2ZXJpdHkgbGV2ZWwuIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9jb21tb24vbG9nZ2luZy9zZXZlcml0eS5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgbG9nU2V2ZXJpdHlMZXZlbD86IDAgfCAxIHwgMiB8IDMgfCA0O1xuXG4gICAgLyoqXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICBsb2dWZXJib3NpdHlMZXZlbD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZSBhbGwgaW5jb21wbGV0ZSBPcnRSdW4gY2FsbHMgYXMgc29vbiBhcyBwb3NzaWJsZSBpZiB0cnVlXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgdGVybWluYXRlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEEgdGFnIGZvciB0aGUgUnVuKCkgY2FsbHMgdXNpbmcgdGhpc1xuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIHRhZz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIHNpbmdsZSBydW4gY29uZmlndXJhdGlvbiBlbnRyeS4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfcnVuX29wdGlvbnNfY29uZmlnX2tleXMuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIG1lbW9yeToge1xuICAgICAqICAgICBlbmFibGVfbWVtb3J5X2FyZW5hX3Nocmlua2FnZTogXCIxXCIsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB2YWx1ZSBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBUaGUgY29tbW9uIHBhcnQgb2YgdGhlIHZhbHVlIG1ldGFkYXRhIHR5cGUgZm9yIGJvdGggdGVuc29yIGFuZCBub24tdGVuc29yIHZhbHVlcy5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFsdWVNZXRhZGF0YUJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzcGVjaWZpZWQgaW5wdXQgb3Igb3V0cHV0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIHRoZSBtZXRhZGF0YSBvZiBhIG5vbi10ZW5zb3IgdmFsdWUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIE5vblRlbnNvclZhbHVlTWV0YWRhdGEgZXh0ZW5kcyBWYWx1ZU1ldGFkYXRhQmFzZSB7XG4gICAgLyoqXG4gICAgICogR2V0IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHRlbnNvci5cbiAgICAgKi9cbiAgICByZWFkb25seSBpc1RlbnNvcjogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGUgbWV0YWRhdGEgb2YgYSB0ZW5zb3IgdmFsdWUuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclZhbHVlTWV0YWRhdGEgZXh0ZW5kcyBWYWx1ZU1ldGFkYXRhQmFzZSB7XG4gICAgLyoqXG4gICAgICogR2V0IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHRlbnNvci5cbiAgICAgKi9cbiAgICByZWFkb25seSBpc1RlbnNvcjogdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHR5cGU6IFRlbnNvci5UeXBlO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2hhcGUgb2YgdGhlIHRlbnNvci5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzaGFwZSBpcyBub3QgZGVmaW5lZCwgdGhlIHZhbHVlIHdpbGwgYW4gZW1wdHkgYXJyYXkuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBhbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHNoYXBlXG4gICAgICogb2YgdGhlIHRlbnNvci4gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcuIElmIHRoZSBlbGVtZW50IGlzIGEgbnVtYmVyLCBpdCByZXByZXNlbnRzXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgZGltZW5zaW9uIHNpemUuIElmIHRoZSBlbGVtZW50IGlzIGEgc3RyaW5nLCBpdCByZXByZXNlbnRzIGEgc3ltYm9saWMgZGltZW5zaW9uLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNoYXBlOiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz47XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGUgbWV0YWRhdGEgb2YgYSB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydCB0eXBlIFZhbHVlTWV0YWRhdGEgPSBOb25UZW5zb3JWYWx1ZU1ldGFkYXRhIHwgVGVuc29yVmFsdWVNZXRhZGF0YTtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcywgZmV0Y2hlcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvciBkZXRhaWwuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uT3V0cHV0VHlwZWAgZm9yXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBpbmZlcmVuY2UuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW4oXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xuXG4gIC8qKlxuICAgKiBTdGFydCBwcm9maWxpbmcuXG4gICAqL1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFbmQgcHJvZmlsaW5nLlxuICAgKi9cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IGlucHV0TWV0YWRhdGE6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG1ldGFkYXRhIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25GYWN0b3J5IHtcbiAgLy8gI3JlZ2lvbiBjcmVhdGUoKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBPTk5YIG1vZGVsIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgLSBUaGUgVVJJIG9yIGZpbGUgcGF0aCBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZSh1cmk6IHN0cmluZywgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gc2VnbWVudCBvZiBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBieXRlT2Zmc2V0IC0gVGhlIGJlZ2lubmluZyBvZiB0aGUgc3BlY2lmaWVkIHBvcnRpb24gb2YgdGhlIGFycmF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsXG4gICAgYnl0ZU9mZnNldDogbnVtYmVyLFxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGEgVWludDhBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEEgVWludDhBcnJheSByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IEluZmVyZW5jZVNlc3Npb246IEluZmVyZW5jZVNlc3Npb25GYWN0b3J5ID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycywgT3B0aW9uc1RlbnNvckxheW91dCB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclRvRGF0YVVybE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzaW9uVXRpbHMge1xuICAvKipcbiAgICogY3JlYXRlcyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0ZW5zb3JcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgRGF0YVVSTCBpbnN0YW5jZSBmcm9tIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYGZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogQHJldHVybnMgYSBEYXRhVVJMIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0RhdGFVUkwob3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGFuIEltYWdlRGF0YSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0ltYWdlRGF0YShvcHRpb25zPzogVGVuc29yVG9JbWFnZURhdGFPcHRpb25zKTogSW1hZ2VEYXRhO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IsIFR5cGVkVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBJbWFnZUZvcm1hdCA9ICdSR0InIHwgJ1JHQkEnIHwgJ0JHUicgfCAnUkJHJztcbmV4cG9ydCB0eXBlIEltYWdlVGVuc29yTGF5b3V0ID0gJ05IV0MnIHwgJ05DSFcnO1xuXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cblxuLy8gI3JlZ2lvbiB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvblxuXG4vKipcbiAqIHJlcHJlc2VudCBjb21tb24gcHJvcGVydGllcyBvZiB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICovXG5pbnRlcmZhY2UgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIEdQVSByZXNvdXJjZS5cbiAqL1xuaW50ZXJmYWNlIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXG4gICAqL1xuICBkb3dubG9hZD8oKTogUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGVNYXBbVF0+O1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgdGVuc29yIHRyZWF0IHRoZSBHUFUgZGF0YSBhcyBleHRlcm5hbCByZXNvdXJjZS5cbiAgICovXG4gIGRpc3Bvc2U/KCk6IHZvaWQ7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXMgPSBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAnY3B1LXBpbm5lZCcuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ2NwdS1waW5uZWQnO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgQ1BVIHBpbm5lZCBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICd0ZXh0dXJlJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAndGV4dHVyZSc7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJHTCB0ZXh0dXJlIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXMgPSBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAnZ3B1LWJ1ZmZlcicuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ2dwdS1idWZmZXInO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGdwdUJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTUxUZW5zb3JDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcyA9IFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcz5cbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ21sLXRlbnNvcicuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ21sLXRlbnNvcic7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYk5OIE1MVGVuc29yIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgbWxUZW5zb3I6IFRlbnNvci5NTFRlbnNvclR5cGU7XG59XG5cbi8vICNlbmRyZWdpb25cblxuLy8gdGhlIGZvbGxvd2luZyByZWdpb24gY29udGFpbnMgdHlwZSBkZWZpbml0aW9ucyBvZiBlYWNoIGluZGl2aWR1YWwgb3B0aW9ucy5cbi8vIHRoZSB0ZW5zb3IgZmFjdG9yeSBmdW5jdGlvbnMgdXNlIGEgY29tcG9zaXRpb24gb2YgdGhvc2Ugb3B0aW9ucyBhcyB0aGUgcGFyYW1ldGVyIHR5cGUuXG5cbi8vICNyZWdpb24gT3B0aW9ucyBmaWVsZHNcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zRm9ybWF0IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgZm9ybWF0IHJlcHJlc2VudGVkIGluIFJHQkEgY29sb3Igc3BhY2UuXG4gICAqL1xuICBmb3JtYXQ/OiBJbWFnZUZvcm1hdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRm9ybWF0IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIE5PVEU6IHRoaXMgaXMgZGlmZmVyZW50IGZyb20gb3B0aW9uICdmb3JtYXQnLiBXaGlsZSBvcHRpb24gJ2Zvcm1hdCcgcmVwcmVzZW50cyB0aGUgb3JpZ2luYWwgaW1hZ2UsICd0ZW5zb3JGb3JtYXQnXG4gICAqIHJlcHJlc2VudHMgdGhlIHRhcmdldCBmb3JtYXQgb2YgdGhlIHRlbnNvci4gQSB0cmFuc3Bvc2Ugd2lsbCBiZSBwZXJmb3JtZWQgaWYgdGhleSBhcmUgZGlmZmVyZW50LlxuICAgKi9cbiAgdGVuc29yRm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckRhdGFUeXBlIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICBkYXRhVHlwZT86ICdmbG9hdDMyJyB8ICd1aW50OCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckxheW91dCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHRlbnNvciBsYXlvdXQgd2hlbiByZXByZXNlbnRpbmcgZGF0YSBvZiBvbmUgb3IgbW9yZSBpbWFnZShzKS5cbiAgICovXG4gIHRlbnNvckxheW91dD86IEltYWdlVGVuc29yTGF5b3V0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNEaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgaGVpZ2h0IGluIHBpeGVsXG4gICAqL1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIHdpZHRoIGluIHBpeGVsXG4gICAqL1xuICB3aWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25SZXNpemVkRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHJlc2l6ZWQgaGVpZ2h0LiBJZiBvbWl0dGVkLCBvcmlnaW5hbCBoZWlnaHQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcmVzaXplZEhlaWdodD86IG51bWJlcjtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyByZXNpemVkIHdpZHRoIC0gY2FuIGJlIGFjY2Vzc2VkIHZpYSB0ZW5zb3IgZGltZW5zaW9ucyBhcyB3ZWxsXG4gICAqL1xuICByZXNpemVkV2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyBub3JtYWxpemF0aW9uIHBhcmFtZXRlcnMgd2hlbiBwcmVwcm9jZXNzaW5nIHRoZSBpbWFnZSBhcyBtb2RlbCBpbnB1dC5cbiAgICpcbiAgICogRGF0YSBlbGVtZW50IGFyZSByYW5nZWQgZnJvbSAwIHRvIDI1NS5cbiAgICovXG4gIG5vcm0/OiB7XG4gICAgLyoqXG4gICAgICogVGhlICdiaWFzJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiAtIElmIG9taXR0ZWQsIHVzZSBkZWZhdWx0IHZhbHVlIDAuXG4gICAgICogLSBJZiBpdCdzIGEgc2luZ2xlIG51bWJlciwgYXBwbHkgdG8gZWFjaCBjaGFubmVsXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XG4gICAgICovXG4gICAgYmlhcz86IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIC8qKlxuICAgICAqIFRoZSAnbWVhbicgdmFsdWUgZm9yIGltYWdlIG5vcm1hbGl6YXRpb24uXG4gICAgICogLSBJZiBvbWl0dGVkLCB1c2UgZGVmYXVsdCB2YWx1ZSAyNTUuXG4gICAgICogLSBJZiBpdCdzIGEgc2luZ2xlIG51bWJlciwgYXBwbHkgdG8gZWFjaCBjaGFubmVsXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XG4gICAgICovXG4gICAgbWVhbj86IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB9O1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gT3B0aW9ucyBjb21wb3NpdGlvblxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc1xuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVVybE9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25zRGltZW5zaW9ucyxcbiAgICBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUmVxdWlyZWQ8T3B0aW9uc0RpbWVuc2lvbnM+LFxuICAgIE9wdGlvbnNGb3JtYXQsXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gLyogVE9ETzogYWRkIG1vcmUgKi8ge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz5cbiAgZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcz5cbiAgZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiBUO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8qKlxuICogdHlwZSBUZW5zb3JGYWN0b3J5IGRlZmluZXMgdGhlIGZhY3RvcnkgZnVuY3Rpb25zIG9mICdUZW5zb3InIHRvIGNyZWF0ZSB0ZW5zb3IgaW5zdGFuY2VzIGZyb20gZXhpc3RpbmcgZGF0YSBvclxuICogcmVzb3VyY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZhY3Rvcnkge1xuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VEYXRhIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VEYXRhIC0gdGhlIEltYWdlRGF0YSBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBJbWFnZURhdGEuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShcbiAgICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgICBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsXG4gICk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VFbGVtZW50IC0gdGhlIEhUTUxJbWFnZUVsZW1lbnQgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSFRNTEltYWdlRWxlbWVudC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKFxuICAgIGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCxcbiAgICBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMsXG4gICk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gVVJMXG4gICAqXG4gICAqIEBwYXJhbSB1cmxTb3VyY2UgLSBhIHN0cmluZyBhcyBhIFVSTCB0byB0aGUgaW1hZ2Ugb3IgYSBkYXRhIFVSTCBjb250YWluaW5nIHRoZSBpbWFnZSBkYXRhLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gVVJMLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UodXJsU291cmNlOiBzdHJpbmcsIG9wdGlvbnM/OiBUZW5zb3JGcm9tVXJsT3B0aW9ucyk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VCaXRtYXAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBiaXRtYXAgLSB0aGUgSW1hZ2VCaXRtYXAgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gVVJMLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoXG4gICAgYml0bWFwOiBJbWFnZUJpdG1hcCxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICAgKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR0wgdGV4dHVyZS5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgd2lkdGhgOiB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxuICAgKiAtIGBoZWlnaHRgOiB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgZm9ybWF0YDogdGhlIGZvcm1hdCBvZiB0aGUgdGV4dHVyZS4gSWYgb21pdHRlZCwgYXNzdW1lICdSR0JBJy5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcbiAgICogd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0XG4gICAqIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXG4gICAqIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic+KFxuICAgIHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPCdmbG9hdDMyJz47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gdGhlIEdQVUJ1ZmZlciBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBXZWJHUFUgYnVmZmVyLlxuICAgKlxuICAgKiBUaGUgb3B0aW9ucyBpbmNsdWRlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAtIGBkYXRhVHlwZWA6IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYXNzdW1lICdmbG9hdDMyJy5cbiAgICogLSBgZGltc2A6IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gUmVxdWlyZWQuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gR1BVIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhXG4gICAqIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndFxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIEdQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhIHdpbGwgbm90IGJlIGRpc3Bvc2VkLlxuICAgKiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgYnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPixcbiAgKTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViTk4gTUxUZW5zb3JcbiAgICpcbiAgICogQHBhcmFtIHRlbnNvciAtIHRoZSBNTFRlbnNvciBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yLlxuICAgKlxuICAgKiBUaGUgb3B0aW9ucyBpbmNsdWRlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAtIGBkYXRhVHlwZWA6IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYXNzdW1lICdmbG9hdDMyJy5cbiAgICogLSBgZGltc2A6IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gUmVxdWlyZWQuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gdGhlIE1MVGVuc29yIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIE1MVGVuc29yXG4gICAqIGRhdGEgd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSB0aGUgV2ViTk4gYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLlxuICAgKiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIHRoZSBXZWJOTiBNTFRlbnNvci4gSWYgb21pdHRlZCwgdGhlIE1MVGVuc29yIHdpbGxcbiAgICogbm90IGJlIGRpc3Bvc2VkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IHRoZSBXZWJOTiBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG9cbiAgICogcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21NTFRlbnNvcjxUIGV4dGVuZHMgVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzPihcbiAgICB0ZW5zb3I6IFRlbnNvci5NTFRlbnNvclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbU1MVGVuc29yT3B0aW9uczxUPixcbiAgKTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgcHJlLWFsbG9jYXRlZCBidWZmZXIuIFRoZSBidWZmZXIgd2lsbCBiZSB1c2VkIGFzIGEgcGlubmVkIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIGEgVHlwZWRBcnJheSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlLlxuICAgKiBAcGFyYW0gZGltcyAtIHNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz4+KFxuICAgIHR5cGU6IFQsXG4gICAgYnVmZmVyOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjxUPjtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiBBIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmaWxlJ3MgVVJMIG9yIHBhdGguXG4gKlxuICogUGF0aCBpcyB2YWlsYWJsZSBvbmx5IGluIG9ubnhydW50aW1lLW5vZGUgb3Igb25ueHJ1bnRpbWUtd2ViIHJ1bm5pbmcgaW4gTm9kZS5qcy5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZVVybE9yUGF0aCA9IHN0cmluZztcblxuLyoqXG4gKiBBIEJsb2Igb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVCbG9iID0gQmxvYjtcblxuLyoqXG4gKiBBIFVpbnQ4QXJyYXksIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBmaWxlIGNvbnRlbnQuXG4gKlxuICogV2hlbiBpdCBpcyBhbiBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciwgdGhlIHdob2xlIGJ1ZmZlciBpcyBhc3N1bWVkIHRvIGJlIHRoZSBmaWxlIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVEYXRhID0gVWludDhBcnJheSB8IEFycmF5QnVmZmVyTGlrZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZmlsZSB0aGF0IGNhbiBiZSBsb2FkZWQgYnkgdGhlIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZVR5cGUgPSBGaWxlVXJsT3JQYXRoIHwgRmlsZUJsb2IgfCBGaWxlRGF0YTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeHRlcm5hbERhdGFGaWxlRGVzY3JpcHRpb24ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICAgKi9cbiAgZGF0YTogRmlsZVR5cGU7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBmaWxlIHBhdGguXG4gICAqL1xuICBwYXRoOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXG4gKlxuICogV2hlbiB1c2luZyBhIHN0cmluZywgaXQgc2hvdWxkIGJlIGEgZmlsZSBVUkwgb3IgcGF0aCB0aGF0IGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGUgbW9kZWwgZmlsZS5cbiAqL1xuZXhwb3J0IHR5cGUgRXh0ZXJuYWxEYXRhRmlsZVR5cGUgPSBFeHRlcm5hbERhdGFGaWxlRGVzY3JpcHRpb24gfCBGaWxlVXJsT3JQYXRoO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIG1vZGVsIGxvYWRpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT25ueE1vZGVsT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5aW5nIGEgbGlzdCBvZiBmaWxlcyB0aGF0IHJlcHJlc2VudHMgdGhlIGV4dGVybmFsIGRhdGEuXG4gICAqL1xuICBleHRlcm5hbERhdGE/OiByZWFkb25seSBFeHRlcm5hbERhdGFGaWxlVHlwZVtdO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIE5vblRlbnNvclR5cGUgPSBuZXZlcjtcblxuLyoqXG4gKiBUeXBlIE9ubnhWYWx1ZSBSZXByZXNlbnRzIGJvdGggdGVuc29ycyBhbmQgbm9uLXRlbnNvcnMgdmFsdWUgZm9yIG1vZGVsJ3MgaW5wdXRzL291dHB1dHMuXG4gKlxuICogTk9URTogY3VycmVudGx5IG5vdCBzdXBwb3J0IG5vbi10ZW5zb3JcbiAqL1xuZXhwb3J0IHR5cGUgT25ueFZhbHVlID0gVGVuc29yIHwgTm9uVGVuc29yVHlwZTtcblxuLyoqXG4gKiBUeXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiByZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSBvZiBhbiBPbm54VmFsdWUuXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiA9IFRlbnNvci5EYXRhTG9jYXRpb247XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogIyBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUElcbiAqXG4gKiBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkgaXMgYSB1bmlmaWVkIEFQSSBmb3IgYWxsIEphdmFTY3JpcHQgdXNhZ2VzLCBpbmNsdWRpbmcgdGhlIGZvbGxvd2luZyBOUE0gcGFja2FnZXM6XG4gKlxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcbiAqIC0gW29ubnhydW50aW1lLXdlYl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtd2ViKVxuICogLSBbb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1yZWFjdC1uYXRpdmUpXG4gKlxuICogU2VlIGFsc286XG4gKiAtIFtHZXQgU3RhcnRlZF0oaHR0cHM6Ly9vbm54cnVudGltZS5haS9kb2NzL2dldC1zdGFydGVkL3dpdGgtamF2YXNjcmlwdC8pXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5leHBvcnQgKiBmcm9tICcuL2JhY2tlbmQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnYuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFjZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtbW9kZWwuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICEhKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cIndlYndvcmtlclwiIC8+XG5cbi8vXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJIVE1MSW1hZ2VFbGVtZW50XCJcbi8vXG4vLyBpbiB0eXBlc2NyaXB0LCB0aGUgdHlwZSBvZiBcIkhUTUxJbWFnZUVsZW1lbnRcIiBpcyBkZWZpbmVkIGluIGxpYi5kb20uZC50cywgd2hpY2ggaXMgY29uZmxpY3Qgd2l0aCBsaWIud2Vid29ya2VyLmQudHMuXG4vLyB3aGVuIHdlIHVzZSB3ZWJ3b3JrZXIsIHRoZSBsaWIud2Vid29ya2VyLmQudHMgd2lsbCBiZSB1c2VkLCB3aGljaCBkb2VzIG5vdCBoYXZlIEhUTUxJbWFnZUVsZW1lbnQgZGVmaW5lZC5cbi8vXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IEhUTUxJbWFnZUVsZW1lbnQgaXMgbm90IGRlZmluZWQ6XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAuLi9jb21tb24vZGlzdC9janMvdGVuc29yLWZhY3RvcnkuZC50czoxODc6MjkgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyAxODcgICAgIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XG4vLyBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyBub2RlX21vZHVsZXMvQHdlYmdwdS90eXBlcy9kaXN0L2luZGV4LmQudHM6ODM6NyAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTEltYWdlRWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDgzICAgICB8IEhUTUxJbWFnZUVsZW1lbnRcbi8vICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGBIVE1MSW1hZ2VFbGVtZW50YCBpcyBvbmx5IHVzZWQgaW4gdHlwZSBkZWNsYXJhdGlvbiBhbmQgbm90IGluIHJlYWwgY29kZS4gU28gd2UgZGVmaW5lIGl0IGFzIGB1bmtub3duYCBoZXJlIHRvXG4vLyBieXBhc3MgdGhlIHR5cGUgY2hlY2suXG5cbi8vXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJkb2N1bWVudFwiXG4vL1xuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJkb2N1bWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCBzbyBpdCdzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLlxuLy9cbi8vIHdlIHdpbGwgZ2V0IHRoZSBmb2xsb3dpbmcgZXJyb3JzIGNvbXBsYWluaW5nIHRoYXQgZG9jdW1lbnQgaXMgbm90IGRlZmluZWQ6XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjMzIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxuLy8gbGlicmFyeT8gVHJ5IGNoYW5naW5nIHRoZSAnbGliJyBjb21waWxlciBvcHRpb24gdG8gaW5jbHVkZSAnZG9tJy5cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+flxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6NjEgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+flxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6ODggLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxTY3JpcHRFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5+XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGBkb2N1bWVudGAgaXMgdXNlZCB0byBnZXQgdGhlIGN1cnJlbnQgc2NyaXB0IFVSTCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiB3ZWJ3b3JrZXIuIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYVxuLy8gXCJkdWFsXCIgZmlsZSBmb3IgZW50cmllcyBvZiBib3RoIHdlYndvcmtlciBhbmQgdGhlIGVzbSBtb2R1bGUuXG4vL1xuZGVjbGFyZSBnbG9iYWwge1xuICB0eXBlIEhUTUxJbWFnZUVsZW1lbnQgPSB1bmtub3duO1xuICB0eXBlIEhUTUxTY3JpcHRFbGVtZW50ID0geyBzcmM/OiBzdHJpbmcgfTtcbiAgY29uc3QgZG9jdW1lbnQ6IHVuZGVmaW5lZCB8IHsgY3VycmVudFNjcmlwdD86IEhUTUxTY3JpcHRFbGVtZW50IH07XG59XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqXG4gKiBUaGlzIGZpbGUgaXMgc2VydmVkIGFzIGEgXCJkdWFsXCIgZmlsZSBmb3IgYm90aCBlbnRyaWVzIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFRoZSBwcm94eSB3b3JrZXIgaXRzZWxmLlxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciwgaXQgbGlzdGVucyB0byB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgbWFpbiB0aHJlYWQgYW5kIHBlcmZvcm1zIHRoZSBjb3JyZXNwb25kaW5nIG9wZXJhdGlvbnMuXG4gKiAgIC0gU2hvdWxkIGJlIGltcG9ydGVkIGRpcmVjdGx5IHVzaW5nIGBuZXcgV29ya2VyKClgIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAtIFRoZSBFU00gbW9kdWxlIHRoYXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIChhcyBhIHdvcmtlciBsYXVuY2hlcikuXG4gKiAgIC0gV2hlbiB1c2VkIGFzIGEgd29ya2VyIGxhdW5jaGVyLCBpdCBjcmVhdGVzIHRoZSBwcm94eSB3b3JrZXIgYW5kIHJldHVybnMgaXQuXG4gKiAgIC0gU2hvdWxkIGJlIGltcG9ydGVkIHVzaW5nIGBpbXBvcnQoKWAgaW4gdGhlIG1haW4gdGhyZWFkLCB3aXRoIHRoZSBxdWVyeSBwYXJhbWV0ZXIgYGltcG9ydD0xYC5cbiAqXG4gKiBUaGlzIGZpbGUgd2lsbCBiZSBhbHdheXMgY29tcGlsaW5nIGludG8gRVNNIGZvcm1hdC5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21NZXNzYWdlLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSB9IGZyb20gJy4uL3Byb3h5LW1lc3NhZ2VzLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVNlc3Npb24sXG4gIGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIsXG4gIGVuZFByb2ZpbGluZyxcbiAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMsXG4gIGluaXRFcCxcbiAgaW5pdFJ1bnRpbWUsXG4gIHJlbGVhc2VTZXNzaW9uLFxuICBydW4sXG59IGZyb20gJy4uL3dhc20tY29yZS1pbXBsLmpzJztcbmltcG9ydCB7IGluaXRpYWxpemVXZWJBc3NlbWJseSB9IGZyb20gJy4uL3dhc20tZmFjdG9yeS5qcyc7XG5pbXBvcnQgeyBzY3JpcHRTcmMgfSBmcm9tICcuLi93YXNtLXV0aWxzLWltcG9ydC5qcyc7XG5cbmNvbnN0IFdPUktFUl9OQU1FID0gJ29ydC13YXNtLXByb3h5LXdvcmtlcic7XG5jb25zdCBpc1Byb3h5V29ya2VyID0gZ2xvYmFsVGhpcy5zZWxmPy5uYW1lID09PSBXT1JLRVJfTkFNRTtcblxuaWYgKGlzUHJveHlXb3JrZXIpIHtcbiAgLy8gV29ya2VyIHRocmVhZFxuICBzZWxmLm9ubWVzc2FnZSA9IChldjogTWVzc2FnZUV2ZW50PE9ydFdhc21NZXNzYWdlPik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHsgdHlwZSwgaW46IG1lc3NhZ2UgfSA9IGV2LmRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpbml0LXdhc20nOlxuICAgICAgICAgIGluaXRpYWxpemVXZWJBc3NlbWJseShtZXNzYWdlIS53YXNtKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBpbml0UnVudGltZShtZXNzYWdlISkudGhlbihcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luaXQtZXAnOiB7XG4gICAgICAgICAgY29uc3QgeyBlcE5hbWUsIGVudiB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgaW5pdEVwKGVudiwgZXBOYW1lKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb3B5LWZyb20nOiB7XG4gICAgICAgICAgY29uc3QgeyBidWZmZXIgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBvdXQ6IGJ1ZmZlckRhdGEgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY3JlYXRlJzoge1xuICAgICAgICAgIGNvbnN0IHsgbW9kZWwsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpLnRoZW4oXG4gICAgICAgICAgICAoc2Vzc2lvbk1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBzZXNzaW9uTWV0YWRhdGEgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWxlYXNlJzpcbiAgICAgICAgICByZWxlYXNlU2Vzc2lvbihtZXNzYWdlISk7XG4gICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdydW4nOiB7XG4gICAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvcHRpb25zIH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBydW4oc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgbmV3IEFycmF5KG91dHB1dEluZGljZXMubGVuZ3RoKS5maWxsKG51bGwpLCBvcHRpb25zKS50aGVuKFxuICAgICAgICAgICAgKG91dHB1dHMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dHMuc29tZSgobykgPT4gb1szXSAhPT0gJ2NwdScpKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnI6ICdQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLicgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICB7IHR5cGUsIG91dDogb3V0cHV0cyB9IGFzIE9ydFdhc21NZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoWy4uLmlucHV0cywgLi4ub3V0cHV0c10gYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6XG4gICAgICAgICAgZW5kUHJvZmlsaW5nKG1lc3NhZ2UhKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJveHlXb3JrZXJcbiAgPyBudWxsXG4gIDogKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PlxuICAgICAgbmV3IFdvcmtlcih1cmxPdmVycmlkZSA/PyBzY3JpcHRTcmMhLCB7IHR5cGU6IEJVSUxEX0RFRlMuSVNfRVNNID8gJ21vZHVsZScgOiAnY2xhc3NpYycsIG5hbWU6IFdPUktFUl9OQU1FIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21Nb2R1bGUgfSBmcm9tICcuL3dhc20tdHlwZXMnO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5cbi8qKlxuICogVGhlIG9yaWdpbiBvZiB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBJbiBOb2RlLmpzLCB0aGlzIGlzIHVuZGVmaW5lZC5cbiAqL1xuY29uc3Qgb3JpZ2luID0gaXNOb2RlIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBsb2NhdGlvbi5vcmlnaW47XG5cbi8qKlxuICogU29tZSBidW5kbGVycyAoZWcuIFdlYnBhY2spIHdpbGwgcmV3cml0ZSBgaW1wb3J0Lm1ldGEudXJsYCB0byBhIGZpbGUgVVJMIGF0IGNvbXBpbGUgdGltZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiBgaW1wb3J0Lm1ldGEudXJsYCBzdGFydHMgd2l0aCBgZmlsZTpgLCBidXQgdXNpbmcgdGhlIGA+YCBhbmQgYDxgIG9wZXJhdG9ycyBpbnN0ZWFkIG9mXG4gKiBgc3RhcnRzV2l0aGAgZnVuY3Rpb24gc28gdGhhdCBjb2RlIG1pbmltaXplcnMgY2FuIHJlbW92ZSB0aGUgZGVhZCBjb2RlIGNvcnJlY3RseS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgd2UgdXNlIHRlcnNlciB0byBtaW5pZnkgdGhlIGZvbGxvd2luZyBjb2RlOlxuICogYGBganNcbiAqIGlmIChcImZpbGU6Ly9oYXJkLWNvZGVkLWZpbGVuYW1lXCIuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gKiAgIGNvbnNvbGUubG9nKDEpXG4gKiB9IGVsc2Uge1xuICogICBjb25zb2xlLmxvZygyKVxuICogfVxuICpcbiAqIGlmIChcImZpbGU6Ly9oYXJkLWNvZGVkLWZpbGVuYW1lXCIgPiBcImZpbGU6XCIgJiYgXCJmaWxlOi8vaGFyZC1jb2RlZC1maWxlbmFtZVwiIDwgXCJmaWxlO1wiKSB7XG4gKiAgIGNvbnNvbGUubG9nKDMpXG4gKiB9IGVsc2Uge1xuICogICBjb25zb2xlLmxvZyg0KVxuICogfVxuICogYGBgXG4gKlxuICogVGhlIG1pbmlmaWVkIGNvZGUgd2lsbCBiZTpcbiAqIGBgYGpzXG4gKiBcImZpbGU6Ly9oYXJkLWNvZGVkLWZpbGVuYW1lXCIuc3RhcnRzV2l0aChcImZpbGU6XCIpP2NvbnNvbGUubG9nKDEpOmNvbnNvbGUubG9nKDIpLGNvbnNvbGUubG9nKDMpO1xuICogYGBgXG4gKlxuICogKHVzZSBUZXJzZXIgNS4zOS4wIHdpdGggZGVmYXVsdCBvcHRpb25zLCBodHRwczovL3RyeS50ZXJzZXIub3JnLylcbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBpbXBvcnQubWV0YS51cmwgaXMgaGFyZGNvZGVkIGFzIGEgZmlsZSBVUkkuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VzbUltcG9ydE1ldGFVcmxIYXJkY29kZWRBc0ZpbGVVcmkgPVxuICBCVUlMRF9ERUZTLklTX0VTTSAmJiBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwhID4gJ2ZpbGU6JyAmJiBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwhIDwgJ2ZpbGU7JztcblxuY29uc3QgZ2V0U2NyaXB0U3JjID0gKCk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIC8vIGlmIE5vZGVqcywgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoaXNOb2RlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBpZiBJdCdzIEVTTSwgdXNlIGltcG9ydC5tZXRhLnVybFxuICBpZiAoQlVJTERfREVGUy5JU19FU00pIHtcbiAgICAvLyBGb3IgRVNNLCBpZiB0aGUgaW1wb3J0Lm1ldGEudXJsIGlzIGEgZmlsZSBVUkwsIHRoaXMgdXN1YWxseSBtZWFucyB0aGUgYnVuZGxlciByZXdyaXRlcyBgaW1wb3J0Lm1ldGEudXJsYCB0b1xuICAgIC8vIHRoZSBmaWxlIHBhdGggYXQgY29tcGlsZSB0aW1lLiBJbiB0aGlzIGNhc2UsIHRoaXMgZmlsZSBwYXRoIGNhbm5vdCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcnVudGltZSBVUkwuXG4gICAgLy9cbiAgICAvLyBXZSBuZWVkIHRvIHVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIGxpa2UgdGhpczpcbiAgICAvLyBgYGBqc1xuICAgIC8vIG5ldyBVUkwoJ2FjdHVhbC1idW5kbGUtbmFtZS5qcycsIGltcG9ydC5tZXRhLnVybCkuaHJlZlxuICAgIC8vIGBgYFxuICAgIC8vIFNvIHRoYXQgYnVuZGxlciBjYW4gcHJlcHJvY2VzcyB0aGUgVVJMIGNvcnJlY3RseS5cbiAgICBpZiAoaXNFc21JbXBvcnRNZXRhVXJsSGFyZGNvZGVkQXNGaWxlVXJpKSB7XG4gICAgICAvLyBpZiB0aGUgcmV3cml0dGVuIFVSTCBpcyBhIHJlbGF0aXZlIHBhdGgsIHdlIG5lZWQgdG8gdXNlIHRoZSBvcmlnaW4gdG8gcmVzb2x2ZSB0aGUgVVJMLlxuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgd29ya2Fyb3VuZCBmb3IgVml0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBWaXRlIHVzZXMgYSBidW5kbGVyKHJvbGx1cC9yb2xsZG93bikgdGhhdCBkb2VzIG5vdCByZXdyaXRlIGBpbXBvcnQubWV0YS51cmxgIHRvIGEgZmlsZSBVUkwuIFNvIGluIHRoZW9yeSwgdGhpc1xuICAgICAgLy8gY29kZSBwYXRoIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQgaW4gVml0ZS4gSG93ZXZlciwgdGhlIGJ1bmRsZXIgZG9lcyBub3Qga25vdyBpdCBhbmQgaXQgc3RpbGwgdHJ5IHRvIGxvYWQgdGhlXG4gICAgICAvLyBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICAgIC8vIC0gYHJldHVybiBuZXcgVVJMKCdmaWxlbmFtZScsIGltcG9ydC5tZXRhLnVybCkuaHJlZmBcbiAgICAgIC8vXG4gICAgICAvLyBCeSByZXBsYWNpbmcgdGhlIHBhdHRlcm4gYWJvdmUgd2l0aCB0aGUgZm9sbG93aW5nIGNvZGUsIHdlIGNhbiBza2lwIHRoZSByZXNvdXJjZSBsb2FkaW5nIGJlaGF2aW9yOlxuICAgICAgLy8gLSBgY29uc3QgVVJMMiA9IFVSTDsgcmV0dXJuIG5ldyBVUkwyKCdmaWxlbmFtZScsIGltcG9ydC5tZXRhLnVybCkuaHJlZjtgXG4gICAgICAvL1xuICAgICAgLy8gQW5kIGl0IHN0aWxsIHdvcmtzIGluIFdlYnBhY2suXG4gICAgICBjb25zdCBVUkwyID0gVVJMO1xuICAgICAgcmV0dXJuIG5ldyBVUkwobmV3IFVSTDIoQlVJTERfREVGUy5CVU5ETEVfRklMRU5BTUUsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZiwgb3JpZ2luKS5ocmVmO1xuICAgIH1cblxuICAgIHJldHVybiBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkw7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmNcbiAgICA6IC8vIHVzZSBgc2VsZi5sb2NhdGlvbi5ocmVmYCBpZiBhdmFpbGFibGVcbiAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBzZWxmLmxvY2F0aW9uPy5ocmVmXG4gICAgICA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogVGhlIGNsYXNzaWMgc2NyaXB0IHNvdXJjZSBVUkwuIFRoaXMgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gbm9uIEVTTW9kdWxlIGVudmlyb25tZW50cy5cbiAqXG4gKiBJbiBOb2RlLmpzLCB0aGlzIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IGdldFNjcmlwdFNyYygpO1xuXG4vKipcbiAqIEluZmVyIHRoZSB3YXNtIHBhdGggcHJlZml4IGZyb20gdGhlIHNjcmlwdCBzb3VyY2UgVVJMLlxuICpcbiAqIEByZXR1cm5zIFRoZSBpbmZlcnJlZCB3YXNtIHBhdGggcHJlZml4LCBvciB1bmRlZmluZWQgaWYgdGhlIHNjcmlwdCBzb3VyY2UgVVJMIGlzIG5vdCBhdmFpbGFibGUgb3IgaXMgYSBibG9iIFVSTC5cbiAqL1xuZXhwb3J0IGNvbnN0IGluZmVyV2FzbVBhdGhQcmVmaXhGcm9tU2NyaXB0U3JjID0gKCk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmIChzY3JpcHRTcmMgJiYgIXNjcmlwdFNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgcmV0dXJuIHNjcmlwdFNyYy5zdWJzdHJpbmcoMCwgc2NyaXB0U3JjLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZmlsZW5hbWUgd2l0aCBwcmVmaXggaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXG4gKi9cbmNvbnN0IGlzU2FtZU9yaWdpbiA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5vcmlnaW4gPT09IG9yaWdpbjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXRzIHRvIGFuIGFic29sdXRlIFVSTCB3aXRoIHRoZSBnaXZlbiBwcmVmaXggb3ZlcnJpZGUuIElmIGZhaWxlZCwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqL1xuY29uc3Qgbm9ybWFsaXplVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhbGxiYWNrIFVSTCBpZiBhbiBhYnNvbHV0ZSBVUkwgY2Fubm90IGJlIGNyZWF0ZWQgYnkgdGhlIG5vcm1hbGl6ZVVybCBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZmFsbGJhY2tVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IGAke3ByZWZpeE92ZXJyaWRlID8/ICcuLyd9JHtmaWxlbmFtZX1gO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlbG9hZCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxuICpcbiAqIElmIHRoZSBvcmlnaW4gb2YgdGhlIHdvcmtlciBVUkwgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb3JpZ2luLCB0aGUgd29ya2VyIGNhbm5vdCBiZSBsb2FkZWQgZGlyZWN0bHkuXG4gKiBTZWUgZGlzY3Vzc2lvbnMgaW4gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93b3JrZXItbG9hZGVyL2lzc3Vlcy8xNTRcbiAqXG4gKiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgZmV0Y2ggdGhlIHdvcmtlciBVUkwgYW5kIGNyZWF0ZSBhIG5ldyBCbG9iIFVSTCB3aXRoIHRoZSBzYW1lIG9yaWdpbiBhcyBhIHdvcmthcm91bmQuXG4gKlxuICogQHBhcmFtIGFic29sdXRlVXJsIC0gVGhlIGFic29sdXRlIFVSTCB0byBwcmVsb2FkLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBuZXcgQmxvYiBVUkxcbiAqL1xuY29uc3QgcHJlbG9hZCA9IGFzeW5jIChhYnNvbHV0ZVVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhYnNvbHV0ZVVybCwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59O1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZHluYW1pY2FsbHkgaW1wb3J0IGEgbW9kdWxlIGZyb20gYSBVUkwuXG4gKlxuICogVGhlIGJ1aWxkIHNjcmlwdCBoYXMgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhpcyBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCB0aGUgVVJMIGlzIG5vdCBidW5kbGVkIGludG8gdGhlIGZpbmFsIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBpbXBvcnQuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVmYXVsdCBleHBvcnQgb2YgdGhlIG1vZHVsZS5cbiAqL1xuY29uc3QgZHluYW1pY0ltcG9ydERlZmF1bHQgPSBhc3luYyA8VD4odXJsOiBzdHJpbmcpOiBQcm9taXNlPFQ+ID0+XG4gIChhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyAvKiBAdml0ZS1pZ25vcmUgKi8gdXJsKSkuZGVmYXVsdDtcblxuLyoqXG4gKiBUaGUgcHJveHkgd29ya2VyIGZhY3RvcnkgaW1wb3J0ZWQgZnJvbSB0aGUgcHJveHkgd29ya2VyIG1vZHVsZS5cbiAqXG4gKiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIFdlYkFzc2VtYmx5IHByb3h5IGlzIG5vdCBkaXNhYmxlZC5cbiAqL1xuY29uc3QgY3JlYXRlUHJveHlXb3JrZXI6ICgodXJsT3ZlcnJpZGU/OiBzdHJpbmcpID0+IFdvcmtlcikgfCB1bmRlZmluZWQgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICBCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSA/IHVuZGVmaW5lZCA6IHJlcXVpcmUoJy4vcHJveHktd29ya2VyL21haW4nKS5kZWZhdWx0O1xuXG4vKipcbiAqIEltcG9ydCB0aGUgcHJveHkgd29ya2VyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwZXJmb3JtIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gKiAxLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxuICogMi4gVXNlIHRoZSBwcm94eSB3b3JrZXIgZmFjdG9yeSB0byBjcmVhdGUgdGhlIHByb3h5IHdvcmtlci5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcbiAqICAgICAgICAgICAgLSBUaGUgb2JqZWN0IFVSTCBvZiB0aGUgcHJlbG9hZGVkIG1vZHVsZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHByZWxvYWQgaXMgbmVlZGVkLlxuICogICAgICAgICAgICAtIFRoZSBwcm94eSB3b3JrZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBpbXBvcnRQcm94eVdvcmtlciA9IGFzeW5jICgpOiBQcm9taXNlPFt1bmRlZmluZWQgfCBzdHJpbmcsIFdvcmtlcl0+ID0+IHtcbiAgaWYgKCFzY3JpcHRTcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHByb3h5IHdvcmtlcjogY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuJyk7XG4gIH1cblxuICAvLyBJZiB0aGUgc2NyaXB0IHNvdXJjZSBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbiwgd2UgY2FuIHVzZSB0aGUgZW1iZWRkZWQgcHJveHkgbW9kdWxlIGRpcmVjdGx5LlxuICBpZiAoaXNTYW1lT3JpZ2luKHNjcmlwdFNyYykpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgY3JlYXRlUHJveHlXb3JrZXIhKCldO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBuZWVkIHRvIHByZWxvYWRcbiAgY29uc3QgdXJsID0gYXdhaXQgcHJlbG9hZChzY3JpcHRTcmMpO1xuICByZXR1cm4gW3VybCwgY3JlYXRlUHJveHlXb3JrZXIhKHVybCldO1xufTtcblxuLyoqXG4gKiBUaGUgZW1iZWRkZWQgV2ViQXNzZW1ibHkgbW9kdWxlLlxuICpcbiAqIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaW4gRVNNIGFuZCB3aGVuIGVtYmVkZGluZyBpcyBub3QgZGlzYWJsZWQuXG4gKi9cbmNvbnN0IGVtYmVkZGVkV2FzbU1vZHVsZTogRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT4gfCB1bmRlZmluZWQgPVxuICBCVUlMRF9ERUZTLklTX0VTTSAmJiBCVUlMRF9ERUZTLkVOQUJMRV9CVU5ETEVfV0FTTV9KU1xuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgIHJlcXVpcmUoXG4gICAgICAgICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUFxuICAgICAgICAgID8gJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcydcbiAgICAgICAgICA6IEJVSUxEX0RFRlMuRU5BQkxFX0pTUElcbiAgICAgICAgICAgID8gJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc3BpLm1qcydcbiAgICAgICAgICAgIDogIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFVcbiAgICAgICAgICAgICAgPyAnLi4vLi4vZGlzdC9vcnQtd2FzbS1zaW1kLXRocmVhZGVkLmFzeW5jaWZ5Lm1qcydcbiAgICAgICAgICAgICAgOiAnLi4vLi4vZGlzdC9vcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qcycsXG4gICAgICApLmRlZmF1bHRcbiAgICA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBJbXBvcnQgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICogMS4gSWYgdGhlIGVtYmVkZGVkIG1vZHVsZSBleGlzdHMgYW5kIG5vIGN1c3RvbSBVUkwgaXMgc3BlY2lmaWVkLCB1c2UgdGhlIGVtYmVkZGVkIG1vZHVsZS5cbiAqIDIuIElmIGEgcHJlbG9hZCBpcyBuZWVkZWQsIGl0IHdpbGwgcHJlbG9hZCB0aGUgbW9kdWxlIGFuZCByZXR1cm4gdGhlIG9iamVjdCBVUkwuXG4gKiAzLiBPdGhlcndpc2UsIGl0IHdpbGwgcGVyZm9ybSBhIGR5bmFtaWMgaW1wb3J0IG9mIHRoZSBtb2R1bGUuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIDIgZWxlbWVudHM6XG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cbiAqICAgICAgICAgICAgLSBUaGUgZGVmYXVsdCBleHBvcnQgb2YgdGhlIG1vZHVsZSwgd2hpY2ggaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlLlxuICovXG5leHBvcnQgY29uc3QgaW1wb3J0V2FzbU1vZHVsZSA9IGFzeW5jIChcbiAgdXJsT3ZlcnJpZGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgcHJlZml4T3ZlcnJpZGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgaXNNdWx0aVRocmVhZGVkOiBib29sZWFuLFxuICBpc1dhc21PdmVycmlkZGVuOiBib29sZWFuLFxuKTogUHJvbWlzZTxbdW5kZWZpbmVkIHwgc3RyaW5nLCBFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPl0+ID0+IHtcbiAgLy9cbiAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgZW1iZWRkZWQgbW9kdWxlLlxuICAvL1xuXG4gIC8vIFRvIHVzZSB0aGUgZW1iZWRkZWQgbW9kdWxlLCBpdCBzaG91bGQgYmUgYXZhaWxhYmxlLCBhbmQgbm8gVVJMIG92ZXJyaWRlIG9yIHByZWZpeCBvdmVycmlkZSBzaG91bGQgYmUgc3BlY2lmaWVkLlxuICBsZXQgdXNlRW1iZWRkZWRNb2R1bGUgPSBlbWJlZGRlZFdhc21Nb2R1bGUgJiYgISh1cmxPdmVycmlkZSB8fCBwcmVmaXhPdmVycmlkZSk7XG4gIGlmICh1c2VFbWJlZGRlZE1vZHVsZSkge1xuICAgIGlmICghc2NyaXB0U3JjKSB7XG4gICAgICAvLyBubyBVUkwgaW5mbyBhdmFpbGFibGUuXG4gICAgICAvL1xuICAgICAgLy8gTm90ZTogd2hlbiB0aGUgZW1iZWRkZWQgbW9kdWxlIGlzIGF2YWlsYWJsZSwgaXQgbWVhbnMgdGhlIGN1cnJlbnQgc2NyaXB0IGlzIEVTTS4gVXN1YWxseSwgaW4gRVNNLCB0aGVcbiAgICAgIC8vIGBpbXBvcnQubWV0YS51cmxgIGlzIGF2YWlsYWJsZS4gQnV0IGluIHNvbWUgY2FzZXMgKGVnLiBDbG91ZGZsYXJlIFdvcmtlcnMpLCB0aGUgdmFsdWUgb2YgYGltcG9ydC5tZXRhLnVybGBcbiAgICAgIC8vIGNhbiBiZSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIEluIHRoaXMgY2FzZSwgd2UgY2FuIG9ubHkgbG9hZCB0aGUgZW1iZWRkZWQgbW9kdWxlIHdoZW46XG4gICAgICAvL1xuICAgICAgLy8gMS4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBiaW5hcnkgaXMgb3ZlcnJpZGRlbjpcbiAgICAgIC8vICAgIGBgYGpzXG4gICAgICAvLyAgICBlbnYud2FzbS53YXNtUGF0aHMgPSB1bmRlZmluZWQ7ICAvLyBvciBub3Qgc3BlY2lmaWVkXG4gICAgICAvLyAgICBlbnYud2FzbS53YXNtQmluYXJ5ID0gLyogYSBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeSAqLztcbiAgICAgIC8vICAgIGBgYFxuICAgICAgLy9cbiAgICAgIC8vIDIuIFRoZSBcIi53YXNtXCIgb25seSBpcyBvdmVycmlkZGVuLlxuICAgICAgLy8gICAgYGBganNcbiAgICAgIC8vICAgIGVudi53YXNtLndhc21QYXRocyA9IHsgd2FzbTogLyogVVJMIG9mIHRoZSAud2FzbSBmaWxlICovIH07XG4gICAgICAvLyAgICBgYGBcbiAgICAgIC8vXG4gICAgICBpZiAoaXNXYXNtT3ZlcnJpZGRlbiAmJiAhaXNNdWx0aVRocmVhZGVkKSB7XG4gICAgICAgIHVzZUVtYmVkZGVkTW9kdWxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHRoZSBzY3JpcHQgc291cmNlIGlzIGF2YWlsYWJsZSwgd2UgY2FuIGNoZWNrIGlmIGl0IGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICAgICAgdXNlRW1iZWRkZWRNb2R1bGUgPSBpc1NhbWVPcmlnaW4oc2NyaXB0U3JjKTtcbiAgICB9XG4gIH1cbiAgaWYgKHVzZUVtYmVkZGVkTW9kdWxlKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGVtYmVkZGVkV2FzbU1vZHVsZSFdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhc21Nb2R1bGVGaWxlbmFtZSA9ICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUFxuICAgICAgPyAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcydcbiAgICAgIDogQlVJTERfREVGUy5FTkFCTEVfSlNQSVxuICAgICAgICA/ICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzcGkubWpzJ1xuICAgICAgICA6ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVXG4gICAgICAgICAgPyAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS5tanMnXG4gICAgICAgICAgOiAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnO1xuICAgIGNvbnN0IHdhc21Nb2R1bGVVcmwgPSB1cmxPdmVycmlkZSA/PyBub3JtYWxpemVVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSk7XG4gICAgLy8gbmVlZCB0byBwcmVsb2FkIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgICAvLyAxLiBub3QgaW4gTm9kZS5qcy5cbiAgICAvLyAgICAtIE5vZGUuanMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBvcmlnaW4gcG9saWN5IGZvciBjcmVhdGluZyB3b3JrZXJzLlxuICAgIC8vIDIuIG11bHRpLXRocmVhZGVkIGlzIGVuYWJsZWQuXG4gICAgLy8gICAgLSBJZiBtdWx0aS10aHJlYWRlZCBpcyBkaXNhYmxlZCwgbm8gd29ya2VyIHdpbGwgYmUgY3JlYXRlZC4gU28gd2UgZG9uJ3QgbmVlZCB0byBwcmVsb2FkIHRoZSBtb2R1bGUuXG4gICAgLy8gMy4gdGhlIGFic29sdXRlIFVSTCBpcyBhdmFpbGFibGUuXG4gICAgLy8gICAgLSBJZiB0aGUgYWJzb2x1dGUgVVJMIGlzIGZhaWxlZCB0byBiZSBjcmVhdGVkLCB0aGUgb3JpZ2luIGNhbm5vdCBiZSBkZXRlcm1pbmVkLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgbm90XG4gICAgLy8gICAgcHJlbG9hZCB0aGUgbW9kdWxlLlxuICAgIC8vIDQuIHRoZSB3b3JrZXIgVVJMIGlzIG5vdCBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAvLyAgICAtIElmIHRoZSB3b3JrZXIgVVJMIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gY3JlYXRlIHRoZSB3b3JrZXIgZGlyZWN0bHkuXG4gICAgY29uc3QgbmVlZFByZWxvYWQgPSAhaXNOb2RlICYmIGlzTXVsdGlUaHJlYWRlZCAmJiB3YXNtTW9kdWxlVXJsICYmICFpc1NhbWVPcmlnaW4od2FzbU1vZHVsZVVybCwgcHJlZml4T3ZlcnJpZGUpO1xuICAgIGNvbnN0IHVybCA9IG5lZWRQcmVsb2FkXG4gICAgICA/IGF3YWl0IHByZWxvYWQod2FzbU1vZHVsZVVybClcbiAgICAgIDogKHdhc21Nb2R1bGVVcmwgPz8gZmFsbGJhY2tVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSkpO1xuICAgIHJldHVybiBbbmVlZFByZWxvYWQgPyB1cmwgOiB1bmRlZmluZWQsIGF3YWl0IGR5bmFtaWNJbXBvcnREZWZhdWx0PEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+Pih1cmwpXTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7IGltcG9ydFdhc21Nb2R1bGUsIGluZmVyV2FzbVBhdGhQcmVmaXhGcm9tU2NyaXB0U3JjIH0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XG5cbmxldCB3YXNtOiBPcnRXYXNtTW9kdWxlIHwgdW5kZWZpbmVkO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xuXG5jb25zdCBpc011bHRpVGhyZWFkU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICAvLyBJZiAnU2hhcmVkQXJyYXlCdWZmZXInIGlzIG5vdCBhdmFpbGFibGUsIFdlYkFzc2VtYmx5IHRocmVhZHMgd2lsbCBub3Qgd29yay5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRlc3QgZm9yIHRyYW5zZmVyYWJpbGl0eSBvZiBTQUJzIChmb3IgYnJvd3NlcnMuIG5lZWRlZCBmb3IgRmlyZWZveClcbiAgICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhbXNnL21vemlsbGEuZGV2LnBsYXRmb3JtL0lIa0JabEhFVHBBL2R3c01OY2hXRVFBSlxuICAgIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpO1xuICAgIH1cblxuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IHRocmVhZHMgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyB0aHJlYWRlZCBpbnN0cnVjdGlvbnMuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCA1LCA0LCAxLCAzLCAxLCAxLCAxMCwgMTEsIDEsIDksIDAsIDY1LCAwLCAyNTQsIDE2LFxuICAgICAgICAyLCAwLCAyNiwgMTEsXG4gICAgICBdKSxcbiAgICApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzU2ltZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBTSU1EIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgU0lNRCBpbnN0cnVjdGlvbnMuXG5cbiAgICAvLyBUaGUgYmluYXJ5IGRhdGEgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIGZvbGxvd2luZyBjb2RlIGJ5IHdhdDJ3YXNtOlxuICAgIC8vXG4gICAgLy8gKG1vZHVsZVxuICAgIC8vICAgKHR5cGUgJHQwIChmdW5jKSlcbiAgICAvLyAgIChmdW5jICRmMCAodHlwZSAkdDApXG4gICAgLy8gICAgIChkcm9wXG4gICAgLy8gICAgICAgKGkzMng0LmRvdF9pMTZ4OF9zXG4gICAgLy8gICAgICAgICAoaTh4MTYuc3BsYXRcbiAgICAvLyAgICAgICAgICAgKGkzMi5jb25zdCAwKSlcbiAgICAvLyAgICAgICAgICh2MTI4LmNvbnN0IGkzMng0IDB4MDAwMDAwMDAgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDApKSkpKVxuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCAxMCwgMzAsIDEsIDI4LCAwLCA2NSwgMCwgMjUzLCAxNSwgMjUzLCAxMiwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjUzLCAxODYsIDEsIDI2LCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuY29uc3QgaXNSZWxheGVkU2ltZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBSZWxheGVkIFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyBSZWxheGVkIFNJTUQgaW5zdHJ1Y3Rpb25zLlxuXG4gICAgLy8gVGhlIGJpbmFyeSBkYXRhIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBmb2xsb3dpbmcgY29kZSBieSB3YXQyd2FzbTpcbiAgICAvLyAobW9kdWxlXG4gICAgLy8gICAoZnVuYyAocmVzdWx0IHYxMjgpXG4gICAgLy8gICAgICBpMzIuY29uc3QgMVxuICAgIC8vICAgICAgaTh4MTYuc3BsYXRcbiAgICAvLyAgICAgIGkzMi5jb25zdCAyXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxuICAgIC8vICAgICAgaTMyLmNvbnN0IDNcbiAgICAvLyAgICAgIGk4eDE2LnNwbGF0XG4gICAgLy8gICAgICBpMzJ4NC5yZWxheGVkX2RvdF9pOHgxNl9pN3gxNl9hZGRfc1xuICAgIC8vICAgKVxuICAgIC8vICApXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDUsIDEsIDk2LCAwLCAxLCAxMjMsIDMsIDIsIDEsIDAsIDEwLCAxOSwgMSwgMTcsIDAsIDY1LCAxLCAyNTMsIDE1LCA2NSwgMiwgMjUzLFxuICAgICAgICAxNSwgNjUsIDMsIDI1MywgMTUsIDI1MywgMTQ3LCAyLCAxMSxcbiAgICAgIF0pLFxuICAgICk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVXZWJBc3NlbWJseSA9IGFzeW5jIChmbGFnczogRW52LldlYkFzc2VtYmx5RmxhZ3MpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGlmIChpbml0aWFsaXppbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtcbiAgfVxuICBpZiAoYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAvLyB3YXNtIGZsYWdzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXG4gIGNvbnN0IHRpbWVvdXQgPSBmbGFncy5pbml0VGltZW91dCE7XG4gIGxldCBudW1UaHJlYWRzID0gZmxhZ3MubnVtVGhyZWFkcyE7XG5cbiAgLy8gZW5zdXJlIFNJTUQgaXMgc3VwcG9ydGVkXG4gIGlmIChmbGFncy5zaW1kID09PSBmYWxzZSkge1xuICAgIC8vIHNraXAgU0lNRCBmZWF0dXJlIGNoZWNraW5nIGFzIGl0IGlzIGRpc2FibGVkIGV4cGxpY2l0bHkgYnkgdXNlclxuICB9IGVsc2UgaWYgKGZsYWdzLnNpbWQgPT09ICdyZWxheGVkJykge1xuICAgIC8vIGNoZWNrIGlmIHJlbGF4ZWQgU0lNRCBpcyBzdXBwb3J0ZWRcbiAgICBpZiAoIWlzUmVsYXhlZFNpbWRTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWxheGVkIFdlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzU2ltZFN1cHBvcnRlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuJyk7XG4gIH1cblxuICBpZiAoQlVJTERfREVGUy5FTkFCTEVfSlNQSSkge1xuICAgIGlmICghKCdTdXNwZW5kaW5nJyBpbiBXZWJBc3NlbWJseSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViQXNzZW1ibHkgSlNQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIG11bHRpLXRocmVhZGluZyBpcyBzdXBwb3J0ZWRcbiAgY29uc3QgbXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSBpc011bHRpVGhyZWFkU3VwcG9ydGVkKCk7XG4gIGlmIChudW1UaHJlYWRzID4gMSAmJiAhbXVsdGlUaHJlYWRTdXBwb3J0ZWQpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byAnICtcbiAgICAgICAgICBudW1UaHJlYWRzICtcbiAgICAgICAgICAnLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gJyArXG4gICAgICAgICAgJ1NlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXZWJBc3NlbWJseSBtdWx0aS10aHJlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gJyArICdGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy4nLFxuICAgICk7XG5cbiAgICAvLyBzZXQgZmxhZ3MubnVtVGhyZWFkcyB0byAxIHNvIHRoYXQgT3J0SW5pdCgpIHdpbGwgbm90IGNyZWF0ZSBhIGdsb2JhbCB0aHJlYWQgcG9vbC5cbiAgICBmbGFncy5udW1UaHJlYWRzID0gbnVtVGhyZWFkcyA9IDE7XG4gIH1cblxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XG4gIGNvbnN0IHdhc21QcmVmaXhPdmVycmlkZSA9IHR5cGVvZiB3YXNtUGF0aHMgPT09ICdzdHJpbmcnID8gd2FzbVBhdGhzIDogdW5kZWZpbmVkO1xuICBjb25zdCBtanNQYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lm1qcztcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlID0gKG1qc1BhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyBtanNQYXRoT3ZlcnJpZGVGbGFnO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy53YXNtO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlID0gKHdhc21QYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gd2FzbVBhdGhPdmVycmlkZUZsYWc7XG4gIGNvbnN0IHdhc21CaW5hcnlPdmVycmlkZSA9IGZsYWdzLndhc21CaW5hcnk7XG5cbiAgY29uc3QgW29iamVjdFVybCwgb3J0V2FzbUZhY3RvcnldID0gYXdhaXQgaW1wb3J0V2FzbU1vZHVsZShcbiAgICBtanNQYXRoT3ZlcnJpZGUsXG4gICAgd2FzbVByZWZpeE92ZXJyaWRlLFxuICAgIG51bVRocmVhZHMgPiAxLFxuICAgICEhd2FzbUJpbmFyeU92ZXJyaWRlIHx8ICEhd2FzbVBhdGhPdmVycmlkZSxcbiAgKTtcblxuICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XG5cbiAgY29uc3QgdGFza3M6IEFycmF5PFByb21pc2U8dm9pZD4+ID0gW107XG5cbiAgLy8gcHJvbWlzZSBmb3IgdGltZW91dFxuICBpZiAodGltZW91dCA+IDApIHtcbiAgICB0YXNrcy5wdXNoKFxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8vIHByb21pc2UgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICB0YXNrcy5wdXNoKFxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZzogUGFydGlhbDxPcnRXYXNtTW9kdWxlPiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcbiAgICAgICAgICogY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIG51bVRocmVhZHMsXG4gICAgICB9O1xuXG4gICAgICBpZiAod2FzbUJpbmFyeU92ZXJyaWRlKSB7XG4gICAgICAgIC8vIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gVGhpcyB3aWxsIHNraXAgdGhlIHdhc20gZmlsZSBmZXRjaGluZy5cbiAgICAgICAgY29uZmlnLndhc21CaW5hcnkgPSB3YXNtQmluYXJ5T3ZlcnJpZGU7XG4gICAgICB9IGVsc2UgaWYgKHdhc21QYXRoT3ZlcnJpZGUgfHwgd2FzbVByZWZpeE92ZXJyaWRlKSB7XG4gICAgICAgIC8vIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gbG9jYXRlIHRoZSBXZWJBc3NlbWJseSBmaWxlLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lKSA9PiB3YXNtUGF0aE92ZXJyaWRlID8/IHdhc21QcmVmaXhPdmVycmlkZSArIGZpbGVOYW1lO1xuICAgICAgfSBlbHNlIGlmIChtanNQYXRoT3ZlcnJpZGUgJiYgbWpzUGF0aE92ZXJyaWRlLmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgICAgLy8gaWYgbWpzIHBhdGggaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lKSA9PiBuZXcgVVJMKGZpbGVOYW1lLCBtanNQYXRoT3ZlcnJpZGUpLmhyZWY7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdFVybCkge1xuICAgICAgICBjb25zdCBpbmZlcnJlZFdhc21QYXRoUHJlZml4ID0gaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMoKTtcbiAgICAgICAgaWYgKGluZmVycmVkV2FzbVBhdGhQcmVmaXgpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgd2FzbSBtb2R1bGUgaXMgcHJlbG9hZGVkLCB1c2UgdGhlIGluZmVycmVkIHdhc20gcGF0aCBhcyB0aGUgYmFzZSBwYXRoIGZvciB0aGUgLndhc20gZmlsZS5cbiAgICAgICAgICBjb25maWcubG9jYXRlRmlsZSA9IChmaWxlTmFtZSkgPT4gaW5mZXJyZWRXYXNtUGF0aFByZWZpeCArIGZpbGVOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9ydFdhc21GYWN0b3J5KGNvbmZpZykudGhlbihcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgIChtb2R1bGUpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgd2FzbSA9IG1vZHVsZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcbiAgICAgICAgKHdoYXQpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3Qod2hhdCk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pLFxuICApO1xuXG4gIGF3YWl0IFByb21pc2UucmFjZSh0YXNrcyk7XG5cbiAgaWYgKGlzVGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3RpbWVvdXR9bXNgKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlID0gKCk6IE9ydFdhc21Nb2R1bGUgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQgJiYgd2FzbSkge1xuICAgIHJldHVybiB3YXNtO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRpc3Bvc2UgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiAhaW5pdGlhbGl6aW5nICYmICFhYm9ydGVkKSB7XG4gICAgLy8gVE9ETzogY3VycmVudGx5IFwiUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKClcIiBpcyBub3QgZXhwb3NlZCBpbiB0aGUgd2FzbSBtb2R1bGUuXG4gICAgLy8gICAgICAgQW5kIHRoaXMgZnVuY3Rpb24gaXMgbm90IHlldCBjYWxsZWQgYnkgYW55IGNvZGUuXG4gICAgLy8gICAgICAgSWYgaXQgaXMgbmVlZGVkIGluIHRoZSBmdXR1cmUsIHdlIHNob3VsZCBleHBvc2UgaXQgaW4gdGhlIHdhc20gbW9kdWxlIGFuZCB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lLlxuXG4gICAgLy8gd2FzbT8uUFRocmVhZD8udGVybWluYXRlQWxsVGhyZWFkcygpO1xuICAgIHdhc20gPSB1bmRlZmluZWQ7XG5cbiAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IGFsbG9jV2FzbVN0cmluZyA9IChkYXRhOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBkYXRhTGVuZ3RoID0gd2FzbS5sZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxO1xuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xuICB3YXNtLnN0cmluZ1RvVVRGOChkYXRhLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgYWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG5cbiAgcmV0dXJuIGRhdGFPZmZzZXQ7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFPcHRpb25zSGFuZGxlciB7XG4gIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgaXRlcmF0ZUV4dHJhT3B0aW9ucyA9IChcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHByZWZpeDogc3RyaW5nLFxuICBzZWVuOiBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PixcbiAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcixcbik6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9ucycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWVuLmFkZChvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBuYW1lID0gcHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBuYW1lICsgJy4nLCBzZWVuLCBoYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBoYW5kbGVyKG5hbWUsIHZhbHVlID8gJzEnIDogJzAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIGNoZWNrIHdlYiBhc3NlbWJseSBBUEkncyBsYXN0IGVycm9yIGFuZCB0aHJvdyBlcnJvciBpZiBhbnkgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0gbWVzc2FnZSBhIG1lc3NhZ2UgdXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tMYXN0RXJyb3IgPSAobWVzc2FnZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcbiAgICBjb25zdCBwYXJhbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xuICAgIHdhc20uX09ydEdldExhc3RFcnJvcihwYXJhbXNPZmZzZXQsIHBhcmFtc09mZnNldCArIHB0clNpemUpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IE51bWJlcih3YXNtLmdldFZhbHVlKHBhcmFtc09mZnNldCwgcHRyU2l6ZSA9PT0gNCA/ICdpMzInIDogJ2k2NCcpKTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2VQb2ludGVyID0gd2FzbS5nZXRWYWx1ZShwYXJhbXNPZmZzZXQgKyBwdHJTaXplLCAnKicpO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZVBvaW50ZXIgPyB3YXNtLlVURjhUb1N0cmluZyhlcnJvck1lc3NhZ2VQb2ludGVyKSA6ICcnO1xuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfSBFUlJPUl9DT0RFOiAke2Vycm9yQ29kZX0sIEVSUk9SX01FU1NBR0U6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBzZXRSdW5PcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBydW5PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID0gMjsgLy8gRGVmYXVsdCB0byB3YXJuaW5nXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8XG4gICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwpIHx8XG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8XG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5sb2dWZXJib3NpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgLy8gRGVmYXVsdCB0byAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8udGVybWluYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xuICAgIGlmIChvcHRpb25zPy50YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhvcHRpb25zLnRhZywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBydW5PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsXG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsISxcbiAgICAgICEhcnVuT3B0aW9ucy50ZXJtaW5hdGUhLFxuICAgICAgdGFnRGF0YU9mZnNldCxcbiAgICApO1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMob3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRSdW5Db25maWdFbnRyeShydW5PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3J1bk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB0eXBlIHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmNvbnN0IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbCA9IChncmFwaE9wdGltaXphdGlvbkxldmVsOiBzdHJpbmcgfCB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChncmFwaE9wdGltaXphdGlvbkxldmVsKSB7XG4gICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnZXh0ZW5kZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnbGF5b3V0JzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2FsbCc6XG4gICAgICByZXR1cm4gOTk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2dyYXBoT3B0aW1pemF0aW9uTGV2ZWx9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEV4ZWN1dGlvbk1vZGUgPSAoZXhlY3V0aW9uTW9kZTogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZXhlY3V0aW9uTW9kZSkge1xuICAgIGNhc2UgJ3NlcXVlbnRpYWwnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAncGFyYWxsZWwnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZXhlY3V0aW9uTW9kZX1gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRGVmYXVsdE9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IHZvaWQgPT4ge1xuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcbiAgICBvcHRpb25zLmV4dHJhID0ge307XG4gIH1cbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcbiAgICBvcHRpb25zLmV4dHJhLnNlc3Npb24gPSB7fTtcbiAgfVxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGlmICghc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcbiAgfVxuXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXG4gIGlmIChcbiAgICBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyAmJlxuICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoKGVwKSA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKVxuICApIHtcbiAgICBvcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4gPSBmYWxzZTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kU2Vzc2lvbkNvbmZpZyA9IChzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgYWxsb2NzOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2tleX0gLSAke3ZhbHVlfS5gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRXBPcHRpb24gPSAoZXBPcHRpb25zOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPiwga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiB2b2lkID0+IHtcbiAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcbiAgZXBPcHRpb25zLnB1c2goW2tleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldF0pO1xufTtcblxuY29uc3Qgc2V0RXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxuICBzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLFxuICBzZXNzaW9uT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgYWxsb2NzOiBudW1iZXJbXSxcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBleGVjdXRpb25Qcm92aWRlcnMgPSBzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMhO1xuICBmb3IgKGNvbnN0IGVwIG9mIGV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgIGxldCBlcE5hbWUgPSB0eXBlb2YgZXAgPT09ICdzdHJpbmcnID8gZXAgOiBlcC5uYW1lO1xuICAgIGNvbnN0IGVwT3B0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcblxuICAgIC8vIGNoZWNrIEVQIG5hbWVcbiAgICBzd2l0Y2ggKGVwTmFtZSkge1xuICAgICAgY2FzZSAnd2Vibm4nOlxuICAgICAgICBlcE5hbWUgPSAnV0VCTk4nO1xuICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHdlYm5uT3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICAvLyBjb25zdCBjb250ZXh0ID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQpPy5jb250ZXh0O1xuICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XG4gICAgICAgICAgaWYgKGRldmljZVR5cGUpIHtcbiAgICAgICAgICAgIGFwcGVuZFNlc3Npb25Db25maWcoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsICdkZXZpY2VUeXBlJywgZGV2aWNlVHlwZSwgYWxsb2NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWJncHUnOlxuICAgICAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcbiAgICAgICAgICBlcE5hbWUgPSAnV2ViR1BVJztcbiAgICAgICAgICBsZXQgY3VzdG9tRGV2aWNlOiBHUFVEZXZpY2UgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3Qgd2ViZ3B1T3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG5cbiAgICAgICAgICAgIC8vIHNldCBjdXN0b20gR1BVIGRldmljZVxuICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnMuZGV2aWNlKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgR1BVRGV2aWNlICE9PSAndW5kZWZpbmVkJyAmJiB3ZWJncHVPcHRpb25zLmRldmljZSBpbnN0YW5jZW9mIEdQVURldmljZSkge1xuICAgICAgICAgICAgICAgIGN1c3RvbURldmljZSA9IHdlYmdwdU9wdGlvbnMuZGV2aWNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgZGV2aWNlIHNldCBpbiBXZWJHUFUgRVAgb3B0aW9ucy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgZ3JhcGggY2FwdHVyZSBvcHRpb24gZnJvbSBzZXNzaW9uIG9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHsgZW5hYmxlR3JhcGhDYXB0dXJlIH0gPSBzZXNzaW9uT3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5hYmxlR3JhcGhDYXB0dXJlID09PSAnYm9vbGVhbicgJiYgZW5hYmxlR3JhcGhDYXB0dXJlKSB7XG4gICAgICAgICAgICAgIGFwcGVuZEVwT3B0aW9uKGVwT3B0aW9ucywgJ2VuYWJsZUdyYXBoQ2FwdHVyZScsICcxJywgYWxsb2NzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGxheW91dCBvcHRpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGFwcGVuZEVwT3B0aW9uKGVwT3B0aW9ucywgJ3ByZWZlcnJlZExheW91dCcsIHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0LCBhbGxvY3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgZm9yY2UgQ1BVIGZhbGxiYWNrIG5vZGVzXG4gICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy5mb3JjZUNwdU5vZGVOYW1lcykge1xuICAgICAgICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmlzQXJyYXkod2ViZ3B1T3B0aW9ucy5mb3JjZUNwdU5vZGVOYW1lcylcbiAgICAgICAgICAgICAgICA/IHdlYmdwdU9wdGlvbnMuZm9yY2VDcHVOb2RlTmFtZXNcbiAgICAgICAgICAgICAgICA6IFt3ZWJncHVPcHRpb25zLmZvcmNlQ3B1Tm9kZU5hbWVzXTtcblxuICAgICAgICAgICAgICBhcHBlbmRFcE9wdGlvbihlcE9wdGlvbnMsICdmb3JjZUNwdU5vZGVOYW1lcycsIG5hbWVzLmpvaW4oJ1xcbicpLCBhbGxvY3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgdmFsaWRhdGlvbiBtb2RlXG4gICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy52YWxpZGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgICBhcHBlbmRFcE9wdGlvbihlcE9wdGlvbnMsICd2YWxpZGF0aW9uTW9kZScsIHdlYmdwdU9wdGlvbnMudmFsaWRhdGlvbk1vZGUsIGFsbG9jcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaW5mbyA9IGdldEluc3RhbmNlKCkud2ViZ3B1UmVnaXN0ZXJEZXZpY2UhKGN1c3RvbURldmljZSk7XG4gICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IFtkZXZpY2VJZCwgaW5zdGFuY2VIYW5kbGUsIGRldmljZUhhbmRsZV0gPSBpbmZvO1xuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnZGV2aWNlSWQnLCBkZXZpY2VJZC50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnd2ViZ3B1SW5zdGFuY2UnLCBpbnN0YW5jZUhhbmRsZS50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnd2ViZ3B1RGV2aWNlJywgZGV2aWNlSGFuZGxlLnRvU3RyaW5nKCksIGFsbG9jcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVwTmFtZSA9ICdKUyc7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHdlYmdwdU9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnM/LnByZWZlcnJlZExheW91dCkge1xuICAgICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOQ0hXJyAmJiB3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05IV0MnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHt3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dH1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcHBlbmRTZXNzaW9uQ29uZmlnKHNlc3Npb25PcHRpb25zSGFuZGxlLCAncHJlZmVycmVkTGF5b3V0Jywgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQsIGFsbG9jcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2FzbSc6XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGVwTmFtZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZXBOYW1lLCBhbGxvY3MpO1xuICAgIGNvbnN0IGVwT3B0aW9uc0NvdW50ID0gZXBPcHRpb25zLmxlbmd0aDtcbiAgICBsZXQga2V5c09mZnNldCA9IDA7XG4gICAgbGV0IHZhbHVlc09mZnNldCA9IDA7XG4gICAgaWYgKGVwT3B0aW9uc0NvdW50ID4gMCkge1xuICAgICAga2V5c09mZnNldCA9IGdldEluc3RhbmNlKCkuX21hbGxvYyhlcE9wdGlvbnNDb3VudCAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUpO1xuICAgICAgYWxsb2NzLnB1c2goa2V5c09mZnNldCk7XG4gICAgICB2YWx1ZXNPZmZzZXQgPSBnZXRJbnN0YW5jZSgpLl9tYWxsb2MoZXBPcHRpb25zQ291bnQgKiBnZXRJbnN0YW5jZSgpLlBUUl9TSVpFKTtcbiAgICAgIGFsbG9jcy5wdXNoKHZhbHVlc09mZnNldCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVwT3B0aW9uc0NvdW50OyBpKyspIHtcbiAgICAgICAgZ2V0SW5zdGFuY2UoKS5zZXRWYWx1ZShrZXlzT2Zmc2V0ICsgaSAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUsIGVwT3B0aW9uc1tpXVswXSwgJyonKTtcbiAgICAgICAgZ2V0SW5zdGFuY2UoKS5zZXRWYWx1ZSh2YWx1ZXNPZmZzZXQgKyBpICogZ2V0SW5zdGFuY2UoKS5QVFJfU0laRSwgZXBPcHRpb25zW2ldWzFdLCAnKicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXG4gICAgICAoYXdhaXQgZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoXG4gICAgICAgIHNlc3Npb25PcHRpb25zSGFuZGxlLFxuICAgICAgICBlcE5hbWVEYXRhT2Zmc2V0LFxuICAgICAgICBrZXlzT2Zmc2V0LFxuICAgICAgICB2YWx1ZXNPZmZzZXQsXG4gICAgICAgIGVwT3B0aW9uc0NvdW50LFxuICAgICAgKSkgIT09IDBcbiAgICApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX0uYCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0U2Vzc2lvbk9wdGlvbnMgPSBhc3luYyAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPFtudW1iZXIsIG51bWJlcltdXT4gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgYXBwZW5kRGVmYXVsdE9wdGlvbnMoc2Vzc2lvbk9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA9IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbChzZXNzaW9uT3B0aW9ucy5ncmFwaE9wdGltaXphdGlvbkxldmVsID8/ICdhbGwnKTtcbiAgICBjb25zdCBleGVjdXRpb25Nb2RlID0gZ2V0RXhlY3V0aW9uTW9kZShzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Nb2RlID8/ICdzZXF1ZW50aWFsJyk7XG4gICAgY29uc3QgbG9nSWREYXRhT2Zmc2V0ID1cbiAgICAgIHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5sb2dJZCA9PT0gJ3N0cmluZycgPyBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMubG9nSWQsIGFsbG9jcykgOiAwO1xuXG4gICAgY29uc3QgbG9nU2V2ZXJpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPz8gMjsgLy8gRGVmYXVsdCB0byAyIC0gd2FybmluZ1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2dTZXZlcml0eUxldmVsKSB8fCBsb2dTZXZlcml0eUxldmVsIDwgMCB8fCBsb2dTZXZlcml0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2V2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nVmVyYm9zaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA/PyAwOyAvLyBEZWZhdWx0IHRvIDAgLSB2ZXJib3NlXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1ZlcmJvc2l0eUxldmVsKSB8fCBsb2dWZXJib3NpdHlMZXZlbCA8IDAgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1ZlcmJvc2l0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQgPVxuICAgICAgdHlwZW9mIHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGggPT09ICdzdHJpbmcnXG4gICAgICAgID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsIGFsbG9jcylcbiAgICAgICAgOiAwO1xuXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcbiAgICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwsXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZUNwdU1lbUFyZW5hLFxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuLFxuICAgICAgZXhlY3V0aW9uTW9kZSxcbiAgICAgICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlUHJvZmlsaW5nLFxuICAgICAgMCxcbiAgICAgIGxvZ0lkRGF0YU9mZnNldCxcbiAgICAgIGxvZ1NldmVyaXR5TGV2ZWwsXG4gICAgICBsb2dWZXJib3NpdHlMZXZlbCxcbiAgICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQsXG4gICAgKTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgICAgYXdhaXQgc2V0RXhlY3V0aW9uUHJvdmlkZXJzKHNlc3Npb25PcHRpb25zSGFuZGxlLCBzZXNzaW9uT3B0aW9ucywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfWApO1xuICAgICAgfVxuICAgICAgYXBwZW5kU2Vzc2lvbkNvbmZpZyhcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUsXG4gICAgICAgICdlbmFibGVHcmFwaENhcHR1cmUnLFxuICAgICAgICBzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSxcbiAgICAgICAgYWxsb2NzLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlc3Npb25PcHRpb25zLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG5hbWUsIGFsbG9jcyk7XG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIG5hbWVPZmZzZXQsIHZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHtuYW1lfSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMoc2Vzc2lvbk9wdGlvbnMuZXh0cmEsICcnLCBuZXcgV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgYXBwZW5kU2Vzc2lvbkNvbmZpZyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5LCB2YWx1ZSwgYWxsb2NzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpICE9PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaCgoYWxsb2MpID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIFRoaXMgZmlsZSBpbmNsdWRlcyBjb21tb24gZGVmaW5pdGlvbnMuIFRoZXkgZG8gTk9UIGhhdmUgZGVwZW5kZW5jeSBvbiB0aGUgV2ViQXNzZW1ibHkgaW5zdGFuY2UuXG5cbi8qKlxuICogQ29waWVkIGZyb20gT05OWCBkZWZpbml0aW9uLiBVc2UgdGhpcyB0byBkcm9wIGRlcGVuZGVuY3kgJ29ubnhfcHJvdG8nIHRvIGRlY3JlYXNlIGNvbXBpbGVkIC5qcyBmaWxlIHNpemUuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIERhdGFUeXBlIHtcbiAgdW5kZWZpbmVkID0gMCxcbiAgZmxvYXQgPSAxLFxuICB1aW50OCA9IDIsXG4gIGludDggPSAzLFxuICB1aW50MTYgPSA0LFxuICBpbnQxNiA9IDUsXG4gIGludDMyID0gNixcbiAgaW50NjQgPSA3LFxuICBzdHJpbmcgPSA4LFxuICBib29sID0gOSxcbiAgZmxvYXQxNiA9IDEwLFxuICBkb3VibGUgPSAxMSxcbiAgdWludDMyID0gMTIsXG4gIHVpbnQ2NCA9IDEzLFxuICBjb21wbGV4NjQgPSAxNCxcbiAgY29tcGxleDEyOCA9IDE1LFxuICBiZmxvYXQxNiA9IDE2LFxuXG4gIC8vIDQtYml0IGRhdGEtdHlwZXNcbiAgdWludDQgPSAyMSxcbiAgaW50NCA9IDIyLFxufVxuXG4vKipcbiAqIE1hcCBzdHJpbmcgdGVuc29yIGRhdGEgdG8gZW51bSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0gPSAodHlwZTogc3RyaW5nKTogRGF0YVR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ4O1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50ODtcbiAgICBjYXNlICdib29sJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5ib29sO1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQxNjtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQxNjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MzI7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MzI7XG4gICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQxNjtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5mbG9hdDtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5kb3VibGU7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5zdHJpbmc7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDY0O1xuICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDY0O1xuICAgIGNhc2UgJ2ludDQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDQ7XG4gICAgY2FzZSAndWludDQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGVudW0gdmFsdWUgdG8gc3RyaW5nIHRlbnNvciBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyA9ICh0eXBlUHJvdG86IERhdGFUeXBlKTogVGVuc29yLlR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGVQcm90bykge1xuICAgIGNhc2UgRGF0YVR5cGUuaW50ODpcbiAgICAgIHJldHVybiAnaW50OCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50ODpcbiAgICAgIHJldHVybiAndWludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQxNjpcbiAgICAgIHJldHVybiAnaW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDE2OlxuICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICByZXR1cm4gJ2ludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQzMjpcbiAgICAgIHJldHVybiAndWludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICByZXR1cm4gJ2Zsb2F0MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuZG91YmxlOlxuICAgICAgcmV0dXJuICdmbG9hdDY0JztcbiAgICBjYXNlIERhdGFUeXBlLnN0cmluZzpcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxuICAgICAgcmV0dXJuICdpbnQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NjQ6XG4gICAgICByZXR1cm4gJ3VpbnQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ0OlxuICAgICAgcmV0dXJuICdpbnQ0JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ0OlxuICAgICAgcmV0dXJuICd1aW50NCc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZVByb3RvfWApO1xuICB9XG59O1xuXG4vKipcbiAqIGdldCB0ZW5zb3Igc2l6ZSBpbiBieXRlcyBieSB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBkaW1lbnNpb25zXG4gKiBAcmV0dXJucyBzaXplIGluIGludGVnZXIgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIHR5cGUgaXMgbm90IHN1cHBvcnRlZFxuICovXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMgPSAoXG4gIGRhdGVUeXBlOiBudW1iZXIsXG4gIGRpbXNPclNpemU6IHJlYWRvbmx5IG51bWJlcltdIHwgbnVtYmVyLFxuKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgZWxlbWVudFNpemUgPSBbXG4gICAgLTEsIC8vIHVuZGVmaW5lZCA9IDBcbiAgICA0LCAvLyBmbG9hdCA9IDFcbiAgICAxLCAvLyB1aW50OCA9IDJcbiAgICAxLCAvLyBpbnQ4ID0gM1xuICAgIDIsIC8vIHVpbnQxNiA9IDRcbiAgICAyLCAvLyBpbnQxNiA9IDVcbiAgICA0LCAvLyBpbnQzMiA9IDZcbiAgICA4LCAvLyBpbnQ2NCA9IDdcbiAgICAtMSwgLy8gc3RyaW5nID0gOFxuICAgIDEsIC8vIGJvb2wgPSA5XG4gICAgMiwgLy8gZmxvYXQxNiA9IDEwXG4gICAgOCwgLy8gZG91YmxlID0gMTFcbiAgICA0LCAvLyB1aW50MzIgPSAxMlxuICAgIDgsIC8vIHVpbnQ2NCA9IDEzXG4gICAgLTEsIC8vIGNvbXBsZXg2NCA9IDE0XG4gICAgLTEsIC8vIGNvbXBsZXgxMjggPSAxNVxuICAgIC0xLCAvLyBiZmxvYXQxNiA9IDE2XG4gICAgLTEsIC8vIEZMT0FUOEU0TTNGTiA9IDE3XG4gICAgLTEsIC8vIEZMT0FUOEU0TTNGTlVaID0gMThcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMiA9IDE5XG4gICAgLTEsIC8vIEZMT0FUOEU1TTJGTlVaID0gMjBcbiAgICAwLjUsIC8vIHVpbnQ0ID0gMjFcbiAgICAwLjUsIC8vIGludDQgPSAyMlxuICBdW2RhdGVUeXBlXTtcblxuICBjb25zdCBzaXplID0gdHlwZW9mIGRpbXNPclNpemUgPT09ICdudW1iZXInID8gZGltc09yU2l6ZSA6IGRpbXNPclNpemUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gIHJldHVybiBlbGVtZW50U2l6ZSA+IDAgPyBNYXRoLmNlaWwoc2l6ZSAqIGVsZW1lbnRTaXplKSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogZ2V0IHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIGJ5IHRoZSBnaXZlbiB0ZW5zb3IgdHlwZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gKFxuICB0eXBlOiBUZW5zb3IuVHlwZSxcbik6XG4gIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQxNkFycmF5Q29uc3RydWN0b3JcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3JcbiAgfCBCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICAvLyBhbGxvdyBGbG9hdDE2QXJyYXkgcG9seWZpbGwuXG4gICAgICByZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBGbG9hdDE2QXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIEludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBGbG9hdDY0QXJyYXk7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgICByZXR1cm4gQmlnSW50NjRBcnJheTtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ1VpbnQ2NEFycmF5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgc3RyaW5nIGxvZyBsZXZlbCB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dMZXZlbFN0cmluZ1RvRW51bSA9IChsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChsb2dMZXZlbCkge1xuICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7bG9nTGV2ZWx9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdGVuc29yIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IEdQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9PlxuICB0eXBlID09PSAnZmxvYXQzMicgfHxcbiAgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8XG4gIHR5cGUgPT09ICdpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ2ludDY0JyB8fFxuICB0eXBlID09PSAndWludDMyJyB8fFxuICB0eXBlID09PSAndWludDgnIHx8XG4gIHR5cGUgPT09ICdib29sJyB8fFxuICB0eXBlID09PSAndWludDQnIHx8XG4gIHR5cGUgPT09ICdpbnQ0JztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgV2ViTk4gTUxUZW5zb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTUxUZW5zb3JTdXBwb3J0ZWRUeXBlID0gKHR5cGU6IFRlbnNvci5UeXBlKTogdHlwZSBpcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPT5cbiAgdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XG4gIHR5cGUgPT09ICdmbG9hdDE2JyB8fFxuICB0eXBlID09PSAnaW50MzInIHx8XG4gIHR5cGUgPT09ICdpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ2ludDgnIHx8XG4gIHR5cGUgPT09ICd1aW50OCcgfHxcbiAgdHlwZSA9PT0gJ2Jvb2wnIHx8XG4gIHR5cGUgPT09ICd1aW50NCcgfHxcbiAgdHlwZSA9PT0gJ2ludDQnO1xuXG4vKipcbiAqIE1hcCBzdHJpbmcgZGF0YSBsb2NhdGlvbiB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0gPSAobG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvY2F0aW9uKSB7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSAnbWwtdGVuc29yJzpcbiAgICAgIHJldHVybiA1O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7bG9jYXRpb259YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGludGVnZXIgZGF0YSBsb2NhdGlvbiB0byBzdHJpbmcgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFMb2NhdGlvbkVudW1Ub1N0cmluZyA9IChsb2NhdGlvbjogbnVtYmVyKTogVGVuc29yLkRhdGFMb2NhdGlvbiB8IHVuZGVmaW5lZCA9PlxuICAoWydub25lJywgJ2NwdScsICdjcHUtcGlubmVkJywgJ3RleHR1cmUnLCAnZ3B1LWJ1ZmZlcicsICdtbC10ZW5zb3InXSBhcyBjb25zdClbbG9jYXRpb25dO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIHRoZSBmaWxlIHRvIGxvYWQuIENhbiBiZSBhIFVSTC9wYXRoLCBhIEJsb2IsIGFuIEFycmF5QnVmZmVyLCBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGUgPSBhc3luYyAoZmlsZTogc3RyaW5nIHwgQmxvYiB8IEFycmF5QnVmZmVyTGlrZSB8IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIC8vIGxvYWQgZmlsZSBpbnRvIEFycmF5QnVmZmVyIGluIE5vZGUuanNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcmVhZEZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6ZnMvcHJvbWlzZXMnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlYWRGaWxlKGZpbGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VSUl9GU19GSUxFX1RPT19MQVJHRScpIHtcbiAgICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIGZzLmNyZWF0ZVJlYWRTdHJlYW0gaW5zdGVhZFxuICAgICAgICAgIGNvbnN0IHsgY3JlYXRlUmVhZFN0cmVhbSB9ID0gcmVxdWlyZSgnbm9kZTpmcycpO1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW0oZmlsZSk7XG4gICAgICAgICAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBicm93c2Vyc1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gY29udGVudExlbmd0aEhlYWRlciA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKSA6IDA7XG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xuICAgICAgICAvLyB3aGVuIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpcyBub3Qgc2V0LCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBmaWxlIHNpemUuIFdlIGFzc3VtZSBpdCBpcyBzbWFsbCBlbm91Z2ggdG9cbiAgICAgICAgLy8gbG9hZCBpbnRvIG1lbW9yeS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBzdHJlYW0gaW5zdGVhZFxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmaWxlU2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHVzZSBXZWJBc3NlbWJseSBNZW1vcnkgdG8gYWxsb2NhdGUgbGFyZ2VyIEFycmF5QnVmZmVyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiBwYWdlcywgbWF4aW11bTogcGFnZXMgfSkuYnVmZmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY2h1bmsuc2V0KHZhbHVlKTtcbiAgICAgICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIDAsIGZpbGVTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShmaWxlKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgbG9nTGV2ZWxTdHJpbmdUb0VudW0gfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbnR5cGUgTG9nTGV2ZWwgPSBOb25OdWxsYWJsZTxFbnZbJ2xvZ0xldmVsJ10+O1xudHlwZSBNZXNzYWdlU3RyaW5nID0gc3RyaW5nO1xudHlwZSBNZXNzYWdlRnVuY3Rpb24gPSAoKSA9PiBzdHJpbmc7XG50eXBlIE1lc3NhZ2UgPSBNZXNzYWdlU3RyaW5nIHwgTWVzc2FnZUZ1bmN0aW9uO1xuXG5jb25zdCBsb2dMZXZlbFByZWZpeCA9IFsnVicsICdJJywgJ1cnLCAnRScsICdGJ107XG5cbmNvbnN0IGRvTG9nID0gKGxldmVsOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyhgWyR7bG9nTGV2ZWxQcmVmaXhbbGV2ZWxdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHttZXNzYWdlfWApO1xufTtcblxubGV0IGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbCB8IHVuZGVmaW5lZDtcbmxldCBkZWJ1ZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGNvbnN0IGNvbmZpZ3VyZUxvZ2dlciA9ICgkY29uZmlnTG9nTGV2ZWw6IExvZ0xldmVsLCAkZGVidWc6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgY29uZmlnTG9nTGV2ZWwgPSAkY29uZmlnTG9nTGV2ZWw7XG4gIGRlYnVnID0gJGRlYnVnO1xufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBsb2dnaW5nIHV0aWxpdHkgdG8gbG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLlxuICovXG5leHBvcnQgY29uc3QgTE9HID0gKGxvZ0xldmVsOiBMb2dMZXZlbCwgbXNnOiBNZXNzYWdlKTogdm9pZCA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VMZXZlbCA9IGxvZ0xldmVsU3RyaW5nVG9FbnVtKGxvZ0xldmVsKTtcbiAgY29uc3QgY29uZmlnTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShjb25maWdMb2dMZXZlbCk7XG4gIGlmIChtZXNzYWdlTGV2ZWwgPj0gY29uZmlnTGV2ZWwpIHtcbiAgICBkb0xvZyhtZXNzYWdlTGV2ZWwsIHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicgPyBtc2coKSA6IG1zZyk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBzaW1wbGUgbG9nZ2luZyB1dGlsaXR5IHRvIGxvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZS4gT25seSBsb2dzIHdoZW4gZGVidWcgaXMgZW5hYmxlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IExPR19ERUJVRzogdHlwZW9mIExPRyA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBMT0c+KSA9PiB7XG4gIGlmIChkZWJ1Zykge1xuICAgIExPRyguLi5hcmdzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY01hdE11bFNoYXBlKGE6IFtudW1iZXIsIG51bWJlcl0sIGI6IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gYVsxXSAhPT0gYlswXSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNTaGFwZShcbiAgICBhZGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYmRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGlzTWF0TXVsID0gZmFsc2UsXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBhcmFuayA9IGFkaW1zLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcbiAgICBpZiAoYXJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBiZGltcztcbiAgICB9XG4gICAgaWYgKGJyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYWRpbXM7XG4gICAgfVxuICAgIGNvbnN0IGNyYW5rID0gTWF0aC5tYXgoYWRpbXMubGVuZ3RoLCBiZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNkaW1zID0gbmV3IEFycmF5PG51bWJlcj4oY3JhbmspO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYXN0IDIgZGltZW5zaW9uIGlmIGl0IGlzIE1hdE11bFxuICAgIGlmIChpc01hdE11bCkge1xuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9IE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFxuICAgICAgICBbYWRpbXNbYXJhbmsgLSAyXSwgYWRpbXNbYXJhbmsgLSAxXV0sXG4gICAgICAgIFtiZGltc1ticmFuayAtIDJdLCBiZGltc1ticmFuayAtIDFdXSxcbiAgICAgICk7XG4gICAgICBpZiAoY1NoYXBlTWF0TXVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFtjZGltc1tjcmFuayAtIDJdLCBjZGltc1tjcmFuayAtIDFdXSA9IGNTaGFwZU1hdE11bDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gaXNNYXRNdWwgPyAzIDogMTsgaSA8PSBjcmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBhTGVuID0gYXJhbmsgLSBpIDwgMCA/IDEgOiBhZGltc1thcmFuayAtIGldO1xuICAgICAgY29uc3QgYkxlbiA9IGJyYW5rIC0gaSA8IDAgPyAxIDogYmRpbXNbYnJhbmsgLSBpXTtcblxuICAgICAgaWYgKGFMZW4gIT09IGJMZW4gJiYgYUxlbiA+IDEgJiYgYkxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgICAgaWYgKGFMZW4gJiYgYkxlbikge1xuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gTWF0aC5tYXgoYUxlbiwgYkxlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIGVpdGhlciBhTGVuIG9yIGJMZW4gaXMgMCwgdGhlIG90aGVyIHNob3VsZCBiZSBlaXRoZXIgMCBvciAxLCBvdGhlcndpc2UgaXQgaXMgbm90IGJyb2FkY2FzdGFibGUuXG4gICAgICAgIGlmIChtYXggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2RpbXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIGZpbmFsU2hhcGUgVGhlIGRlc2lyZWQgc2hhcGUgYWZ0ZXIgYnJvYWRjYXN0aW5nXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGZpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gYWxpZ24gc2hhcGUgdG8gdGhlIHJpZ2h0XG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsUmFuayA9IGZpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGlmIChpbnB1dFJhbmsgPiBmaW5hbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpXG4gICAqL1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGRpbXMgY29ycmVzcG9uZGluZyB0byB0eXBlIGNoYW5nZSB0byBwYWNrLiBleC4gdWludDggZGF0YSB0byB1aW50MzJcbiAgICovXG4gIHN0YXRpYyBjb252ZXJ0U2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHNpemUgPSA0KTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBuZXdEaW1zID0gbmV3IEFycmF5KHJhbmspO1xuICAgIGxldCBpID0gcmFuayAtIDE7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKGRpbXNbaV0gJSBzaXplID09PSAwKSB7XG4gICAgICAgIG5ld0RpbXNbaV0gPSBkaW1zW2ldIC8gc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZSAlIGRpbXNbaV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29udmVydCBzaGFwZScpO1xuICAgICAgfVxuICAgICAgbmV3RGltc1tpXSA9IDE7XG4gICAgICBzaXplIC89IGRpbXNbaV07XG4gICAgICBpLS07XG4gICAgfVxuICAgIGZvciAoaS0tOyBpID49IDA7IGktLSkge1xuICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBuZXdEaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIHRoZSBnaXZlbiBheGlzIChpbmNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpIHRvIHRoZSBnaXZlbiBheGlzIChleGNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIGFuZCB0byB0aGUgZ2l2ZW4gYXhpcyBbc3RhcnQsIGVuZClcbiAgICovXG4gIHN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAvLyBzYWZldHkgY2hlY2sgYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IG11bHRpcGxlIG90aGVyIG1ldGhvZHMgcmVxdWlyaW5nIHNpemUuXG4gICAgICAvLyBzaXplIGNhbm5vdCBiZSBuZWdhdGl2ZS5cbiAgICAgIGlmIChkaW1zW2ldIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBOdW1iZXIoZGltc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgc3RhdGljIGNvbXB1dGVTdHJpZGVzKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAxXSA9IDE7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBkaW1zW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBkaW1zW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlkZXM7XG4gIH1cblxuICAvKipcbiAgICogbm9ybWFsaXplIGF4aXMgb2YgcmFuZ2UgWy1yLCByKSBpbnRvIFswLCByKS5cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVBeGlzKGF4aXM6IG51bWJlciwgdGVuc29yUmFuazogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IC10ZW5zb3JSYW5rICYmIGF4aXMgPj0gdGVuc29yUmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXMgPCAwID8gYXhpcyArIHRlbnNvclJhbmsgOiBheGlzO1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZUF4ZXMoYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHRlbnNvclJhbms/OiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKCh4KSA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuayA/PyBheGVzLmxlbmd0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIGEgZ2l2ZW4gYXJyYXkgYmFzZWQgb24gdGhlIGluZGljZXMgaW4gdGhlIFBlcm0gYXJyYXlcbiAgICogVXNlZCBpbiBUcmFuc3Bvc2VcbiAgICogQHBhcmFtIGEgQXJyYXkgdG8gYmUgc29ydGVkIHN1Y2ggYXMgZGltcyBvciBzdHJpZGVzXG4gICAqIEBwYXJhbSBwZXJtIFBlcm0gZ2l2ZW47IGlmIG51bGwgYSB3aWxsIGJlIHJldmVyc2VkXG4gICAqL1xuICBzdGF0aWMgc29ydEJhc2VkT25QZXJtKGE6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKHBlcm0pIHtcbiAgICAgIHJldHVybiBwZXJtLm1hcCgodikgPT4gYVt2XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWRzIGEgZ2l2ZW4gc2hhcGUgYWNjb3JkaW5nIHRvIHRoZSBwYWRkaW5nIHZhbHVlc1xuICAgKiBAcGFyYW0gZGltcyBzaGFwZSBvZiB0aGUgVGVuc29yIHRvIGJlIHBhZGRlZFxuICAgKiBAcGFyYW0gcGFkIHBhZCB2YWx1ZXNcbiAgICovXG4gIHN0YXRpYyBwYWRTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgcGFkOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgcmV0dXJuIGRpbXMubWFwKCh2LCBpKSA9PiB2ICsgcGFkW2ldICsgcGFkW2kgKyByYW5rXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdHdvIHNoYXBlcyBhcmUgaWRlbnRpY2FsXG4gICAqIEBwYXJhbSBzaGFwZTFcbiAgICogQHBhcmFtIHNoYXBlMlxuICAgKi9cbiAgc3RhdGljIGFyZUVxdWFsKHNoYXBlMTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlMjogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICBpZiAoc2hhcGUxLmxlbmd0aCAhPT0gc2hhcGUyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBzaGFwZTJbaV0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb29sQ29udlV0aWwge1xuICAvKipcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKi9cbiAgc3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sXG4gICAgc3RyaWRlczogbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFpc0dsb2JhbE9wZXJhdG9yICYmIGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgaWYgKGRpbSA+PSBrZXJuZWxTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VybmVsU2hhcGVbZGltXSA9IGlucHV0RGltc1tkaW0gKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBzdHJpZGVzIGxlbmd0aCB0byBtYXRjaCBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpZGVzLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IGRpbGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWxhdGlvbnMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgcGFkcyBsZW5ndGggdG8gbWF0Y2ggMiAqIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHBhZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYWRzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzIGZvciB2YWx1ZXMgaW4ga2VybmVsIHNoYXBlcyBhbmQgcGFkc1xuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZHNbZGltXSA+PSBrZXJuZWxTaGFwZVtkaW1dIHx8IHBhZHNbZGltICsga2VybmVsU2hhcGUubGVuZ3RoXSA+PSBrZXJuZWxTaGFwZVtkaW1dKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBwYWQgdmFsdWVzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGVcbiAgc3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGlzQ2hhbm5lbExhc3Q6IGJvb2xlYW4sXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFhdXRvUGFkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhZHMubGVuZ3RoICE9PSAyICogKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaWRlcy5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChrZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICBpbnB1dERpbXNbZGltICsgKGlzQ2hhbm5lbExhc3QgPyAxIDogMildLFxuICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgIGRpbGF0aW9uc1tkaW1dLFxuICAgICAgICBrZXJuZWxTaGFwZVtkaW1dLFxuICAgICAgICBwYWRzLFxuICAgICAgICBkaW0sXG4gICAgICAgIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICBhdXRvUGFkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICAgIGlucHV0RGltcyxcbiAgICAgIG91dHB1dERpbXMsXG4gICAgICBzdHJpZGVzLFxuICAgICAgZGlsYXRpb25zLFxuICAgICAga2VybmVsU2hhcGUsXG4gICAgICBwYWRzLFxuICAgICAgYXV0b1BhZCxcbiAgICApO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBDb252IG9wIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBDb252IG9wKVxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwIHx8IGZpbHRlckRpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltcycpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihmYWxzZSwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcbiAgLy8gY2FsbGVkIGJ5IGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoKSBhbmQgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSgpXG4gIC8vIGFkanVzdCBwYWRzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGUgcHJpb3IgdG8gc2hhcGUgY29tcHV0YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBvdXRwdXREaW1zOiBudW1iZXJbXSxcbiAgICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxuICApIHtcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChcbiAgICAgICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sXG4gICAgICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgICAgICBkaWxhdGlvbnNbZGltXSxcbiAgICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXG4gICAgICAgICAgICBwYWRzLFxuICAgICAgICAgICAgZGltLFxuICAgICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBhdXRvUGFkLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjb21wdXRlU2hhcGVIZWxwZXIoKSBhbmQgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKClcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gIHByaXZhdGUgc3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgIGluU2l6ZTogbnVtYmVyLFxuICAgIHN0cmlkZTogbnVtYmVyLFxuICAgIGRpbGF0aW9uOiBudW1iZXIsXG4gICAga2VybmVsOiBudW1iZXIsXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgcGFkSGVhZEluZGV4OiBudW1iZXIsXG4gICAgcGFkVGFpbEluZGV4OiBudW1iZXIsXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5TaXplIC0gZGtlcm5lbCkgLyBzdHJpZGUgKyAxKTtcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XG4gICAgICAgIGNhc2UgJ1NBTUVfVVBQRVInOlxuICAgICAgICAgIGlmIChkaWxhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5VGFyZ2V0U2l6ZSA9IChpblNpemUgKyBzdHJpZGUgLSAxKSAvIHN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XG4gICAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPSBhdXRvUGFkID09PSAnU0FNRV9MT1dFUicgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2VtbVV0aWwge1xuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcbiAgLy8gYW5kIHJldHVybiBiYWNrIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGluIHRoZSBmb3JtIG9mIGEgdHVwbGVcbiAgLy8gd2lsbCB0aHJvdyBleGNlcHRpb24gaWYgdGhlIGlucHV0IHNoYXBlcyBhcmUgbm90IGNvbXBhdGlibGVcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGxlZnRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgdHJhbnNMZWZ0OiBib29sZWFuLFxuICAgIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHRyYW5zUmlnaHQ6IGJvb2xlYW4sXG4gICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAobGVmdFNoYXBlLmxlbmd0aCAhPT0gMiB8fCByaWdodFNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMicpO1xuICAgIH1cblxuICAgIGxldCBNOiBudW1iZXI7XG4gICAgbGV0IEs6IG51bWJlcjtcbiAgICBsZXQgTjogbnVtYmVyO1xuXG4gICAgaWYgKHRyYW5zTGVmdCkge1xuICAgICAgTSA9IGxlZnRTaGFwZVsxXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMF07XG4gICAgICBLID0gbGVmdFNoYXBlWzFdO1xuICAgIH1cblxuICAgIGxldCBrRGltID0gLTE7XG5cbiAgICBpZiAodHJhbnNSaWdodCkge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMF07XG4gICAgICBrRGltID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMV07XG4gICAgICBrRGltID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoTSA8PSAwIHx8IE4gPD0gMCB8fCBLIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaGFwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoYmlhc1NoYXBlICYmICFCcm9hZGNhc3RVdGlsLmlzVmFsaWRCcm9hZGNhc3QoYmlhc1NoYXBlLCBbTSwgTl0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTUlOX0NMSVAgPSAtMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuZXhwb3J0IGNvbnN0IE1BWF9DTElQID0gMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKFxuICBkYXRhQnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgdHlwZTogVGVuc29yLlR5cGUsXG4pOlxuICB8IEludDMyQXJyYXlcbiAgfCBVaW50MzJBcnJheVxuICB8IEJpZ0ludDY0QXJyYXlcbiAgfCBCaWdVaW50NjRBcnJheVxuICB8IFVpbnQ4QXJyYXlcbiAgfCBGbG9hdDMyQXJyYXlcbiAgfCBGbG9hdDY0QXJyYXlcbiAgfCBJbnQ4QXJyYXlcbiAgfCBJbnQxNkFycmF5XG4gIHwgVWludDE2QXJyYXkgPT4gbmV3ICh0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSkpKGRhdGFCdWZmZXIpO1xuXG4vKipcbiAqIGEgVGVuc29yVmlldyBkb2VzIG5vdCBvd24gdGhlIGRhdGEuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVmlldyB7XG4gIHJlYWRvbmx5IGRhdGE6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGF0YVR5cGU6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgLyoqXG4gICAqIGdldCBhIEZsb2F0MTZBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBGbG9hdDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXG4gICAqL1xuICBnZXRGbG9hdDMyQXJyYXkoKTogRmxvYXQzMkFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBCaWdJbnQ2NEFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0QmlnSW50NjRBcnJheSgpOiBCaWdJbnQ2NEFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBJbnQzMkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBVaW50MTZBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSBuZXcgdGVuc29yIHZpZXcgd2l0aCB0aGUgc2FtZSBkYXRhIGJ1dCBkaWZmZXJlbnQgZGltZW5zaW9ucy5cbiAgICovXG4gIHJlc2hhcGUobmV3RGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBXZWJOTkJhY2tlbmQgfSBmcm9tICcuLi9iYWNrZW5kLXdlYm5uJztcbmltcG9ydCB7IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uL2xvZyc7XG5cbi8vIFdlYk5OIEFQSSBjdXJyZW50bHkgZG9lcyBub3QgaGF2ZSBhIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmaWxlLiBUaGlzIGZpbGUgaXMgYSB3b3JrYXJvdW5kIHdpdGggdHlwZXMgZ2VuZXJhdGVkIGZyb21cbi8vIFdlYk5OIEFQSSBzcGVjaWZpY2F0aW9uLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYm1hY2hpbmVsZWFybmluZy93ZWJubi9pc3N1ZXMvNjc3XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwid2Vibm4uZC50c1wiIC8+XG5cbi8qKlxuICogTWFwIGZyb20gTUxPcGVyYW5kRGF0YVR5cGUgdG8gc2l6ZSBpbiBiaXRzLiBVc2luZyBiaXRzIGluc3RlYWQgb2YgYnl0ZXMgdG8gYXZvaWQgcG9zc2libGUgcHJlY2lzaW9uIGxvc3Mgb24gaW50NCBhbmQgdWludDQuXG4gKi9cbmNvbnN0IHdlYm5uRGF0YVR5cGVUb1NpemUgPSBuZXcgTWFwPE1MT3BlcmFuZERhdGFUeXBlLCBudW1iZXI+KFtcbiAgWydmbG9hdDMyJywgMzJdLFxuICBbJ2Zsb2F0MTYnLCAxNl0sXG4gIFsnaW50MzInLCAzMl0sXG4gIFsndWludDMyJywgMzJdLFxuICBbJ2ludDY0JywgNjRdLFxuICBbJ3VpbnQ2NCcsIDY0XSxcbiAgWydpbnQ4JywgOF0sXG4gIFsndWludDgnLCA4XSxcbiAgWydpbnQ0JywgNF0sXG4gIFsndWludDQnLCA0XSxcbl0pO1xuXG4vLyBDb252ZXJ0IGludGVnZXIgZGF0YSB0byBhbiBJbnQzMkFycmF5IGJ1ZmZlci5cbi8vIFN1cHBvcnRzIGNvbnZlcnNpb24gZnJvbSBpbnQ2NCwgdWludDY0LCB1aW50MzIsIGludDggYW5kIHVpbnQ4IHRvIGludDMyLlxuZXhwb3J0IGNvbnN0IGNvbnZlcnREYXRhVG9JbnQzMiA9IChkYXRhOiBVaW50OEFycmF5LCBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUpOiBVaW50OEFycmF5ID0+IHtcbiAgaWYgKGRhdGFUeXBlID09PSAnaW50MzInKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBjb25zdCBkYXRhVHlwZVNpemUgPSB3ZWJubkRhdGFUeXBlVG9TaXplLmdldChkYXRhVHlwZSk7XG4gIGlmICghZGF0YVR5cGVTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xuICB9XG4gIGNvbnN0IGJ5dGVzUGVyRWxlbWVudCA9IGRhdGFUeXBlU2l6ZSAvIDg7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZGF0YSBsZW5ndGggaXMgYSBtdWx0aXBsZSBvZiB0aGUgZGF0YSB0eXBlIHNpemUuXG4gIGlmIChkYXRhLmJ5dGVMZW5ndGggJSBieXRlc1BlckVsZW1lbnQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVWludDhBcnJheSBsZW5ndGggLSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtieXRlc1BlckVsZW1lbnR9LmApO1xuICB9XG5cbiAgLy8gQ29udmVydCBVaW50OEFycmF5IHRvIG9yaWdpbmFsIHR5cGVkIGFycmF5LlxuICBjb25zdCBudW1FbGVtZW50cyA9IGRhdGEuYnl0ZUxlbmd0aCAvIGJ5dGVzUGVyRWxlbWVudDtcbiAgY29uc3Qgb3JpZ2luYWxBcnJheSA9IG5ldyAodGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGFUeXBlKSkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgbnVtRWxlbWVudHMpO1xuXG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgY2FzZSAndWludDY0Jzoge1xuICAgICAgLy8gQ29udmVydCBvcmlnaW5hbCB0eXBlZCBhcnJheSB0byBJbnQzMkFycmF5LlxuICAgICAgY29uc3QgaW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KG51bUVsZW1lbnRzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsQXJyYXlbaV07XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJmbG93LlxuICAgICAgICBpZiAodmFsdWUgPiAyMTQ3NDgzNjQ3biB8fCB2YWx1ZSA8IC0yMTQ3NDgzNjQ4bikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IGludDY0IGRhdGEgdG8gaW50MzIgLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnQzMkFycmF5W2ldID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGludDMyQXJyYXkuYnVmZmVyKTtcbiAgICB9XG4gICAgY2FzZSAnaW50OCc6XG4gICAgY2FzZSAndWludDgnOlxuICAgIGNhc2UgJ3VpbnQzMic6IHtcbiAgICAgIC8vIENoZWNrIGZvciBvdmVyZmxvdy5cbiAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ3VpbnQzMicpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlID4gMjE0NzQ4MzY0NykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgY29udmVydCB1aW50MzIgZGF0YSB0byBpbnQzMiAtIHZhbHVlIG91dCBvZiByYW5nZS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ29udmVydCBvcmlnaW5hbCB0eXBlZCBhcnJheSB0byBJbnQzMkFycmF5LlxuICAgICAgY29uc3QgaW50MzJBcnJheSA9IEludDMyQXJyYXkuZnJvbShvcmlnaW5hbEFycmF5LCBOdW1iZXIpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGludDMyQXJyYXkuYnVmZmVyKTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSBjb252ZXJzaW9uIGZyb20gJHtkYXRhVHlwZX0gdG8gJ2ludDMyJ2ApO1xuICB9XG59O1xuXG4vLyBDb252ZXJ0IEludDMyQXJyYXkgZGF0YSB0byBvcmlnaW5hbCBpbnRlZ2VyIGRhdGEgYnVmZmVyLlxuLy8gU3VwcG9ydHMgY29udmVyc2lvbiBmcm9tIGludDMyIHRvIGludDY0LCB1aW50NjQsIHVpbnQzMiwgaW50OCBhbmQgdWludDguXG5leHBvcnQgY29uc3QgY29udmVydEludDMyVG9EYXRhID0gKGRhdGE6IFVpbnQ4QXJyYXksIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSk6IFVpbnQ4QXJyYXkgPT4ge1xuICBpZiAoZGF0YVR5cGUgPT09ICdpbnQzMicpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgZGF0YSBsZW5ndGggaXMgYSBtdWx0aXBsZSBvZiA0IGJ5dGVzIChJbnQzMkFycmF5KS5cbiAgaWYgKGRhdGEuYnl0ZUxlbmd0aCAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVWludDhBcnJheSBsZW5ndGggLSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCAoaW50MzIpLicpO1xuICB9XG5cbiAgLy8gQ29udmVydCBVaW50OEFycmF5IHRvIEludDMyQXJyYXkuXG4gIGNvbnN0IG51bUVsZW1lbnRzID0gZGF0YS5ieXRlTGVuZ3RoIC8gNDtcbiAgY29uc3QgaW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIG51bUVsZW1lbnRzKTtcblxuICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgY2FzZSAnaW50NjQnOiB7XG4gICAgICBjb25zdCBiaWdJbnQ2NEFycmF5ID0gQmlnSW50NjRBcnJheS5mcm9tKGludDMyQXJyYXksIEJpZ0ludCk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYmlnSW50NjRBcnJheS5idWZmZXIpO1xuICAgIH1cbiAgICBjYXNlICd1aW50NjQnOiB7XG4gICAgICBpZiAoaW50MzJBcnJheS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIHVpbjY0IC0gbmVnYXRpdmUgdmFsdWUgZm91bmQuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBiaWdVaW50NjRBcnJheSA9IEJpZ1VpbnQ2NEFycmF5LmZyb20oaW50MzJBcnJheSwgQmlnSW50KTtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaWdVaW50NjRBcnJheS5idWZmZXIpO1xuICAgIH1cbiAgICBjYXNlICdpbnQ4Jzoge1xuICAgICAgaWYgKGludDMyQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlIDwgLTEyOCB8fCB2YWx1ZSA+IDEyNykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byBpbnQ4IC0gdmFsdWUgb3V0IG9mIHJhbmdlLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW50OEFycmF5ID0gSW50OEFycmF5LmZyb20oaW50MzJBcnJheSwgTnVtYmVyKTtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnQ4QXJyYXkuYnVmZmVyKTtcbiAgICB9XG4gICAgY2FzZSAndWludDgnOiB7XG4gICAgICBpZiAoaW50MzJBcnJheS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPCAwIHx8IHZhbHVlID4gMjU1KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIHVpbnQ4IC0gdmFsdWUgb3V0IG9mIHJhbmdlLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShpbnQzMkFycmF5LCBOdW1iZXIpO1xuICAgIH1cbiAgICBjYXNlICd1aW50MzInOiB7XG4gICAgICBpZiAoaW50MzJBcnJheS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIHVpbnQzMiAtIG5lZ2F0aXZlIHZhbHVlIGZvdW5kLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgdWludDMyQXJyYXkgPSBVaW50MzJBcnJheS5mcm9tKGludDMyQXJyYXksIE51bWJlcik7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodWludDMyQXJyYXkuYnVmZmVyKTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSBjb252ZXJzaW9uIGZyb20gJ2ludDMyJyB0byAke2RhdGFUeXBlfWApO1xuICB9XG59O1xuXG5leHBvcnQgdHlwZSBUZW5zb3JJZCA9IG51bWJlcjtcblxuLyoqXG4gKiBNYW5hZ2VzIFRlbnNvcklkIHRvIE1MVGVuc29yIG1hcHBpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yTWFuYWdlciB7XG4gIC8qKlxuICAgKiBSZXNlcnZlIGEgbmV3IFRlbnNvcklkLlxuICAgKi9cbiAgcmVzZXJ2ZVRlbnNvcklkKCk6IFRlbnNvcklkO1xuICAvKipcbiAgICogUmVsZWFzZSBhIFRlbnNvcklkLlxuICAgKi9cbiAgcmVsZWFzZVRlbnNvcklkKHRlbnNvcklkOiBUZW5zb3JJZCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBFbnN1cmUgYSBNTFRlbnNvciBpcyBjcmVhdGVkIGZvciB0aGUgVGVuc29ySWQuXG4gICAqL1xuICBlbnN1cmVUZW5zb3IoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXG4gICAgdGVuc29ySWQ6IFRlbnNvcklkLFxuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSxcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgY29weU9sZDogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxNTFRlbnNvcj47XG4gIC8qKlxuICAgKiBVcGxvYWQgZGF0YSB0byBhIE1MVGVuc29yLlxuICAgKi9cbiAgdXBsb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBEb3dubG9hZCBkYXRhIGZyb20gYSBNTFRlbnNvci5cbiAgICovXG4gIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xuICBkb3dubG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRzdFRlbnNvcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBSZWxlYXNlIGFsbCB0ZW5zb3JzIGZvciBhIGdpdmVuIHNlc3Npb24uXG4gICAqL1xuICByZWxlYXNlVGVuc29yc0ZvclNlc3Npb24oc2Vzc2lvbjogbnVtYmVyKTogdm9pZDtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV4dGVybmFsbHkgY3JlYXRlZCBNTFRlbnNvciB3aXRoIGEgZ2l2ZW4gc2Vzc2lvbiBpZCBhbmQgcmV0dXJuIGEgVGVuc29ySWQuXG4gICAqL1xuICByZWdpc3RlclRlbnNvcihzZXNzaW9uSWQ6IG51bWJlciwgbWxUZW5zb3I6IE1MVGVuc29yLCBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsIHNoYXBlOiBudW1iZXJbXSk6IFRlbnNvcklkO1xufVxuXG5sZXQgdGVuc29yR3VpZCA9IDE7XG5jb25zdCBjcmVhdGVOZXdUZW5zb3JJZCA9ICgpOiBUZW5zb3JJZCA9PiB0ZW5zb3JHdWlkKys7XG5cbi8qKlxuICogTWFwIGZyb20gZGF0YSB0eXBlIHRvIGZhbGxiYWNrIGRhdGEgdHlwZS5cbiAqIFdoZW4gdGhlIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgb3JpZ2luYWwgZGF0YSB0eXBlLCB1c2UgZmFsbGJhY2sgZGF0YSB0eXBlIGFzIHdvcmthcm91bmQuXG4gKiBOb3RlOiBDdXJyZW50bHksIHdlIG9ubHkgc3VwcG9ydCBmYWxsYmFjayB0byBpbnQzMiBmb3IgY2VydGFpbiBpbnRlZ2VyIGRhdGEgdHlwZXMuXG4gKi9cbmNvbnN0IHdlYm5uRGF0YVR5cGVUb0ZhbGxiYWNrID0gbmV3IE1hcDxNTE9wZXJhbmREYXRhVHlwZSwgTUxPcGVyYW5kRGF0YVR5cGU+KFtcbiAgWydpbnQ4JywgJ2ludDMyJ10sXG4gIFsndWludDgnLCAnaW50MzInXSxcbiAgWyd1aW50MzInLCAnaW50MzInXSxcbiAgWydpbnQ2NCcsICdpbnQzMiddLFxuXSk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBieXRlIGxlbmd0aCBvZiBhIHRlbnNvciB3aXRoIHRoZSBnaXZlbiBkYXRhIHR5cGUgYW5kIHNoYXBlLlxuICovXG5jb25zdCBjYWxjdWxhdGVCeXRlTGVuZ3RoID0gKGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyID0+IHtcbiAgY29uc3QgZGF0YVR5cGVTaXplID0gd2Vibm5EYXRhVHlwZVRvU2l6ZS5nZXQoZGF0YVR5cGUpO1xuICBpZiAoIWRhdGFUeXBlU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgV2ViTk4gYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IGRhdGEgdHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgfVxuICByZXR1cm4gc2hhcGUubGVuZ3RoID4gMCA/IE1hdGguY2VpbCgoc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYikgKiBkYXRhVHlwZVNpemUpIC8gOCkgOiAwO1xufTtcblxuLyoqXG4gKiBUZW5zb3JXcmFwcGVyIHdyYXBzIGFuIE1MVGVuc29yIGFuZCBwcm92aWRlcyBhIHdheSB0byB0cmFjayB0aGUgbGFzdCBzZXNzaW9uIHRoYXQgdXNlZCBpdC5cbiAqL1xuY2xhc3MgVGVuc29yV3JhcHBlciB7XG4gIC8vIFRoZSBpZCBvZiB0aGUgbGFzdCBzZXNzaW9uIHRoYXQgdXNlZCB0aGlzIHRlbnNvci5cbiAgcHVibGljIHNlc3Npb25JZDogbnVtYmVyO1xuICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBkYXRhIGhhcyBiZWVuIGNvbnZlcnRlZCB0byBmYWxsYmFjayBkYXRhIHR5cGUuXG4gIHB1YmxpYyBpc0RhdGFDb252ZXJ0ZWQgPSBmYWxzZTtcblxuICBwcml2YXRlIG1sQ29udGV4dDogTUxDb250ZXh0O1xuICBwcml2YXRlIG1sVGVuc29yOiBNTFRlbnNvcjtcbiAgcHJpdmF0ZSBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGU7XG4gIC8vIEZhbGxiYWNrIGRhdGEgdHlwZSB0byB1c2Ugd2hlbiB0aGUgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBvcmlnaW5hbCBkYXRhIHR5cGUuXG4gIHByaXZhdGUgZmFsbGJhY2tEYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgdGVuc29yU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKGRlc2NyaXB0b3I6IHtcbiAgICBzZXNzaW9uSWQ6IG51bWJlcjtcbiAgICBjb250ZXh0OiBNTENvbnRleHQ7XG4gICAgdGVuc29yOiBNTFRlbnNvcjtcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGU7XG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICAgIGZhbGxiYWNrRGF0YVR5cGU/OiBNTE9wZXJhbmREYXRhVHlwZTtcbiAgfSkge1xuICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBjb250ZXh0LCB0ZW5zb3IsIGRhdGFUeXBlLCBzaGFwZSwgZmFsbGJhY2tEYXRhVHlwZSB9ID0gZGVzY3JpcHRvcjtcbiAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB0aGlzLm1sQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5tbFRlbnNvciA9IHRlbnNvcjtcbiAgICB0aGlzLmRhdGFUeXBlID0gZGF0YVR5cGU7XG4gICAgdGhpcy50ZW5zb3JTaGFwZSA9IHNoYXBlO1xuICAgIHRoaXMuZmFsbGJhY2tEYXRhVHlwZSA9IGZhbGxiYWNrRGF0YVR5cGU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHRlbnNvcigpOiBNTFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMubWxUZW5zb3I7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHR5cGUoKTogTUxPcGVyYW5kRGF0YVR5cGUge1xuICAgIHJldHVybiB0aGlzLmRhdGFUeXBlO1xuICB9XG5cbiAgcHVibGljIGdldCBmYWxsYmFja1R5cGUoKTogTUxPcGVyYW5kRGF0YVR5cGUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmZhbGxiYWNrRGF0YVR5cGU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNoYXBlKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JTaGFwZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnl0ZUxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiBjYWxjdWxhdGVCeXRlTGVuZ3RoKHRoaXMuZGF0YVR5cGUsIHRoaXMudGVuc29yU2hhcGUpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gJ1tXZWJOTl0gVGVuc29yV3JhcHBlci5kZXN0cm95Jyk7XG4gICAgdGhpcy5tbFRlbnNvci5kZXN0cm95KCk7XG4gIH1cblxuICBwdWJsaWMgd3JpdGUoZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xuICAgIHRoaXMubWxDb250ZXh0LndyaXRlVGVuc29yKHRoaXMubWxUZW5zb3IsIGRhdGEpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWQoKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj47XG4gIHB1YmxpYyBhc3luYyByZWFkKGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD47XG4gIHB1YmxpYyBhc3luYyByZWFkKGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICh0aGlzLmZhbGxiYWNrRGF0YVR5cGUpIHtcbiAgICAgIC8vIFRoaXMgdGVuc29yIGhhcyBiZWVuIGZhbGxiYWNrIHRvIGludDMyIGFzIHdvcmthcm91bmQsIHdlIG5lZWQgdG8gcmVhZCBpdCBhcyBpdHMgb3JpZ2luYWwgaW50ZWdlciBkYXRhIHR5cGUuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGF0YSA9IGNvbnZlcnRJbnQzMlRvRGF0YShuZXcgVWludDhBcnJheShkYXRhKSwgdGhpcy5kYXRhVHlwZSk7XG5cbiAgICAgIGlmIChkc3RCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyID1cbiAgICAgICAgICBkc3RCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgPyBuZXcgVWludDhBcnJheShkc3RCdWZmZXIpXG4gICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlci5idWZmZXIsIGRzdEJ1ZmZlci5ieXRlT2Zmc2V0LCBkc3RCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRhcmdldEJ1ZmZlci5zZXQob3JpZ2luYWxEYXRhKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbERhdGEuYnVmZmVyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZHN0QnVmZmVyID8gdGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yLCBkc3RCdWZmZXIpIDogdGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2FuUmV1c2VUZW5zb3IoY29udGV4dDogTUxDb250ZXh0LCBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1sQ29udGV4dCA9PT0gY29udGV4dCAmJlxuICAgICAgdGhpcy5kYXRhVHlwZSA9PT0gZGF0YVR5cGUgJiZcbiAgICAgIHRoaXMudGVuc29yU2hhcGUubGVuZ3RoID09PSBzaGFwZS5sZW5ndGggJiZcbiAgICAgIHRoaXMudGVuc29yU2hhcGUuZXZlcnkoKHYsIGkpID0+IHYgPT09IHNoYXBlW2ldKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgc2V0SXNEYXRhQ29udmVydGVkKGlzQ29udmVydGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5pc0RhdGFDb252ZXJ0ZWQgPSBpc0NvbnZlcnRlZDtcbiAgfVxufVxuXG4vKipcbiAqIFRlbnNvclRyYWNrZXIgdHJhY2tzIHRoZSBNTFRlbnNvciBhbmQgcGVuZGluZyB1cGxvYWQgZGF0YS5cbiAqXG4gKiBXZSBuZWVkIHRvIHRyYWNrIHRoZSBNTFRlbnNvciBhbmQgcGVuZGluZyB1cGxvYWQgZGF0YSBiZWNhdXNlIHdlIGRlbGF5IHRoZSBjcmVhdGlvbiBvZiBNTFRlbnNvciB1bnRpbFxuICogd2Uga25vdyB0aGUgZGF0YSB0eXBlIGFuZCBzaGFwZS4gVGhpcyBpcyBiZWNhdXNlIFdlYk5OIG9ubHkgc3VwcG9ydCBjcmVhdGluZyBNTFRlbnNvcnMgd2l0aCBkYXRhVHlwZXMgYW5kIHNoYXBlLlxuICovXG5jbGFzcyBUZW5zb3JJZFRyYWNrZXIge1xuICBwcml2YXRlIGFjdGl2ZVVwbG9hZD86IFVpbnQ4QXJyYXk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW5zb3JNYW5hZ2VyOiBUZW5zb3JNYW5hZ2VySW1wbCxcbiAgICBwcml2YXRlIHdyYXBwZXI/OiBUZW5zb3JXcmFwcGVyLFxuICApIHt9XG5cbiAgcHVibGljIGdldCB0ZW5zb3JXcmFwcGVyKCk6IFRlbnNvcldyYXBwZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLndyYXBwZXI7XG4gIH1cblxuICBwdWJsaWMgcmVsZWFzZVRlbnNvcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50ZW5zb3JXcmFwcGVyKSB7XG4gICAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcih0aGlzLnRlbnNvcldyYXBwZXIpO1xuICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbnN1cmVUZW5zb3IoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxuICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBjb3B5T2xkOiBib29sZWFuLFxuICApOiBQcm9taXNlPE1MVGVuc29yPiB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMudGVuc29yTWFuYWdlci5nZXRNTENvbnRleHQoc2Vzc2lvbklkKTtcbiAgICBjb25zdCBvcExpbWl0cyA9IHRoaXMudGVuc29yTWFuYWdlci5nZXRNTE9wU3VwcG9ydExpbWl0cyhzZXNzaW9uSWQpO1xuICAgIGxldCBmYWxsYmFja0RhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSB8IHVuZGVmaW5lZDtcbiAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBzdXBwb3J0cyB0aGUgZGF0YSB0eXBlLiBJZiBub3QsIHRyeSB0byB1c2UgdGhlIGZhbGxiYWNrIGRhdGEgdHlwZS5cbiAgICBpZiAoIW9wTGltaXRzPy5pbnB1dC5kYXRhVHlwZXMuaW5jbHVkZXMoZGF0YVR5cGUpKSB7XG4gICAgICBmYWxsYmFja0RhdGFUeXBlID0gd2Vibm5EYXRhVHlwZVRvRmFsbGJhY2suZ2V0KGRhdGFUeXBlKTtcbiAgICAgIGlmICghZmFsbGJhY2tEYXRhVHlwZSB8fCBvcExpbWl0cz8uaW5wdXQuZGF0YVR5cGVzLmluY2x1ZGVzKGZhbGxiYWNrRGF0YVR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViTk4gYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IGRhdGEgdHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIExPR19ERUJVRyhcbiAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAoKSA9PiBgW1dlYk5OXSBUZW5zb3JJZFRyYWNrZXIuZW5zdXJlVGVuc29yOiBmYWxsYmFjayBkYXRhVHlwZSBmcm9tICR7ZGF0YVR5cGV9IHRvICR7ZmFsbGJhY2tEYXRhVHlwZX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICBpZiAodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKGNvbnRleHQsIGRhdGFUeXBlLCBzaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlci50ZW5zb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29weU9sZCkge1xuICAgICAgICAgIGlmICh0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCAhPT0gY2FsY3VsYXRlQnl0ZUxlbmd0aChkYXRhVHlwZSwgc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjb3B5IGRhdGEgdG8gdGVuc29yIHdpdGggZGlmZmVyZW50IHNpemUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWN0aXZlVXBsb2FkID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGNvbnN0IHVzYWdlID0gdHlwZW9mIE1MVGVuc29yVXNhZ2UgPT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNTFRlbnNvclVzYWdlLlJFQUQgfCBNTFRlbnNvclVzYWdlLldSSVRFO1xuICAgIHRoaXMud3JhcHBlciA9IGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5nZXRDYWNoZWRUZW5zb3IoXG4gICAgICBzZXNzaW9uSWQsXG4gICAgICBkYXRhVHlwZSxcbiAgICAgIHNoYXBlLFxuICAgICAgdXNhZ2UsXG4gICAgICB0cnVlLFxuICAgICAgdHJ1ZSxcbiAgICAgIGZhbGxiYWNrRGF0YVR5cGUsXG4gICAgKTtcblxuICAgIGlmIChjb3B5T2xkICYmIHRoaXMuYWN0aXZlVXBsb2FkKSB7XG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnZlcnQgdGhlIG9yaWdpbmFsIGludGVnZXIgZGF0YSB0byBpbnQzMixcbiAgICAgIC8vIGJlY2F1c2UgaXQgaGFzIGJlZW4gY29udmVydGVkIHdoZW4gaXQgd2FzIHVwbG9hZGVkLlxuICAgICAgdGhpcy53cmFwcGVyLndyaXRlKHRoaXMuYWN0aXZlVXBsb2FkKTtcbiAgICAgIHRoaXMuYWN0aXZlVXBsb2FkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLndyYXBwZXIudGVuc29yO1xuICB9XG5cbiAgcHVibGljIHVwbG9hZChkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgbGV0IG5ld0RhdGEgPSBkYXRhO1xuICAgIGlmICh0aGlzLndyYXBwZXIpIHtcbiAgICAgIGlmICh0aGlzLndyYXBwZXIuZmFsbGJhY2tUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXIuZmFsbGJhY2tUeXBlID09PSAnaW50MzInKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBvcmlnaW5hbCBpbnRlZ2VyIGRhdGEgdG8gaW50MzIuXG4gICAgICAgICAgbmV3RGF0YSA9IGNvbnZlcnREYXRhVG9JbnQzMihkYXRhLCB0aGlzLndyYXBwZXIudHlwZSk7XG4gICAgICAgICAgdGhpcy53cmFwcGVyLnNldElzRGF0YUNvbnZlcnRlZCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGZhbGxiYWNrIGRhdGEgdHlwZTogJHt0aGlzLndyYXBwZXIuZmFsbGJhY2tUeXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBkYXRhIHNpemUgbWF0Y2hlcyB0aGUgdGVuc29yIHNpemUuXG4gICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSB0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAvLyBXcml0ZSB0aGUgbmV3RGF0YSB0byB0aGUgdGVuc29yLlxuICAgICAgICB0aGlzLndyYXBwZXIud3JpdGUobmV3RGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+ICdEYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGVuc29yIHNpemUuIFJlbGVhc2luZyB0ZW5zb3IuJyk7XG4gICAgICAgIHRoaXMucmVsZWFzZVRlbnNvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFjdGl2ZVVwbG9hZCkge1xuICAgICAgdGhpcy5hY3RpdmVVcGxvYWQuc2V0KG5ld0RhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjdGl2ZVVwbG9hZCA9IG5ldyBVaW50OEFycmF5KG5ld0RhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkb3dubG9hZChkc3RCdWZmZXI/OiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8QXJyYXlCdWZmZXIgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAodGhpcy5hY3RpdmVVcGxvYWQpIHtcbiAgICAgIC8vIElmIHRoaXMuYWN0aXZlVXBsb2FkIGhhcyBiZWVuIGNvbnZlcnRlZCB0byBpbnQzMiwgd2UgbmVlZCB0byBjb252ZXJ0IGl0IGJhY2sgdG8gb3JpZ2luYWwgaW50ZWdlciBkYXRhIHR5cGUuXG4gICAgICBjb25zdCBkc3REYXRhID0gdGhpcy53cmFwcGVyPy5pc0RhdGFDb252ZXJ0ZWRcbiAgICAgICAgPyBjb252ZXJ0SW50MzJUb0RhdGEodGhpcy5hY3RpdmVVcGxvYWQsIHRoaXMud3JhcHBlcj8udHlwZSlcbiAgICAgICAgOiB0aGlzLmFjdGl2ZVVwbG9hZDtcblxuICAgICAgaWYgKGRzdEJ1ZmZlcikge1xuICAgICAgICBpZiAoZHN0QnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBuZXcgVWludDhBcnJheShkc3RCdWZmZXIpLnNldChkc3REYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXcgVWludDhBcnJheShkc3RCdWZmZXIuYnVmZmVyLCBkc3RCdWZmZXIuYnl0ZU9mZnNldCwgZHN0QnVmZmVyLmJ5dGVMZW5ndGgpLnNldChkc3REYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZHN0RGF0YS5idWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy53cmFwcGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBoYXMgbm90IGJlZW4gY3JlYXRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWRzdEJ1ZmZlcikge1xuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlci5yZWFkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyYXBwZXIucmVhZChkc3RCdWZmZXIpO1xuICB9XG59XG5cbmNsYXNzIFRlbnNvck1hbmFnZXJJbXBsIGltcGxlbWVudHMgVGVuc29yTWFuYWdlciB7XG4gIHByaXZhdGUgdGVuc29yVHJhY2tlcnNCeUlkOiBNYXA8VGVuc29ySWQsIFRlbnNvcklkVHJhY2tlcj4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgZnJlZVRlbnNvcnM6IFRlbnNvcldyYXBwZXJbXSA9IFtdO1xuICBwcml2YXRlIGV4dGVybmFsVGVuc29yczogU2V0PFRlbnNvcldyYXBwZXI+ID0gbmV3IFNldCgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViTk5CYWNrZW5kKSB7fVxuXG4gIHB1YmxpYyBnZXRNTENvbnRleHQoc2Vzc2lvbklkOiBudW1iZXIpOiBNTENvbnRleHQge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmJhY2tlbmQuZ2V0TUxDb250ZXh0KHNlc3Npb25JZCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01MQ29udGV4dCBub3QgZm91bmQgZm9yIHNlc3Npb24uJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgcHVibGljIGdldE1MT3BTdXBwb3J0TGltaXRzKHNlc3Npb25JZDogbnVtYmVyKTogTUxPcFN1cHBvcnRMaW1pdHMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZ2V0TUxPcFN1cHBvcnRMaW1pdHMoc2Vzc2lvbklkKTtcbiAgfVxuXG4gIHB1YmxpYyByZXNlcnZlVGVuc29ySWQoKTogVGVuc29ySWQge1xuICAgIGNvbnN0IHRlbnNvcklkID0gY3JlYXRlTmV3VGVuc29ySWQoKTtcbiAgICB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQodGVuc29ySWQsIG5ldyBUZW5zb3JJZFRyYWNrZXIodGhpcykpO1xuICAgIHJldHVybiB0ZW5zb3JJZDtcbiAgfVxuXG4gIHB1YmxpYyByZWxlYXNlVGVuc29ySWQodGVuc29ySWQ6IFRlbnNvcklkKTogdm9pZCB7XG4gICAgY29uc3QgdGVuc29yVHJhY2tlciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XG4gICAgaWYgKCF0ZW5zb3JUcmFja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmRlbGV0ZSh0ZW5zb3JJZCk7XG4gICAgaWYgKHRlbnNvclRyYWNrZXIudGVuc29yV3JhcHBlcikge1xuICAgICAgdGhpcy5yZWxlYXNlVGVuc29yKHRlbnNvclRyYWNrZXIudGVuc29yV3JhcHBlcik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGVuc3VyZVRlbnNvcihcbiAgICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgICB0ZW5zb3JJZDogVGVuc29ySWQsXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxuICAgIHNoYXBlOiBudW1iZXJbXSxcbiAgICBjb3B5T2xkOiBib29sZWFuLFxuICApOiBQcm9taXNlPE1MVGVuc29yPiB7XG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgKCkgPT5cbiAgICAgICAgYFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke3RlbnNvcklkfSwgZGF0YVR5cGU6ICR7XG4gICAgICAgICAgZGF0YVR5cGVcbiAgICAgICAgfSwgc2hhcGU6ICR7c2hhcGV9LCBjb3B5T2xkOiAke2NvcHlPbGR9fWAsXG4gICAgKTtcbiAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodGVuc29ySWQpO1xuICAgIGlmICghdGVuc29yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBub3QgZm91bmQuJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3IuZW5zdXJlVGVuc29yKHNlc3Npb25JZCwgZGF0YVR5cGUsIHNoYXBlLCBjb3B5T2xkKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgY29uc3QgdGVuc29yID0gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHRlbnNvcklkKTtcbiAgICBpZiAoIXRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3Igbm90IGZvdW5kLicpO1xuICAgIH1cbiAgICB0ZW5zb3IudXBsb2FkKGRhdGEpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xuICBwdWJsaWMgYXN5bmMgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+O1xuICBhc3luYyBkb3dubG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD4ge1xuICAgIExPR19ERUJVRyhcbiAgICAgICd2ZXJib3NlJyxcbiAgICAgICgpID0+IGBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZG93bmxvYWQge3RlbnNvcklkOiAke3RlbnNvcklkfSwgZHN0QnVmZmVyOiAke2RzdEJ1ZmZlcj8uYnl0ZUxlbmd0aH19YCxcbiAgICApO1xuICAgIGNvbnN0IHRlbnNvclRyYWNrZXIgPSB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodGVuc29ySWQpO1xuICAgIGlmICghdGVuc29yVHJhY2tlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3Igbm90IGZvdW5kLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGVuc29yVHJhY2tlci5kb3dubG9hZChkc3RCdWZmZXIpO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgdGVuc29yIG9mIHRoaXMuZnJlZVRlbnNvcnMpIHtcbiAgICAgIGlmICh0ZW5zb3Iuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgdGVuc29yLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcmVlVGVuc29ycyA9IHRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKCh0ZW5zb3IpID0+IHRlbnNvci5zZXNzaW9uSWQgIT09IHNlc3Npb25JZCk7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXJUZW5zb3IoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXG4gICAgbWxUZW5zb3I6IE1MVGVuc29yLFxuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSxcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFRlbnNvcklkIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRNTENvbnRleHQoc2Vzc2lvbklkKTtcbiAgICBjb25zdCB0ZW5zb3JJZCA9IGNyZWF0ZU5ld1RlbnNvcklkKCk7XG4gICAgLy8gRGVmYXVsdGluZyB0byBSRUFEIHwgV1JJVEUgaWYgdXNhZ2UgaXMgbm90IHByb3ZpZGVkLlxuICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgVGVuc29yV3JhcHBlcih7XG4gICAgICBzZXNzaW9uSWQsXG4gICAgICBjb250ZXh0LFxuICAgICAgdGVuc29yOiBtbFRlbnNvcixcbiAgICAgIGRhdGFUeXBlLFxuICAgICAgc2hhcGUsXG4gICAgfSk7XG4gICAgdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHRlbnNvcklkLCBuZXcgVGVuc29ySWRUcmFja2VyKHRoaXMsIHdyYXBwZXIpKTtcbiAgICB0aGlzLmV4dGVybmFsVGVuc29ycy5hZGQod3JhcHBlcik7XG4gICAgcmV0dXJuIHRlbnNvcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBjcmVhdGUgYW4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBzaGFwZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRDYWNoZWRUZW5zb3IoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxuICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICB1c2FnZTogTUxUZW5zb3JVc2FnZUZsYWdzIHwgdW5kZWZpbmVkLFxuICAgIHdyaXRhYmxlOiBib29sZWFuLFxuICAgIHJlYWRhYmxlOiBib29sZWFuLFxuICAgIGZhbGxiYWNrRGF0YVR5cGU/OiBNTE9wZXJhbmREYXRhVHlwZSxcbiAgKTogUHJvbWlzZTxUZW5zb3JXcmFwcGVyPiB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0TUxDb250ZXh0KHNlc3Npb25JZCk7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHRlbnNvcl0gb2YgdGhpcy5mcmVlVGVuc29ycy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICh0ZW5zb3IuY2FuUmV1c2VUZW5zb3IoY29udGV4dCwgZGF0YVR5cGUsIHNoYXBlKSkge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgICBgW1dlYk5OXSBSZXVzaW5nIHRlbnNvciB7ZGF0YVR5cGU6ICR7ZGF0YVR5cGV9LCAke1xuICAgICAgICAgICAgICBmYWxsYmFja0RhdGFUeXBlID8gYGZhbGxiYWNrRGF0YVR5cGU6ICR7ZmFsbGJhY2tEYXRhVHlwZX0sYCA6ICcnXG4gICAgICAgICAgICB9IHNoYXBlOiAke3NoYXBlfWAsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmZyZWVUZW5zb3JzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgIHdyYXBwZXIuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgKCkgPT5cbiAgICAgICAgYFtXZWJOTl0gTUxDb250ZXh0LmNyZWF0ZVRlbnNvciB7ZGF0YVR5cGU6ICR7ZGF0YVR5cGV9LCAke1xuICAgICAgICAgIGZhbGxiYWNrRGF0YVR5cGUgPyBgZmFsbGJhY2tEYXRhVHlwZTogJHtmYWxsYmFja0RhdGFUeXBlfSxgIDogJydcbiAgICAgICAgfSBzaGFwZTogJHtzaGFwZX19YCxcbiAgICApO1xuICAgIGNvbnN0IHRlbnNvciA9IGF3YWl0IGNvbnRleHQuY3JlYXRlVGVuc29yKHtcbiAgICAgIGRhdGFUeXBlOiBmYWxsYmFja0RhdGFUeXBlID8/IGRhdGFUeXBlLCAvLyBJZiBmYWxsYmFjayBkYXRhIHR5cGUgaXMgcHJvdmlkZWQsIHVzZSBpdC5cbiAgICAgIHNoYXBlLFxuICAgICAgZGltZW5zaW9uczogc2hhcGUsXG4gICAgICB1c2FnZSxcbiAgICAgIHdyaXRhYmxlLFxuICAgICAgcmVhZGFibGUsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUZW5zb3JXcmFwcGVyKHsgc2Vzc2lvbklkLCBjb250ZXh0LCB0ZW5zb3IsIGRhdGFUeXBlLCBzaGFwZSwgZmFsbGJhY2tEYXRhVHlwZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRlbnNvciBmb3IgcmV1c2UgdW5sZXNzIGV4dGVybmFsLlxuICAgKi9cbiAgcHVibGljIHJlbGVhc2VUZW5zb3IodGVuc29yV3JhcHBlcjogVGVuc29yV3JhcHBlcikge1xuICAgIGlmICh0aGlzLmV4dGVybmFsVGVuc29ycy5oYXModGVuc29yV3JhcHBlcikpIHtcbiAgICAgIHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmRlbGV0ZSh0ZW5zb3JXcmFwcGVyKTtcbiAgICB9XG4gICAgdGhpcy5mcmVlVGVuc29ycy5wdXNoKHRlbnNvcldyYXBwZXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUZW5zb3JNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgVGVuc29yTWFuYWdlckltcGw+KTogVGVuc29yTWFuYWdlciA9PlxuICBuZXcgVGVuc29yTWFuYWdlckltcGwoLi4uYXJncyk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFdlYk5OIEFQSSBjdXJyZW50bHkgZG9lcyBub3QgaGF2ZSBhIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmaWxlLiBUaGlzIGZpbGUgaXMgYSB3b3JrYXJvdW5kIHdpdGggdHlwZXMgZ2VuZXJhdGVkIGZyb21cbi8vIFdlYk5OIEFQSSBzcGVjaWZpY2F0aW9uLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYm1hY2hpbmVsZWFybmluZy93ZWJubi9pc3N1ZXMvNjc3XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwid2Vibm4vd2Vibm4uZC50c1wiIC8+XG5cbmltcG9ydCB7IEVudiwgVGVuc29yIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgRGF0YVR5cGUsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuLi93YXNtLWZhY3RvcnknO1xuXG5pbXBvcnQgeyBjcmVhdGVWaWV3IH0gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBUZW5zb3JJZCwgY3JlYXRlVGVuc29yTWFuYWdlciwgY29udmVydERhdGFUb0ludDMyIH0gZnJvbSAnLi93ZWJubi90ZW5zb3ItbWFuYWdlcic7XG5pbXBvcnQgeyBjb25maWd1cmVMb2dnZXIsIExPR19ERUJVRyB9IGZyb20gJy4vbG9nJztcblxuLypcbiAqIFRlbnNvclByb3RvOjpkYXRhX3R5cGUgdG8gV2ViTk4gT3BlcmFuZFR5cGUgbWFwcGluZy5cbiAqL1xuY29uc3Qgb25ueERhdGFUeXBlVG9XZWJubkRhdGFUeXBlID0gbmV3IE1hcDxEYXRhVHlwZSwgTUxPcGVyYW5kRGF0YVR5cGU+KFtcbiAgW0RhdGFUeXBlLmZsb2F0LCAnZmxvYXQzMiddLFxuICBbRGF0YVR5cGUuZmxvYXQxNiwgJ2Zsb2F0MTYnXSxcbiAgW0RhdGFUeXBlLmludDMyLCAnaW50MzInXSxcbiAgW0RhdGFUeXBlLnVpbnQzMiwgJ3VpbnQzMiddLFxuICBbRGF0YVR5cGUuaW50NjQsICdpbnQ2NCddLFxuICBbRGF0YVR5cGUudWludDY0LCAndWludDY0J10sXG4gIFtEYXRhVHlwZS5pbnQ0LCAnaW50NCddLFxuICBbRGF0YVR5cGUudWludDQsICd1aW50NCddLFxuICBbRGF0YVR5cGUuaW50OCwgJ2ludDgnXSxcbiAgW0RhdGFUeXBlLnVpbnQ4LCAndWludDgnXSxcbiAgW0RhdGFUeXBlLmJvb2wsICd1aW50OCddLFxuXSk7XG5cbnR5cGUgTUxDb250ZXh0RW50cnkgPSB7XG4gIGdwdURldmljZT86IEdQVURldmljZTtcbiAgb3B0aW9ucz86IE1MQ29udGV4dE9wdGlvbnM7XG4gIG1sQ29udGV4dDogTUxDb250ZXh0O1xufTtcblxuY29uc3QgY29tcGFyZU1MQ29udGV4dE9wdGlvbnMgPSAoYT86IE1MQ29udGV4dE9wdGlvbnMsIGI/OiBNTENvbnRleHRPcHRpb25zKTogYm9vbGVhbiA9PiB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKS5zb3J0KCkgYXMgQXJyYXk8a2V5b2YgdHlwZW9mIGE+O1xuICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpLnNvcnQoKSBhcyBBcnJheTxrZXlvZiB0eXBlb2YgYj47XG4gIHJldHVybiBhS2V5cy5sZW5ndGggPT09IGJLZXlzLmxlbmd0aCAmJiBhS2V5cy5ldmVyeSgoa2V5LCBpbmRleCkgPT4ga2V5ID09PSBiS2V5c1tpbmRleF0gJiYgYVtrZXldID09PSBiW2tleV0pO1xufTtcblxuLyoqXG4gKiBXZWJOTiBiYWNrZW5kIGltcGxlbWVudGF0aW9uLiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgTUxUZW5zb3JzIGNyZWF0ZWQgYnkgdGhlIGJhY2tlbmQgYW5kIGtlZXAgdHJhY2tcbiAqIG9mIHRoZSBjdXJyZW50IE1MQ29udGV4dCBiZWluZyB1c2VkIGJ5IHRoZSBzZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYk5OQmFja2VuZCB7XG4gIC8qKlxuICAgKiBUZW5zb3IgbWFuYWdlcnMgZm9yIGVhY2ggc2Vzc2lvbi5cbiAgICovXG4gIHByaXZhdGUgdGVuc29yTWFuYWdlciA9IGNyZWF0ZVRlbnNvck1hbmFnZXIodGhpcyk7XG4gIC8qKlxuICAgKiBNYXBzIGZyb20gc2Vzc2lvbiBpZCB0byBNTENvbnRleHRzLlxuICAgKi9cbiAgcHJpdmF0ZSBtbENvbnRleHRCeVNlc3Npb25JZCA9IG5ldyBNYXA8bnVtYmVyLCBNTENvbnRleHQ+KCk7XG4gIC8qKlxuICAgKiBNYXBzIGZyb20gTUxDb250ZXh0IHRvIHNlc3Npb24gaWRzLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXNzaW9uSWRzQnlNTENvbnRleHQgPSBuZXcgTWFwPE1MQ29udGV4dCwgU2V0PG51bWJlcj4+KCk7XG4gIC8qKlxuICAgKiBDYWNoZSBvZiBNTENvbnRleHRzLlxuICAgKi9cbiAgcHJpdmF0ZSBtbENvbnRleHRDYWNoZTogTUxDb250ZXh0RW50cnlbXSA9IFtdO1xuICAvKipcbiAgICogQ3VycmVudCBzZXNzaW9uIGlkLlxuICAgKi9cbiAgcHJpdmF0ZSBhY3RpdmVTZXNzaW9uSWQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBNYXBzIGZyb20gc2Vzc2lvbiBpZCB0byBsaXN0IG9mIGdyYXBoIGlucHV0cy5cbiAgICovXG4gIHByaXZhdGUgc2Vzc2lvbkdyYXBoSW5wdXRzOiBNYXA8bnVtYmVyLCBzdHJpbmdbXT4gPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBNYXBzIGZyb20gc2Vzc2lvbiBpZCB0byBsaXN0IG9mIGdyYXBoIG91dHB1dHMuXG4gICAqL1xuICBwcml2YXRlIHNlc3Npb25HcmFwaE91dHB1dHM6IE1hcDxudW1iZXIsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFRlbXBvcmFyeSBncmFwaCBpbnB1dHMgZm9yIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAqIFRoZXNlIGlucHV0cyB3aWxsIGJlIHJlZ2lzdGVyZWQgd2hlbiB0aGUgc2Vzc2lvbiBpcyBjcmVhdGVkLlxuICAgKi9cbiAgcHJpdmF0ZSB0ZW1wb3JhcnlHcmFwaElucHV0czogc3RyaW5nW10gPSBbXTtcbiAgLyoqXG4gICAqIFRlbXBvcmFyeSBncmFwaCBvdXRwdXRzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgKiBUaGVzZSBvdXRwdXRzIHdpbGwgYmUgcmVnaXN0ZXJlZCB3aGVuIHRoZSBzZXNzaW9uIGlzIGNyZWF0ZWQuXG4gICAqL1xuICBwcml2YXRlIHRlbXBvcmFyeUdyYXBoT3V0cHV0czogc3RyaW5nW10gPSBbXTtcbiAgLyoqXG4gICAqIFRlbXBvcmFyeSB0ZW5zb3JzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgKi9cbiAgcHJpdmF0ZSB0ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzOiBNYXA8bnVtYmVyLCBUZW5zb3JJZFtdPiA9IG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIE1hcHMgZnJvbSBzZXNzaW9uIGlkIHRvIE1MT3BTdXBwb3J0TGltaXRzLlxuICAgKi9cbiAgcHJpdmF0ZSBtbE9wU3VwcG9ydExpbWl0c0J5U2Vzc2lvbklkID0gbmV3IE1hcDxudW1iZXIsIE1MT3BTdXBwb3J0TGltaXRzPigpO1xuXG4gIGNvbnN0cnVjdG9yKGVudjogRW52KSB7XG4gICAgY29uZmlndXJlTG9nZ2VyKGVudi5sb2dMZXZlbCEsICEhZW52LmRlYnVnKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY3VycmVudFNlc3Npb25JZCgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmFjdGl2ZVNlc3Npb25JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFjdGl2ZVNlc3Npb25JZDtcbiAgfVxuXG4gIHB1YmxpYyBvblJ1blN0YXJ0KHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gb25SdW5TdGFydCB7c2Vzc2lvbklkOiAke3Nlc3Npb25JZH19YCk7XG4gICAgdGhpcy5hY3RpdmVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH1cblxuICBwdWJsaWMgb25SdW5FbmQoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSBvblJ1bkVuZCB7c2Vzc2lvbklkOiAke3Nlc3Npb25JZH19YCk7XG4gICAgY29uc3QgdGVuc29ySWRzID0gdGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmdldChzZXNzaW9uSWQpO1xuICAgIGlmICghdGVuc29ySWRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGVuc29ySWQgb2YgdGVuc29ySWRzKSB7XG4gICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSByZWxlYXNpbmcgdGVtcG9yYXJ5IHRlbnNvciB7dGVuc29ySWQ6ICR7dGVuc29ySWR9fWApO1xuICAgICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCk7XG4gICAgfVxuICAgIHRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB0aGlzLmFjdGl2ZVNlc3Npb25JZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVNTENvbnRleHQob3B0aW9uc09yRGV2aWNlPzogTUxDb250ZXh0T3B0aW9ucyB8IEdQVURldmljZSk6IFByb21pc2U8TUxDb250ZXh0PiB7XG4gICAgaWYgKG9wdGlvbnNPckRldmljZSBpbnN0YW5jZW9mIEdQVURldmljZSkge1xuICAgICAgY29uc3QgbWxDb250ZXh0SW5kZXggPSB0aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5LmdwdURldmljZSA9PT0gb3B0aW9uc09yRGV2aWNlKTtcbiAgICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbWxDb250ZXh0SW5kZXhdLm1sQ29udGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1sQ29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KG9wdGlvbnNPckRldmljZSk7XG4gICAgICAgIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7IGdwdURldmljZTogb3B0aW9uc09yRGV2aWNlLCBtbENvbnRleHQgfSk7XG4gICAgICAgIHJldHVybiBtbENvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zT3JEZXZpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWxDb250ZXh0SW5kZXggPSB0aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChcbiAgICAgICAgKGVudHJ5KSA9PiBlbnRyeS5vcHRpb25zID09PSB1bmRlZmluZWQgJiYgZW50cnkuZ3B1RGV2aWNlID09PSB1bmRlZmluZWQsXG4gICAgICApO1xuICAgICAgaWYgKG1sQ29udGV4dEluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVttbENvbnRleHRJbmRleF0ubWxDb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWxDb250ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHsgbWxDb250ZXh0IH0pO1xuICAgICAgICByZXR1cm4gbWxDb250ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoKGVudHJ5KSA9PlxuICAgICAgY29tcGFyZU1MQ29udGV4dE9wdGlvbnMoZW50cnkub3B0aW9ucywgb3B0aW9uc09yRGV2aWNlKSxcbiAgICApO1xuICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW21sQ29udGV4dEluZGV4XS5tbENvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1sQ29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KG9wdGlvbnNPckRldmljZSk7XG4gICAgICB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goeyBvcHRpb25zOiBvcHRpb25zT3JEZXZpY2UsIG1sQ29udGV4dCB9KTtcbiAgICAgIHJldHVybiBtbENvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyTUxDb250ZXh0KHNlc3Npb25JZDogbnVtYmVyLCBtbENvbnRleHQ6IE1MQ29udGV4dCk6IHZvaWQge1xuICAgIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHNlc3Npb25JZCwgbWxDb250ZXh0KTtcbiAgICBsZXQgc2Vzc2lvbklkcyA9IHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmdldChtbENvbnRleHQpO1xuICAgIGlmICghc2Vzc2lvbklkcykge1xuICAgICAgc2Vzc2lvbklkcyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LnNldChtbENvbnRleHQsIHNlc3Npb25JZHMpO1xuICAgIH1cbiAgICBzZXNzaW9uSWRzLmFkZChzZXNzaW9uSWQpO1xuXG4gICAgaWYgKCF0aGlzLm1sT3BTdXBwb3J0TGltaXRzQnlTZXNzaW9uSWQuaGFzKHNlc3Npb25JZCkpIHtcbiAgICAgIHRoaXMubWxPcFN1cHBvcnRMaW1pdHNCeVNlc3Npb25JZC5zZXQoc2Vzc2lvbklkLCBtbENvbnRleHQub3BTdXBwb3J0TGltaXRzKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzLnNldChzZXNzaW9uSWQsIHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cyA9IFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZW1wb3JhcnlHcmFwaE91dHB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZXNzaW9uR3JhcGhPdXRwdXRzLnNldChzZXNzaW9uSWQsIHRoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzKTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzID0gW107XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb25HcmFwaElucHV0cy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB0aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgY29uc3QgbWxDb250ZXh0ID0gdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQoc2Vzc2lvbklkKSE7XG4gICAgaWYgKCFtbENvbnRleHQpIHtcbiAgICAgIC8vIEN1cnJlbnQgc2Vzc2lvbiBpcyBub3QgYSBXZWJOTiBzZXNzaW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHNlc3Npb25JZCk7XG4gICAgdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB0aGlzLm1sT3BTdXBwb3J0TGltaXRzQnlTZXNzaW9uSWQuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgY29uc3Qgc2Vzc2lvbklkcyA9IHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmdldChtbENvbnRleHQpITtcbiAgICBzZXNzaW9uSWRzLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIGlmIChzZXNzaW9uSWRzLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShtbENvbnRleHQpO1xuICAgICAgY29uc3QgbWxDb250ZXh0SW5kZXggPSB0aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm1sQ29udGV4dCA9PT0gbWxDb250ZXh0KTtcbiAgICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobWxDb250ZXh0SW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRNTENvbnRleHQoc2Vzc2lvbklkOiBudW1iZXIpOiBNTENvbnRleHQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldChzZXNzaW9uSWQpO1xuICB9XG5cbiAgcHVibGljIGdldE1MT3BTdXBwb3J0TGltaXRzKHNlc3Npb25JZDogbnVtYmVyKTogTUxPcFN1cHBvcnRMaW1pdHMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm1sT3BTdXBwb3J0TGltaXRzQnlTZXNzaW9uSWQuZ2V0KHNlc3Npb25JZCk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXJ2ZVRlbnNvcklkKCk6IFRlbnNvcklkIHtcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZDogVGVuc29ySWQpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSByZWxlYXNlVGVuc29ySWQge3RlbnNvcklkOiAke3RlbnNvcklkfX1gKTtcbiAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHRlbnNvcklkKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbnN1cmVUZW5zb3IoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgdGVuc29ySWQ6IFRlbnNvcklkLFxuICAgIG9ubnhEYXRhVHlwZTogRGF0YVR5cGUsXG4gICAgZGltZW5zaW9uczogbnVtYmVyW10sXG4gICAgY29weU9sZDogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxNTFRlbnNvcj4ge1xuICAgIGNvbnN0IHdlYm5uRGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KG9ubnhEYXRhVHlwZSk7XG4gICAgaWYgKCF3ZWJubkRhdGFUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke29ubnhEYXRhVHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IoXG4gICAgICBzZXNzaW9uSWQgPz8gdGhpcy5jdXJyZW50U2Vzc2lvbklkLFxuICAgICAgdGVuc29ySWQsXG4gICAgICB3ZWJubkRhdGFUeXBlLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIGNvcHlPbGQsXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVUZW1wb3JhcnlUZW5zb3IoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXG4gICAgb25ueERhdGFUeXBlOiBEYXRhVHlwZSxcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFByb21pc2U8VGVuc29ySWQ+IHtcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ige29ubnhEYXRhVHlwZTogJHtvbm54RGF0YVR5cGV9LCBzaGFwZTogJHtzaGFwZX19YCk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KG9ubnhEYXRhVHlwZSk7XG4gICAgaWYgKCFkYXRhVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtvbm54RGF0YVR5cGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IHRlbnNvcklkID0gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpO1xuICAgIGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3JJZCwgZGF0YVR5cGUsIHNoYXBlLCBmYWxzZSk7XG4gICAgY29uc3QgdGVuc29ySWRzID0gdGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmdldChzZXNzaW9uSWQpO1xuICAgIGlmICghdGVuc29ySWRzKSB7XG4gICAgICB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuc2V0KHNlc3Npb25JZCwgW3RlbnNvcklkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbnNvcklkcy5wdXNoKHRlbnNvcklkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbnNvcklkO1xuICB9XG5cbiAgcHVibGljIHVwbG9hZFRlbnNvcih0ZW5zb3JJZDogVGVuc29ySWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIXdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byB1cGxvYWQgdG8gYSBNTFRlbnNvciB3aGlsZSBzaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgaXMgZmFsc2UnKTtcbiAgICB9XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gdXBsb2FkVGVuc29yIHt0ZW5zb3JJZDogJHt0ZW5zb3JJZH0sIGRhdGE6ICR7ZGF0YS5ieXRlTGVuZ3RofX1gKTtcbiAgICB0aGlzLnRlbnNvck1hbmFnZXIudXBsb2FkKHRlbnNvcklkLCBkYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkb3dubG9hZFRlbnNvcih0ZW5zb3JJZDogVGVuc29ySWQsIGRzdEJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodGVuc29ySWQsIGRzdEJ1ZmZlcik7XG4gIH1cblxuICBwdWJsaWMgY3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKHRlbnNvcklkOiBUZW5zb3JJZCwgdHlwZTogVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzKTogKCkgPT4gUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGU+IHtcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0ZW5zb3JJZCk7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhkYXRhLCB0eXBlKTtcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyTUxUZW5zb3Ioc2Vzc2lvbklkOiBudW1iZXIsIHRlbnNvcjogTUxUZW5zb3IsIG9ubnhEYXRhVHlwZTogRGF0YVR5cGUsIGRpbWVuc2lvbnM6IG51bWJlcltdKTogVGVuc29ySWQge1xuICAgIGNvbnN0IHdlYm5uRGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KG9ubnhEYXRhVHlwZSk7XG4gICAgaWYgKCF3ZWJubkRhdGFUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke29ubnhEYXRhVHlwZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IHRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcihzZXNzaW9uSWQsIHRlbnNvciwgd2Vibm5EYXRhVHlwZSwgZGltZW5zaW9ucyk7XG4gICAgTE9HX0RFQlVHKFxuICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgKCkgPT5cbiAgICAgICAgYFtXZWJOTl0gcmVnaXN0ZXJNTFRlbnNvciB7dGVuc29yOiAke3RlbnNvcn0sIGRhdGFUeXBlOiAke3dlYm5uRGF0YVR5cGV9LCBkaW1lbnNpb25zOiAke1xuICAgICAgICAgIGRpbWVuc2lvbnNcbiAgICAgICAgfX0gLT4ge3RlbnNvcklkOiAke2lkfX1gLFxuICAgICk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYSBXZWJOTiBDb25zdGFudCBvcGVyYW5kIGZyb20gZXh0ZXJuYWwgZGF0YS5cbiAgcHVibGljIHJlZ2lzdGVyTUxDb25zdGFudChcbiAgICBleHRlcm5hbEZpbGVQYXRoOiBzdHJpbmcsXG4gICAgZGF0YU9mZnNldDogbnVtYmVyLFxuICAgIGRhdGFMZW5ndGg6IG51bWJlcixcbiAgICBidWlsZGVyOiBNTEdyYXBoQnVpbGRlcixcbiAgICBkZXNjOiBNTE9wZXJhbmREZXNjcmlwdG9yLFxuICAgIG1vdW50ZWRGaWxlczogTWFwPHN0cmluZywgVWludDhBcnJheT4gfCB1bmRlZmluZWQsXG4gICAgc2hvdWxkQ29udmVydEludDY0VG9JbnQzMiA9IGZhbHNlLFxuICApOiBNTE9wZXJhbmQge1xuICAgIC8vIElmIGF2YWlsYWJsZSwgXCJNb2R1bGUuTW91bnRlZEZpbGVzXCIgaXMgYSBNYXAgZm9yIGFsbCBwcmVsb2FkZWQgZmlsZXMuXG4gICAgaWYgKCFtb3VudGVkRmlsZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZXJuYWwgbW91bnRlZCBmaWxlcyBhcmUgbm90IGF2YWlsYWJsZS4nKTtcbiAgICB9XG5cbiAgICBsZXQgZmlsZVBhdGggPSBleHRlcm5hbEZpbGVQYXRoO1xuICAgIGlmIChleHRlcm5hbEZpbGVQYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgIGZpbGVQYXRoID0gZXh0ZXJuYWxGaWxlUGF0aC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVEYXRhID0gbW91bnRlZEZpbGVzLmdldChmaWxlUGF0aCk7XG4gICAgaWYgKCFmaWxlRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWxlIHdpdGggbmFtZSAke2ZpbGVQYXRofSBub3QgZm91bmQgaW4gcHJlbG9hZGVkIGZpbGVzLmApO1xuICAgIH1cblxuICAgIGlmIChkYXRhT2Zmc2V0ICsgZGF0YUxlbmd0aCA+IGZpbGVEYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IGZpbGVEYXRhLnNsaWNlKGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBkYXRhTGVuZ3RoKS5idWZmZXI7XG4gICAgbGV0IGJ1ZmZlclZpZXc6IEFycmF5QnVmZmVyVmlldztcbiAgICBzd2l0Y2ggKGRlc2MuZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgICBidWZmZXJWaWV3ID1cbiAgICAgICAgICB0eXBlb2YgRmxvYXQxNkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBGbG9hdDE2QXJyYXkuZnJvbSA/IG5ldyBGbG9hdDE2QXJyYXkoYnVmZmVyKSA6IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgICAgaWYgKHNob3VsZENvbnZlcnRJbnQ2NFRvSW50MzIpIHtcbiAgICAgICAgICAvLyBJbnQ2NCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29udGV4dCwgdXNlIGludDMyIGluc3RlYWQuXG4gICAgICAgICAgY29uc3QgaW50MzJCdWZmZXIgPSBjb252ZXJ0RGF0YVRvSW50MzIobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgJ2ludDY0Jyk7XG4gICAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBJbnQzMkFycmF5KGludDMyQnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgZGVzYy5kYXRhVHlwZSA9ICdpbnQzMic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyVmlldyA9IG5ldyBCaWdJbnQ2NEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1aW50NjQnOlxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW50NCc6XG4gICAgICBjYXNlICd1aW50NCc6XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2Rlc2MuZGF0YVR5cGV9IGluIGNyZWF0aW5nIFdlYk5OIENvbnN0YW50IGZyb20gZXh0ZXJuYWwgZGF0YS5gKTtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoXG4gICAgICAndmVyYm9zZScsXG4gICAgICAoKSA9PlxuICAgICAgICBgW1dlYk5OXSByZWdpc3Rlck1MQ29uc3RhbnQge2RhdGFUeXBlOiAke2Rlc2MuZGF0YVR5cGV9LCBzaGFwZTogJHtkZXNjLnNoYXBlfX19ICR7XG4gICAgICAgICAgc2hvdWxkQ29udmVydEludDY0VG9JbnQzMiA/ICcoTm90ZTogaXQgd2FzIGludDY0IGRhdGEgdHlwZSBhbmQgcmVnaXN0ZXJlZCB0byBpbnQzMiBhcyB3b3JrYXJvdW5kKScgOiAnJ1xuICAgICAgICB9YCxcbiAgICApO1xuXG4gICAgcmV0dXJuIGJ1aWxkZXIuY29uc3RhbnQoZGVzYywgYnVmZmVyVmlldyk7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXJHcmFwaElucHV0KGlucHV0TmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cy5wdXNoKGlucHV0TmFtZSk7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXJHcmFwaE91dHB1dChvdXRwdXROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cy5wdXNoKG91dHB1dE5hbWUpO1xuICB9XG5cbiAgcHVibGljIGlzR3JhcGhJbnB1dChzZXNzaW9uSWQ6IG51bWJlciwgaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dE5hbWVzID0gdGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKCFpbnB1dE5hbWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dE5hbWVzLmluY2x1ZGVzKGlucHV0TmFtZSk7XG4gIH1cblxuICBwdWJsaWMgaXNHcmFwaE91dHB1dChzZXNzaW9uSWQ6IG51bWJlciwgb3V0cHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSB0aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKCFvdXRwdXROYW1lcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0TmFtZXMuaW5jbHVkZXMob3V0cHV0TmFtZSk7XG4gIH1cblxuICBwdWJsaWMgaXNHcmFwaElucHV0T3V0cHV0VHlwZVN1cHBvcnRlZChzZXNzaW9uSWQ6IG51bWJlciwgdHlwZTogVGVuc29yLlR5cGUsIGlzSW5wdXQgPSB0cnVlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKHR5cGUpKTtcbiAgICBjb25zdCBvcExpbWl0cyA9IHRoaXMubWxPcFN1cHBvcnRMaW1pdHNCeVNlc3Npb25JZC5nZXQoc2Vzc2lvbklkKTtcblxuICAgIGlmICh0eXBlb2YgZGF0YVR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzSW5wdXQpIHtcbiAgICAgIHJldHVybiAhIW9wTGltaXRzPy5pbnB1dC5kYXRhVHlwZXMuaW5jbHVkZXMoZGF0YVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gISFvcExpbWl0cz8ub3V0cHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhkYXRhVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGZsdXNoKCk6IHZvaWQge1xuICAgIC8vIFVubGlrZSB0aGUgV2ViR1BVIGJhY2tlbmQsIHRoZSBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IG5lZWQgdG8gZmx1c2ggYW55IHBlbmRpbmcgb3BlcmF0aW9ucy5cbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi90ZW5zb3Itdmlldyc7XG5cbmltcG9ydCB7IFNoYWRlckhlbHBlciB9IGZyb20gJy4vb3BzL2NvbW1vbic7XG5cbmV4cG9ydCB0eXBlIFNlc3Npb25TdGF0ZSA9ICdkZWZhdWx0JyB8ICdjYXB0dXJpbmcnIHwgJ3JlcGxheWluZyc7XG5cbmV4cG9ydCBlbnVtIEdwdURhdGFUeXBlIHtcbiAgZGVmYXVsdCA9IDAsXG4gIHVwbG9hZCA9IDEsXG4gIHByb2ZpbGUgPSAyLFxufVxuZXhwb3J0IHR5cGUgR3B1RGF0YUlkID0gbnVtYmVyO1xuXG5leHBvcnQgdHlwZSBHcHVBcmNoaXRlY3R1cmUgPSAnYW1wZXJlJyB8ICdnZW4tMTJscCc7XG5leHBvcnQgdHlwZSBHcHVWZW5kb3IgPSAnYW1kJyB8ICdpbnRlbCcgfCAnbnZpZGlhJztcbmV4cG9ydCBpbnRlcmZhY2UgQWRhcHRlckluZm8ge1xuICBpc0FyY2hpdGVjdHVyZTogKGFyY2hpdGVjdHVyZTogR3B1QXJjaGl0ZWN0dXJlKSA9PiBib29sZWFuO1xuICBpc1ZlbmRvcjogKHZlbmRvcjogR3B1VmVuZG9yKSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdwdURhdGEge1xuICB0eXBlOiBHcHVEYXRhVHlwZTtcbiAgaWQ6IEdwdURhdGFJZDtcbiAgYnVmZmVyOiBHUFVCdWZmZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29ySW5mbyB7XG4gIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICBkYXRhVHlwZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1Vbmlmb3JtIHtcbiAgdHlwZTogRGF0YVR5cGU7XG4gIGRhdGE6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5leHBvcnQgdHlwZSBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mbyA9IFt0eXBlOiBEYXRhVHlwZSwgbGVuZ3RoOiBudW1iZXJdO1xuXG4vKipcbiAqIFJlcHJlc2VudCB0aGUgZGVwZW5kZW5jeSBvZiBhIHByb2dyYW0gb24gYSBzcGVjaWZpYyBpbnB1dCB0ZW5zb3IuXG4gKlxuICogLSAnbm9uZSc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkb2VzIG5vdCBkZXBlbmQgb24gdGhpcyBpbnB1dCdzIGluZm9cbiAqIC0gJ3R5cGUnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgb2YgdGhpcyBpbnB1dFxuICogLSAncmFuayc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSBhbmQgdGhlIHJhbmsgb2YgdGhpcyBpbnB1dFxuICogLSAnZGltcyc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSBhbmQgdGhlIGRpbXMgb2YgdGhpcyBpbnB1dFxuICogLSAnZGF0YSc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSwgdGhlIGRpbXMgYW5kIHRoZSBkYXRhIG9mIHRoaXMgaW5wdXRcbiAqL1xuZXhwb3J0IHR5cGUgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3kgPSAnbm9uZScgfCAndHlwZScgfCAncmFuaycgfCAnZGltcycgfCAnZGF0YSc7XG5cbi8qKlxuICogUmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgcHJvZ3JhbSdzIGNhY2hlIGZvciBzaGFkZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBzdHJpbmcgYXMgYSBjYWNoZSBoaW50IGluIHRoZSBhcnRpZmFjdCBjYWNoZS4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgY2FjaGUgaGludCB3aWxsIGJlIGVtcHR5LlxuICAgKlxuICAgKiBUaGlzIGhpbnQgc3RyaW5nIHNob3VsZCBvbmx5IGNvbnRhaW5zIGluaXRpYWxpemluZy10aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBhdHRyaWJ1dGVzIG9yIGFueSBpbmZvcm1hdGlvbiBvZlxuICAgKiBpbml0aWFsaXplcnMuIEl0IHNob3VsZCBOT1QgY29udGFpbiBhbnkgcnVudGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgc2hhcGUgb2YgaW5wdXRzLlxuICAgKi9cbiAgaGludD86IHN0cmluZztcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgbGlzdCBvZiBkZXBlbmRlbmNpZXMgb2YgdGhlIHByb2dyYW0gb24gdGhlIGlucHV0IHRlbnNvcnMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIHByb2dyYW0gZGVwZW5kc1xuICAgKiBvbiAnZGltcycgb2YgYWxsIGlucHV0cy5cbiAgICovXG4gIGlucHV0RGVwZW5kZW5jaWVzPzogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBwcm9ncmFtJ3MgY2FjaGUgZm9yIHVuaWZvcm0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVVuaWZvcm1DYWNoZUluZm8ge1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgc3RyaW5nIGFzIGEgY2FjaGUgaGludCBpbiB0aGUgdW5pZm9ybSBjYWNoZS4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgY2FjaGUgaGludCB3aWxsIGJlIGVtcHR5LlxuICAgKlxuICAgKiBUaGlzIGhpbnQgc3RyaW5nIHNob3VsZCBvbmx5IGNvbnRhaW5zIHJ1bnRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHNoYXBlIG9mIGlucHV0cy5cbiAgICovXG4gIGhpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGxpc3Qgb2YgZGVwZW5kZW5jaWVzIG9mIHRoZSBwcm9ncmFtIG9uIHRoZSBpbnB1dCB0ZW5zb3JzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBwcm9ncmFtIGRlcGVuZHNcbiAgICogb24gJ25vbmUnIG9mIGFsbCBpbnB1dHMuXG4gICAqL1xuICBpbnB1dERlcGVuZGVuY2llcz86IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W107XG59XG5cbi8qKlxuICogQSBzZXQgb2YgZGF0YSB0aGF0IHJlcHJlc2VudCBhIHNoYWRlciBwcm9ncmFtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbUluZm8ge1xuICAvKipcbiAgICogdGhlIG5hbWUgb2YgdGhlIHByb2dyYW0uIHVzZWQgZm9yIGRlYnVnZ2luZyBhbmQgcHJvZmlsaW5nXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjYWNoZSBpbmZvcm1hdGlvbiBvZiB0aGUgcHJvZ3JhbSBzaGFkZXIuXG4gICAqXG4gICAqIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgYXNzdW1lIGhpbnQgaXMgZW1wdHkgYW5kIGlucHV0RGVwZW5kZW5jaWVzIGFyZSBbJ2RpbXMnXSBmb3IgYWxsIGlucHV0cy5cbiAgICovXG4gIHNoYWRlckNhY2hlPzogUHJvZ3JhbVNoYWRlckNhY2hlSW5mbztcblxuICAvKipcbiAgICogdGhlIHNoYWRlcidzIHByb2Nlc3Npbmcgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBzaGFkZXIgY2FjaGUgbWlzc2VkLlxuICAgKi9cbiAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHN0cmluZztcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0byBnZXQgcnVuIGRhdGEgcmVxdWlyZWQgdG8gcnVuIHRoZSBwcm9ncmFtLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb2dyYW0gaXMgZXhlY3V0ZWQuIFNob3VsZCBrZWVwIHRoaXMgZnVuY3Rpb24gYXMgc2ltcGxlIGFzIHBvc3NpYmxlLlxuICAgKi9cbiAgZ2V0UnVuRGF0YTogKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKSA9PiB7XG4gICAgb3V0cHV0czogcmVhZG9ubHkgVGVuc29ySW5mb1tdO1xuICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogbnVtYmVyOyB5PzogbnVtYmVyOyB6PzogbnVtYmVyIH07XG4gICAgcHJvZ3JhbVVuaWZvcm1zPzogcmVhZG9ubHkgUHJvZ3JhbVVuaWZvcm1bXTtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdCB7XG4gIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbztcbiAgY29tcHV0ZVBpcGVsaW5lOiBHUFVDb21wdXRlUGlwZWxpbmU7XG4gIHVuaWZvcm1WYXJpYWJsZXNJbmZvOiByZWFkb25seSBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mb1tdIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcge1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbWFwcGluZyB0byB0aGUgcHJvZ3JhbSdzIGlucHV0cy4gdGhlIHZhbHVlIGNhbiBiZSBhIG51bWJlciBvciBhIHRlbnNvciB2aWV3LlxuICAgKiAtIGlmIGl0J3MgYSBudW1iZXIsIGl0J3MgdGhlIGluZGV4IG9mIHRoZSBrZXJuZWwncyBpbnB1dFxuICAgKiAtIGlmIGl0J3MgYSB0ZW5zb3IgdmlldywgaXQncyBhbiBleGlzdGluZyB0ZW5zb3IgdmlldyB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5wdXRcbiAgICpcbiAgICogaWYgaW5wdXRzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtYXBwaW5nIHdpbGwgYmUgdGhlIGtlcm5lbCdzIGlucHV0cyBpbiBvcmRlci5cbiAgICovXG4gIHJlYWRvbmx5IGlucHV0cz86IFJlYWRvbmx5QXJyYXk8VGVuc29yVmlldyB8IG51bWJlcj47XG4gIC8qKlxuICAgKiBzcGVjaWZ5IHRoZSBtYXBwaW5nIHRvIHRoZSBwcm9ncmFtJ3Mgb3V0cHV0cy4gdGhlIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuXG4gICAqIC0gaWYgaXQncyBhIG5vbi1uZWdhdGl2ZSBudW1iZXIsIGl0J3MgdGhlIGluZGV4IG9mIHRoZSBrZXJuZWwncyBvdXRwdXRcbiAgICogLSBpZiBpdCdzIC0xLCBpdCdzIGFuIG91dHB1dCB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBhIHRlbXBvcmFyeSB2YWx1ZS4gdGhpcyB2YWx1ZSB3aWxsIGJlIHJlbGVhc2VkIGFmdGVyXG4gICAqIHRoZSBrZXJuZWwgaXMgZXhlY3V0ZWQuXG4gICAqIC0gaWYgaXQncyAtMiwgaXQncyBhbiBvdXRwdXQgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYXMgYSBwZXJzaXN0ZW50IHZhbHVlLiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB0aGVcbiAgICoga2VybmVsIGlzIHJlbGVhc2VkLlxuICAgKlxuICAgKiBpZiBvdXRwdXRzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtYXBwaW5nIHdpbGwgYmUgdGhlIGtlcm5lbCdzIG91dHB1dHMgaW4gb3JkZXIuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRzPzogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbi8qKlxuICogQSBDb21wdXRlQ29udGV4dCBpbnN0YW5jZSBjYXJyaWVzIHRoZSBzdGF0ZXMgdGhhdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcnVubmluZyBvZiBhIGtlcm5lbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wdXRlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBncHUgYWRhcHRlciBpbmZvXG4gICAqL1xuICByZWFkb25seSBhZGFwdGVySW5mbzogQWRhcHRlckluZm87XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgcG9pbnRlciB0byBPcEtlcm5lbENvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IG9wS2VybmVsQ29udGV4dDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgaW5wdXRzLCBlYWNoIGlucHV0IGlzIGFuIGluc3RhbmNlIG9mIFRlbnNvclZpZXdcbiAgICovXG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuXG4gIC8qKlxuICAgKiBhIGN1c3RvbSBkYXRhIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFueSBkYXRhIHRoYXQgaXMgbmVlZGVkIGJ5IHRoZSBrZXJuZWxcbiAgICovXG4gIHJlYWRvbmx5IGtlcm5lbEN1c3RvbURhdGE6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xuXG4gIC8qKlxuICAgKiBhIGJ1ZmZlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGFjY2VzcyBjdXN0b20gZGF0YSBjcmVhdGVkIGVhY2ggdGltZSB0aGUga2VybmVsIGlzIGV4ZWN1dGVkXG4gICAqL1xuICByZWFkb25seSBjdXN0b21EYXRhQnVmZmVyOiBVaW50OEFycmF5O1xuXG4gIC8qKlxuICAgKiBhIG51bWJlciBvZiBvdXRwdXRzIGZvciB0aGUgbm9kZVxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcblxuICBjb21wdXRlKHByb2dyYW06IFByb2dyYW1JbmZvLCBpbnB1dHNPdXRwdXRzTWFwcGluZz86IENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcpOiBUZW5zb3JWaWV3W107XG4gIG91dHB1dChpbmRleDogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgVGltZXN0YW1wUXVlcnkgPSAnbm9uZScgfCAnaW5zaWRlLXBhc3NlcycgfCAnYXQtcGFzc2VzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgV2ViR3B1QmFja2VuZCB9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ3B1JztcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uL2xvZyc7XG5cbmltcG9ydCB7IEdwdURhdGEsIEdwdURhdGFJZCwgR3B1RGF0YVR5cGUgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBtYW5hZ2VzIEdwdURhdGFJZCAtPiBHcHVCdWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHcHVEYXRhTWFuYWdlciB7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBDUFUgdG8gR1BVLlxuICAgKi9cbiAgdXBsb2FkKGlkOiBHcHVEYXRhSWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIEdQVS5cbiAgICovXG4gIG1lbWNweShzb3VyY2VJZDogR3B1RGF0YUlkLCBkZXN0aW5hdGlvbklkOiBHcHVEYXRhSWQpOiB2b2lkO1xuICAvKipcbiAgICogY3JlYXRlIG5ldyBkYXRhIG9uIEdQVS5cbiAgICovXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlPzogbnVtYmVyKTogR3B1RGF0YTtcbiAgLyoqXG4gICAqIGdldCBHUFUgZGF0YSBieSBJRC5cbiAgICovXG4gIGdldChpZDogR3B1RGF0YUlkKTogR3B1RGF0YSB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVIGJ5IElELlxuICAgKlxuICAgKiBAcmV0dXJuIHNpemUgb2YgdGhlIGRhdGEgcmVsZWFzZWRcbiAgICovXG4gIHJlbGVhc2UoaWQ6IEdwdURhdGFJZCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIGNvcHkgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBkb3dubG9hZChpZDogR3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXI6ICgpID0+IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiByZWZyZXNoIHRoZSBidWZmZXJzIHRoYXQgbWFya2VkIGZvciByZWxlYXNlLlxuICAgKlxuICAgKiB3aGVuIHJlbGVhc2UoKSBpcyBjYWxsZWQsIHRoZSBidWZmZXIgaXMgbm90IHJlbGVhc2VkIGltbWVkaWF0ZWx5LiB0aGlzIGlzIGJlY2F1c2Ugd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgY29tbWFuZHNcbiAgICogdG8gYmUgc3VibWl0dGVkIHRvIHRoZSBHUFUuIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBjb21tYW5kcyBhcmUgc3VibWl0dGVkIHNvIHRoYXQgdGhlIGJ1ZmZlcnMgY2FuIGJlXG4gICAqIGFjdHVhbGx5IHJlbGVhc2VkLlxuICAgKi9cbiAgcmVmcmVzaFBlbmRpbmdCdWZmZXJzKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVyIGFuIGV4dGVybmFsIGJ1ZmZlciBmb3IgSU8gQmluZGluZy4gSWYgdGhlIGJ1ZmZlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHJldHVybiB0aGUgZXhpc3RpbmcgR1BVIGRhdGEgSUQuXG4gICAqXG4gICAqIEdQVSBkYXRhIG1hbmFnZXIgb25seSBtYW5hZ2VzIGEgbWFwcGluZyBiZXR3ZWVuIHRoZSBidWZmZXIgYW5kIHRoZSBHUFUgZGF0YSBJRC4gSXQgd2lsbCBub3QgbWFuYWdlIHRoZSBsaWZlY3ljbGUgb2ZcbiAgICogdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAgICovXG4gIHJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVyOiBHUFVCdWZmZXIsIG9yaWdpbmFsU2l6ZTogbnVtYmVyLCBwcmV2aW91cz86IFtHcHVEYXRhSWQsIEdQVUJ1ZmZlcl0pOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHVucmVnaXN0ZXIgYW4gZXh0ZXJuYWwgYnVmZmVyIGZvciBJTyBCaW5kaW5nLlxuICAgKi9cbiAgdW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGlkOiBHcHVEYXRhSWQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBkZXN0cm95IGFsbCBncHUgYnVmZmVycy5cbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcblxuICAvKipcbiAgICogY3JlYXRlIHNlc3Npb24gcmVsYXRlZCBkYXRhLlxuICAgKi9cbiAgb25DcmVhdGVTZXNzaW9uKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIHJlbGVhc2Ugc2Vzc2lvbiByZWxhdGVkIGRhdGEuXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgLSBzcGVjaWZ5IHRoZSBzZXNzaW9uIElELlxuICAgKi9cbiAgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBTdG9yYWdlQ2FjaGVWYWx1ZSB7XG4gIGdwdURhdGE6IEdwdURhdGE7XG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyO1xufVxuXG5jb25zdCBidWNrZXRGcmVlbGlzdDogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXAoW1xuICBbNjQsIDI1MF0sXG4gIFsxMjgsIDIwMF0sXG4gIFsyNTYsIDIwMF0sXG4gIFs1MTIsIDIwMF0sXG4gIFsyMDQ4LCAyMzBdLFxuICBbNDA5NiwgMjAwXSxcbiAgWzgxOTIsIDUwXSxcbiAgWzE2Mzg0LCA1MF0sXG4gIFszMjc2OCwgNTBdLFxuICBbNjU1MzYsIDUwXSxcbiAgWzEzMTA3MiwgNTBdLFxuICBbMjYyMTQ0LCA1MF0sXG4gIFs1MjQyODgsIDUwXSxcbiAgWzEwNDg1NzYsIDUwXSxcbiAgWzIwOTcxNTIsIDMwXSxcbiAgWzQxOTQzMDQsIDIwXSxcbiAgWzgzODg2MDgsIDEwXSxcbiAgWzEyNTgyOTEyLCAxMF0sXG4gIFsxNjc3NzIxNiwgMTBdLFxuICBbMjYyMTQ0MDAsIDE1XSxcbiAgWzMzNTU0NDMyLCAyMl0sXG4gIFs0NDIzNjgwMCwgMl0sXG4gIFs1ODk4MjQwMCwgNl0sXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FjaGUgdGhlIGJ1Y2tldCBzaXplcyBiZWxvdyBidXQgbm90IGNhY2hpbmcgdGhlbVxuICAvLyByZXN1bHRzIGluIHNvbWUgbWFqb3IgcGVyZm9ybWFuY2UgaGl0cyBmb3IgbW9kZWxzIGxpa2Ugc2QtdHVyYm8uXG4gIFs2NzEwODg2NCwgNl0sXG4gIFsxMzQyMTc3MjgsIDZdLFxuICBbMTY3NzcyMTYwLCA2XSxcbl0pO1xuXG5jb25zdCBidWNrZXRBcnI6IG51bWJlcltdID0gW107XG5cbi8qKlxuICogbm9ybWFsaXplIHRoZSBidWZmZXIgc2l6ZSBzbyB0aGF0IGl0IGZpdHMgdGhlIDEyOC1iaXRzICgxNiBieXRlcykgYWxpZ25tZW50LlxuICovXG5jb25zdCBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUgPSAoc2l6ZTogbnVtYmVyKSA9PiBNYXRoLmNlaWwoTnVtYmVyKHNpemUpIC8gMTYpICogMTY7XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBidWZmZXIgc2l6ZSBzbyB0aGF0IGl0IGZpdHMgaW50byBidWNrZXRzLlxuICovXG5jb25zdCBjYWxjQnVja2V0QnVmZmVyU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IHtcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYnVja2V0QXJyLmxlbmd0aDsgaWR4KyspIHtcbiAgICBjb25zdCBzaXplRm9yQnVja2V0ID0gYnVja2V0QXJyW2lkeF07XG4gICAgaWYgKHNpemUgPD0gc2l6ZUZvckJ1Y2tldCkge1xuICAgICAgcmV0dXJuIHNpemVGb3JCdWNrZXQ7XG4gICAgfVxuICB9XG4gIC8vIG5vdCBpbiBidWNrZXQgbGlzdCAtPiBjYWxsZXIgd2lsbCBub3QgY2FjaGUsIHJvdW5kIHVwIHRvIDE2LlxuICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyAxNikgKiAxNjtcbn07XG5cbmxldCBndWlkID0gMTtcbmNvbnN0IGNyZWF0ZU5ld0dwdURhdGFJZCA9ICgpID0+IGd1aWQrKztcblxuLyoqXG4gKiBleHBvcnRlZCBzdGFuZGFyZCBkb3dubG9hZCBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IHRoZSBzZXNzaW9uIHRvIGRvd25sb2FkIHRoZSBkYXRhIGZyb20gR1BVLCBhbmQgYWxzbyBieVxuICogZmFjdG9yeSB0byBjcmVhdGUgR1BVIHRlbnNvcnMgd2l0aCB0aGUgY2FwYWNpdHkgb2YgZG93bmxvYWRpbmcgZGF0YSBmcm9tIEdQVS5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBXZWJHUFUgYmFja2VuZFxuICogQHBhcmFtIGdwdUJ1ZmZlciAtIHRoZSBHUFUgYnVmZmVyIHRvIGRvd25sb2FkXG4gKiBAcGFyYW0gb3JpZ2luYWxTaXplIC0gdGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIGRhdGFcbiAqIEBwYXJhbSBnZXRUYXJnZXRCdWZmZXIgLSBvcHRpb25hbC4gSWYgcHJvdmlkZWQsIHRoZSBkYXRhIHdpbGwgYmUgY29waWVkIHRvIHRoZSB0YXJnZXQgYnVmZmVyLiBPdGhlcndpc2UsIGEgbmV3IGJ1ZmZlclxuICogd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRvd25sb2FkR3B1RGF0YSA9IGFzeW5jIChcbiAgYmFja2VuZDogV2ViR3B1QmFja2VuZCxcbiAgZ3B1QnVmZmVyOiBHUFVCdWZmZXIsXG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyLFxuICBnZXRUYXJnZXRCdWZmZXI/OiAoKSA9PiBVaW50OEFycmF5LFxuKTogUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XG4gIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUob3JpZ2luYWxTaXplKTtcbiAgY29uc3QgZ3B1UmVhZEJ1ZmZlciA9IGJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQgfSxcbiAgKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IGJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICBiYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKFxuICAgICAgZ3B1QnVmZmVyIC8qIHNvdXJjZSBidWZmZXIgKi8sXG4gICAgICAwIC8qIHNvdXJjZSBvZmZzZXQgKi8sXG4gICAgICBncHVSZWFkQnVmZmVyIC8qIGRlc3RpbmF0aW9uIGJ1ZmZlciAqLyxcbiAgICAgIDAgLyogZGVzdGluYXRpb24gb2Zmc2V0ICovLFxuICAgICAgYnVmZmVyU2l6ZSAvKiBzaXplICovLFxuICAgICk7XG4gICAgYmFja2VuZC5mbHVzaCgpO1xuXG4gICAgYXdhaXQgZ3B1UmVhZEJ1ZmZlci5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO1xuXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBncHVSZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCk7XG4gICAgaWYgKGdldFRhcmdldEJ1ZmZlcikge1xuICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgQ1BVIGJ1ZmZlciB0byBhY2NlcHQgdGhlIGRhdGEsIG5vIG5lZWQgdG8gY2xvbmUgdGhlIEFycmF5QnVmZmVyLlxuICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyID0gZ2V0VGFyZ2V0QnVmZmVyKCk7XG4gICAgICB0YXJnZXRCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCAwLCBvcmlnaW5hbFNpemUpKTtcbiAgICAgIHJldHVybiB0YXJnZXRCdWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZSBtYXBwZWQgQXJyYXlCdWZmZXIgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHRoZSBHUFUgYnVmZmVyIGlzIGRlc3Ryb3llZC4gTmVlZCB0byBjbG9uZSB0aGVcbiAgICAgIC8vIEFycmF5QnVmZmVyLlxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLnNsaWNlKDAsIG9yaWdpbmFsU2l6ZSkpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBncHVSZWFkQnVmZmVyLmRlc3Ryb3koKTtcbiAgfVxufTtcblxuY2xhc3MgR3B1RGF0YU1hbmFnZXJJbXBsIGltcGxlbWVudHMgR3B1RGF0YU1hbmFnZXIge1xuICAvLyBHUFUgRGF0YSBJRCA9PiBHUFUgRGF0YSAoIHN0b3JhZ2UgYnVmZmVyIClcbiAgcHJpdmF0ZSBzdG9yYWdlQ2FjaGU6IE1hcDxHcHVEYXRhSWQsIFN0b3JhZ2VDYWNoZVZhbHVlPjtcblxuICAvLyBwZW5kaW5nIGJ1ZmZlcnMgZm9yIGNvbXB1dGluZ1xuICBwcml2YXRlIGJ1ZmZlcnNQZW5kaW5nOiBHUFVCdWZmZXJbXTtcblxuICAvLyBUaGUgcmV1c2FibGUgc3RvcmFnZSBidWZmZXJzIGZvciBjb21wdXRpbmcuXG4gIHByaXZhdGUgZnJlZUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcbiAgLy8gVGhlIHJldXNhYmxlIHVuaWZvcm0gYnVmZmVyc1xuICBwcml2YXRlIGZyZWVVbmlmb3JtQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xuXG4gIC8vIFRoZSBwZW5kaW5nQnVmZmVycyBmb3IgY2FwdHVyZSBncmFwaC5cbiAgLy8gYSBTZXNzaW9uSUQgLT4gR1BVQnVmZmVyW10gbWFwcGluZy5cbiAgcHJpdmF0ZSBjYXB0dXJlZFBlbmRpbmdCdWZmZXJzOiBNYXA8bnVtYmVyLCBHUFVCdWZmZXJbXT47XG5cbiAgLy8gVGhlIHNlc3Npb24gY291bnQuXG4gIHByaXZhdGUgc2Vzc2lvbkNvdW50OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kKSB7XG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nID0gW107XG4gICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCBba2V5XSBvZiBidWNrZXRGcmVlbGlzdCkge1xuICAgICAgYnVja2V0QXJyLnB1c2goa2V5KTtcbiAgICAgIHRoaXMuZnJlZUJ1ZmZlcnMuc2V0KGtleSwgW10pO1xuICAgICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuc2V0KGtleSwgW10pO1xuICAgIH1cblxuICAgIHRoaXMuc2Vzc2lvbkNvdW50ID0gMDtcbiAgfVxuXG4gIHVwbG9hZChpZDogR3B1RGF0YUlkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgY29uc3Qgc3JjQXJyYXlCdWZmZXIgPSBkYXRhLmJ1ZmZlcjtcbiAgICBjb25zdCBzcmNPZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IHNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUoc3JjTGVuZ3RoKTtcblxuICAgIC8vIGdldCBkZXN0aW5hdGlvbiBncHUgYnVmZmVyXG4gICAgY29uc3QgZ3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWdwdURhdGFDYWNoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIGlmIChOdW1iZXIoZ3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSkgIT09IHNyY0xlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7Z3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke3NyY0xlbmd0aH1gKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGdwdUJ1ZmZlckZvclVwbG9hZGluZyA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIHsgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSwgc2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIH0sXG4gICAgKTtcblxuICAgIC8vIGNvcHkgKHVwbG9hZCkgZGF0YVxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLmdldE1hcHBlZFJhbmdlKCk7XG4gICAgbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLnNldChuZXcgVWludDhBcnJheShzcmNBcnJheUJ1ZmZlciwgc3JjT2Zmc2V0LCBzcmNMZW5ndGgpKTtcbiAgICBncHVCdWZmZXJGb3JVcGxvYWRpbmcudW5tYXAoKTtcblxuICAgIC8vIEdQVSBjb3B5XG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKGdwdUJ1ZmZlckZvclVwbG9hZGluZywgMCwgZ3B1RGF0YUNhY2hlLmdwdURhdGEuYnVmZmVyLCAwLCBzaXplKTtcbiAgICB0aGlzLmJhY2tlbmQuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgICBncHVCdWZmZXJGb3JVcGxvYWRpbmcuZGVzdHJveSgpO1xuXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke2lkfSlgKTtcbiAgfVxuXG4gIG1lbWNweShzb3VyY2VJZDogR3B1RGF0YUlkLCBkZXN0aW5hdGlvbklkOiBHcHVEYXRhSWQpOiB2b2lkIHtcbiAgICAvLyBnZXQgc291cmNlIGdwdSBidWZmZXJcbiAgICBjb25zdCBzb3VyY2VHcHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoc291cmNlSWQpO1xuICAgIGlmICghc291cmNlR3B1RGF0YUNhY2hlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIC8vIGdldCBkZXN0aW5hdGlvbiBncHUgYnVmZmVyXG4gICAgY29uc3QgZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoZGVzdGluYXRpb25JZCk7XG4gICAgaWYgKCFkZXN0aW5hdGlvbkdwdURhdGFDYWNoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VHcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplICE9PSBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUoc291cmNlR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSk7XG5cbiAgICAvLyBHUFUgY29weVxuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKFxuICAgICAgc291cmNlR3B1RGF0YUNhY2hlLmdwdURhdGEuYnVmZmVyLFxuICAgICAgMCxcbiAgICAgIGRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlLmdwdURhdGEuYnVmZmVyLFxuICAgICAgMCxcbiAgICAgIHNpemUsXG4gICAgKTtcbiAgfVxuXG4gIHJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVyOiBHUFVCdWZmZXIsIG9yaWdpbmFsU2l6ZTogbnVtYmVyLCBwcmV2aW91cz86IFtHcHVEYXRhSWQsIEdQVUJ1ZmZlcl0pOiBudW1iZXIge1xuICAgIGxldCBpZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGlmIChwcmV2aW91cykge1xuICAgICAgaWQgPSBwcmV2aW91c1swXTtcbiAgICAgIGlmIChidWZmZXIgPT09IHByZXZpb3VzWzFdKSB7XG4gICAgICAgIExPR19ERUJVRyhcbiAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtvcmlnaW5hbFNpemV9KSA9PiBpZD0ke2lkfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdpc3RlcmluZyBhIGRpZmZlcmVudCBleHRlcm5hbCBidWZmZXIgdW5kZXIgZ3JhcGggY2FwdHVyZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgICAgICAgIFBsZWFzZSB1c2UgdGhlIHByZXZpb3VzIGV4dGVybmFsIGJ1ZmZlciFgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSBjcmVhdGVOZXdHcHVEYXRhSWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoaWQsIHsgZ3B1RGF0YTogeyBpZCwgdHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCwgYnVmZmVyIH0sIG9yaWdpbmFsU2l6ZSB9KTtcbiAgICBMT0dfREVCVUcoXG4gICAgICAndmVyYm9zZScsXG4gICAgICAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7b3JpZ2luYWxTaXplfSkgPT4gaWQ9JHtpZH0sIHJlZ2lzdGVyZWQuYCxcbiAgICApO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIHVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihpZDogR3B1RGF0YUlkKTogdm9pZCB7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHtpZH1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICBjcmVhdGUoc2l6ZTogbnVtYmVyLCB1c2FnZSA9IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTogR3B1RGF0YSB7XG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGNCdWNrZXRCdWZmZXJTaXplKHNpemUpO1xuXG4gICAgbGV0IGdwdUJ1ZmZlcjtcbiAgICAvLyBDdXJyZW50bHksIG9ubHkgc3RvcmFnZSBidWZmZXJzIGFyZSByZXVzZWQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBjb25zdCBpc1N0b3JhZ2UgPSAodXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSA9PT0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGNvbnN0IGlzVW5pZm9ybSA9ICh1c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pID09PSBHUFVCdWZmZXJVc2FnZS5VTklGT1JNO1xuICAgIGlmIChpc1N0b3JhZ2UgfHwgaXNVbmlmb3JtKSB7XG4gICAgICBjb25zdCBmcmVlQnVmZmVycyA9IGlzU3RvcmFnZSA/IHRoaXMuZnJlZUJ1ZmZlcnMgOiB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycztcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBmcmVlQnVmZmVycy5nZXQoYnVmZmVyU2l6ZSk7XG4gICAgICBpZiAoIWJ1ZmZlcnMpIHtcbiAgICAgICAgLy8gbm8gc3VjaCBidWNrZXQvZnJlZWxpc3QgLSBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgICAgICBncHVCdWZmZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7IHNpemU6IGJ1ZmZlclNpemUsIHVzYWdlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGluIGZyZWVsaXN0LCB1c2UgaXRcbiAgICAgICAgICBncHVCdWZmZXIgPSBidWZmZXJzLnBvcCgpIGFzIEdQVUJ1ZmZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBidWNrZXQgZW1wdHksIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBncHVEYXRhID0geyBpZDogY3JlYXRlTmV3R3B1RGF0YUlkKCksIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlcjogZ3B1QnVmZmVyIH07XG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGdwdURhdGEuaWQsIHsgZ3B1RGF0YSwgb3JpZ2luYWxTaXplOiBOdW1iZXIoc2l6ZSkgfSk7XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHtzaXplfSkgPT4gaWQ9JHtncHVEYXRhLmlkfWApO1xuICAgIHJldHVybiBncHVEYXRhO1xuICB9XG5cbiAgZ2V0KGlkOiBHcHVEYXRhSWQpOiBHcHVEYXRhIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKT8uZ3B1RGF0YTtcbiAgfVxuXG4gIHJlbGVhc2UoaWRJbnB1dDogR3B1RGF0YUlkKTogbnVtYmVyIHtcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBpZElucHV0ID09PSAnYmlnaW50JyA/IE51bWJlcihpZElucHV0KSA6IGlkSW5wdXQ7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFjYWNoZWREYXRhKSB7XG4gICAgICBpZiAodGhpcy5zdG9yYWdlQ2FjaGUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBjYWNoZSB3YXMgcHJldmlvdXNseSBjbGVhcmVkLCBubyBuZWVkIHRvIHJlbGVhc2UgYW55dGhpbmcuXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7aWR9KSwgZ3B1RGF0YUlkPSR7Y2FjaGVkRGF0YS5ncHVEYXRhLmlkfWApO1xuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlcik7XG4gICAgLy8gY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XG5cbiAgICByZXR1cm4gY2FjaGVkRGF0YS5vcmlnaW5hbFNpemU7XG4gIH1cblxuICBhc3luYyBkb3dubG9hZChpZDogR3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXI6ICgpID0+IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KE51bWJlcihpZCkpO1xuICAgIGlmICghY2FjaGVkRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIGF3YWl0IGRvd25sb2FkR3B1RGF0YSh0aGlzLmJhY2tlbmQsIGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIsIGNhY2hlZERhdGEub3JpZ2luYWxTaXplLCBnZXRUYXJnZXRCdWZmZXIpO1xuICB9XG5cbiAgcmVmcmVzaFBlbmRpbmdCdWZmZXJzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmJ1ZmZlcnNQZW5kaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cyA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IG1heEluRnJlZUxpc3QgPSBidWNrZXRGcmVlbGlzdC5nZXQoYnVmZmVyLnNpemUpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIGlmICgoYnVmZmVyLnVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSkgPT09IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpIHtcbiAgICAgICAgICAvLyBQdXQgdGhlIHBlbmRpbmcgYnVmZmVyIHRvIGZyZWVCdWZmZXJzIGxpc3QgaW5zdGVhZCBvZiByZWFsbHkgZGVzdHJveWluZyBpdCBmb3IgYnVmZmVyIHJldXNpbmcuXG4gICAgICAgICAgY29uc3QgZnJlZWxpc3QgPSB0aGlzLmZyZWVCdWZmZXJzLmdldChidWZmZXIuc2l6ZSkgfHwgW107XG4gICAgICAgICAgaWYgKG1heEluRnJlZUxpc3QgPT09IHVuZGVmaW5lZCB8fCBmcmVlbGlzdC5sZW5ndGggPj0gbWF4SW5GcmVlTGlzdCkge1xuICAgICAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJlZWxpc3QucHVzaChidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB9IGVsc2UgaWYgKChidWZmZXIudXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSA9PT0gR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkge1xuICAgICAgICAgIC8vIFB1dCB0aGUgcGVuZGluZyBidWZmZXIgdG8gZnJlZVVuaWZvcm1CdWZmZXJzIGxpc3QgaW5zdGVhZCBvZiByZWFsbHkgZGVzdHJveWluZyBpdCBmb3IgYnVmZmVyIHJldXNpbmcuXG4gICAgICAgICAgY29uc3QgZnJlZWxpc3QgPSB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQoYnVmZmVyLnNpemUpIHx8IFtdO1xuICAgICAgICAgIGlmIChtYXhJbkZyZWVMaXN0ID09PSB1bmRlZmluZWQgfHwgZnJlZWxpc3QubGVuZ3RoID49IG1heEluRnJlZUxpc3QpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZWVsaXN0LnB1c2goYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJzUGVuZGluZyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEb24ndCByZWxlYXNlIGludGVybWVkaWF0ZSB0ZW5zb3JzIGluIG5vbi1kZWZhdWx0IG1vZGUuXG4gICAgICAvLyBUT0RPOiByZXVzZSB0aGUgc3RvcmFnZSBidWZmZXJzIGluIG5vbi1kZWZhdWx0IG1vZGUuXG4gICAgICBsZXQgY2FwdHVyZWRCdWZmZXJzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpO1xuICAgICAgaWYgKCFjYXB0dXJlZEJ1ZmZlcnMpIHtcbiAgICAgICAgY2FwdHVyZWRCdWZmZXJzID0gW107XG4gICAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhLCBjYXB0dXJlZEJ1ZmZlcnMpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5idWZmZXJzUGVuZGluZykge1xuICAgICAgICBjYXB0dXJlZEJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJzUGVuZGluZyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XG4gICAgICBidWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xuICAgICAgYnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgICAgc3RvcmFnZS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xuICAgICAgYnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgb25DcmVhdGVTZXNzaW9uKCkge1xuICAgIHRoaXMuc2Vzc2lvbkNvdW50ICs9IDE7XG4gIH1cblxuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKSB7XG4gICAgLy8gcmVsZWFzZSB0aGUgY2FwdHVyZWQgcGVuZGluZyBidWZmZXJzLlxuICAgIGNvbnN0IHBlbmRpbmdCdWZmZXJzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldChzZXNzaW9uSWQpO1xuICAgIGlmIChwZW5kaW5nQnVmZmVycykge1xuICAgICAgcGVuZGluZ0J1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG5cbiAgICAvLyByZWxlYXNlIHRoZSBzdG9yYWdlIGNhY2hlIGlmIG5vIGFjdGl2ZSBzZXNzaW9ucy5cbiAgICB0aGlzLnNlc3Npb25Db3VudCAtPSAxO1xuICAgIGlmICh0aGlzLnNlc3Npb25Db3VudCA9PT0gMCkge1xuICAgICAgTE9HX0RFQlVHKCd3YXJuaW5nJywgKCkgPT4gJ1tXZWJHUFVdIENsZWFyaW5nIHdlYmdwdSBidWZmZXIgY2FjaGUnKTtcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2goKHN0b3JhZ2UpID0+IHtcbiAgICAgICAgc3RvcmFnZS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlR3B1RGF0YU1hbmFnZXIgPSAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBHcHVEYXRhTWFuYWdlckltcGw+KTogR3B1RGF0YU1hbmFnZXIgPT5cbiAgbmV3IEdwdURhdGFNYW5hZ2VySW1wbCguLi5hcmdzKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBwcml2YXRlIGtleTogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgdGhpcy5rZXkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5tYXAoKG5hbWUpID0+IGAkeyh0aGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtuYW1lXX1gKVxuICAgICAgICAuam9pbignOycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXR0cmlidXRlLCBhbmQgYWRkIGEgY2FjaGVLZXkgcHJvcGVydHkgdG8gaXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9IDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICBhdHRyaWJ1dGU6IFQsXG4pOiBUICYgQXR0cmlidXRlV2l0aENhY2hlS2V5ID0+IG5ldyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXlJbXBsKGF0dHJpYnV0ZSkgYXMgdW5rbm93biBhcyBUICYgQXR0cmlidXRlV2l0aENhY2hlS2V5O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0sIFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIGNvbnN0YW50IHZhbHVlIGZvciBhIHdvcmtncm91cCBzaXplLlxuICpcbiAqIFdlIGRlZmluaXRlbHkgY2FuIGRvIGZ1cnRoZXIgb3B0aW1pemF0aW9uIGluIGZ1dHVyZSwgYnV0IGZvciBub3cgd2UgdXNlIDY0LlxuICpcbiAqIHJ1bGUgb2YgdGh1bWI6IFVzZSBbYSB3b3JrZ3JvdXAgc2l6ZSBvZl0gNjQgdW5sZXNzIHlvdSBrbm93IHdoYXQgR1BVIHlvdSBhcmUgdGFyZ2V0aW5nIG9yIHRoYXQgeW91ciB3b3JrbG9hZFxuICogICAgICAgICAgICAgICAgbmVlZHMgc29tZXRoaW5nIGRpZmZlcmVudC5cbiAqXG4gKiBmcm9tOiBodHRwczovL3N1cm1hLmRldi90aGluZ3Mvd2ViZ3B1L1xuICoqL1xuZXhwb3J0IGNvbnN0IFdPUktHUk9VUF9TSVpFID0gNjQ7XG5cbmludGVyZmFjZSBJbmRpY2VzSGVscGVyVHlwZXMge1xuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIGluZGljZXMgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIHR5cGUgb2YgYSB2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIHN0b3JhZ2UgdHlwZSByZXByZXNlbnRpbmcgYSB2YWx1ZVxuICAgKlxuICAgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgdG8gYHZhbHVlYCwgYnV0IGZvciBzb21lIHR5cGUgKGVnLiBib29sKSwgd2UgbmVlZCB0byB1c2UgYHUzMmAgYXMgc3RvcmFnZSB0eXBlIGZvclxuICAgKiB2YWx1ZSB0eXBlIGB2ZWM0PGJvb2w+YFxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3XG4gICAqL1xuICByZWFkb25seSB0ZW5zb3I6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhIGZvciBhIHNoYWRlcidzIGlucHV0IG9yIG91dHB1dC5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIG9mZmVyIGEgdW5pZmllZCB3YXkgdG8gZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YSBmb3IgYSBzaGFkZXInc1xuICogaW5wdXQgb3Igb3V0cHV0LlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSBsaXN0IG9mIHRlcm1pbm9sb2dpZXMgdXNlZCBpbiB0aGlzIGNsYXNzOlxuICogLSBgb2Zmc2V0YDogYSB1aW50MzIgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgb2YgYW4gZWxlbWVudCBpbiB0aGUgZGF0YSBidWZmZXIuXG4gKiAtIGBpbmRpY2VzYDogYW4gYWJzdHJhY3Rpb24gb2YgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSdzIGluZGljZXMgcmVwcmVzZW50aW5nIHRoZSBkYXRhJ3MgaW5kZXggb24gZWFjaCBkaW1lbnNpb24uXG4gKiAtIGB2YWx1ZWA6IGEgdmFsdWUgb2YgYSBkYXRhIGVsZW1lbnQuXG4gKlxuICogVXNlcnMgYXJlIGV4cGVjdGVkIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZvciBlYWNoIHNoYWRlcidzIGlucHV0IG9yIG91dHB1dCwgYW5kIHVzZSB0aGUgaW5zdGFuY2UgdG9cbiAqIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEuIFRoZSBmb2xsb3dpbmcgMiBleHBvcnRlZCBmdW5jdGlvbnMgYXJlIGZvciB1c2VycyB0byBjYWxsIHRvXG4gKiBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gaW5kaWNlcyBoZWxwZXI6XG4gKiAtIGBpbnB1dFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIGlucHV0LlxuICogLSBgb3V0cHV0VmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gb3V0cHV0LlxuICogLSBgaW50ZXJuYWxWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cbiAqXG4gKiBBbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBjb250YWlucyBoZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gKiAtIGFjY2VzcyByZWFkb25seSBiYXNpYyBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgbmFtZWAodGhlIG5hbWUgb2YgdGhlIGlucHV0IG9yIG91dHB1dCksIGB1c2FnZWAod2hldGhlciBpdCdzIGFuXG4gKiBpbnB1dCwgYW4gb3V0cHV0IG9yIGFuIGludGVybmFsIHZhcmlhYmxlKSBhbmQgYHNoYXBlYCh0aGUgcGFzc2VkIGluIHNoYXBlKS5cbiAqIC0gYHR5cGVgOiBhY2Nlc3MgcmVhZG9ubHkgdHlwZSBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgaW5kaWNlc2AodGhlIHR5cGUgb2YgaW5kaWNlcyksIGB2YWx1ZWAodGhlIHR5cGUgb2YgdmFsdWUgYXRcbiAqIHJ1bnRpbWUpLCBgc3RvcmFnZWAodGhlIHR5cGUgb2YgdmFsdWUgYXQgc3RvcmFnZSkgYW5kIGB0ZW5zb3JgKHRoZSB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3KS5cbiAqIC0gZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBnZXR0aW5nIGluZGljZXMgZnJvbSBvZmZzZXQuIFVzZSBgb2Zmc2V0VG9JbmRpY2VzKClgIGZvciBXR1NMIGNvZGUgc25pcHBldCB0byBjYWxjdWxhdGVcbiAqIGluZGljZXMgZnJvbSBvZmZzZXQsIGFuZCB1c2UgYGluZGljZXNUb09mZnNldCgpYCBmb3IgV0dTTCBjb2RlIHNuaXBwZXQgdG8gY2FsY3VsYXRlIG9mZnNldCBmcm9tIGluZGljZXMuXG4gKiAtIHRvIG1hbmlwdWxhdGUgYW4gaW5zdGFuY2Ugb2YgaW5kaWNlcywgdXNlIGBzZXRJbmRpY2VzKClgIGFuZCBgZ2V0SW5kaWNlcygpYCB0byBzZXQgYW5kIGdldCB0aGUgaW5kaWNlcyBvbiBhblxuICogaW5kaWNlcyB2YXJpYWJsZS5cbiAqIC0gdG8gbWFuaXB1bGF0ZSBkYXRhLCB1c2UgYHNldCgpYC9gZ2V0KClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gcGFyYW1ldGVyIGxpc3QsIHVzZVxuICogYHNldEJ5SW5kaWNlcygpYC9gZ2V0QnlJbmRpY2VzKClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gYW4gaW5kaWNlcyB2YXJpYWJsZSwgYW5kIHVzZVxuICogYHNldEJ5T2Zmc2V0KClgL2BnZXRCeU9mZnNldCgpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICogLSBgaW1wbGA6IGdldCBXR1NMIGNvZGUgb2YgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1dGlsIGZ1bmN0aW9ucyBtZW50aW9uZWQgYWJvdmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5kaWNlc0hlbHBlciB7XG4gIC8qKlxuICAgKiBnZXQgV0dTTCBjb2RlIG9mIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgdXRpbCBmdW5jdGlvbnMuXG4gICAqXG4gICAqL1xuICByZWFkb25seSBpbXBsOiAoKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGdldCB0eXBlIGluZm9cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IEluZGljZXNIZWxwZXJUeXBlcztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGEgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBpbmRpY2VzIGZyb20gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gdmFyT2Zmc2V0IC0gYSB1MzIgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgb2Zmc2V0VG9JbmRpY2VzOiAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb2Zmc2V0IGZyb20gaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzVG9PZmZzZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb3JpZ2luYWwgb2Zmc2V0IGZyb20gYnJvYWRjYXN0ZWQgaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBvdXRwdXQgaW5kaWNlcy5cbiAgICogQHBhcmFtIG91dHB1dCAtIG91dHB1dCBJbmRpY2VzSGVscGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDogKHZhckluZGljZXM6IHN0cmluZywgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBnZW5lcmF0aW5nIGFuIGluZGljZXMgbGl0ZXJhbFxuICAgKlxuICAgKiBAcGFyYW0gaW5pdCAtIGluaXRpYWwgdmFsdWUuXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzOiAoLi4uaW5pdDogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGluZGljZXMgdG8gc2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYSBXR1NMIHN0YXRlbWVudFxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc1NldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgaW5kaWNlcyB0byBnZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc0dldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kaWNlc0FuZFZhbHVlIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcywgZm9sbG93ZWRcbiAgICogICAgIGJ5IHRoZSB2YWx1ZSB0byBzZXQuIFRoaXMgYXJyYXkgc2hvdWxkIGhhdmUgZXhhY3RseSBgc2hhcGUubGVuZ3RoICsgMWAgZWxlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBzZXQ6ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHNldC4gc2hvdWxkIGJlIGEgV0dTTCBleHByZXNzaW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgc2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhbiBleHByZXNzaW9uIGZvciBnZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRpY2VzIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcy5cbiAgICovXG4gIHJlYWRvbmx5IGdldDogKC4uLmluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICovXG4gIHJlYWRvbmx5IGdldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogbmFtZSBvZiB0aGUgZGF0YSB2YXJpYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB3aGV0aGVyIHRoZSBoZWxwZXIgaXMgZm9yIGFuIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gICAqL1xuICByZWFkb25seSB1c2FnZTogJ2lucHV0JyB8ICdvdXRwdXQnIHwgJ2F0b21pY091dHB1dCcgfCAnaW50ZXJuYWwnO1xuXG4gIC8qKlxuICAgKiB0aGUgcmFuayBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgKi9cbiAgcmVhZG9ubHkgcmFuazogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgKi9cbiAgcmVhZG9ubHkgc2hhcGU6IHN0cmluZztcblxuICAvKipcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc3RyaWRlcyBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaWRlczogc3RyaW5nO1xufVxuXG5jb25zdCBnZXRXZ3NsTWFwcGVkVHlwZSA9ICh0eXBlOiBudW1iZXIsIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQpOiBzdHJpbmcgfCBbc3RyaW5nLCBzdHJpbmddID0+IHtcbiAgaWYgKGNvbXBvbmVudHMgPT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWQnKTtcbiAgfVxuXG4gIC8vIHJldHVybiB0eXBlIGlzIFsgc3RvcmFnZSB0eXBlLCBydW50aW1lIHR5cGUgXSBvciBhIHNpbmdsZSBzdHJpbmcgZm9yIGJvdGhcbiAgc3dpdGNoIChOdW1iZXIodHlwZSkpIHtcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxmMTY+YCA6ICdmMTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxmMzI+YCA6ICdmMzInO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxpMzI+YCA6ICdpMzInO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308dTMyPmAgOiAndTMyJztcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxuICAgICAgaWYgKGNvbXBvbmVudHMgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWyd2ZWMyPHUzMj4nLCAnaTMyJ107XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NjQ6XG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICd1MzInXTtcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICBpZiAoY29tcG9uZW50cyAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jvb2wgbXVzdCBiZSB2ZWM0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWyd1MzInLCAndmVjNDxib29sPiddO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NDpcbiAgICAgIHJldHVybiAnaTMyJztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ0OlxuICAgICAgcmV0dXJuICd1MzInO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUgPSAodHlwZTogRGF0YVR5cGUsIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxKSA9PiB7XG4gIGNvbnN0IG1hcHBlZFR5cGUgPSBnZXRXZ3NsTWFwcGVkVHlwZSh0eXBlLCBjb21wb25lbnRzKTtcbiAgcmV0dXJuIHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzBdO1xufTtcblxuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUgPSAodHlwZTogRGF0YVR5cGUsIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxKSA9PiB7XG4gIGNvbnN0IG1hcHBlZFR5cGUgPSBnZXRXZ3NsTWFwcGVkVHlwZSh0eXBlLCBjb21wb25lbnRzKTtcbiAgcmV0dXJuIHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzFdO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzID0gKC4uLmRpbXM6IFJlYWRvbmx5QXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+KTogUHJvZ3JhbVVuaWZvcm1bXSA9PiB7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtdO1xuICBkaW1zLmZvckVhY2goKGRpbSkgPT4ge1xuICAgIGlmIChkaW0ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGRpbSB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGRpbSkgfSxcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb2dyYW1Vbmlmb3Jtcztcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IG1heGltdW0gdmVjdG9yIHNpemUgZm9yIHNwZWNpZmllZCBkYXRhIGxlbmd0aFxuICogQHBhcmFtIHNpemVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE1heENvbXBvbmVudHMgPSAoc2l6ZTogbnVtYmVyKSA9PiB7XG4gIC8vIHdlIGNhbm5vdCB1c2UgdmVjMyB0eXBlIHNpbmNlIGl0IGhhcyBhbGlnbm1lbnQgb2YgMTYgYnl0ZXNcbiAgaWYgKHNpemUgJSA0ID09PSAwKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH0gZWxzZSBpZiAoc2l6ZSAlIDIgPT09IDApIHtcbiAgICByZXR1cm4gMjtcbiAgfVxuXG4gIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHZhcmlhYmxlIGFzIGEgc2NhbGFyIG9yIHZlY3Rvci4gZS5nLiBmMzIoMCkgb3IgdmVjNGYoMCwwLDAsMClcbiAqIEBwYXJhbSBkYXRhVHlwZVxuICogQHBhcmFtIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZmlsbFZlY3RvciA9IChkYXRhVHlwZSA9ICdmMzInLCBjb21wb25lbnRzPzogbnVtYmVyLCB2YWx1ZSA9ICcwJykgPT4ge1xuICBpZiAoIWNvbXBvbmVudHMgfHwgY29tcG9uZW50cyA9PT0gMSkge1xuICAgIHJldHVybiBgJHtkYXRhVHlwZX0oJHt2YWx1ZX0pYDtcbiAgfVxuXG4gIHJldHVybiBgdmVjJHtjb21wb25lbnRzfTwke2RhdGFUeXBlfT4oJHt2YWx1ZX0pYDtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjYXN0cyB2YWx1ZSBvciB2ZWN0b3IgdG8gZjMyXG4gKiBAcGFyYW0gZGF0YVR5cGVcbiAqIEBwYXJhbSBjb21wb25lbnRzXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGNhc3RUb0YzMiA9IChkYXRhVHlwZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgaWYgKGRhdGFUeXBlID09PSAnZjMyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoY29tcG9uZW50cyA9PT0gMSkge1xuICAgIHJldHVybiBgZjMyKCR7dmFsdWV9KWA7XG4gIH1cblxuICByZXR1cm4gYHZlYyR7Y29tcG9uZW50c308ZjMyPigke3ZhbHVlfSlgO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgc2NhbGFyIG9yIHN1bXMgYWxsIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSBuYW1lXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICovXG5leHBvcnQgY29uc3Qgc3VtVmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XG4gIGlmIChjb21wb25lbnRzID09PSA0KSB7XG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55ICsgJHtuYW1lfS56ICsgJHtuYW1lfS53KWA7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMikge1xuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSlgO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDMpIHtcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkgKyAke25hbWV9LnopYDtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdmFyaWFibGUgZWxlbWVudCBhdCBpbmRleC5cbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdmFyaWFibGUuXG4gKiBAcGFyYW0gaW5kZXggLSB0aGUgaW5kZXggb2YgdmFyaWFibGUgZWxlbWVudC5cbiAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHZhcmlhYmxlLlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiB2YXJpYWJsZSwgb3B0aW9uYWwuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbGVtZW50QXQgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgaW5kZXg6IG51bWJlciB8IHN0cmluZyxcbiAgbGVuZ3RoOiBudW1iZXIsXG4gIHR5cGU/OiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxuKTogc3RyaW5nID0+IHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykgJiYgbGVuZ3RoID4gNCkge1xuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2YxNicpIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9Wygke2luZGV4fSkgLyA4XVsoJHtpbmRleH0pICUgOCAvIDRdWygke2luZGV4fSkgJSA4ICUgNF1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9Wygke2luZGV4fSkgLyA0XVsoJHtpbmRleH0pICUgNF1gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2YxNicpIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7TWF0aC5mbG9vcihpbmRleCAvIDgpfV1bJHtNYXRoLmZsb29yKChpbmRleCAlIDgpIC8gNCl9XVskeyhpbmRleCAlIDgpICUgNH1dYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske01hdGguZmxvb3IoaW5kZXggLyA0KX1dWyR7aW5kZXggJSA0fV1gO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGVuZ3RoID4gMSA/IGAke25hbWV9WyR7aW5kZXh9XWAgOiBuYW1lO1xuICB9XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIEluZGljZXNIZWxwZXIgZm9yIGEgZ2l2ZW4gaW5wdXQgb3Igb3V0cHV0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSB0ZW5zb3JUeXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXG4gKiBAcGFyYW0gdXNhZ2UgLSB0aGUgdXNhZ2Ugb2YgdGhlIGluZGljZXMgaGVscGVyLlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIGVhY2ggZWxlbWVudC4gMSBmb3Igc2NhbGFyLCAyIGZvciB2ZWMyLCAzIGZvciB2ZWMzLCA0IGZvclxuICogICAgdmVjNC5cbiAqL1xuY29uc3QgY3JlYXRlSW5kaWNlc0hlbHBlciA9IChcbiAgbmFtZTogc3RyaW5nLFxuICB0ZW5zb3JUeXBlOiBudW1iZXIsXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcbiAgdXNhZ2U6IEluZGljZXNIZWxwZXJbJ3VzYWdlJ10sXG4gIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQsXG4pOiBJbmRpY2VzSGVscGVyID0+IHtcbiAgY29uc3QgdXNlVW5pZm9ybSA9IHR5cGVvZiBzaGFwZU9yUmFuayA9PT0gJ251bWJlcic7XG4gIGNvbnN0IHJhbmsgPSB1c2VVbmlmb3JtID8gc2hhcGVPclJhbmsgOiBzaGFwZU9yUmFuay5sZW5ndGg7XG4gIGNvbnN0IHJhbmtJZGVudGl0eSA9IFsuLi5uZXcgQXJyYXkocmFuaykua2V5cygpXTtcbiAgY29uc3QgaW5kaWNlc1R5cGUgPSByYW5rIDwgMiA/ICd1MzInIDogcmFuayA8PSA0ID8gYHZlYyR7cmFua308dTMyPmAgOiBgYXJyYXk8dTMyLCAke3Jhbmt9PmA7XG4gIGNvbnN0IG1hcHBlZFR5cGUgPSBnZXRXZ3NsTWFwcGVkVHlwZSh0ZW5zb3JUeXBlLCBjb21wb25lbnRzKTtcbiAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMV07XG4gIGNvbnN0IHN0b3JhZ2VUeXBlID0gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XG4gIGNvbnN0IHR5cGUgPSB7IGluZGljZXM6IGluZGljZXNUeXBlLCB2YWx1ZTogdmFsdWVUeXBlLCBzdG9yYWdlOiBzdG9yYWdlVHlwZSwgdGVuc29yOiB0ZW5zb3JUeXBlIH07XG5cbiAgY29uc3Qgbm9ybWFsaXplRGltID0gKGRpbTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nID0+ICh0eXBlb2YgZGltID09PSAnc3RyaW5nJyA/IGRpbSA6IGAke2RpbX11YCk7XG5cbiAgY29uc3QgaW1wbGVtZW50YXRpb25Vc2VkID0ge1xuICAgIG9mZnNldFRvSW5kaWNlczogZmFsc2UsXG4gICAgaW5kaWNlc1RvT2Zmc2V0OiBmYWxzZSxcbiAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDogZmFsc2UsXG4gICAgc2V0OiBmYWxzZSxcbiAgICBzZXRCeUluZGljZXM6IGZhbHNlLFxuICAgIGdldDogZmFsc2UsXG4gICAgZ2V0QnlJbmRpY2VzOiBmYWxzZSxcbiAgfTtcblxuICBjb25zdCB1bmlmb3JtUHJlZml4ID0gdXNlVW5pZm9ybSA/ICd1bmlmb3Jtcy4nIDogJyc7XG4gIGNvbnN0IHNoYXBlID0gYCR7dW5pZm9ybVByZWZpeH0ke25hbWV9X3NoYXBlYDtcbiAgY29uc3Qgc3RyaWRlcyA9IGAke3VuaWZvcm1QcmVmaXh9JHtuYW1lfV9zdHJpZGVzYDtcblxuICBsZXQgbzJpU25pcHBldCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAxOyBpKyspIHtcbiAgICBvMmlTbmlwcGV0ICs9IGBcbiAgICBsZXQgZGltJHtpfSA9IGN1cnJlbnQgLyAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX07XG4gICAgbGV0IHJlc3Qke2l9ID0gY3VycmVudCAlICR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfTtcbiAgICBpbmRpY2VzWyR7aX1dID0gZGltJHtpfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7aX07XG4gICAgYDtcbiAgfVxuICBvMmlTbmlwcGV0ICs9IGBpbmRpY2VzWyR7cmFuayAtIDF9XSA9IGN1cnJlbnQ7YDtcblxuICBjb25zdCBvZmZzZXRUb0luZGljZXNJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogYFxuICBmbiBvMmlfJHtuYW1lfShvZmZzZXQ6IHUzMikgLT4gJHt0eXBlLmluZGljZXN9IHtcbiAgICB2YXIgaW5kaWNlczogJHt0eXBlLmluZGljZXN9O1xuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xuICAgICR7bzJpU25pcHBldH1cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfWA7XG5cbiAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzID0gKHZhck9mZnNldDogc3RyaW5nKSA9PiB7XG4gICAgaW1wbGVtZW50YXRpb25Vc2VkLm9mZnNldFRvSW5kaWNlcyA9IHRydWU7XG4gICAgcmV0dXJuIHJhbmsgPCAyID8gdmFyT2Zmc2V0IDogYG8yaV8ke25hbWV9KCR7dmFyT2Zmc2V0fSlgO1xuICB9O1xuXG4gIGNvbnN0IG9mZnNldHM6IHN0cmluZ1tdID0gW107XG4gIGlmIChyYW5rID49IDIpIHtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBvZmZzZXRzLnB1c2goYCR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfSAqIChpbmRpY2VzWyR7aX1dKWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uID1cbiAgICByYW5rIDwgMlxuICAgICAgPyAnJ1xuICAgICAgOiBgXG4gIGZuIGkyb18ke25hbWV9KGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtvZmZzZXRzLmpvaW4oJysnKX07XG4gIH1gO1xuXG4gIGNvbnN0IGluZGljZXNUb09mZnNldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHtcbiAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmFuayA8IDIgPyB2YXJJbmRpY2VzIDogYGkyb18ke25hbWV9KCR7dmFySW5kaWNlc30pYDtcbiAgfTtcblxuICBjb25zdCBpbmRpY2VzID0gKC4uLmluaXQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT5cbiAgICByYW5rID09PSAwID8gJzB1JyA6IGAke3R5cGUuaW5kaWNlc30oJHtpbml0Lm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKX0pYDtcblxuICBjb25zdCBpbmRpY2VzR2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcpID0+IHtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHJldHVybiBgJHt2YXJJbmRpY2VzfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtnZXRFbGVtZW50QXQodmFySW5kaWNlcywgaWR4LCByYW5rKX1gO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBpbmRpY2VzU2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHJldHVybiBgJHt2YXJJbmRpY2VzfT0ke3ZhbHVlfTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7Z2V0RWxlbWVudEF0KHZhckluZGljZXMsIGlkeCwgcmFuayl9PSR7dmFsdWV9O2A7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb246IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgY29uc3QgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpID0+IHtcbiAgICBpbXBsZW1lbnRhdGlvblVzZWQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgIGNvbnN0IGltcGxLZXkgPSBgJHtvdXRwdXQubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7bmFtZX1PZmZzZXRgO1xuICAgIGlmIChpbXBsS2V5IGluIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHJldHVybiBgJHtpbXBsS2V5fSgke3ZhckluZGljZXN9KWA7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBpZHggPSBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGkgKyBvdXRwdXQucmFuayAtIHJhbmspO1xuICAgICAgb2Zmc2V0cy5wdXNoKGAke2luZGljZXNHZXQoc3RyaWRlcywgaSl9ICogKCR7aWR4fSAlICR7aW5kaWNlc0dldChzaGFwZSwgaSl9KWApO1xuICAgIH1cbiAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uW2ltcGxLZXldID0gYGZuICR7aW1wbEtleX0ob3V0cHV0SW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgICByZXR1cm4gJHtvZmZzZXRzLmxlbmd0aCA+IDAgPyBvZmZzZXRzLmpvaW4oJysnKSA6ICcwdSd9O1xuICAgICAgICAgICB9YDtcblxuICAgIHJldHVybiBgJHtpbXBsS2V5fSgke3ZhckluZGljZXN9KWA7XG4gIH07XG5cbiAgY29uc3Qgc2V0QnlPZmZzZXQgPSAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+XG4gICAgKCgpID0+IHtcbiAgICAgIGlmICh0eXBlLnN0b3JhZ2UgPT09IHR5cGUudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09JHt2YWx1ZX07YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAnaTMyJykge1xuICAgICAgICAvLyBpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT12ZWMyPHUzMj4odTMyKCR7dmFsdWV9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHt2YWx1ZX0gPCAwKSk7YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAndTMyJykge1xuICAgICAgICAvLyB1aW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09dmVjMjx1MzI+KHUzMigke3ZhbHVlfSksIDB1KTtgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd1MzInICYmIHR5cGUudmFsdWUgPT09ICd2ZWM0PGJvb2w+Jykge1xuICAgICAgICAvLyBib29sLCBjb21wb25lbnRzID09PSA0XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7dmFsdWV9KSk7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt0eXBlLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7dHlwZS52YWx1ZX0geWV0YCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICBjb25zdCBnZXRCeU9mZnNldCA9IChvZmZzZXQ6IG51bWJlciB8IHN0cmluZykgPT5cbiAgICAoKCkgPT4ge1xuICAgICAgaWYgKHR5cGUuc3RvcmFnZSA9PT0gdHlwZS52YWx1ZSkge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ2kzMicpIHtcbiAgICAgICAgLy8gaW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgcmV0dXJuIGBpMzIoJHtuYW1lfVske29mZnNldH1dLngpYDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAndTMyJykge1xuICAgICAgICAvLyB1aW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgcmV0dXJuIGB1MzIoJHtuYW1lfVske29mZnNldH1dLngpYDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndTMyJyAmJiB0eXBlLnZhbHVlID09PSAndmVjNDxib29sPicpIHtcbiAgICAgICAgLy8gYm9vbCwgY29tcG9uZW50cyA9PT0gNFxuICAgICAgICByZXR1cm4gYHZlYzQ8Ym9vbD4oYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGdSksIGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRjAwdSksIGJvb2woJHtuYW1lfVske1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRjAwMDAwMHUpKWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7dHlwZS5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3R5cGUudmFsdWV9IHlldGApO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgY29uc3QgZ2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24gPVxuICAgIHJhbmsgPCAyXG4gICAgICA/ICcnXG4gICAgICA6IGBcbiAgZm4gZ2V0XyR7bmFtZX1CeUluZGljZXMoaW5kaWNlczogJHt0eXBlLmluZGljZXN9KSAtPiAke3ZhbHVlVHlwZX0ge1xuICAgIHJldHVybiAke2dldEJ5T2Zmc2V0KGBpMm9fJHtuYW1lfShpbmRpY2VzKWApfTtcbiAgfWA7XG5cbiAgY29uc3QgZ2V0SW1wbGVtZW50YXRpb24gPVxuICAgIHJhbmsgPCAyXG4gICAgICA/ICcnXG4gICAgICA6ICgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25QYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKChpKSA9PiBgZCR7aX06IHUzMmApLmpvaW4oJywgJyk7XG4gICAgICAgICAgY29uc3QgZGltc1BhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfWApLmpvaW4oJywgJyk7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgZm4gZ2V0XyR7bmFtZX0oJHtmdW5jdGlvblBhcmFtc30pIC0+ICR7dmFsdWVUeXBlfSB7XG4gICAgcmV0dXJuIGdldF8ke25hbWV9QnlJbmRpY2VzKCR7aW5kaWNlcyhkaW1zUGFyYW1zKX0pO1xuICB9YDtcbiAgICAgICAgfSkoKTtcblxuICBjb25zdCBnZXQgPSAoLi4uaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiB7XG4gICAgaWYgKGluZGljZXMubGVuZ3RoICE9PSByYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtyYW5rfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRpY2VzID0gaW5kaWNlcy5tYXAobm9ybWFsaXplRGltKS5qb2luKCcsJyk7XG5cbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KCcwdScpO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KG5vcm1hbGl6ZWRJbmRpY2VzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldCA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGBnZXRfJHtuYW1lfSgke25vcm1hbGl6ZWRJbmRpY2VzfSlgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRCeUluZGljZXMgPSAodmFySW5kaWNlczogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQodmFySW5kaWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICByZXR1cm4gYGdldF8ke25hbWV9QnlJbmRpY2VzKCR7dmFySW5kaWNlc30pYDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24gPVxuICAgIHJhbmsgPCAyXG4gICAgICA/ICcnXG4gICAgICA6IGBcbiAgZm4gc2V0XyR7bmFtZX1CeUluZGljZXMoaW5kaWNlczogJHt0eXBlLmluZGljZXN9LCB2YWx1ZTogJHt2YWx1ZVR5cGV9KSB7XG4gICAgJHtzZXRCeU9mZnNldChgaTJvXyR7bmFtZX0oaW5kaWNlcylgLCAndmFsdWUnKX1cbiAgfWA7XG5cbiAgY29uc3Qgc2V0SW1wbGVtZW50YXRpb24gPVxuICAgIHJhbmsgPCAyXG4gICAgICA/ICcnXG4gICAgICA6ICgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25QYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKChpKSA9PiBgZCR7aX06IHUzMmApLmpvaW4oJywgJyk7XG4gICAgICAgICAgY29uc3QgZGltc1BhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfWApLmpvaW4oJywgJyk7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgZm4gc2V0XyR7bmFtZX0oJHtmdW5jdGlvblBhcmFtc30sIHZhbHVlOiAke3ZhbHVlVHlwZX0pIHtcbiAgICBzZXRfJHtuYW1lfUJ5SW5kaWNlcygke2luZGljZXMoZGltc1BhcmFtcyl9LCB2YWx1ZSk7XG4gIH1gO1xuICAgICAgICB9KSgpO1xuXG4gIGNvbnN0IHNldCA9ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4ge1xuICAgIGlmIChpbmRpY2VzQW5kVmFsdWUubGVuZ3RoICE9PSByYW5rICsgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7cmFua31gKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBpbmRpY2VzQW5kVmFsdWVbcmFua107XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkSW5kaWNlcyA9IGluZGljZXNBbmRWYWx1ZS5zbGljZSgwLCByYW5rKS5tYXAobm9ybWFsaXplRGltKS5qb2luKCcsJyk7XG5cbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KCcwdScsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBzZXRCeU9mZnNldChub3JtYWxpemVkSW5kaWNlc1swXSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0ID0gdHJ1ZTtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICByZXR1cm4gYHNldF8ke25hbWV9KCR7bm9ybWFsaXplZEluZGljZXN9LCAke3ZhbHVlfSlgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRCeUluZGljZXMgPSAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICByZXR1cm4gc2V0QnlPZmZzZXQodmFySW5kaWNlcywgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGBzZXRfJHtuYW1lfUJ5SW5kaWNlcygke3ZhckluZGljZXN9LCAke3ZhbHVlfSk7YDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaW1wbCA9ICgpID0+IHtcbiAgICBjb25zdCBpbXBscyA9IFtdO1xuICAgIGxldCBuZWVkU2hhcGVTdHJpZGVzID0gZmFsc2U7XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5vZmZzZXRUb0luZGljZXMpIHtcbiAgICAgIGltcGxzLnB1c2gob2Zmc2V0VG9JbmRpY2VzSW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0KSB7XG4gICAgICBpbXBscy5wdXNoKGluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KSB7XG4gICAgICBPYmplY3QudmFsdWVzKGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pLmZvckVhY2goKGltcGwpID0+IGltcGxzLnB1c2goaW1wbCkpO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuc2V0KSB7XG4gICAgICBpbXBscy5wdXNoKHNldEltcGxlbWVudGF0aW9uKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLnNldEJ5SW5kaWNlcykge1xuICAgICAgaW1wbHMucHVzaChzZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5nZXQpIHtcbiAgICAgIGltcGxzLnB1c2goZ2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzKSB7XG4gICAgICBpbXBscy5wdXNoKGdldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXVzZVVuaWZvcm0gJiYgbmVlZFNoYXBlU3RyaWRlcykge1xuICAgICAgaW1wbHMudW5zaGlmdChcbiAgICAgICAgYGNvbnN0ICR7c2hhcGV9ID0gJHt0eXBlLmluZGljZXN9KCR7c2hhcGVPclJhbmsuam9pbignLCcpfSk7YCxcbiAgICAgICAgYGNvbnN0ICR7c3RyaWRlc30gPSAke3R5cGUuaW5kaWNlc30oJHtTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoc2hhcGVPclJhbmspLmpvaW4oJywnKX0pO2AsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaW1wbHMuam9pbignXFxuJyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBpbXBsLFxuICAgIHR5cGUsXG4gICAgb2Zmc2V0VG9JbmRpY2VzLFxuICAgIGluZGljZXNUb09mZnNldCxcbiAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCxcbiAgICBpbmRpY2VzLFxuICAgIGluZGljZXNHZXQsXG4gICAgaW5kaWNlc1NldCxcbiAgICBzZXQsXG4gICAgc2V0QnlPZmZzZXQsXG4gICAgc2V0QnlJbmRpY2VzLFxuICAgIGdldCxcbiAgICBnZXRCeU9mZnNldCxcbiAgICBnZXRCeUluZGljZXMsXG4gICAgLy8gaXNWZWM0LFxuICAgIHVzYWdlLFxuICAgIG5hbWUsXG4gICAgc3RyaWRlcyxcbiAgICBzaGFwZSxcbiAgICByYW5rLFxuICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIGlucHV0LiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgaW5wdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnB1dFZhcmlhYmxlID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHR5cGU6IG51bWJlcixcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxuICBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSxcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2lucHV0JywgY29tcG9uZW50cyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gb3V0cHV0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgb3V0cHV0LiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgb3V0cHV0LlxuICovXG5leHBvcnQgY29uc3Qgb3V0cHV0VmFyaWFibGUgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgdHlwZTogbnVtYmVyLFxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxLFxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnb3V0cHV0JywgY29tcG9uZW50cyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gYXRvbWljIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgb3V0cHV0LlxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIG91dHB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGF0b21pY091dHB1dFZhcmlhYmxlID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHR5cGU6IG51bWJlcixcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnYXRvbWljT3V0cHV0JywgMSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgdmFyaWFibGUuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSB2YXJpYWJsZS4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgaW50ZXJuYWxWYXJpYWJsZSA9IChcbiAgbmFtZTogc3RyaW5nLFxuICB0eXBlOiBudW1iZXIsXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEsXG4pOiBJbmRpY2VzSGVscGVyID0+IGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdpbnRlcm5hbCcsIGNvbXBvbmVudHMpO1xuXG5leHBvcnQgdHlwZSBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlID0gJ3UzMicgfCAnZjE2JyB8ICdmMzInIHwgJ2kzMic7XG5leHBvcnQgdHlwZSBVbmlmb3Jtc0FycmF5VHlwZSA9IEFycmF5PHsgbmFtZTogc3RyaW5nOyB0eXBlOiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlOyBsZW5ndGg/OiBudW1iZXIgfT47XG5cbi8qKlxuICogQSBTaGFkZXJIZWxwZXIgaXMgYSBoZWxwZXIgY2xhc3MgZm9yIGdlbmVyYXRpbmcgV0dTTCBjb2RlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNoYWRlckhlbHBlciB7XG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgc3RhcnQgb2YgbWFpbiBmdW5jdGlvbiBpbiBXR1NMIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICogIC4uLlxuICAgKlxuICAgKiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAqICAgIC8vIHlvdXIgY29kZSBoZXJlIGluc2lkZSBtYWluKCkgZnVuY3Rpb25cbiAgICogICAgLi4uXG4gICAqICB9XG4gICAqIGA7XG4gICAqXG4gICAqIEBwYXJhbSB3b3JrZ3JvdXBTaXplIC0gYW4gb3B0aW9uYWwgd29ya2dyb3VwIHNpemUuIGRlZmF1bHQgaXMgV09SS0dST1VQX1NJWkUuXG4gICAqL1xuICBtYWluU3RhcnQod29ya2dyb3VwU2l6ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IHN0cmluZztcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNvZGUgc25pcHBldCBmb3IgZ3VhcmRpbmcgYWdhaW5zdCBvdXQtb2YtYm91bmRzIHNpemUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgKiAgLi4uXG4gICAqXG4gICAqICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICogICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cbiAgICpcbiAgICogICAgLy8geW91ciBjb2RlIGhlcmUgaW5zaWRlIG1haW4oKSBmdW5jdGlvblxuICAgKiAgICAuLi5cbiAgICogIH1cbiAgICogYDtcbiAgICpcbiAgICogQHBhcmFtIHNpemUgLSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSB0byBndWFyZCBhZ2FpbnN0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqL1xuICBndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHNpemU6IHVua25vd24pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHNuaXBwZXQgZm9yIGRlY2xhcmluZyBtdWx0aXBsZSBpbnB1dHMgb3Igb3V0cHV0cy5cbiAgICpcbiAgICogQHBhcmFtIHZhcmlhYmxlcyAtIGFuIGFycmF5IG9mIEluZGljZXNIZWxwZXIgZm9yIHRoZSB2YXJpYWJsZXMuXG4gICAqL1xuICBkZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBvbmUgdW5pZm9ybS4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdW5pZm9ybS5cbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiB0aGUgdW5pZm9ybS5cbiAgICogQHBhcmFtIGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIHVuaWZvcm0sIGRlZmF1bHQgdG8gMSB3aGVuIGl0IGlzIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIHJlZ2lzdGVyVW5pZm9ybShuYW1lOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgbGVuZ3RoPzogbnVtYmVyKTogU2hhZGVySGVscGVyO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy5cbiAgICpcbiAgICogQHBhcmFtIHVuaWZvcm1zIC0gYW4gYXJyYXkgb2YgdW5pZm9ybXMuIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgYW4gb2JqZWN0IHdpdGggMiBwcm9wZXJ0aWVzOiBgbmFtZWAgYW5kXG4gICAqICAgICBgdHlwZWAuXG4gICAqL1xuICByZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlcjtcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgbXVsdGlwbGUgaW50ZXJuYWwgdmFyaWFibGVzLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlXG4gICAqIGludGVybmFsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhcmlhYmxlcyAtIGFuIGFycmF5IG9mIEluZGljZXNIZWxwZXIgZm9yIHRoZSB2YXJpYWJsZXMuXG4gICAqL1xuICByZWdpc3RlckludGVybmFsVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogU2hhZGVySGVscGVyO1xufVxuXG5jbGFzcyBTaGFkZXJIZWxwZXJJbXBsIGltcGxlbWVudHMgU2hhZGVySGVscGVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBub3JtYWxpemVkRGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIHByaXZhdGUgbGltaXRzOiBHUFVTdXBwb3J0ZWRMaW1pdHMsXG4gICkge31cblxuICBndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHNpemU6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gR3VhcmQgYWdhaW5zdCBvdXQtb2YtYm91bmRzIHdvcmsgZ3JvdXAgc2l6ZXNcbiAgICBjb25zdCBzaXplSW5Db2RlID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gYCR7c2l6ZX11YCA6IHNpemU7XG4gICAgcmV0dXJuIGBpZiAoZ2xvYmFsX2lkeCA+PSAke3NpemVJbkNvZGV9KSB7IHJldHVybjsgfWA7XG4gIH1cblxuICBtYWluU3RhcnQod29ya2dyb3VwU2l6ZTogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gV09SS0dST1VQX1NJWkUpIHtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWCA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IHdvcmtncm91cFNpemUgOiB3b3JrZ3JvdXBTaXplWzBdO1xuICAgIGNvbnN0IHdvcmtncm91cFNpemVZID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gMSA6IHdvcmtncm91cFNpemVbMV07XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVogPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyAxIDogd29ya2dyb3VwU2l6ZVsyXTtcblxuICAgIGlmIChcbiAgICAgIHdvcmtncm91cFNpemVYID4gdGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYIHx8XG4gICAgICB3b3JrZ3JvdXBTaXplWSA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSB8fFxuICAgICAgd29ya2dyb3VwU2l6ZVogPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVpcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHdvcmtncm91cCBzaXplIFske3dvcmtncm91cFNpemVYfSwgJHt3b3JrZ3JvdXBTaXplWX0sICR7XG4gICAgICAgICAgd29ya2dyb3VwU2l6ZVpcbiAgICAgICAgfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgc2l6ZSBbJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh9LCAke1xuICAgICAgICAgIHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWVxuICAgICAgICB9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn1dLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh3b3JrZ3JvdXBTaXplWCAqIHdvcmtncm91cFNpemVZICogd29ya2dyb3VwU2l6ZVogPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHdvcmtncm91cCBzaXplIFske3dvcmtncm91cFNpemVYfSwgJHt3b3JrZ3JvdXBTaXplWX0sICR7XG4gICAgICAgICAgd29ya2dyb3VwU2l6ZVpcbiAgICAgICAgfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgaW52b2NhdGlvbnMgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXB9LmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGlzMURpbWVuc2lvbkRpc3BhdGNoID0gdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXSA9PT0gMSAmJiB0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdID09PSAxO1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IGlzMURpbWVuc2lvbkRpc3BhdGNoXG4gICAgICA/IGBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmBcbiAgICAgIDogYEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIG51bV93b3JrZ3JvdXBzIDogdmVjMzx1MzI+YDtcbiAgICBjb25zdCBnbG9iYWxJZHhEZWZpbml0aW9uID0gaXMxRGltZW5zaW9uRGlzcGF0Y2hcbiAgICAgID8gYGxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7XG4gICAgICAgICBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLng7YFxuICAgICAgOiBgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54O1xuICAgICAgICAgbGV0IGdsb2JhbF9pZHggPSB3b3JrZ3JvdXBfaW5kZXggKiAke3dvcmtncm91cFNpemVYICogd29ya2dyb3VwU2l6ZVkgKiB3b3JrZ3JvdXBTaXplWn11ICsgbG9jYWxfaWR4O2A7XG5cbiAgICByZXR1cm4gYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVYfSwgJHt3b3JrZ3JvdXBTaXplWX0sICR7d29ya2dyb3VwU2l6ZVp9KVxuICBmbiBtYWluKCR7cGFyYW1MaXN0fSkge1xuICAgICR7Z2xvYmFsSWR4RGVmaW5pdGlvbn1cbiAgYDtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZTogSW5kaWNlc0hlbHBlcik6IHZvaWQge1xuICAgIGlmICh2YXJpYWJsZS5yYW5rICE9PSAwKSB7XG4gICAgICBpZiAodmFyaWFibGUuc2hhcGUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5wdXNoKHsgbmFtZTogdmFyaWFibGUuc2hhcGUucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHZhcmlhYmxlLnN0cmlkZXMuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5wdXNoKHsgbmFtZTogdmFyaWFibGUuc3RyaWRlcy5yZXBsYWNlKCd1bmlmb3Jtcy4nLCAnJyksIHR5cGU6ICd1MzInLCBsZW5ndGg6IHZhcmlhYmxlLnJhbmsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZWNsYXJlVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJpbmRpbmdJbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAodmFyaWFibGUudXNhZ2UgPT09ICdpbnRlcm5hbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSBpbnRlcm5hbCB2YXJpYWJsZSB3aXRoIGRlY2xhcmVWYXJpYWJsZSgpLiB1c2UgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcygpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHRoaXMudmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgIHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZSk7XG4gICAgY29uc3QgYWNjZXNzID0gdmFyaWFibGUudXNhZ2UgPT09ICdpbnB1dCcgPyAncmVhZCcgOiAncmVhZF93cml0ZSc7XG4gICAgY29uc3Qgc3RvcmFnZVR5cGUgPSB2YXJpYWJsZS51c2FnZSA9PT0gJ2F0b21pY091dHB1dCcgPyBgYXRvbWljPGkzMj5gIDogdmFyaWFibGUudHlwZS5zdG9yYWdlO1xuICAgIHJldHVybiBgQGdyb3VwKDApIEBiaW5kaW5nKCR7YmluZGluZ0luZGV4fSkgdmFyPHN0b3JhZ2UsICR7YWNjZXNzfT4gJHt2YXJpYWJsZS5uYW1lfTogYXJyYXk8JHtzdG9yYWdlVHlwZX0+O2A7XG4gIH1cblxuICBkZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFyaWFibGVzLm1hcCgodikgPT4gdGhpcy5kZWNsYXJlVmFyaWFibGUodiwgdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHZhcmlhYmxlOiBJbmRpY2VzSGVscGVyKTogdm9pZCB7XG4gICAgaWYgKHZhcmlhYmxlLnVzYWdlICE9PSAnaW50ZXJuYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICB0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGUpO1xuICB9XG5cbiAgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IFNoYWRlckhlbHBlciB7XG4gICAgdmFyaWFibGVzLmZvckVhY2goKHYpID0+IHRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHYpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZ2lzdGVyVW5pZm9ybShuYW1lOiBzdHJpbmcsIHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsIGxlbmd0aCA9IDEpOiBTaGFkZXJIZWxwZXIge1xuICAgIHRoaXMudW5pZm9ybXMucHVzaCh7IG5hbWUsIHR5cGUsIGxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZ2lzdGVyVW5pZm9ybXMoYWRkaXRpb25hbFVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlciB7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXMuY29uY2F0KGFkZGl0aW9uYWxVbmlmb3Jtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcml2YXRlIGludGVybmFsVmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10gPSBbXTtcbiAgcHJpdmF0ZSB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1EZWNsYXJhdGlvbigpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1TbmlwcGV0czogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdHlwZSwgbGVuZ3RoIH0gb2YgdGhpcy51bmlmb3Jtcykge1xuICAgICAgaWYgKGxlbmd0aCAmJiBsZW5ndGggPiA0KSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGBAYWxpZ24oMTYpICR7bmFtZX06YXJyYXk8bWF0Mng0PCR7dHlwZX0+LCAke01hdGguY2VpbChsZW5ndGggLyA4KX0+YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06YXJyYXk8dmVjNDwke3R5cGV9PiwgJHtNYXRoLmNlaWwobGVuZ3RoIC8gNCl9PmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlVGVtcCA9IGxlbmd0aCA9PSBudWxsIHx8IGxlbmd0aCA9PT0gMSA/IHR5cGUgOiBgdmVjJHtsZW5ndGh9PCR7dHlwZX0+YDtcbiAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06JHt0eXBlVGVtcH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt1bmlmb3JtU25pcHBldHMuam9pbignLCAnKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YDtcbiAgfVxuICBwcml2YXRlIHZhcmlhYmxlSW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBHZXQgYWRkaXRpb25hbCBpbXBsZW1lbnRhdGlvbiB0aGF0IG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXIgc291cmNlLlxuICAgKi9cbiAgZ2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSArXG4gICAgICB0aGlzLnZhcmlhYmxlcy5tYXAoKGkpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKSArXG4gICAgICB0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcCgoaSkgPT4gaS5pbXBsKCkpLmpvaW4oJ1xcbicpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhcmlhYmxlIGluZm8gb2YgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKi9cbiAgZ2V0IHZhcmlhYmxlc0luZm8oKTogUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm9bXSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMudW5pZm9ybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1XZ3NsVHlwZVRvRGF0YVR5cGUgPSAodHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZSkgPT5cbiAgICAgIFtEYXRhVHlwZS51aW50MzIsIERhdGFUeXBlLmZsb2F0MTYsIERhdGFUeXBlLmZsb2F0LCBEYXRhVHlwZS5pbnQzMl1bWyd1MzInLCAnZjE2JywgJ2YzMicsICdpMzInXS5pbmRleE9mKHR5cGUpXTtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXAoKHUpID0+IFt1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlKHUudHlwZSksIHUubGVuZ3RoID8/IDFdKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlU2hhZGVySGVscGVyID0gKGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgbGltaXRzOiBHUFVTdXBwb3J0ZWRMaW1pdHMpID0+XG4gIG5ldyBTaGFkZXJIZWxwZXJJbXBsKGRpc3BhdGNoR3JvdXAsIGxpbWl0cyk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc3Bvc2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgcGVybTogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBwZXJtOiByZWFkb25seSBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChwZXJtLmxlbmd0aCAhPT0gMCAmJiBwZXJtLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwZXJtIHNpemUgJHtwZXJtLmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggaW5wdXQgcmFuayAke2lucHV0c1swXS5kaW1zLmxlbmd0aH1gKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRQZXJtID0gKGlucHV0UmFuazogbnVtYmVyLCBwZXJtOiBudW1iZXJbXSk6IG51bWJlcltdID0+XG4gIHBlcm0ubGVuZ3RoICE9PSAwID8gcGVybSA6IFsuLi5uZXcgQXJyYXkoaW5wdXRSYW5rKS5rZXlzKCldLnJldmVyc2UoKTtcblxuY29uc3QgZ2V0T3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm06IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10gPT5cbiAgU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShpbnB1dFNoYXBlLCBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZS5sZW5ndGgsIHBlcm0pKTtcblxuY29uc3QgcGVybUZ1bmN0aW9uQm9keSA9IChwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyLCBpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKTogc3RyaW5nID0+IHtcbiAgbGV0IHJldmVyc2VGdW5jID0gYGZuIHBlcm0oaTogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtpbnB1dC50eXBlLmluZGljZXN9O2A7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgLy8gaW5wdXQgaW5kaWNlcyBhbmQgb3V0cHV0IGluZGljZXMgc2hvdWxkIGFsd2F5cyBiZSBsYXJnZXIgb3IgZXF1YWwgdG8gMixcbiAgICAvLyBzbyBpbmRleGVyIGlzIGFsd2F5cyB2YWxpZCB0byBiZSB1c2VkIG9uIGBhYCBhbmQgYGlgLlxuICAgIHJldmVyc2VGdW5jICs9IGBhWyR7cGVybVtpXX1dPWlbJHtpfV07YDtcbiAgfVxuICByZXR1cm4gKHJldmVyc2VGdW5jICs9ICdyZXR1cm4gYTt9Jyk7XG59O1xuXG5jb25zdCBzcXVlZXplU2hhcGUgPSAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBhZGp1c3RlZFBlcm06IG51bWJlcltdKTogeyBuZXdTaGFwZTogbnVtYmVyW107IG5ld1Blcm06IG51bWJlcltdIH0gPT4ge1xuICBjb25zdCBuZXdTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgbmV3UGVybTogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgfVxuICAgIGlmIChzaGFwZVthZGp1c3RlZFBlcm1baV1dICE9PSAxKSB7XG4gICAgICBuZXdQZXJtLnB1c2goYWRqdXN0ZWRQZXJtW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbmV3U2hhcGUsIG5ld1Blcm0gfTtcbn07XG5cbmNvbnN0IGlzVHJhbnNwb3NlUmVzaGFwZSA9IChwZXJtOiBudW1iZXJbXSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiB7XG4gIC8vIEFzIGxvbmcgYXMgdGhlIGRpbXMgd2l0aCB2YWx1ZXMgPiAxIHN0YXkgaW4gdGhlIHNhbWUgb3JkZXIsIGl0J3MgYSByZXNoYXBlLlxuICAvLyBFeGFtcGxlOiBTaGFwZT0oMSwxLDEwMjQsNDA5NikgLT4gcGVybT0oMiwwLDMsMSkuXG4gIGxldCBsYXN0UGVybXV0ZWRBeGlzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJtLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHNoYXBlW3Blcm1baV1dID09PSAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHBlcm1baV0gPCBsYXN0UGVybXV0ZWRBeGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RQZXJtdXRlZEF4aXMgPSBwZXJtW2ldO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvID0gKGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LCBwZXJtQXR0cjogbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0RGF0YVR5cGUgPSBpbnB1dFRlbnNvci5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRUZW5zb3IuZGltcy5sZW5ndGg7XG4gIGNvbnN0IHBlcm0gPSBnZXRBZGp1c3RlZFBlcm0oaW5wdXRSYW5rLCBwZXJtQXR0cik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZ2V0T3V0cHV0U2hhcGUoaW5wdXRUZW5zb3IuZGltcywgcGVybSk7XG4gIGxldCBuZXdJbnB1dFNoYXBlID0gaW5wdXRUZW5zb3IuZGltcztcbiAgbGV0IG5ld091dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gIGNvbnN0IHRyYW5zcG9zZUFzUmVzaGFwZSA9IGlucHV0UmFuayA8IDIgfHwgaXNUcmFuc3Bvc2VSZXNoYXBlKHBlcm0sIGlucHV0VGVuc29yLmRpbXMpO1xuICBsZXQgZ2V0U2hhZGVyU291cmNlO1xuICBpZiAodHJhbnNwb3NlQXNSZXNoYXBlKSB7XG4gICAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXREYXRhVHlwZSwgbmV3SW5wdXRTaGFwZSwgNCk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgbmV3T3V0cHV0U2hhcGUsIDQpO1xuICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xuICB9YDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdUcmFuc3Bvc2VDb3B5JyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiBjb21wb25lbnRzICovKSB9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczogW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDQpIH1dLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IHsgbmV3U2hhcGUsIG5ld1Blcm0gfSA9IHNxdWVlemVTaGFwZShpbnB1dFRlbnNvci5kaW1zLCBwZXJtKTtcbiAgY29uc3QgY2hhbm5lbHNMYXN0ID0gU2hhcGVVdGlsLmFyZUVxdWFsKG5ld1Blcm0sIFsyLCAzLCAxXSk7XG4gIGNvbnN0IGNoYW5uZWxzRmlyc3QgPSBTaGFwZVV0aWwuYXJlRXF1YWwobmV3UGVybSwgWzMsIDEsIDJdKTtcbiAgY29uc3QgdXNlU2hhcmVkID0gbmV3U2hhcGUubGVuZ3RoID09PSAyIHx8IGNoYW5uZWxzTGFzdCB8fCBjaGFubmVsc0ZpcnN0O1xuICBpZiAodXNlU2hhcmVkKSB7XG4gICAgbmV3SW5wdXRTaGFwZSA9IGNoYW5uZWxzTGFzdFxuICAgICAgPyBbbmV3U2hhcGVbMF0sIG5ld1NoYXBlWzFdICogbmV3U2hhcGVbMl1dXG4gICAgICA6IGNoYW5uZWxzRmlyc3RcbiAgICAgICAgPyBbbmV3U2hhcGVbMF0gKiBuZXdTaGFwZVsxXSwgbmV3U2hhcGVbMl1dXG4gICAgICAgIDogbmV3U2hhcGU7XG4gICAgbmV3T3V0cHV0U2hhcGUgPSBbbmV3SW5wdXRTaGFwZVsxXSwgbmV3SW5wdXRTaGFwZVswXV07XG4gICAgY29uc3QgdGlsZVNpemUgPSAxNjtcbiAgICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0RGF0YVR5cGUsIG5ld0lucHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dERhdGFUeXBlLCBuZXdPdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICB2YXI8d29ya2dyb3VwPiB0aWxlIDogYXJyYXk8YXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7dGlsZVNpemUgKyAxfT4sICR7dGlsZVNpemV9PjtcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt0aWxlU2l6ZSwgdGlsZVNpemUsIDFdKX1cbiAgICBsZXQgc3RyaWRlID0gKHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSAtIDEpIC8gJHt0aWxlU2l6ZX0gKyAxO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeCA9IHdvcmtncm91cF9pbmRleCAlIHN0cmlkZTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3kgPSB3b3JrZ3JvdXBfaW5kZXggLyBzdHJpZGU7XG4gICAgbGV0IGlucHV0X2NvbCA9IHdvcmtncm91cF9pZF95ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgaW5wdXRfcm93ID0gd29ya2dyb3VwX2lkX3ggKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChpbnB1dF9yb3cgPCB1bmlmb3Jtcy5hX3NoYXBlWzBdICYmIGlucHV0X2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMV0pIHtcbiAgICAgIHRpbGVbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2lucHV0LmdldEJ5SW5kaWNlcyhgJHtpbnB1dC50eXBlLmluZGljZXN9KGlucHV0X3JvdywgaW5wdXRfY29sKWApfTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgbGV0IG91dHB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeCAqICR7dGlsZVNpemV9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IG91dHB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeSAqICR7dGlsZVNpemV9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKG91dHB1dF9yb3cgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMF0gJiYgb3V0cHV0X2NvbCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSkge1xuICAgICAgJHtvdXRwdXQuc2V0QnlJbmRpY2VzKGAke291dHB1dC50eXBlLmluZGljZXN9KG91dHB1dF9yb3csIG91dHB1dF9jb2wpYCwgJ3RpbGVbbG9jYWxfaWQueF1bbG9jYWxfaWQueV0nKX1cbiAgICB9XG4gIH1gO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdUcmFuc3Bvc2VTaGFyZWQnLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFRlbnNvci5kYXRhVHlwZSB9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChuZXdPdXRwdXRTaGFwZVsxXSAvIHRpbGVTaXplKSwgeTogTWF0aC5jZWlsKG5ld091dHB1dFNoYXBlWzBdIC8gdGlsZVNpemUpIH0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMobmV3SW5wdXRTaGFwZSwgbmV3T3V0cHV0U2hhcGUpLFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH07XG4gIH1cblxuICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dERhdGFUeXBlLCBuZXdJbnB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIG5ld091dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuXG4gICR7cGVybUZ1bmN0aW9uQm9keShwZXJtLCBpbnB1dFJhbmssIGlucHV0LCBvdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJykpfVxuICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnVHJhbnNwb3NlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtwZXJtQXR0cn1gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFRlbnNvci5kYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG5ld0lucHV0U2hhcGUsIG5ld091dHB1dFNoYXBlKSxcbiAgICAgICAgXSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdHJhbnNwb3NlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLnBlcm0pO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcGVybTogYXR0cmlidXRlcy5wZXJtIGFzIG51bWJlcltdIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzLCBSZWR1Y2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9yZWR1Y2UnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IHJlZHVjZU9wczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgbWF4OiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpJyxcbiAgbWluOiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpJyxcbiAgbWVhbjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHN1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHByb2Q6ICdiZXN0VmFsdWUgKiBjYW5kaWRhdGUnLFxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxuICBsb2dTdW1FeHA6ICdiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKScsXG4gIGwxOiAnYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSknLFxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG59O1xuXG5jb25zdCByZWR1Y2VTaGFyZWRPcHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIG1heDogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKScsXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBzdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbG9nU3VtRXhwOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbDE6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG59O1xuXG5jb25zdCByZWR1Y2VJbml0VmFsdWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICBtYXg6ICdfQVtvZmZzZXRdJyxcbiAgbWluOiAnX0Fbb2Zmc2V0XScsXG4gIG1lYW46ICcwJyxcbiAgc3VtOiAnMCcsXG4gIHByb2Q6ICcxJyxcbiAgc3VtU3F1YXJlOiAnMCcsXG4gIGxvZ1N1bUV4cDogJzAnLFxuICBsMTogJzAnLFxuICBsMjogJzAnLFxuICBsb2dTdW06ICcwJyxcbn07XG5cbmNvbnN0IHJlZHVjZU91dHB1dFZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgbWF4OiAnYmVzdFZhbHVlJyxcbiAgbWluOiAnYmVzdFZhbHVlJyxcbiAgc3VtOiAnYmVzdFZhbHVlJyxcbiAgcHJvZDogJ2Jlc3RWYWx1ZScsXG4gIHN1bVNxdWFyZTogJ2Jlc3RWYWx1ZScsXG4gIGxvZ1N1bUV4cDogJ2xvZyhiZXN0VmFsdWUpJyxcbiAgbDE6ICdiZXN0VmFsdWUnLFxuICBsMjogJ3NxcnQoYmVzdFZhbHVlKScsXG4gIGxvZ1N1bTogJ2xvZyhiZXN0VmFsdWUpJyxcbn07XG5cbmNvbnN0IGdldElubmVyTW9zdEF4ZXMgPSAobnVtSW5uZXJBeGVzOiBudW1iZXIsIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSByYW5rIC0gbnVtSW5uZXJBeGVzOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmVzLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMgPSAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSk6IFtudW1iZXJbXSwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbXTtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKHNoYXBlW2RpbV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCByZWR1Y2VTaGFwZSA9IGF4ZXMubWFwKChkaW0pID0+IHNoYXBlW2RpbV0pO1xuICByZXR1cm4gW291dHB1dFNoYXBlLCByZWR1Y2VTaGFwZV07XG59O1xuXG5jb25zdCBleHBhbmRTaGFwZVRvS2VlcERpbSA9IChzaGFwZTogbnVtYmVyW10sIGF4ZXM6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoICsgYXhlcy5sZW5ndGg7XG4gIGNvbnN0IGV4cGFuZFNoYXBlID0gW107XG4gIGxldCBzaGFwZUlkeCA9IDA7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgZXhwYW5kU2hhcGUucHVzaChzaGFwZVtzaGFwZUlkeCsrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHBhbmRTaGFwZTtcbn07XG5cbmNvbnN0IGFyZUF4ZXNJbm5lck1vc3REaW1zID0gKGF4ZXM6IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGF4ZXNbYXhlcy5sZW5ndGggLSBpIC0gMV0gIT09IHJhbmsgLSAxIC0gaSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGdldEF4ZXNQZXJtdXRhdGlvbiA9IChheGVzOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXMgPSBbXTtcbiAgaWYgKCFhcmVBeGVzSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICByZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXhlcy5mb3JFYWNoKChheGlzKSA9PiByZXMucHVzaChheGlzKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VTaGFyZWRQcm9ncmFtSW5mbyA9IChcbiAgbmFtZTogc3RyaW5nLFxuICBjYWNoZUtleTogc3RyaW5nLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgcmVkdWNlVHlwZTogc3RyaW5nLFxuICBvdXRwdXREYXRhVHlwZTogRGF0YVR5cGUsXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbiAgcmVkdWNlU2hhcGU6IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgcmVkdWNlU2l6ZSA9IFNoYXBlVXRpbC5zaXplKHJlZHVjZVNoYXBlKTtcblxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ19BJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIG91dHB1dERhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG5cbiAgbGV0IHdvcmtncm91cFNpemUgPSA2NDtcbiAgLy8gSWYgb25seSBvbmUgd29ya2dyb3VwIGlzIGRpc3BhdGNoZWQsIGluY3JlYXNlIHdvcmtncm91cFNpemUgdG8gaW1wcm92ZSBwYXJhbGxlbGlzbS5cbiAgaWYgKG91dHB1dFNpemUgPT09IDEpIHtcbiAgICB3b3JrZ3JvdXBTaXplID0gMjU2O1xuICB9XG5cbiAgY29uc3Qgc2hhcmVkTWVtb3J5U25pcHBldCA9IGBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHt3b3JrZ3JvdXBTaXplfT47XG4gICAgICAgYDtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdyZWR1Y2VTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICR7c2hhcmVkTWVtb3J5U25pcHBldH1cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCh3b3JrZ3JvdXBTaXplKX1cblxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke3dvcmtncm91cFNpemV9O1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBvdXRwdXRJbmRleCAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XG5cbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gZjMyKCR7cmVkdWNlSW5pdFZhbHVlc1tyZWR1Y2VUeXBlXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHt3b3JrZ3JvdXBTaXplfSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZjMyKCR7aW5wdXQuZ2V0QnlPZmZzZXQoJ29mZnNldCArIGsnKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke3JlZHVjZU9wc1tyZWR1Y2VUeXBlXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7d29ya2dyb3VwU2l6ZX11KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke3JlZHVjZVNoYXJlZE9wc1tyZWR1Y2VUeXBlXX07XG4gICAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobG9jYWxfaWR4ID09IDB1KSB7XG4gICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAnb3V0cHV0SW5kZXgnLFxuICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgIHJlZHVjZVR5cGUgPT09ICdtZWFuJ1xuICAgICAgICAgICAgICAgID8gYCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKWBcbiAgICAgICAgICAgICAgICA6IGAke291dHB1dC50eXBlLnN0b3JhZ2V9KCR7cmVkdWNlT3V0cHV0VmFsdWVzW3JlZHVjZVR5cGVdfSlgXG4gICAgICAgICAgICB9YCxcbiAgICAgICAgICApfTtcbiAgICAgICAgIH1cbiAgICAgICAgfWA7XG5cbiAgLy8gT25lIHdvcmsgZ3JvdXAgaXMgcmVzcG9uc2libGUgZm9yIG9ubHkgb25lIGVsZW1lbnQgb2Ygb3V0cHV0LlxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgLy8gTm90ZSB0aGF0IGluIEpTRVAsIFdHIHNpemUgaXMgbm90IGluY2x1ZGVkIGluIGNhY2hlIGJ5IGRlZmF1bHQsIGJ1dCBXZWJHUFUgRVAgaXQgaXMuXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y2FjaGVLZXl9OyR7d29ya2dyb3VwU2l6ZX1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ10gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IG91dHB1dFNpemUgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiByZWR1Y2VTaXplIH1dLFxuICAgIH0pLFxuICB9O1xufTtcblxuY29uc3QgcmVkdWNlQ29tbW9uID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgbmFtZTogc3RyaW5nLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuICByZWR1Y2VUeXBlOiAnc3VtJyB8ICdzdW1TcXVhcmUnIHwgJ3Byb2QnIHwgJ21pbicgfCAnbWF4JyB8ICdtZWFuJyB8ICdsb2dTdW1FeHAnIHwgJ2wxJyB8ICdsMicgfCAnbG9nU3VtJyxcbik6IHZvaWQgPT4ge1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyA9XG4gICAgY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcblxuICBsZXQgdXBkYXRlZEF4ZXMgPSB1cGRhdGVkQXR0cmlidXRlcy5heGVzO1xuICBpZiAodXBkYXRlZEF4ZXMubGVuZ3RoID09PSAwICYmICF1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykge1xuICAgIHVwZGF0ZWRBeGVzID0gY29udGV4dC5pbnB1dHNbMF0uZGltcy5tYXAoKF9kaW0sIGkpID0+IGkpO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZUF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyh1cGRhdGVkQXhlcywgY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuXG4gIGxldCBheGVzID0gbm9ybWFsaXplQXhlcztcbiAgbGV0IGlucHV0ID0gY29udGV4dC5pbnB1dHNbMF07XG4gIGNvbnN0IHBlcm11dGVkQXhlcyA9IGdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCBjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIGlmIChwZXJtdXRlZEF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGlucHV0ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBwZXJtdXRlZEF4ZXMpLCB7XG4gICAgICBpbnB1dHM6IFswXSxcbiAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgfSlbMF07XG4gICAgYXhlcyA9IGdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIGNvbnN0IFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdID0gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5kaW1zLCBheGVzKTtcbiAgbGV0IGZpbmFsT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgaWYgKHVwZGF0ZWRBdHRyaWJ1dGVzLmtlZXBEaW1zKSB7XG4gICAgZmluYWxPdXRwdXRTaGFwZSA9IGV4cGFuZFNoYXBlVG9LZWVwRGltKG91dHB1dFNoYXBlLCBub3JtYWxpemVBeGVzKTtcbiAgfVxuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VTaGFyZWRQcm9ncmFtSW5mbyhcbiAgICAgIG5hbWUsXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIFtpbnB1dF0sXG4gICAgICByZWR1Y2VUeXBlLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBmaW5hbE91dHB1dFNoYXBlLFxuICAgICAgcmVkdWNlU2hhcGUsXG4gICAgKSxcbiAgICB7IGlucHV0czogW2lucHV0XSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW5TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNZWFuU2hhcmVkJywgYXR0cmlidXRlcywgJ21lYW4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUwxU2hhcmVkJywgYXR0cmlidXRlcywgJ2wxJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDJTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMMlNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsMicpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bUV4cFNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW1FeHAnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNYXhTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNYXhTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbWF4Jyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWluU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWluU2hhcmVkJywgYXR0cmlidXRlcywgJ21pbicpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVByb2RTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VQcm9kU2hhcmVkJywgYXR0cmlidXRlcywgJ3Byb2QnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnc3VtJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU3F1YXJlU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlU3VtU3F1YXJlU2hhcmVkJywgYXR0cmlidXRlcywgJ3N1bVNxdWFyZScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW0nKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7XG4gIHJlZHVjZUwxU2hhcmVkLFxuICByZWR1Y2VMMlNoYXJlZCxcbiAgcmVkdWNlTG9nU3VtRXhwU2hhcmVkLFxuICByZWR1Y2VMb2dTdW1TaGFyZWQsXG4gIHJlZHVjZU1heFNoYXJlZCxcbiAgcmVkdWNlTWVhblNoYXJlZCxcbiAgcmVkdWNlTWluU2hhcmVkLFxuICByZWR1Y2VQcm9kU2hhcmVkLFxuICByZWR1Y2VTdW1TaGFyZWQsXG4gIHJlZHVjZVN1bVNxdWFyZVNoYXJlZCxcbn0gZnJvbSAnLi9yZWR1Y2Utc2hhcmVkJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCBpbnB1dHMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMiAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXhlcyBpbnB1dCBkaW1zLicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlZHVjZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBrZWVwRGltczogYm9vbGVhbjtcbiAgbm9vcFdpdGhFbXB0eUF4ZXM6IGJvb2xlYW47XG4gIGF4ZXM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgdHlwZSBSZWR1Y2VPcCA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sXG4pID0+IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIC4uLnN0cmluZ1tdXTtcblxuY29uc3Qgbm9PcDogUmVkdWNlT3AgPSAoaW5wdXQpID0+IFsnJywgJycsIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLCAnJ107XG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8gPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgc2hhZGVyQ2FjaGU6IFByb2dyYW1TaGFkZXJDYWNoZUluZm8sXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICByZWR1Y2VPcDogUmVkdWNlT3AsXG4gIGF4ZXNJbnB1dDogbnVtYmVyW10sXG4gIG91dHB1dERhdGFUeXBlOiBEYXRhVHlwZSxcbiAga2VlcERpbXMgPSBmYWxzZSxcbiAgbm9vcFdpdGhFbXB0eUF4ZXMgPSBmYWxzZSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhheGVzSW5wdXQsIGlucHV0UmFuayk7XG4gIGNvbnN0IHJlZHVjZU9uQWxsQXhlcyA9ICFub29wV2l0aEVtcHR5QXhlcyAmJiBheGVzLmxlbmd0aCA9PT0gMDtcbiAgaW5wdXRTaGFwZS5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaSkgPj0gMCkge1xuICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIG91dHB1dFNoYXBlLnB1c2goMSk7XG4gICAgICB9IC8vIGVsc2UgeyAvLyBza2lwIHRoaXMgYXhpc31cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0U2hhcGUucHVzaChkKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdOyAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcblxuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnX0EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuayk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIG91dHB1dERhdGFUeXBlLCBvdXRwdXRSYW5rKTtcbiAgICBjb25zdCBvcHMgPSByZWR1Y2VPcChpbnB1dCwgb3V0cHV0LCBheGVzKTtcbiAgICBsZXQgcmVkdWNlT3BzID0gb3BzWzJdO1xuXG4gICAgZm9yIChsZXQgayA9IDAsIGwgPSAwOyBrIDwgaW5wdXRSYW5rOyBrKyspIHtcbiAgICAgIC8vIGlmIHRoaXMgYXhpcyBpcyByZWR1Y2VkXG4gICAgICBpZiAocmVkdWNlT25BbGxBeGVzIHx8IGF4ZXMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgIGwrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29wIG92ZXIgdGhlIGQtdGggYXhpc1xuICAgICAgICByZWR1Y2VPcHMgPSBgZm9yKHZhciBqJHtrfTogdTMyID0gMDsgaiR7a30gPCAke2lucHV0U2hhcGVba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke29wc1syXS5pbmNsdWRlcygnbGFzdF9pbmRleCcpID8gYGxldCBsYXN0X2luZGV4ID0gaiR7a307YCA6ICcnfVxuICAgICAgICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgYGoke2t9YCl9XG4gICAgICAgICAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICAgICAgICB9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeENvcHkucHVzaChgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgb3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgbCkpfTtgKTtcbiAgICAgICAgbCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cblxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgJHtpZHhDb3B5LmpvaW4oJ1xcbicpfVxuICAgICAgICAgICR7b3BzWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke29wc1sxXX1cbiAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICAke29wc1szXX1cbiAgICAgICAgICAke29wcy5sZW5ndGggPT09IDQgPyBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKSA6IG9wcy5zbGljZSg0KS5qb2luKCdcXG4nKX1cbiAgICAgICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXG4gICAgICBdLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbik6IFJlZHVjZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBheGVzOiBudW1iZXJbXSA9IFtdO1xuICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gPiAwKSB7XG4gICAgaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBheGVzLnB1c2goTnVtYmVyKHYpKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYXhlcyxcbiAgICBrZWVwRGltczogYXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICBub29wV2l0aEVtcHR5QXhlczogYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyxcbiAgfSk7XG59O1xuXG5jb25zdCBydW5SZWR1Y2VQcm9ncmFtID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgbmFtZTogc3RyaW5nLFxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuICByZWR1Y2VPcDogUmVkdWNlT3AsXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzID1cbiAgICBpbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKFxuICAgICAgbmFtZSxcbiAgICAgIHsgaGludDogdXBkYXRlZEF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgICAgW2lucHV0c1swXV0sXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyAmJiB1cGRhdGVkQXR0cmlidXRlcy5heGVzLmxlbmd0aCA9PT0gMCA/IG5vT3AgOiByZWR1Y2VPcCxcbiAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLmF4ZXMsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFswXSB9LFxuICApO1xufTtcblxuY29uc3QgcmVkdWNlTG9nU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW0nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VMMU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSArPSBhYnMoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUwxJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTDJOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXG4gICAgYHZhciB0ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO2AsXG4gICAgJycsXG4gICAgYHQgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFxuICAgICd2YWx1ZSA9IHNxcnQodmFsdWUpOycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUwyJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTG9nU3VtRXhwTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICs9IGV4cCgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAndmFsdWUgPSBsb2codmFsdWUpOycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1heE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBfb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGlucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCAwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICAgYHZhbHVlID0gbWF4KHZhbHVlLCAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgICcnLFxuICAgIF07XG4gIH07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1heCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1lYW5OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgbGV0IHNpemUgPSAxLjA7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGRlcGVuZHMgb24gdGhlIGlucHV0IGRpbXMuIElmIHdlIHdhbnQgdG8gdXNlIHVuaWZvcm0sIHRoaXMgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAgICBzaXplICo9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICd2YXIgc3VtID0gZjMyKDApOycsXG4gICAgICAnJyxcbiAgICAgIGBzdW0gKz0gZjMyKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgYGxldCB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KHN1bSAvICR7c2l6ZX0pO2AsXG4gICAgXTtcbiAgfTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWVhbicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1pbk5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBfb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgIGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAnJyxcbiAgICBdO1xuICB9O1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNaW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VQcm9kTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDEpO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICo9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVByb2QnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VTdW1OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAnJyxcbiAgICBgdmFsdWUgKz0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAnJyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlU3VtJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlU3VtU3F1YXJlTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtgLFxuICAgICcnLFxuICAgIGB0ID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07IHZhbHVlICs9IHQgKiB0O2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHVzZU5haXZlUmVkdWNlTWV0aG9kID0gKFxuICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBub29wV2l0aEVtcHR5QXhlczogYm9vbGVhbixcbik6IGJvb2xlYW4gPT4ge1xuICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbm9vcFdpdGhFbXB0eUF4ZXM7XG4gIH1cblxuICBsZXQgb3V0cHV0U2l6ZSA9IDE7XG4gIGxldCByZWR1Y2VTaXplID0gMTtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgYXhlcy5sZW5ndGg7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgb3V0cHV0U2l6ZSAqPSBzaGFwZVtkaW1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y2VTaXplICo9IHNoYXBlW2RpbV07XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIGNvbmRpdGlvbiBkYXRhIGlzIHZlcnkgcm91Z2gsIGFsdGhvdWdoIGNvbnNpZGVyaW5nIHRoZSBjb3VudCBvZiBFeGVjdXRpb24gVW5pdCAoRVUpLCB0aGUgcG90ZW50aWFsXG4gIC8vIHdvcmsgZ3JvdXBzIGluIGEgRVUgYW5kIHRoZSBjb3VudHMgb2YgbG9vcHMgaW4gdGhlIG5haXZlIGFuZCBzaGFyZWQgbWV0aG9kcywgYWxzbyBkb2luZyBleHBlcmltZW50c1xuICAvLyBvbiBzb21lIG1hY2hpbmVzLlxuICByZXR1cm4gcmVkdWNlU2l6ZSA8IDMyICYmIG91dHB1dFNpemUgPiAxMDI0O1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNZWFuTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTWVhblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwxID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTDFOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMMVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTDJOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMMlNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bUV4cCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUxvZ1N1bUV4cE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZU1heE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1heFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1pbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZU1pbk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1pblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVByb2QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VQcm9kTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlUHJvZFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZVN1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVN1bVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNxdWFyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZVN1bVNxdWFyZU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVN1bVNxdWFyZVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUxvZ1N1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUxvZ1N1bVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVE9ETzogdGhpcyBpcyB0aGUgc2FtZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB3ZSB1c2UgZm9yIHJlZHVjZSB0aGF0IGhhc1xuLy8gcGVyZm9ybWFuY2UgbGltaXRhdGlvbnMgd2hlbiB0aGUgcmVkdWNlZCBheGlzIGlzIGxvbmcuIE5lZWQgdG8gYWRkXG4vLyBhIG9wdGltaXplZCBjb2RlcGF0aCBmb3IgdGhpcy5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvLCBSZWR1Y2VPcCB9IGZyb20gJy4vcmVkdWNlJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCBpbnB1dHMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyZ01pbk1heEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBrZWVwRGltczogYm9vbGVhbjtcbiAgYXhpczogbnVtYmVyO1xuICBzZWxlY3RMYXN0SW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGFyZ01pbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXJnTWluTWF4QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxuICAgICAgYGlmICgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSAke2F0dHJpYnV0ZXMuc2VsZWN0TGFzdEluZGV4ID4gMCA/ICc8PScgOiAnPCd9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcbiAgICAgICcnLFxuICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKSxcbiAgICBdO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgICdBcmdNaW4nLFxuICAgICAgeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICAgIFtjb250ZXh0LmlucHV0c1swXV0sXG4gICAgICBhcmdNaW5NYXhPcCxcbiAgICAgIFthdHRyaWJ1dGVzLmF4aXNdLFxuICAgICAgRGF0YVR5cGUuaW50NjQsXG4gICAgICBhdHRyaWJ1dGVzLmtlZXBEaW1zLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFswXSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGFyZ01heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXJnTWluTWF4QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxuICAgICAgYGlmICgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSAke2F0dHJpYnV0ZXMuc2VsZWN0TGFzdEluZGV4ID4gMCA/ICc+PScgOiAnPid9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcbiAgICAgICcnLFxuICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKSxcbiAgICBdO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgICdhcmdNYXgnLFxuICAgICAgeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICAgIFtjb250ZXh0LmlucHV0c1swXV0sXG4gICAgICBhcmdNaW5NYXhPcCxcbiAgICAgIFthdHRyaWJ1dGVzLmF4aXNdLFxuICAgICAgRGF0YVR5cGUuaW50NjQsXG4gICAgICBhdHRyaWJ1dGVzLmtlZXBEaW1zLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFswXSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXJnTWluTWF4QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEFyZ01pbk1heEF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgT21pdDxBcmdNaW5NYXhBdHRyaWJ1dGVzLCBrZXlvZiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk+KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgR3B1RGF0YVR5cGUsIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLFxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25Ra3ZGb3JtYXQge1xuICB1bmtub3duLCAvLyBlbnVtIHZhbHVlIG5vdCBzZXQsIG9yIGRlcGVuZHMgb24gcWt2IHByb2plY3Rpb24gaW1wbGVtZW50YXRpb24gZGV0YWlsc1xuICBxa3ZCTlNILCAvLyBmb3Igbm9uLXBhY2tlZCBxa3YsIHBlcm11dGVkXG4gIHFrdkJTTkgsIC8vIGZvciBub24tcGFja2VkIHFrdiwgbm90IHBlcm11dGVkLCB1c2VkIGJ5IG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uIG9yIE11bHRpSGVhZEF0dGVudGlvblxuICBxa3ZCU04zSCwgLy8gZm9yIFRSVCBmdXNlZCBhdHRlbnRpb24sIHFrdiBhcmUgcGFja2VkXG4gIHFrdkJOU0hxa3ZCUzNOSCwgLy8gZm9yIFRSVCBmdXNlZCBjYXVzYWwgYXR0ZW50aW9uLCBkYXRhIGhhcyB0d28gZm9ybWF0cyAocWt2IGlzIDNCTlNILCBnZW1tX2J1ZmZlciBpcyBCUzNOSClcbiAgcUt2QlNOSHhCU04ySCwgLy8gZm9yIFRSVCBmdXNlZCBjcm9zcyBhdHRlbnRpb24sIGt2IGFyZSBwYWNrZWRcbiAgcWt2VE5ILCAvLyBmb3IgbWVtb3J5IGVmZmljaWVudCBhdHRlbnRpb24sIHFrdiBhcmUgbm90IHBhY2tlZCwgYW5kIHBhZGRpbmdzIGFyZSByZW1vdmVkLlxuICBxa3ZUTjNILCAvLyBmb3IgVFJUIGZ1c2VkIGF0dGVudGlvbiwgcWt2IGFyZSBwYWNrZWQgYW5kIHBhZGRpbmdzIGFyZSByZW1vdmVkXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIEF0dGVudGlvbk1hc2tUeXBlIHtcbiAgbm9uZSwgLy8gTm8gbWFza1xuICBtYXNrMWRLZXlTZXFMZW4sIC8vIFtiYXRjaF9zaXplXSwga2V5IHNlcXVlbmNlIGxlbmd0aFxuICBtYXNrMWRFbmRTdGFydCwgLy8gWzIgKiBiYXRjaF9zaXplXSB3aXRoIGVuZCBwb3NpdGlvbnMgYW5kIHN0YXJ0IHBvc2l0aW9uc1xuICBtYXNrMURLZXlTZXFMZW5TdGFydCwgLy8gWzMgKiBiYXRjaF9zaXplICsgMl0gd2l0aCBba2V5X2xlblswXSwgLi4uLCBrZXlfbGVuW2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfc3RhcnRbMF0sXG4gIC8vIC4uLiwgcXVlcnlfc3RhcnRbYmF0Y2hfc2l6ZSAtIDFdLCBxdWVyeV9lbmRbYmF0Y2hfc2l6ZSAtIDFdLCBrZXlfc3RhcnRbMF0sIC4uLixcbiAgLy8ga2V5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwga2V5X2VuZFtiYXRjaF9zaXplIC0gMV1dXG4gIG1hc2syZER1bW15LCAvLyBkdW1teSBtYXNrIHdpdGggc2hhcGUgWzEsIDFdIG9yIFtiYXRjaF9zaXplLCAxXS4gSXQgaGFzIHNhbWUgZWZmZWN0IGFzIG5vIG1hc2suXG4gIG1hc2syZEtleVBhZGRpbmcsIC8vIFtiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhdXG4gIG1hc2szZEF0dGVudGlvbiwgLy8gW2JhdGNoX3NpemUsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxuICBtYXNrNGRNZWdhdHJvbiwgLy8gTWVnYXRyb24gY2F1c2FsIG1hc2sgd2l0aCBzaGFwZSBbYmF0Y2hfc2l6ZSwgMSwgbWF4X3NlcXVlbmNlX2xlbmd0aCwgbWF4X3NlcXVlbmNlX2xlbmd0aF1cbiAgbWFza1Vua25vd24sXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0ZW50aW9uUGFyYW1ldGVycyB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAga3ZTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICB0b3RhbFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIG1heFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIGlucHV0SGlkZGVuU2l6ZTogbnVtYmVyO1xuICBoaWRkZW5TaXplOiBudW1iZXI7XG4gIHZIaWRkZW5TaXplOiBudW1iZXI7XG4gIGhlYWRTaXplOiBudW1iZXI7XG4gIHZIZWFkU2l6ZTogbnVtYmVyO1xuICBudW1IZWFkczogbnVtYmVyO1xuICBrdk51bUhlYWRzPzogbnVtYmVyO1xuICBuUmVwcz86IG51bWJlcjtcbiAgaXNVbmlkaXJlY3Rpb25hbD86IGJvb2xlYW47XG4gIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGJvb2xlYW47XG4gIG1hc2tGaWx0ZXJWYWx1ZT86IG51bWJlcjtcbiAgbWFza1R5cGU6IEF0dGVudGlvbk1hc2tUeXBlO1xuICBzY2FsZTogbnVtYmVyO1xuICBicm9hZGNhc3RSZXNQb3NCaWFzOiBib29sZWFuO1xuICBwYXNzUGFzdEluS3Y6IGJvb2xlYW47XG4gIHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xuICBzb2Z0Y2FwPzogbnVtYmVyO1xuICBkb1JvdGFyeT86IG51bWJlcjtcbiAgcm90YXJ5SW50ZXJMZWF2ZWQ/OiBudW1iZXI7XG4gIHNvbW1vb3RoU29mdG1heD86IG51bWJlcjtcbiAgbG9jYWxXaW5kb3dzU2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRlbnRpb25BdHRycyB7XG4gIG51bUhlYWRzOiBudW1iZXI7XG4gIGlzVW5pZGlyZWN0aW9uYWw6IG51bWJlcjtcbiAgbWFza0ZpbHRlclZhbHVlOiBudW1iZXI7XG4gIHNjYWxlOiBudW1iZXI7XG4gIGRvUm90YXJ5OiBudW1iZXI7XG4gIHFrdkhpZGRlblNpemVzOiBudW1iZXJbXTtcbiAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogYm9vbGVhbjtcbn1cblxuY29uc3QgdmFsaWRhdGVBdHRlbnRpb25JbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxuXG4gIC8vIFdoZW4gcGFzdCBzdGF0ZSBpcyB1c2VkLCBRLCBLIGFuZCBWIHNob3VsZCBoYXZlIHNhbWUgaGlkZGVuIHNpemUgKHVubGVzcyB3ZSBzcGxpdCBpdCBpbnRvIHBhc3Rfa2V5IGFuZCBwYXN0X3ZhbHVlKS5cblxuICAvLyBJbnB1dCBzaGFwZXM6XG4gIC8vICAgaW5wdXQgICAgICAgIChRL0svVikgICAgOiAoQiwgUywgRF9pKVxuICAvLyAgIHdlaWdodHMgICAgICAoUS9LL1YpICAgIDogKERfaSwgRCArIEQgKyBEX3YpXG4gIC8vICAgYmlhcyAgICAgICAgIChRL0svVikgICAgOiAoRCArIEQgKyBEX3YpXG4gIC8vICAgbWFza19pbmRleCAgICAgICAgICAgICAgOiBzZWUgYmVsb3dcbiAgLy8gICBwYXN0ICAgICAgICAgKEsvVikgICAgICA6ICgyLCBCLCBOLCBQLCBIKSBvciBOVUxMXG4gIC8vICAgYXR0ZW50aW9uX2JpYXMgICAgICAgICAgOiAoQiwgTiwgUywgVCkgb3IgTlVMTFxuXG4gIC8vIEZvciBtYXNrX2luZGV4LCB0aGUgZm9sbG93aW5nIHNoYXBlcyBhcmUgc3VwcG9ydGVkOlxuICAvLyAgICAgTlVMTCwgKEIsIDEpLCAoMSwgMSlcbiAgLy8gICAgIChCKSwgKDIgKiBCKSwgKDMgKiBCICsgMilcbiAgLy8gICAgIChCLCBUKVxuICAvLyAgICAgKEIsIFMsIFQpXG4gIC8vICAgICAoQiwgMSwgTSwgTSlcbiAgLy9cbiAgLy8gV2hlbiBhIG1vZGVsIGlzIHBydW5lZCAobGlrZSBzb21lIGF0dGVudGlvbiBoZWFkcyBhcmUgcmVtb3ZlZCBpbiBRL0svViksIGlucHV0X2hpZGRlbl9zaXplIGNvdWxkIGJlIGxhcmdlclxuICAvLyB0aGFuIGhpZGRlbiBkaW1lbnNpb24gb2YgUSwgSyBhbmQgVi5cblxuICBjb25zdCBpbnB1dCA9IGlucHV0c1swXTtcbiAgY29uc3Qgd2VpZ2h0cyA9IGlucHV0c1sxXTtcbiAgY29uc3QgYmlhcyA9IGlucHV0c1syXTtcbiAgY29uc3QgbWFza0luZGV4ID0gaW5wdXRzWzNdO1xuICBjb25zdCBwYXN0ID0gaW5wdXRzWzRdO1xuICBjb25zdCBhdHRlbnRpb25CaWFzID0gaW5wdXRzWzVdO1xuXG4gIGlmIChwYXN0ICYmIGF0dGVudGlvbkJpYXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzJyk7XG4gIH1cblxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiaW5wdXRcIiBtdXN0IGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dC5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0LmRpbXNbMV07XG4gIGNvbnN0IGlucHV0SGlkZGVuU2l6ZSA9IGlucHV0LmRpbXNbMl07XG5cbiAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAod2VpZ2h0cy5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICh3ZWlnaHRzLmRpbXNbMF0gIT09IGlucHV0SGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgMSBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMiBvZiBpbnB1dCAwJyk7XG4gIH1cblxuICBpZiAoYmlhcy5kaW1zWzBdICE9PSB3ZWlnaHRzLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAxIG9mIGlucHV0IFwid2VpZ2h0c1wiJyk7XG4gIH1cblxuICBsZXQgcUhpZGRlblNpemUgPSBiaWFzLmRpbXNbMF0gLyAzO1xuICBsZXQga0hpZGRlblNpemUgPSBxSGlkZGVuU2l6ZTtcbiAgbGV0IHZIaWRkZW5TaXplID0ga0hpZGRlblNpemU7XG4gIGlmIChhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBhdHRyaWJ1dGUgc2hvdWxkIGhhdmUgMyBlbGVtZW50cycpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN6IG9mIGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMpIHtcbiAgICAgIGlmIChzeiAlIGF0dHJpYnV0ZXMubnVtSGVhZHMgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcUhpZGRlblNpemUgPSBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzWzBdO1xuICAgIGtIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1sxXTtcbiAgICB2SGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMl07XG4gIH1cblxuICBjb25zdCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG5cbiAgaWYgKHFIaWRkZW5TaXplICE9PSBrSGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmQnKTtcbiAgfVxuXG4gIGlmIChiaWFzLmRpbXNbMF0gIT09IHFIaWRkZW5TaXplICsga0hpZGRlblNpemUgKyB2SGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgc3VtIG9mIFEvSy9WIGhpZGRlbiBzaXplcycpO1xuICB9XG5cbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGlmIChwYXN0KSB7XG4gICAgaWYgKGtIaWRkZW5TaXplICE9PSB2SGlkZGVuU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBleHBlY3Qga19oaWRkZW5fc2l6ZSA9PSB2X2hpZGRlbl9zaXplJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1swXSAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaXJzdCBkaW1lbnNpb24gbXVzdCBiZSAyJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbMV0gIT09IGJhdGNoU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHRoaXJkIGRpbWVuc2lvbiBtdXN0IGJlIG51bV9oZWFkcycpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzRdICE9PSBrSGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlmdGggZGltZW5zaW9uIG11c3QgYmUga19oaWRkZW5fc2l6ZSAvIG51bV9oZWFkcycpO1xuICAgIH1cblxuICAgIGlmICghYXR0cmlidXRlcy5wYXN0UHJlc2VudFNoYXJlQnVmZmVyKSB7XG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0LmRpbXNbM107XG4gICAgfVxuICAgIC8vIFRPRE86IGhhbmRsZSBwYXN0X3NlcV9sZW5cbiAgfVxuXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBrdlNlcXVlbmNlTGVuZ3RoICsgcGFzdFNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IC0xO1xuXG4gIGNvbnN0IG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubm9uZTtcbiAgaWYgKG1hc2tJbmRleCkge1xuICAgIC8vIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUuTUFTS19VTktOT1dOO1xuICAgIC8vIFRPRE86IGhhbmRsZSBtYXNrXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXNrIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGlmIChwYXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXN0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGlmIChhdHRlbnRpb25CaWFzKSB7XG4gICAgaWYgKGF0dGVudGlvbkJpYXMuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIG11c3QgaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBzdXBwb3J0IGJyb2FkY2FzdGluZyB0aGUgZmlyc3QgYW5kIHNlY29uZCBkaW1lbnNpb25zIG9mIGF0dGVudGlvbl9iaWFzXG4gICAgaWYgKFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzJdICE9PSBzZXF1ZW5jZUxlbmd0aCB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzNdICE9PSB0b3RhbFNlcXVlbmNlTGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcbiAgICBpbnB1dEhpZGRlblNpemUsXG4gICAgaGlkZGVuU2l6ZTogcUhpZGRlblNpemUsXG4gICAgdkhpZGRlblNpemUsXG4gICAgaGVhZFNpemU6IE1hdGguZmxvb3IocUhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICBudW1IZWFkczogYXR0cmlidXRlcy5udW1IZWFkcyxcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrRmlsdGVyVmFsdWU6IGF0dHJpYnV0ZXMubWFza0ZpbHRlclZhbHVlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXM6IGZhbHNlLFxuICAgIHBhc3NQYXN0SW5LdjogZmFsc2UsXG4gICAgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2Qk5TSCxcbiAgfTtcbn07XG5cbmNvbnN0IGluaXRWYXJTdHViID0gKFxuICBzZXFMZW5zSW5wdXQ6IEluZGljZXNIZWxwZXIgfCB1bmRlZmluZWQsXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dDogSW5kaWNlc0hlbHBlciB8IHVuZGVmaW5lZCxcbiAgaW5pdFBhc3RTZXF1ZW5jZUxlbmd0aDogYm9vbGVhbixcbikgPT4ge1xuICAvLyBJbiB0aGUgY2FzZSBvZiBHUUEsIHJlZGVmaW5lIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggYW5kIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIGJhc2VkIG9uIHNlcWxlbl9rIGlucHV0XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQgJiYgc2VxTGVuc0lucHV0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZ2V0QnlPZmZzZXQoJzAnKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtzZXFMZW5zSW5wdXQ/LmdldEJ5T2Zmc2V0KCdiYXRjaElkeCcpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgJHtpbml0UGFzdFNlcXVlbmNlTGVuZ3RoID8gJ2xldCBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoJyA6ICcnfTtcbiAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgYDtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlSW5QbGFjZVNvZnRtYXhQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxuICBudW1IZWFkczogbnVtYmVyLFxuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4pID0+IHtcbiAgLy8gU2V0IGNvbXBvbmVudHMgdG8gMSBpZiBzZXFMZW5zIGlzIHNwZWNpZmllZCwgaS5lLiBHcm91cFF1ZXJ5QXR0ZW50aW9uLlxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhzZXFMZW5zID8gMSA6IHRvdGFsU2VxdWVuY2VMZW5ndGgpO1xuICBsZXQgV0cgPSA2NDtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aENvbXAgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoIC8gY29tcG9uZW50cztcbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhDb21wIDwgV0cpIHtcbiAgICBXRyA9IDMyO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gTWF0aC5jZWlsKHRvdGFsU2VxdWVuY2VMZW5ndGggLyBjb21wb25lbnRzIC8gV0cpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJhdGNoU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aENvbXAgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWxlbWVudHNQZXJUaHJlYWQgfSxcbiAgXTtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXQuZGF0YVR5cGUsIGNvbXBvbmVudHMpO1xuICBjb25zdCBmMzJUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJ107XG4gIGlmIChzZXFMZW5zKSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dEhlbHBlcnMgPSBbaW5wdXRIZWxwZXJdO1xuICAgIGNvbnN0IHNlcUxlbnNJbnB1dEhlbHBlciA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNlcUxlbnNJbnB1dEhlbHBlcikge1xuICAgICAgaW5wdXRIZWxwZXJzLnB1c2goc2VxTGVuc0lucHV0SGVscGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRcbiAgICAgID8gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0JywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRhdGFUeXBlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGltcylcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIpIHtcbiAgICAgIGlucHV0SGVscGVycy5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dEhlbHBlcik7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1WYWx1ZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGlucHV0LmRhdGFUeXBlKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdiYXRjaF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAndG90YWxfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2VsZW1lbnRzX3Blcl90aHJlYWQnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7V0d9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke1dHfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRIZWxwZXJzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtXRywgMSwgMV0pfVxuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0SGVscGVyLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIsIGZhbHNlKX1cbiAgICBsZXQgbG9jYWxfb2Zmc2V0ID0gbG9jYWxfaWR4ICogdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZDtcbiAgICBsZXQgb2Zmc2V0ID0gKGdsb2JhbF9pZHggLyAke1dHfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHtzZXFMZW5zID8gJ3UzMihwYXN0X3NlcXVlbmNlX2xlbmd0aCArIHdvcmtncm91cF9pZC55ICsgMSknIDogJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aCd9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7ZjMyVHlwZX0oLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzhmKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHtmMzJUeXBlfSh4W29mZnNldCArIGldKSwgdGhyZWFkX21heF92ZWN0b3IpO1xuICAgIH1cbiAgICB0aHJlYWRfbWF4W2xvY2FsX2lkeF0gPSAkeygoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAndGhyZWFkX21heF92ZWN0b3InO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuICdtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSknO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuICdtYXgobWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpLCBtYXgodGhyZWFkX21heF92ZWN0b3IueiwgdGhyZWFkX21heF92ZWN0b3IudykpJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Y29tcG9uZW50c31gKTtcbiAgICAgIH1cbiAgICB9KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgbWF4X3ZhbHVlID0gIGYzMigtMy40MDI4MjM0NjYzODUyODg2ZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7V0d9OyBpKyspIHtcbiAgICAgIG1heF92YWx1ZSA9IG1heCh0aHJlYWRfbWF4W2ldLCBtYXhfdmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBzdW1fdmVjdG9yID0gJHtmMzJUeXBlfSgwKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgc3VtX3ZlY3RvciArPSBleHAoJHtmMzJUeXBlfSh4W29mZnNldCArIGldKSAtIG1heF92YWx1ZSk7XG4gICAgfVxuICAgIHRocmVhZF9zdW1bbG9jYWxfaWR4XSA9ICR7KCgpID0+IHtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yJztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAnc3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55JztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAnc3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55ICsgc3VtX3ZlY3Rvci56ICsgc3VtX3ZlY3Rvci53JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Y29tcG9uZW50c31gKTtcbiAgICAgIH1cbiAgICB9KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgc3VtOiBmMzIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7V0d9OyBpKyspIHtcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oJHtlbGVtVmFsdWVUeXBlfSgxLjApIC8gJHtlbGVtVmFsdWVUeXBlfShzZXFfY2F1c2FsX2xlbmd0aCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZjMyaW5wdXQgPSAke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pO1xuICAgICAgICB4W29mZnNldCArIGldID0gJHtpbnB1dEhlbHBlci50eXBlLnZhbHVlfShleHAoZjMyaW5wdXQgLSBtYXhfdmFsdWUpIC8gc3VtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAke1xuICAgICAgICBzZXFMZW5zXG4gICAgICAgICAgPyBgXG4gICAgICAgIGZvciAodmFyIHRvdGFsX3NlcV9pZDogdTMyID0gc2VxX2NhdXNhbF9sZW5ndGg7IHRvdGFsX3NlcV9pZCArIGxvY2FsX29mZnNldCA8IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgdG90YWxfc2VxX2lkKyspIHtcbiAgICAgICAgICB4W29mZnNldCArIHRvdGFsX3NlcV9pZF0gPSAke2lucHV0SGVscGVyLnR5cGUudmFsdWV9KCR7ZWxlbVZhbHVlVHlwZX0oMCkpO1xuICAgICAgICB9YFxuICAgICAgICAgIDogJydcbiAgICAgIH07XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0F0dGVudGlvblByb2JzU29mdG1heCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7V0d9OyR7ZGF0YVR5cGV9OyR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW10sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IDEsIHk6IHNlcXVlbmNlTGVuZ3RoLCB6OiBiYXRjaFNpemUgKiBudW1IZWFkcyB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlQXR0ZW50aW9uUHJvYnNQcm9ncmFtSW5mbyA9IChcbiAgb3V0cHV0Q291bnQ6IG51bWJlcixcbiAgcTogVGVuc29yVmlldyxcbiAga2V5OiBUZW5zb3JWaWV3LFxuICBwYXN0S2V5OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBhdHRlbnRpb25CaWFzOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgc2VxTGVuczogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuKSA9PiB7XG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IHByb2JzU2hhcGUgPSBbcGFyYW1ldGVycy5iYXRjaFNpemUsIHBhcmFtZXRlcnMubnVtSGVhZHMsIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsIHRvdGFsU2VxdWVuY2VMZW5ndGhdO1xuICBjb25zdCBwcmVzZW50S2V5ID0gb3V0cHV0Q291bnQgPiAxICYmIHBhc3RLZXk7XG4gIGNvbnN0IGt2TnVtSGVhZHMgPSBwYXJhbWV0ZXJzLmt2TnVtSGVhZHMgPyBwYXJhbWV0ZXJzLmt2TnVtSGVhZHMgOiBwYXJhbWV0ZXJzLm51bUhlYWRzO1xuICBjb25zdCBwcmVzZW50S2V5U2hhcGUgPSBwcmVzZW50S2V5XG4gICAgPyBbcGFyYW1ldGVycy5iYXRjaFNpemUsIGt2TnVtSGVhZHMsIHRvdGFsU2VxdWVuY2VMZW5ndGgsIHBhcmFtZXRlcnMuaGVhZFNpemVdXG4gICAgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5SZXBzID0gcGFyYW1ldGVycy5uUmVwcyA/IHBhcmFtZXRlcnMublJlcHMgOiAxO1xuICAvLyBUT0RPOiBoYW5kbGUgbWFza1xuXG4gIGNvbnN0IGFscGhhID0gcGFyYW1ldGVycy5zY2FsZSA9PT0gMCA/IDEuMCAvIE1hdGguc3FydChwYXJhbWV0ZXJzLmhlYWRTaXplKSA6IHBhcmFtZXRlcnMuc2NhbGU7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKHBhcmFtZXRlcnMuaGVhZFNpemUpO1xuICBjb25zdCB2ZWN0b3JpemVkSGVhZFNpemUgPSBwYXJhbWV0ZXJzLmhlYWRTaXplIC8gY29tcG9uZW50cztcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XG4gIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgIHg6IE1hdGguY2VpbCh0b3RhbFNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgejogcGFyYW1ldGVycy5iYXRjaFNpemUgKiBwYXJhbWV0ZXJzLm51bUhlYWRzLFxuICB9O1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdmVjdG9yaXplZEhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHRvdGFsU2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5udW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYWxwaGEgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFzdFNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMua3ZTZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBuUmVwcyB9LFxuICBdO1xuICAvLyBGZWVkIHBhc3RLZXkgdG8gdGhlIHNoYWRlci1jb2RlIG9ubHkgaWYgaXQgaXMgbm9uLXplcm8gYW5kIHByZXNlbnRLZXkgaXMgYmVpbmcgcHJvZHVjZWRcbiAgY29uc3QgZmVlZFBhc3RLZXkgPSBwcmVzZW50S2V5ICYmIHBhc3RLZXkgJiYgU2hhcGVVdGlsLnNpemUocGFzdEtleS5kaW1zKSA+IDA7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcbiAgaWYgKGZlZWRQYXN0S2V5KSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGlmIChhdHRlbnRpb25CaWFzKSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGlmIChzZXFMZW5zKSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0cyA9IFt7IGRpbXM6IHByb2JzU2hhcGUsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XTtcbiAgaWYgKHByZXNlbnRLZXkpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBwcmVzZW50S2V5U2hhcGUhLCBkYXRhVHlwZTogcS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSk7XG4gIH1cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgcUlucHV0ID0gaW5wdXRWYXJpYWJsZSgncScsIHEuZGF0YVR5cGUsIHEuZGltcywgY29tcG9uZW50cyk7XG4gICAgY29uc3Qga0lucHV0ID0gaW5wdXRWYXJpYWJsZSgna2V5Jywga2V5LmRhdGFUeXBlLCBrZXkuZGltcywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3FJbnB1dCwga0lucHV0XTtcbiAgICBpZiAoZmVlZFBhc3RLZXkpIHtcbiAgICAgIGNvbnN0IHBhc3RLZXlJbnB1dCA9IGlucHV0VmFyaWFibGUoJ3Bhc3Rfa2V5JywgcGFzdEtleS5kYXRhVHlwZSwgcGFzdEtleS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgIGlucHV0VmFycy5wdXNoKHBhc3RLZXlJbnB1dCk7XG4gICAgfVxuICAgIGlmIChhdHRlbnRpb25CaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdhdHRlbnRpb25fYmlhcycsIGF0dGVudGlvbkJpYXMuZGF0YVR5cGUsIGF0dGVudGlvbkJpYXMuZGltcykpO1xuICAgIH1cbiAgICBjb25zdCBzZXFMZW5zSW5wdXRWYXJpYWJsZSA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNlcUxlbnNJbnB1dFZhcmlhYmxlKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChzZXFMZW5zSW5wdXRWYXJpYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlID0gdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XG4gICAgICA/IGlucHV0VmFyaWFibGUoJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCcsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kYXRhVHlwZSwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRpbXMpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUpIHtcbiAgICAgIGlucHV0VmFycy5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHEuZGF0YVR5cGUsIHByb2JzU2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dFZhcnMgPSBbb3V0cHV0XTtcbiAgICBpZiAocHJlc2VudEtleSkge1xuICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X2tleScsIHEuZGF0YVR5cGUsIHByZXNlbnRLZXlTaGFwZSEsIGNvbXBvbmVudHMpKTtcbiAgICB9XG4gICAgY29uc3QgZjMyVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hlYWRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgIHsgbmFtZTogJ3Bhc3Rfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2t2X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICduX3JlcHMnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUs6IGFycmF5PCR7cUlucHV0LnR5cGUuc3RvcmFnZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCAuLi5vdXRwdXRWYXJzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtUSUxFX1NJWkUsIFRJTEVfU0laRSwgMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBrdkhlYWRJZHggPSAke25SZXBzID09PSAxID8gJ2hlYWRJZHgnIDogJ2hlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHMnfTtcbiAgICBsZXQga3ZfbnVtX2hlYWRzID0gJHtuUmVwcyA9PT0gMSA/ICd1bmlmb3Jtcy5udW1faGVhZHMnIDogJ3VuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwcyd9O1xuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTjtcbiAgICAke2luaXRWYXJTdHViKHNlcUxlbnNJbnB1dFZhcmlhYmxlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSwgdHJ1ZSl9XG4gICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4O1xuICAgIGxldCBxT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7ZmVlZFBhc3RLZXkgJiYgcHJlc2VudEtleSA/ICdsZXQgcGFzdEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSzsnIDogJyd9O1xuICAgIGxldCBrT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcbiAgICAke3ByZXNlbnRLZXkgPyAnbGV0IHByZXNlbnRLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSzsnIDogJyd9XG4gICAgdmFyIHZhbHVlID0gJHtmMzJUeXBlfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBxW3FPZmZzZXQgKyBsb2NhbF9pZC55ICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcbiAgICAgICR7KCgpID0+IHtcbiAgICAgICAgaWYgKGZlZWRQYXN0S2V5ICYmIHByZXNlbnRLZXkpIHtcbiAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBwYXN0X2tleVtwYXN0S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobiArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aWxlS1tpZHhdID0ga2V5W2tPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICB9YDtcbiAgICAgICAgfVxuICAgICAgfSkoKX1cbiAgICAgICR7XG4gICAgICAgIHByZXNlbnRLZXlcbiAgICAgICAgICA/IGBpZiAobiArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICBwcmVzZW50X2tleVtwcmVzZW50S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF0gPSB0aWxlS1tpZHhdO1xuICAgICAgfWBcbiAgICAgICAgICA6ICcnXG4gICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICAgIHZhbHVlICs9ICR7ZjMyVHlwZX0odGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZUtbVElMRV9TSVpFICogbG9jYWxfaWQueCArIGtdKTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgZ2xvYmFsX2lkLnggPCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgIGxldCBoZWFkT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBoZWFkT2Zmc2V0ICsgZ2xvYmFsX2lkLnkgKiB1bmlmb3Jtcy5OICsgZ2xvYmFsX2lkLng7XG4gICAgICB2YXIgc3VtOiBmMzIgPSAkeygoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAndmFsdWUnO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAndmFsdWUueCArIHZhbHVlLnknO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAndmFsdWUueCArIHZhbHVlLnkgKyB2YWx1ZS56ICsgdmFsdWUudyc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgICB9XG4gICAgICB9KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke291dHB1dC50eXBlLnZhbHVlfSAoc3VtICogdW5pZm9ybXMuYWxwaGEpICsgJHtcbiAgICAgICAgICBhdHRlbnRpb25CaWFzID8gJ2F0dGVudGlvbl9iaWFzW291dHB1dElkeF0nIDogJzAuMCdcbiAgICAgICAgfTtcbiAgICB9XG4gIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdBdHRlbnRpb25Qcm9icycsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7YXR0ZW50aW9uQmlhcyAhPT0gdW5kZWZpbmVkfTske3Bhc3RLZXkgIT09IHVuZGVmaW5lZH07JHtvdXRwdXRDb3VudH1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoeyBvdXRwdXRzLCBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCwgcHJvZ3JhbVVuaWZvcm1zIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVZ4QXR0ZW50aW9uU2NvcmVQcm9ncmFtSW5mbyA9IChcbiAgb3V0cHV0Q291bnQ6IG51bWJlcixcbiAgcHJvYnM6IFRlbnNvclZpZXcsXG4gIHY6IFRlbnNvclZpZXcsXG4gIHBhc3RWYWx1ZTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgc2VxTGVuczogVGVuc29yVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuKSA9PiB7XG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgblJlcHMgPSBwYXJhbXMublJlcHMgPyBwYXJhbXMublJlcHMgOiAxO1xuICBjb25zdCByZXBlYXRlZFZIaWRkZW5TaXplID0gcGFyYW1zLnZIaWRkZW5TaXplICogblJlcHM7XG4gIGNvbnN0IHByZXNlbnRWYWx1ZSA9IG91dHB1dENvdW50ID4gMSAmJiBwYXN0VmFsdWU7XG4gIGNvbnN0IGt2TnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyA/IHBhcmFtcy5rdk51bUhlYWRzIDogcGFyYW1zLm51bUhlYWRzO1xuICBjb25zdCBwcmVzZW50VmFsdWVTaGFwZSA9IHByZXNlbnRWYWx1ZVxuICAgID8gW3BhcmFtcy5iYXRjaFNpemUsIGt2TnVtSGVhZHMsIHRvdGFsU2VxdWVuY2VMZW5ndGgsIHBhcmFtcy5oZWFkU2l6ZV1cbiAgICA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLCByZXBlYXRlZFZIaWRkZW5TaXplXTtcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XG4gIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgIHg6IE1hdGguY2VpbChwYXJhbXMudkhlYWRTaXplIC8gVElMRV9TSVpFKSxcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1zLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICB6OiBwYXJhbXMuYmF0Y2hTaXplICogcGFyYW1zLm51bUhlYWRzLFxuICB9O1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHRvdGFsU2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnZIZWFkU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMubnVtSGVhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLmhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHJlcGVhdGVkVkhpZGRlblNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFzdFNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5SZXBzIH0sXG4gIF07XG4gIC8vIEZlZWQgcGFzdFZhbHVlIHRvIHRoZSBzaGFkZXItY29kZSBvbmx5IGlmIGl0IGlzIG5vbi1lbXB0eSBhbmQgcHJlc2VudFZhbHVlIGlzIGJlaW5nIHByb2R1Y2VkXG4gIGNvbnN0IGZlZWRQYXN0VmFsdWUgPSBwcmVzZW50VmFsdWUgJiYgcGFzdFZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSA+IDA7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcbiAgaWYgKGZlZWRQYXN0VmFsdWUpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKHNlcUxlbnMpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCkge1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgfVxuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBwcm9icy5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfV07XG4gIGlmIChwcmVzZW50VmFsdWUpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBwcmVzZW50VmFsdWVTaGFwZSEsIGRhdGFUeXBlOiBwcm9icy5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSk7XG4gIH1cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgcHJvYnNIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdwcm9icycsIHByb2JzLmRhdGFUeXBlLCBwcm9icy5kaW1zKTtcbiAgICBjb25zdCB2SGVscGVyID0gaW5wdXRWYXJpYWJsZSgndicsIHYuZGF0YVR5cGUsIHYuZGltcyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3Byb2JzSGVscGVyLCB2SGVscGVyXTtcbiAgICBpZiAoZmVlZFBhc3RWYWx1ZSkge1xuICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgncGFzdF92YWx1ZScsIHBhc3RWYWx1ZS5kYXRhVHlwZSwgcGFzdFZhbHVlLmRpbXMpKTtcbiAgICB9XG4gICAgY29uc3Qgc2VxTGVuc0lucHV0VmFyaWFibGUgPSBzZXFMZW5zID8gaW5wdXRWYXJpYWJsZSgnc2VxX2xlbnMnLCBzZXFMZW5zLmRhdGFUeXBlLCBzZXFMZW5zLmRpbXMpIDogdW5kZWZpbmVkO1xuICAgIGlmIChzZXFMZW5zKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChzZXFMZW5zSW5wdXRWYXJpYWJsZSEpO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSA9IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFxuICAgICAgPyBpbnB1dFZhcmlhYmxlKCd0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQnLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGF0YVR5cGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kaW1zKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCkge1xuICAgICAgaW5wdXRWYXJzLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUhKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHByb2JzLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xuICAgIGlmIChwcmVzZW50VmFsdWUpIHtcbiAgICAgIG91dHB1dFZhcnMucHVzaChvdXRwdXRWYXJpYWJsZSgncHJlc2VudF92YWx1ZScsIHByb2JzLmRhdGFUeXBlLCBwcmVzZW50VmFsdWVTaGFwZSEpKTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hlYWRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICd2X2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3Bhc3Rfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2t2X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICduX3JlcHMnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7cHJvYnNIZWxwZXIudHlwZS52YWx1ZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVWOiBhcnJheTwke3Byb2JzSGVscGVyLnR5cGUudmFsdWV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgLi4ub3V0cHV0VmFycyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbVElMRV9TSVpFLCBUSUxFX1NJWkUsIDFdKX1cbiAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBrdkhlYWRJZHggPSAke25SZXBzID09PSAxID8gJ2hlYWRJZHgnIDogJ2hlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHMnfTtcbiAgIGxldCBrdl9udW1faGVhZHMgPSAke25SZXBzID09PSAxID8gJ3VuaWZvcm1zLm51bV9oZWFkcycgOiAndW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzJ307XG4gICBsZXQgbSA9IGdsb2JhbF9pZC55O1xuICAgbGV0IG4gPSBnbG9iYWxfaWQueDtcbiAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xuICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLks7XG4gICAke2luaXRWYXJTdHViKHNlcUxlbnNJbnB1dFZhcmlhYmxlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSwgdHJ1ZSl9XG4gICBsZXQgb2Zmc2V0QSA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKyBtICogdW5pZm9ybXMuSztcbiAgIGxldCBhYnNLdkhlYWRJZHggPSBiYXRjaElkeCAqIGt2X251bV9oZWFkcyArIGt2SGVhZElkeDsgLy8ga3ZIZWFkSWR4IGlzIHJlbGF0aXZlIHRvIHRoZSBiYXRjaFxuICAgJHtmZWVkUGFzdFZhbHVlICYmIHByZXNlbnRWYWx1ZSA/ICdsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjsnIDogJyd9O1xuICAgbGV0IHZPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICsgbjtcbiAgICR7cHJlc2VudFZhbHVlID8gJ2xldCBwcmVzZW50VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47JyA6ICcnfVxuICAgdmFyIHZhbHVlID0gJHtwcm9ic0hlbHBlci50eXBlLnN0b3JhZ2V9KDApO1xuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICBpZiAoZmVlZFBhc3RWYWx1ZSAmJiBwcmVzZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2UgaWYgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgICAgIH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX1cbiAgICAgICAgJHtcbiAgICAgICAgICBwcmVzZW50VmFsdWVcbiAgICAgICAgICAgID8gYFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICBwcmVzZW50X3ZhbHVlW3ByZXNlbnRWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXSA9IHRpbGVWW2lkeF07XG4gICAgICAgIH1gXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IGsrKykge1xuICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVWW1RJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54XTtcbiAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICB9XG5cbiAgIC8vIHdlIG5lZWQgdG8gdHJhbnNwb3NlIG91dHB1dCBmcm9tIEJOU0hfdiB0byBCU05EX3ZcbiAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICBsZXQgb3V0cHV0SWR4ID0gYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZSArIG0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplXG4gICAgICAgKyBoZWFkSWR4ICogdW5pZm9ybXMuTiArIG47XG4gICAgIG91dHB1dFtvdXRwdXRJZHhdID0gdmFsdWU7XG4gICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0F0dGVudGlvblNjb3JlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtwYXN0VmFsdWUgIT09IHVuZGVmaW5lZH07JHtvdXRwdXRDb3VudH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7IG91dHB1dHMsIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLCBwcm9ncmFtVW5pZm9ybXMgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGFwcGx5QXR0ZW50aW9uID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgcTogVGVuc29yVmlldyxcbiAgazogVGVuc29yVmlldyxcbiAgdjogVGVuc29yVmlldyxcbiAgX21hc2tJbmRleDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgX3Bhc3Q6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhc3RLZXk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhc3RWYWx1ZTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgYXR0ZW50aW9uQmlhc0lucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4pID0+IHtcbiAgLy8gQXNzdW1wdGlvbiBpcyB0aGF0IHByZXNlbnRLZXkvcHJlc2VudFZhbHVlIGV4aXN0cyBvbmx5IGlmIHBhc3RLZXkvcGFzdFZhbHVlIGV4aXN0cy5cbiAgY29uc3Qgb3V0cHV0Q291bnQgPSBNYXRoLm1pbihjb250ZXh0Lm91dHB1dENvdW50LCAxICsgKHBhc3RLZXkgPyAxIDogMCkgKyAocGFzdFZhbHVlID8gMSA6IDApKTtcbiAgY29uc3QgcGFzdFNlcXVlbmNlTGVuZ3RoID0gb3V0cHV0Q291bnQgPiAxID8gcGFyYW1ldGVycy5wYXN0U2VxdWVuY2VMZW5ndGggOiAwO1xuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsgcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBhdHRlbnRpb25CaWFzID1cbiAgICBhdHRlbnRpb25CaWFzSW5wdXQgJiYgU2hhcGVVdGlsLnNpemUoYXR0ZW50aW9uQmlhc0lucHV0LmRpbXMpID4gMCA/IGF0dGVudGlvbkJpYXNJbnB1dCA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBpbnB1dHNLID0gW3EsIGtdO1xuICBpZiAob3V0cHV0Q291bnQgPiAxICYmIHBhc3RLZXkgJiYgU2hhcGVVdGlsLnNpemUocGFzdEtleS5kaW1zKSA+IDApIHtcbiAgICBpbnB1dHNLLnB1c2gocGFzdEtleSk7XG4gIH1cbiAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICBpbnB1dHNLLnB1c2goYXR0ZW50aW9uQmlhcyk7XG4gIH1cbiAgaWYgKHNlcUxlbnMpIHtcbiAgICBpbnB1dHNLLnB1c2goc2VxTGVucyk7XG4gIH1cbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCkge1xuICAgIGlucHV0c0sucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpO1xuICB9XG4gIC8vIFJ1biBBdHRlbnRpb25Qcm9ic1xuICBjb25zdCBwcm9icyA9IGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVBdHRlbnRpb25Qcm9ic1Byb2dyYW1JbmZvKFxuICAgICAgb3V0cHV0Q291bnQsXG4gICAgICBxLFxuICAgICAgayxcbiAgICAgIHBhc3RLZXksXG4gICAgICBhdHRlbnRpb25CaWFzLFxuICAgICAgcGFyYW1ldGVycyxcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcbiAgICAgIHNlcUxlbnMsXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXG4gICAgKSxcbiAgICB7IGlucHV0czogaW5wdXRzSywgb3V0cHV0czogb3V0cHV0Q291bnQgPiAxID8gWy0xLCAxXSA6IFstMV0gfSxcbiAgKVswXTtcblxuICAvLyBSdW4gU29mdG1heFxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlSW5QbGFjZVNvZnRtYXhQcm9ncmFtSW5mbyhcbiAgICAgIHByb2JzLFxuICAgICAgcGFyYW1ldGVycy5iYXRjaFNpemUsXG4gICAgICBwYXJhbWV0ZXJzLm51bUhlYWRzLFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgICAgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCxcbiAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgsXG4gICAgICBzZXFMZW5zLFxuICAgICAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LFxuICAgICksXG4gICAgeyBpbnB1dHM6IHNlcUxlbnMgJiYgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0ID8gW3Byb2JzLCBzZXFMZW5zLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRdIDogW3Byb2JzXSwgb3V0cHV0czogW10gfSxcbiAgKTtcblxuICAvLyBSdW4gQXR0ZW50aW9uU2NvcmVcbiAgY29uc3QgaW5wdXRzViA9IFtwcm9icywgdl07XG4gIGlmIChvdXRwdXRDb3VudCA+IDEgJiYgcGFzdFZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSA+IDApIHtcbiAgICBpbnB1dHNWLnB1c2gocGFzdFZhbHVlKTtcbiAgfVxuICBpZiAoc2VxTGVucykge1xuICAgIGlucHV0c1YucHVzaChzZXFMZW5zKTtcbiAgfVxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XG4gICAgaW5wdXRzVi5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCk7XG4gIH1cbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZVZ4QXR0ZW50aW9uU2NvcmVQcm9ncmFtSW5mbyhcbiAgICAgIG91dHB1dENvdW50LFxuICAgICAgcHJvYnMsXG4gICAgICB2LFxuICAgICAgcGFzdFZhbHVlLFxuICAgICAgcGFyYW1ldGVycyxcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcbiAgICAgIHNlcUxlbnMsXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXG4gICAgKSxcbiAgICB7XG4gICAgICBpbnB1dHM6IGlucHV0c1YsXG4gICAgICBvdXRwdXRzOiBvdXRwdXRDb3VudCA+IDEgPyBbMCwgMl0gOiBbMF0sXG4gICAgfSxcbiAgKTtcbn07XG5cbmNvbnN0IHByZXBhcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMpID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1ldGVycy5iYXRjaFNpemUsIHBhcmFtZXRlcnMubnVtSGVhZHMsIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsIHBhcmFtZXRlcnMuaGVhZFNpemVdO1xuICBjb25zdCBNID0gcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgSyA9IHBhcmFtZXRlcnMuaW5wdXRIaWRkZW5TaXplO1xuICBjb25zdCBOID0gcGFyYW1ldGVycy5oZWFkU2l6ZTtcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XG4gIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgIHg6IE1hdGguY2VpbChwYXJhbWV0ZXJzLmhlYWRTaXplIC8gVElMRV9TSVpFKSxcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgejogcGFyYW1ldGVycy5iYXRjaFNpemUgKiBwYXJhbWV0ZXJzLm51bUhlYWRzLFxuICB9O1xuICBjb25zdCBpbnB1dHMgPSBbY29udGV4dC5pbnB1dHNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLCBjb250ZXh0LmlucHV0c1syXV07XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBLIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE4gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5udW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGlkZGVuU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLnZIaWRkZW5TaXplIH0sXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0USA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfcScsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dEsgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X2snLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRWID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF92JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMpO1xuICAgIGNvbnN0IHdlaWdodCA9IGlucHV0VmFyaWFibGUoJ3dlaWdodCcsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcyk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnN0b3JhZ2U7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGVhZF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2xkYicsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSW5wdXQ6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRLOiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFY6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCB3ZWlnaHQsIGJpYXMsIG91dHB1dFEsIG91dHB1dEssIG91dHB1dFYpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1RJTEVfU0laRSwgVElMRV9TSVpFLCAxXSl9XG4gICAgbGV0IGJhdGNoSW5kZXggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICAgbGV0IG4gPSBnbG9iYWxfaWQueDtcblxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJhdGNoSW5kZXggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XG4gICAgbGV0IGJpYXNPZmZzZXRRID0gaGVhZE51bWJlciAqIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICBsZXQgYmlhc09mZnNldEsgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRRO1xuICAgIGxldCBiaWFzT2Zmc2V0ViA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldEs7XG5cbiAgICB2YXIgdmFsdWVRID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgdmFyIHZhbHVlSyA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke2RhdGFUeXBlfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVJbnB1dFtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBpbnB1dFtpbnB1dE9mZnNldCArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IG4gKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMubGRiO1xuICAgICAgICB0aWxlV2VpZ2h0UVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFEgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0S1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldEsgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0VltUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFYgKyBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8VElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICBsZXQgaW5wdXRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGs7XG4gICAgICAgIGxldCB3ZWlnaHRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogayArIGxvY2FsX2lkLng7XG4gICAgICAgIHZhbHVlUSArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRRW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZUsgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0S1t3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVWICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFZbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBsZXQgaGVhZE9mZnNldCA9IChtICogdW5pZm9ybXMuTiArIG4pICUgdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIHZhbHVlUSArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0UV07XG4gICAgdmFsdWVLICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRLXTtcbiAgICB2YWx1ZVYgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFZdO1xuXG4gICAgbGV0IG9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gb2Zmc2V0ICsgbSAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICAgb3V0cHV0X3Fbb3V0cHV0SWR4XSA9IHZhbHVlUTtcbiAgICAgIG91dHB1dF9rW291dHB1dElkeF0gPSB2YWx1ZUs7XG4gICAgICBvdXRwdXRfdltvdXRwdXRJZHhdID0gdmFsdWVWO1xuICAgIH1cbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnQXR0ZW50aW9uUHJlcGFyZScsXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnLCAndHlwZSddIH0sXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9LFxuICAgICAgICAgIHsgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSxcbiAgICAgICAgICB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzLCBvdXRwdXRzOiBbLTEsIC0xLCAtMV0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlQXR0ZW50aW9uSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcblxuICBjb25zdCBbcSwgaywgdl0gPSBwcmVwYXJlKGNvbnRleHQsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIGFwcGx5QXR0ZW50aW9uKFxuICAgIGNvbnRleHQsXG4gICAgcSxcbiAgICBrLFxuICAgIHYsXG4gICAgY29udGV4dC5pbnB1dHNbNF0sXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgY29udGV4dC5pbnB1dHNbNV0sXG4gICAgcGFyYW1zLFxuICApO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoTm9ybUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBlcHNpbG9uOiBudW1iZXI7XG4gIHJlYWRvbmx5IG1vbWVudHVtOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNwYXRpYWw6IGJvb2xlYW47XG4gIHJlYWRvbmx5IHRyYWluaW5nTW9kZTogYm9vbGVhbjtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0cycpO1xuICB9XG5cbiAgY29uc3QgY2hlY2tTaGFwZUVxdWFsID0gKGFjdHVhbDogcmVhZG9ubHkgbnVtYmVyW10sIGV4cGVjdGVkOiByZWFkb25seSBudW1iZXJbXSwgbWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgciA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBpZiAociAhPT0gYWN0dWFsLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9OiBudW0gZGltZW5zaW9ucyAhPSAke3J9YCk7XG4gICAgfVxuICAgIGV4cGVjdGVkLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIGlmICh2ICE9PSBhY3R1YWxbaV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9OiBkaW1bJHtpfV0gZG8gbm90IG1hdGNoYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzaGFwZSA9XG4gICAgICBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnXG4gICAgICAgID8gYXR0cmlidXRlcy5zcGF0aWFsXG4gICAgICAgICAgPyBpbnB1dHNbMF0uZGltcy5zbGljZSgtMSlcbiAgICAgICAgICA6IGlucHV0c1swXS5kaW1zLnNsaWNlKC0xKS5jb25jYXQoaW5wdXRzWzBdLmRpbXMuc2xpY2UoMSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMSkpXG4gICAgICAgIDogaW5wdXRzWzBdLmRpbXMuc2xpY2UoMSwgYXR0cmlidXRlcy5zcGF0aWFsID8gMiA6IHVuZGVmaW5lZCk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgc2NhbGUnKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzJdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBCJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1szXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgbWVhbicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IHZhcicpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMV0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBzY2FsZScpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBCJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1szXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IG1lYW4nKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzRdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgdmFyJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQmF0Y2hOb3JtQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgeyBlcHNpbG9uLCBzcGF0aWFsLCBmb3JtYXQgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IHlTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBjb21wb25lbnRzID0gc3BhdGlhbCA/IGdldE1heENvbXBvbmVudHMoeVNoYXBlW3lTaGFwZS5sZW5ndGggLSAxXSkgOiAxO1xuICBjb25zdCBjQ29tcG9uZW50cyA9IGZvcm1hdCA9PT0gJ05IV0MnICYmIHlTaGFwZS5sZW5ndGggPiAxID8gY29tcG9uZW50cyA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZSh5U2hhcGUpIC8gY29tcG9uZW50cztcbiAgLy8gT25seSBzdXBwb3J0IHVuaWZvcm1zIGZvciBvcHNldCB2ZXJzaW9uID49IDkgKHNwYXRpYWwgPSB0cnVlKS5cbiAgY29uc3QgdXNlU2hhcGVzVW5pZm9ybXMgPSBzcGF0aWFsO1xuICBjb25zdCBzaGFwZU9yUmFuayA9IHVzZVNoYXBlc1VuaWZvcm1zID8geVNoYXBlLmxlbmd0aCA6IHlTaGFwZTtcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKTtcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLCBjQ29tcG9uZW50cyk7XG4gIGNvbnN0IGlucHV0TWVhbiA9IGlucHV0VmFyaWFibGUoJ2lucHV0TWVhbicsIGlucHV0c1szXS5kYXRhVHlwZSwgaW5wdXRzWzNdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgY29uc3QgaW5wdXRWYXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dFZhcicsIGlucHV0c1s0XS5kYXRhVHlwZSwgaW5wdXRzWzRdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgY29uc3QgeSA9IG91dHB1dFZhcmlhYmxlKCd5JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBzaGFwZU9yUmFuaywgY29tcG9uZW50cyk7XG4gIC8vIFRPRE86IHN1cHBvcnQgaW5wdXRzIHdpdGggZGlmZmVyZW50IGRhdGEgdHlwZS4gQ3VycmVudCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgaW5wdXRzIGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlxuICAvLyBPdGhlcndpc2UsIHRoZSBzaGFkZXIgY29tcGlsYXRpb24gd2lsbCBmYWlsLlxuICBjb25zdCBjYWxjQ09mZnNldCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgIGxldCBjT2Zmc2V0ID0gJyc7XG4gICAgaWYgKHNwYXRpYWwpIHtcbiAgICAgIGNPZmZzZXQgPSBgbGV0IGNPZmZzZXQgPSAke1xuICAgICAgICB5U2hhcGUubGVuZ3RoID09PSAxXG4gICAgICAgICAgPyAnMHUnXG4gICAgICAgICAgOiBmb3JtYXQgPT09ICdOSFdDJ1xuICAgICAgICAgICAgPyBgb3V0cHV0SW5kaWNlc1ske3lTaGFwZS5sZW5ndGggLSAxfV0gLyAke2NvbXBvbmVudHN9YFxuICAgICAgICAgICAgOiAnb3V0cHV0SW5kaWNlc1sxXSdcbiAgICAgIH07YDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gJ05DSFcnKSB7XG4gICAgICAgIGNPZmZzZXQgPSBgXG4gICAgICAgICAgICAke3kuaW5kaWNlc1NldCgnb3V0cHV0SW5kaWNlcycsICcwJywgJzAnKX1cbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHt5LmluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycpfTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIEMgY2hhbm5lbC5cbiAgICAgICAgY09mZnNldCA9IGB2YXIgY0luZGljZXMgPSAke3NjYWxlLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGNJbmRpY2VzWzBdID0gb3V0cHV0SW5kaWNlc1ske3lTaGFwZS5sZW5ndGggLSAxfV07YDtcbiAgICAgICAgLy8gdXBkYXRlIEQxIHggLi4uIHggRG4gY2hhbm5lbHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2NhbGUucmFuazsgaSsrKSB7XG4gICAgICAgICAgY09mZnNldCArPSBgY0luZGljZXNbJHtpfV0gPSBvdXRwdXRJbmRpY2VzWyR7aX1dO2A7XG4gICAgICAgIH1cbiAgICAgICAgY09mZnNldCArPSBgbGV0IGNPZmZzZXQgPSAke3NjYWxlLmluZGljZXNUb09mZnNldCgnY0luZGljZXMnKX07YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNPZmZzZXQ7XG4gIH07XG4gIGNvbnN0IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UgPSAoaGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgY29uc3QgZXBzaWxvbiA9ICR7ZXBzaWxvbn07XG4gICR7aGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHgsIHNjYWxlLCBiaWFzLCBpbnB1dE1lYW4sIGlucHV0VmFyLCB5KX1cbiAgJHtoZWxwZXIubWFpblN0YXJ0KCl9XG4gICR7aGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9YCl9O1xuICAgICR7Y2FsY0NPZmZzZXQoKX1cbiAgICBsZXQgc2NhbGUgPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBiaWFzID0gJHtiaWFzLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke2lucHV0TWVhbi5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke2lucHV0VmFyLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCB4ID0gJHt4LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHt5LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XG4gIH1gO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCYXRjaE5vcm1hbGl6YXRpb24nLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmVwc2lsb259XyR7YXR0cmlidXRlcy5mb3JtYXR9XyR7c3BhdGlhbH1fJHtjb21wb25lbnRzfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogdXNlU2hhcGVzVW5pZm9ybXMgPyBbJ3JhbmsnLCAndHlwZScsICd0eXBlJywgJ3R5cGUnLCAndHlwZSddIDogdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlOiBnZXRJbmZlcmVuY2VNb2RlU2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBpbnB1dHNbMF0uZGltcywgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogdXNlU2hhcGVzVW5pZm9ybXNcbiAgICAgICAgPyBbeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoeVNoYXBlKV1cbiAgICAgICAgOiBbeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfV0sXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VCYXRjaE5vcm1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQmF0Y2hOb3JtQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PEJhdGNoTm9ybUF0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xuXG5leHBvcnQgY29uc3QgYmF0Y2hOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQgPT4ge1xuICBjb25zdCB7IGlucHV0cywgb3V0cHV0Q291bnQgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gcGFyc2VCYXRjaE5vcm1BdHRyaWJ1dGVzKHsgLi4uYXR0cmlidXRlcywgb3V0cHV0Q291bnQgfSk7XG4gIGlmIChlbnYud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50KSB7XG4gICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyk7XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMudHJhaW5pbmdNb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaE5vcm1hbGl6YXRpb24gdHJhaW5pbmdNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCYXRjaE5vcm1JbmZlcmVuY2VQcm9ncmFtSW5mbyhpbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoIVszMjAsIDY0MCwgMTI4MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODAnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1syXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmlhc0FkZFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuXG4gIGNvbnN0IGNoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbMl07XG4gIC8vIHNpbmNlIGNoYW5uZWwgbnVtYmVyIGNhbiBiZSBvbmx5IDMyMC82NDAvMTI4MCwgaXQncyBhbHdheXMgZGl2aXNpYmxlIGJ5IDRcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGRhdGFUeXBlLCBbY2hhbm5lbHNdLCA0KTtcbiAgY29uc3QgcmVzaWR1YWwgPSBpbnB1dFZhcmlhYmxlKCdyZXNpZHVhbCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICBjb25zdCBjaGFubmVscyA9ICR7Y2hhbm5lbHN9dSAvIDQ7XG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGJpYXMsIHJlc2lkdWFsLCBvdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAgbGV0IHZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfVxuICAgICAgKyAke2JpYXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHggJSBjaGFubmVscycpfSArICR7cmVzaWR1YWwuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQmlhc0FkZCcsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBiaWFzQWRkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJpYXNBZGRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLFxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG50eXBlIEJ1aWx0aW5GdW5jdGlvbk5hbWUgPSBzdHJpbmc7XG50eXBlIEVsZW1lbnR3aXNlQ3VzdG9tRXhwcmVzc2lvbiA9IChleHByZXNzaW9uOiBzdHJpbmcpID0+IHN0cmluZztcbnR5cGUgRWxlbWVudHdpc2VGdW5jdGlvbkNhbGwgPSBCdWlsdGluRnVuY3Rpb25OYW1lIHwgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uO1xuXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1TaGFkZXIgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBkYXRhc2l6ZTogbnVtYmVyLFxuICBpbnB1dERhdGFUeXBlOiBudW1iZXIsXG4gIG91dHB1dERhdGFUeXBlOiBudW1iZXIsXG4gIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCxcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlPzogVW5pZm9ybXNBcnJheVR5cGUsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKGRhdGFzaXplIC8gNCk7XG5cbiAgbGV0IGV4cHJlc3Npb24gPSAnJztcbiAgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ3N0cmluZycpIHtcbiAgICBleHByZXNzaW9uID0gYCR7ZnVuY0NhbGx9KGEpYDtcbiAgfSBlbHNlIHtcbiAgICBleHByZXNzaW9uID0gZnVuY0NhbGwoJ2EnKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXREYXRhJywgaW5wdXREYXRhVHlwZSwgW3ZlY1NpemVdLCA0KTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dERhdGEnLCBvdXRwdXREYXRhVHlwZSwgW3ZlY1NpemVdLCA0KTtcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW3sgbmFtZTogJ3ZlY19zaXplJywgdHlwZTogJ3UzMicgfV07XG4gIGlmIChhZGRpdGlvbmFsVW5pZm9ybXNUeXBlKSB7XG4gICAgdW5pZm9ybXMucHVzaCguLi5hZGRpdGlvbmFsVW5pZm9ybXNUeXBlKTtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuXG4gICR7YWRkaXRpb25hbEltcGxlbWVudGF0aW9uID8/ICcnfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XG5cbiAgICBsZXQgYSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBleHByZXNzaW9uKX1cbiAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvID0gKFxuICBpbnB1dDogVGVuc29yVmlldyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdW5jQ2FsbDogRWxlbWVudHdpc2VGdW5jdGlvbkNhbGwsXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXG4gIG91dHB1dERhdGFUeXBlOiBudW1iZXIgPSBpbnB1dC5kYXRhVHlwZSxcbiAgYWRkaXRpb25hbFVuaWZvcm1zPzogUHJvZ3JhbVVuaWZvcm1bXSxcbiAgYWRkaXRpb25hbFVuaWZvcm1zVHlwZT86IFVuaWZvcm1zQXJyYXlUeXBlLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSAvIDQpIH0sXG4gIF07XG4gIGlmIChhZGRpdGlvbmFsVW5pZm9ybXMpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5hZGRpdGlvbmFsVW5pZm9ybXMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ10gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1TaGFkZXIoXG4gICAgICAgIHNoYWRlckhlbHBlcixcbiAgICAgICAgU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcyksXG4gICAgICAgIGlucHV0LmRhdGFUeXBlLFxuICAgICAgICBvdXRwdXREYXRhVHlwZSxcbiAgICAgICAgZnVuY0NhbGwsXG4gICAgICAgIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbixcbiAgICAgICAgYWRkaXRpb25hbFVuaWZvcm1zVHlwZSxcbiAgICAgICksXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0VGVuc29ycykgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0LmRpbXMsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHtcbiAgICAgICAgeDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0VGVuc29yc1swXS5kaW1zKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiB2ZWMgc2l6ZSAqLyksXG4gICAgICB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGFicyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FicycsICdhYnMnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYWNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Fjb3MnLCAnYWNvcycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Fjb3NoJywgJ2Fjb3NoJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFzaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBc2luJywgJ2FzaW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXNpbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBc2luaCcsICdhc2luaCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdGFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbicsICdhdGFuJykpO1xufTtcbmV4cG9ydCBjb25zdCBhdGFuaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0F0YW5oJywgJ2F0YW5oJykpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDYXN0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHRvOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNhdHVyYXRlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQ2FzdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDYXN0QXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyB7IHRvOiBudW1iZXIgfSk7XG5cbmV4cG9ydCBjb25zdCBjYXN0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDYXN0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBsZXQgZnVuYzogRWxlbWVudHdpc2VGdW5jdGlvbkNhbGw7XG4gIHN3aXRjaCAoYXR0cmlidXRlcy50bykge1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcbiAgICAgIGZ1bmMgPSAndmVjNDxmMTY+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICBmdW5jID0gJ3ZlYzQ8ZjMyPic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQzMjpcbiAgICAgIGZ1bmMgPSAndmVjNDx1MzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICBmdW5jID0gJ3ZlYzQ8aTMyPic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICBmdW5jID0gJ3ZlYzQ8Ym9vbD4nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgJ3RvJyBmcm9tICdDYXN0JyBvcGVyYXRvcik6ICR7YXR0cmlidXRlcy50b31gKTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nhc3QnLCBmdW5jLCB1bmRlZmluZWQsIGF0dHJpYnV0ZXMuY2FjaGVLZXksIGF0dHJpYnV0ZXMudG8pLFxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGlwQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG1pbjogbnVtYmVyO1xuICByZWFkb25seSBtYXg6IG51bWJlcjtcbn1cblxuY29uc3QgZ2VuZXJhdGVDbGlwQXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBDbGlwQXR0cmlidXRlcyA9PiB7XG4gIGxldCBtaW46IG51bWJlcjtcbiAgbGV0IG1heDogbnVtYmVyO1xuICBjb25zdCBoYXNNaW4gPSBpbnB1dHMubGVuZ3RoID49IDIgJiYgaW5wdXRzWzFdLmRhdGEgIT09IDA7XG4gIGNvbnN0IGhhc01heCA9IGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YSAhPT0gMDtcblxuICBzd2l0Y2ggKGlucHV0c1swXS5kYXRhVHlwZSkge1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICBtaW4gPSBoYXNNaW4gPyBpbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAtMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuICAgICAgbWF4ID0gaGFzTWF4ID8gaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdIDogMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgbWluID0gaGFzTWluID8gaW5wdXRzWzFdLmdldFVpbnQxNkFycmF5KClbMF0gOiA2NDUxMTsgLy8gdWludDE2KDY0NTExKSA8LT4gZmxvYXQxNigtNjU1MDQuMClcbiAgICAgIG1heCA9IGhhc01heCA/IGlucHV0c1syXS5nZXRVaW50MTZBcnJheSgpWzBdIDogMzE3NDM7IC8vIHVpbnQxNigzMTc0MykgPC0+IGZsb2F0MTYoNjU1MDQuMClcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydCBkYXRhIHR5cGUnKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBtaW4sIG1heCB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjbGlwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBjbGlwQXR0cmlidXRlczogQ2xpcEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGNsaXBBdHRyaWJ1dGVzID8gY2xpcEF0dHJpYnV0ZXMgOiBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnQ2xpcCcsXG4gICAgICAoYSkgPT4gYGNsYW1wKCR7YX0sIHZlYzQ8JHtkYXRhVHlwZX0+KHVuaWZvcm1zLm1pbiksIHZlYzQ8JHtkYXRhVHlwZX0+KHVuaWZvcm1zLm1heCkpYCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBbXG4gICAgICAgIHsgdHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGRhdGE6IGF0dHJpYnV0ZXMubWluIH0sXG4gICAgICAgIHsgdHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGRhdGE6IGF0dHJpYnV0ZXMubWF4IH0sXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICB7IG5hbWU6ICdtaW4nLCB0eXBlOiBkYXRhVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlIH0sXG4gICAgICAgIHsgbmFtZTogJ21heCcsIHR5cGU6IGRhdGFUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgIF0sXG4gICAgKSxcbiAgICB7IGlucHV0czogWzBdIH0sXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY2VpbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NlaWwnLCAnY2VpbCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb3MgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdDb3MnLCAnY29zJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvc2ggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdDb3NoJywgJ2Nvc2gnKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFscGhhQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUFscGhhQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEFscGhhQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyB7IGFscGhhOiBudW1iZXIgfSk7XG5cbmV4cG9ydCBjb25zdCBlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ0VsdScsXG4gICAgICAoYSkgPT4gYGVsdV92ZjMyKCR7YX0pYCxcbiAgICAgIGBcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtkYXRhVHlwZX0pIC0+ICR7ZGF0YVR5cGV9IHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtkYXRhVHlwZX0+KSAtPiB2ZWM0PCR7ZGF0YVR5cGV9PiB7XG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XG4gIH1gLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGVyZkltcGwgPSAodmFyVHlwZSA9ICdmMzInKSA9PiBgXG5jb25zdCByMDogJHt2YXJUeXBlfSA9IDAuMzI3NTkxMTtcbmNvbnN0IHIxOiAke3ZhclR5cGV9ID0gMC4yNTQ4Mjk1OTI7XG5jb25zdCByMjogJHt2YXJUeXBlfSA9IC0wLjI4NDQ5NjczNjtcbmNvbnN0IHIzOiAke3ZhclR5cGV9ID0gMS40MjE0MTM3NDE7XG5jb25zdCByNDogJHt2YXJUeXBlfSA9IC0xLjQ1MzE1MjAyNztcbmNvbnN0IHI1OiAke3ZhclR5cGV9ID0gMS4wNjE0MDU0Mjk7XG5cbmZuIGVyZl92ZjMyKHY6IHZlYzQ8JHt2YXJUeXBlfT4pIC0+IHZlYzQ8JHt2YXJUeXBlfT4ge1xuICBsZXQgYWJzdiA9IGFicyh2KTtcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XG59YDtcblxuZXhwb3J0IGNvbnN0IGVyZiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0VyZicsIChhKSA9PiBgZXJmX3ZmMzIoJHthfSlgLCBlcmZJbXBsKGRhdGFUeXBlKSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGV4cCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0V4cCcsICdleHAnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZmxvb3IgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdGbG9vcicsICdmbG9vcicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnR2VsdScsXG4gICAgICAoYSkgPT4gYDAuNSAqICR7YX0gKiAoMS4wICsgZXJmX3ZmMzIoJHthfSAqIDAuNzA3MTA2NzgxMTg2NTQ3NSkpYCxcbiAgICAgIGVyZkltcGwoZGF0YVR5cGUpLFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVha3lSZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBbHBoYUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdMZWFreVJlbHUnLFxuICAgICAgKGEpID0+IGBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke2F9LCAke2F9LCAke2F9ID49IHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCkpYCxcbiAgICAgIGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5hbHBoYX0pO2AsXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3Qgbm90ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTm90JywgKGEpID0+IGAhJHthfWApKTtcbn07XG5cbmV4cG9ydCBjb25zdCBuZWcgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdOZWcnLCAoYSkgPT4gYC0ke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlY2lwcm9jYWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdSZWNpcHJvY2FsJywgKGEpID0+IGAxLjAvJHthfWApKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnUmVsdScsXG4gICAgICAoYSkgPT4gYHNlbGVjdCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCAke2F9LCAke2F9ID4gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgLFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2lnbW9pZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpZ21vaWQnLCAoYSkgPT4gYCgxLjAgLyAoMS4wICsgZXhwKC0ke2F9KSkpYCkpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhbHBoYTogbnVtYmVyO1xuICByZWFkb25seSBiZXRhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUhhcmRTaWdtb2lkQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEhhcmRTaWdtb2lkQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoXG4gICAgYXR0cmlidXRlcyBhcyB7XG4gICAgICBhbHBoYTogbnVtYmVyO1xuICAgICAgYmV0YTogbnVtYmVyO1xuICAgIH0sXG4gICk7XG5cbmV4cG9ydCBjb25zdCBoYXJkU2lnbW9pZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogSGFyZFNpZ21vaWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnSGFyZFNpZ21vaWQnLFxuICAgICAgKGEpID0+XG4gICAgICAgIGBtYXgodmVjNDwke2RhdGFUeXBlfT4oMC4wKSwgbWluKHZlYzQ8JHtkYXRhVHlwZX0+KDEuMCksICR7YXR0cmlidXRlcy5hbHBoYX0gKiAke2F9ICsgdmVjNDwke2RhdGFUeXBlfT4oJHthdHRyaWJ1dGVzLmJldGF9KSkpYCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTaW4nLCAnc2luJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTaW5oJywgJ3NpbmgnKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc3FydCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NxcnQnLCAnc3FydCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdUYW4nLCAndGFuJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRhbmhFeHByZXNzaW9uID0gKGE6IHN0cmluZykgPT4gYHNpZ24oJHthfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2F9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHthfSkpKWA7XG5cbmV4cG9ydCBjb25zdCB0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IHJldmlzaXQgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2dwdXdlYi9ncHV3ZWIvaXNzdWVzLzQ0NTggaXMgcmVzb2x2ZWRcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdUYW5oJywgdGFuaEV4cHJlc3Npb24pKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmYXN0R2VsdUltcGwgPSAodmFyVHlwZSA9ICdmMzInKSA9PiBgXG5jb25zdCBmYXN0X2dlbHVfYTogJHt2YXJUeXBlfSA9IDAuNTtcbmNvbnN0IGZhc3RfZ2VsdV9iOiAke3ZhclR5cGV9ID0gMC43OTc4ODQ1NjA4MDI4NjU0O1xuY29uc3QgZmFzdF9nZWx1X2M6ICR7dmFyVHlwZX0gPSAwLjAzNTY3NzQwODEzNjMwMDEyNTtcblxuZm4gdGFuaF92KHY6IHZlYzQ8JHt2YXJUeXBlfT4pIC0+IHZlYzQ8JHt2YXJUeXBlfT4ge1xuICByZXR1cm4gJHt0YW5oRXhwcmVzc2lvbigndicpfTtcbn1cbmA7XG5cbmV4cG9ydCBjb25zdCBmYXN0R2VsdUV4cHJlc3Npb24gPSAoeDogc3RyaW5nKSA9PlxuICBgKGZhc3RfZ2VsdV9hICsgZmFzdF9nZWx1X2EgKiB0YW5oX3YoJHt4fSAqIChmYXN0X2dlbHVfYyAqICR7eH0gKiAke3h9ICsgZmFzdF9nZWx1X2IpKSkgKiAke3h9YDtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnRmFzdEdlbHUnLFxuICAgICAgZmFzdEdlbHVFeHByZXNzaW9uLFxuICAgICAgZmFzdEdlbHVJbXBsKGRhdGFUeXBlKSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgdGhyZXNob2xkZWRSZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBbHBoYUF0dHJpYnV0ZXMpOiBudW1iZXIgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ1RocmVzaG9sZGVkUmVsdScsXG4gICAgICAoYSkgPT4gYHNlbGVjdCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCAke2F9LCAke2F9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxcbiAgICAgIGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtkYXRhVHlwZX0+KCR7YXR0cmlidXRlcy5hbHBoYX0pO2AsXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICksXG4gICk7XG4gIHJldHVybiAwO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0xvZycsICdsb2cnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcXVpY2tHZWx1SW1wbCA9ICh2YXJUeXBlOiBzdHJpbmcsIGFscGhhOiBudW1iZXIpID0+IGBcbmNvbnN0IGFscGhhID0gdmVjNDwke3ZhclR5cGV9Pigke2FscGhhfSk7XG5jb25zdCBvbmUgPSAke3ZhclR5cGV9KDEuMCk7XG5jb25zdCB6ZXJvID0gJHt2YXJUeXBlfSgwLjApO1xuXG5mbiBxdWlja19nZWx1X2ltcGwoeDogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIGxldCB2ID0geCAqYWxwaGE7XG4gIHZhciB4MSA6IHZlYzQ8JHt2YXJUeXBlfT47XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSA9IGkgKyAxKSB7XG4gICAgaWYgKHZbaV0gPj0gemVybykge1xuICAgICAgeDFbaV0gPSBvbmUgLyAob25lICsgZXhwKC12W2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxW2ldID0gb25lIC0gb25lIC8gKG9uZSArIGV4cCh2W2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4ICogeDE7XG59XG5gO1xuXG5leHBvcnQgY29uc3QgcXVpY2tHZWx1RXhwcmVzc2lvbiA9ICh4OiBzdHJpbmcpID0+IGBxdWlja19nZWx1X2ltcGwoJHt4fSlgO1xuXG5leHBvcnQgY29uc3QgcXVpY2tnZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBbHBoYUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZFR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdRdWlja0dlbHUnLFxuICAgICAgcXVpY2tHZWx1RXhwcmVzc2lvbixcbiAgICAgIHF1aWNrR2VsdUltcGwoZFR5cGUsIGF0dHJpYnV0ZXMuYWxwaGEpLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICksXG4gICk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IGVyZkltcGwgfSBmcm9tICcuL3VuYXJ5LW9wJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoIVsyNTYwLCA1MTIwLCAxMDI0MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDAnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1syXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmlhc1NwbGl0R2VsdVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIG91dHB1dFNoYXBlWzJdID0gb3V0cHV0U2hhcGVbMl0gLyAyO1xuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCA0KTtcbiAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIFtpbnB1dHNbMF0uZGltc1syXV0sIDQpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7aW5wdXRzWzBdLmRpbXNbMl0gLyA0IC8gMn11O1xuXG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGJpYXMsIG91dHB1dCl9XG5cbiAgJHtlcmZJbXBsKGRhdGFUeXBlKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcbiAgICBsZXQgYmF0Y2hJbmRleCA9IGdsb2JhbF9pZHggLyBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xuICAgIGxldCB2YWx1ZVJpZ2h0ID0gaW5wdXRbaW5wdXRPZmZzZXQgKyBoYWxmQ2hhbm5lbHNdICsgYmlhc1tiaWFzSWR4ICsgaGFsZkNoYW5uZWxzXTtcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcblxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlTGVmdCAqIGdlbHVSaWdodCcpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCaWFzU3BsaXRHZWx1JyxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGJpYXNTcGxpdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmlhc1NwbGl0R2VsdVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbiA9IChleHByZXNzaW9uQTogc3RyaW5nLCBleHByZXNzaW9uQjogc3RyaW5nKSA9PiBzdHJpbmc7XG50eXBlIEJpbmFyeUZ1bmN0aW9uQ2FsbCA9XG4gIHwgQnVpbHRpbkZ1bmN0aW9uTmFtZVxuICB8IEJpbmFyeUN1c3RvbUV4cHJlc3Npb25cbiAgfCB7XG4gICAgICBzY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gICAgICB2ZWN0b3I6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gICAgfTtcblxuY29uc3QgY3JlYXRlQmluYXJ5T3BQcm9ncmFtU2hhZGVyID0gKFxuICBzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcixcbiAgZGltc0E6IHJlYWRvbmx5IG51bWJlcltdLFxuICBkaW1zQjogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbXNPdXRwdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxuICB2ZWN0b3JpemU6IGJvb2xlYW4sXG4gIGRvQnJvYWRjYXN0OiBib29sZWFuLFxuICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQ6IGJvb2xlYW4sXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gIHR5cGVBOiBudW1iZXIsXG4gIHR5cGVCOiBudW1iZXIsXG4gIHR5cGVPdXRwdXQ6IG51bWJlcixcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuKSA9PiB7XG4gIGxldCBleHByZXNzaW9uU2NhbGFyOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xuICBsZXQgZXhwcmVzc2lvblZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ3N0cmluZycpIHtcbiAgICBleHByZXNzaW9uU2NhbGFyID0gZXhwcmVzc2lvblZlY3RvciA9IChhLCBiKSA9PiBgJHtmdW5jQ2FsbH0oKCR7YX0pLCgke2J9KSlgO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gZnVuY0NhbGw7XG4gIH0gZWxzZSB7XG4gICAgZXhwcmVzc2lvblNjYWxhciA9IGZ1bmNDYWxsLnNjYWxhcjtcbiAgICBleHByZXNzaW9uVmVjdG9yID0gZnVuY0NhbGwudmVjdG9yO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dERhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XG4gIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhRGF0YScsIHR5cGVBLCBkaW1zQS5sZW5ndGgsIDQpO1xuICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYkRhdGEnLCB0eXBlQiwgZGltc0IubGVuZ3RoLCA0KTtcblxuICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICBpZiAodmVjdG9yaXplKSB7XG4gICAgaWYgKGRvQnJvYWRjYXN0KSB7XG4gICAgICBjb25zdCBpc0FPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoZGltc0EpID09PSAxO1xuICAgICAgY29uc3QgaXNCT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGRpbXNCKSA9PT0gMTtcbiAgICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gZGltc0EubGVuZ3RoID4gMCAmJiBkaW1zQVtkaW1zQS5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICBjb25zdCBiTGFzdERpbURpdmlzaWJsZUJ5NCA9IGRpbXNCLmxlbmd0aCA+IDAgJiYgZGltc0JbZGltc0IubGVuZ3RoIC0gMV0gJSA0ID09PSAwO1xuICAgICAgaWYgKGlzQU9uZUVsZW1lbnQgfHwgaXNCT25lRWxlbWVudCkge1xuICAgICAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICdnbG9iYWxfaWR4JyxcbiAgICAgICAgICBleHByZXNzaW9uVmVjdG9yKFxuICAgICAgICAgICAgaXNBT25lRWxlbWVudCA/IGAke2EudHlwZS52YWx1ZX0oJHthLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSxcbiAgICAgICAgICAgIGlzQk9uZUVsZW1lbnQgPyBgJHtiLnR5cGUudmFsdWV9KCR7Yi5nZXRCeU9mZnNldCgnMCcpfS54KWAgOiBiLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCAqIDR1Jyl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEgPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJywgb3V0cHV0KX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICAgICAgICBleHByZXNzaW9uVmVjdG9yKFxuICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBhTGFzdERpbURpdmlzaWJsZUJ5NFxuICAgICAgICAgICAgICAgICAgPyBhLmdldEJ5T2Zmc2V0KCdvZmZzZXRBIC8gNHUnKVxuICAgICAgICAgICAgICAgICAgOiBgJHthLnR5cGUudmFsdWV9KCR7YS5nZXRCeU9mZnNldCgnb2Zmc2V0QSAvIDR1Jyl9W29mZnNldEEgJSA0dV0pYCxcbiAgICAgICAgICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgfHwgYkxhc3REaW1EaXZpc2libGVCeTRcbiAgICAgICAgICAgICAgICAgID8gYi5nZXRCeU9mZnNldCgnb2Zmc2V0QiAvIDR1JylcbiAgICAgICAgICAgICAgICAgIDogYCR7Yi50eXBlLnZhbHVlfSgke2IuZ2V0QnlPZmZzZXQoJ29mZnNldEIgLyA0dScpfVtvZmZzZXRCICUgNHVdKWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApfVxuICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICdnbG9iYWxfaWR4JyxcbiAgICAgICAgZXhwcmVzc2lvblZlY3RvcihhLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksIGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSksXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWRvQnJvYWRjYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4ge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkEgPSBgYURhdGFbaW5kZXhBJHt4fV1bY29tcG9uZW50QSR7eH1dYDtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25CID0gYGJEYXRhW2luZGV4QiR7eH1dW2NvbXBvbmVudEIke3h9XWA7XG4gICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke3h9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHt4fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHt4fSA9ICR7Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBpbmRleEEke3h9ID0gb2Zmc2V0QSR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleEIke3h9ID0gb2Zmc2V0QiR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHt4fSA9IG9mZnNldEEke3h9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7eH0gPSBvZmZzZXRCJHt4fSAlIDR1O1xuICAgICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtleHByZXNzaW9uU2NhbGFyKGV4cHJlc3Npb25BLCBleHByZXNzaW9uQil9KTtcbiAgICAgICAgICBgO1xuICAgIH07XG4gICAgaWYgKHR5cGVPdXRwdXQgPT09IERhdGFUeXBlLmJvb2wpIHtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDAsICd1MzInKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDIsICd1MzInKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDMsICd1MzInKX1cbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDApfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMSl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAyKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDMpfVxuICAgICAgICAgIGA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGEsIGIsIG91dHB1dCl9XG5cbiAgICAgICAgJHthZGRpdGlvbmFsSW1wbGVtZW50YXRpb24gPz8gJyd9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XG4gICAgICAgICR7YXNzaWdubWVudH1cbiAgICAgIH1gO1xufTtcblxuY29uc3QgY3JlYXRlQmluYXJ5T3BQcm9ncmFtSW5mbyA9IChcbiAgbmFtZTogc3RyaW5nLFxuICBjYWNoZUtleTogc3RyaW5nLFxuICBhOiBUZW5zb3JWaWV3LFxuICBiOiBUZW5zb3JWaWV3LFxuICBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4gIG91dHB1dERhdGFUeXBlOiBudW1iZXIgPSBhLmRhdGFUeXBlLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBhRGltcyA9IGEuZGltcy5tYXAoTnVtYmVyKTtcbiAgY29uc3QgYkRpbXMgPSBiLmRpbXMubWFwKE51bWJlcik7XG4gIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChhRGltcywgYkRpbXMpO1xuICBsZXQgb3V0cHV0U2hhcGUgPSBhRGltcztcbiAgbGV0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhRGltcyk7XG5cbiAgbGV0IHZlY3Rvcml6ZSA9IGZhbHNlO1xuICBsZXQgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0ID0gZmFsc2U7XG5cbiAgLy8gVE9ETzogZGVhbCB3aXRoIHplcm8tc2l6ZWQgdGVuc29ycyAoZWcuIGRpbXM9WzEsMF0pXG4gIGNvbnN0IGNhY2hlS2V5QXV4ID0gW2lzQnJvYWRjYXN0XTtcbiAgaWYgKGlzQnJvYWRjYXN0KSB7XG4gICAgY29uc3QgY2FsY3VsYXRlZFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoYURpbXMsIGJEaW1zLCBmYWxzZSk7XG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICAgIH1cbiAgICBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZWRTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgY29uc3QgaXNBT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGFEaW1zKSA9PT0gMTtcbiAgICBjb25zdCBpc0JPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoYkRpbXMpID09PSAxO1xuICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gYURpbXMubGVuZ3RoID4gMCAmJiBhRGltc1thRGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgY29uc3QgYkxhc3REaW1EaXZpc2libGVCeTQgPSBiRGltcy5sZW5ndGggPiAwICYmIGJEaW1zW2JEaW1zLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICBjYWNoZUtleUF1eC5wdXNoKGlzQU9uZUVsZW1lbnQpO1xuICAgIGNhY2hlS2V5QXV4LnB1c2goaXNCT25lRWxlbWVudCk7XG4gICAgY2FjaGVLZXlBdXgucHVzaChhTGFzdERpbURpdmlzaWJsZUJ5NCk7XG4gICAgY2FjaGVLZXlBdXgucHVzaChiTGFzdERpbURpdmlzaWJsZUJ5NCk7XG4gICAgLy8gY2hlY2sgd2hldGhlciB2ZWN0b3JpemUgY2FuIGJlIGVuYWJsZWRcbiAgICBsZXQgc2hhcmVkRGltZW5zaW9uID0gMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaW1BID0gYURpbXNbYURpbXMubGVuZ3RoIC0gaV07XG4gICAgICBjb25zdCBkaW1CID0gYkRpbXNbYkRpbXMubGVuZ3RoIC0gaV07XG4gICAgICBpZiAoZGltQSA9PT0gZGltQikge1xuICAgICAgICBzaGFyZWREaW1lbnNpb24gKj0gZGltQTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hhcmVkRGltZW5zaW9uICUgNCA9PT0gMCkge1xuICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0ID0gdHJ1ZTtcbiAgICAgIHZlY3Rvcml6ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0FPbmVFbGVtZW50IHx8IGlzQk9uZUVsZW1lbnQgfHwgYUxhc3REaW1EaXZpc2libGVCeTQgfHwgYkxhc3REaW1EaXZpc2libGVCeTQpIHtcbiAgICAgIHZlY3Rvcml6ZSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGVsZW1lbnQtd2lzZVxuICAgIHZlY3Rvcml6ZSA9IHRydWU7XG4gIH1cbiAgY2FjaGVLZXlBdXgucHVzaCh2ZWN0b3JpemUpO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogY2FjaGVLZXkgKyBjYWNoZUtleUF1eC5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSkuam9pbignXycpLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICBjcmVhdGVCaW5hcnlPcFByb2dyYW1TaGFkZXIoXG4gICAgICAgIHNoYWRlckhlbHBlcixcbiAgICAgICAgYURpbXMsXG4gICAgICAgIGJEaW1zLFxuICAgICAgICBvdXRwdXRTaGFwZSxcbiAgICAgICAgdmVjdG9yaXplLFxuICAgICAgICBpc0Jyb2FkY2FzdCxcbiAgICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0LFxuICAgICAgICBmdW5jQ2FsbCxcbiAgICAgICAgYS5kYXRhVHlwZSxcbiAgICAgICAgYi5kYXRhVHlwZSxcbiAgICAgICAgb3V0cHV0RGF0YVR5cGUsXG4gICAgICAgIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbixcbiAgICAgICksXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIGNvbXBvbmVudCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNCkgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYURpbXMsIGJEaW1zLCBvdXRwdXRTaGFwZSksXG4gICAgICBdLFxuICAgIH0pLFxuICB9O1xufTtcblxuY29uc3QgcnVuQmluYXJ5T3AgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXG4gIG91dHB1dERhdGFUeXBlPzogbnVtYmVyLFxuKTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvKFxuICAgICAgbmFtZSxcbiAgICAgIGNhY2hlS2V5ID8/ICcnLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICBjb250ZXh0LmlucHV0c1sxXSxcbiAgICAgIGZ1bmNDYWxsLFxuICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgb3V0cHV0RGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0FkZCcsIChhLCBiKSA9PiBgJHthfSske2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZGl2ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKGNvbnRleHQsICdEaXYnLCAoYSwgYikgPT4gYCR7YX0vJHtifWApO1xufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0VxdWFsJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT09JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX09PSR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtdWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ011bCcsIChhLCBiKSA9PiBgJHthfSoke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgcG93ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IHR5cGUgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBjb250ZXh0LmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO1xuICBjb25zdCByb3VuZFN0ciA9IHR5cGUgPT09ICdpMzInID8gJ3JvdW5kJyA6ICcnO1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdQb3cnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHBvd19jdXN0b20oJHthfSwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7Yn0pYCB9LFxuICAgIGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R5cGV9LCBiIDogJHt0eXBlfSkgLT4gJHt0eXBlfSB7XG4gICAgICBpZiAoYiA9PSAke3R5cGV9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dHlwZX0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dHlwZX0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dHlwZX0oMi4wKSkpICE9IDEuMCkgKiAke3R5cGV9KCR7cm91bmRTdHJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R5cGV9PiwgYiA6IHZlYzQ8JHt0eXBlfT4pIC0+IHZlYzQ8JHt0eXBlfT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R5cGV9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdWIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ1N1YicsIChhLCBiKSA9PiBgJHthfS0ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdHcmVhdGVyJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT4ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT4ke2J9KWAgfSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIERhdGFUeXBlLmJvb2wsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVzcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdMZXNzJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfTwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfTwke2J9KWAgfSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIERhdGFUeXBlLmJvb2wsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlck9yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgY29udGV4dCxcbiAgICAnR3JlYXRlck9yRXF1YWwnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9Pj0ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT49JHtifSlgIH0sXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBEYXRhVHlwZS5ib29sLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlc3NPckVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0xlc3NPckVxdWFsJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfTw9JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08PSR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmNhdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgcmVmZXJlbmNlSW5kZXggPSAwO1xuICBjb25zdCByZWZlcmVuY2VJbnB1dCA9IGlucHV0c1tyZWZlcmVuY2VJbmRleF07XG4gIGNvbnN0IGlucHV0VHlwZSA9IHJlZmVyZW5jZUlucHV0LmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSByZWZlcmVuY2VJbnB1dC5kaW1zLmxlbmd0aDtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IHJlZmVyZW5jZUluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBvZiBhbGwgaW5wdXRzIG1hdGNoXG4gICAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkaW1lbnNpb25hbGl0eSBvZiBhbGwgaW5wdXRzIGFyZSB0aGUgc2FtZVxuICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gaW5wdXRSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gICAgaW5wdXQuZGltcy5mb3JFYWNoKChkaW0sIGkpID0+IHtcbiAgICAgIGlmIChpICE9PSBheGlzICYmIGRpbSAhPT0gcmVmZXJlbmNlSW5wdXQuZGltc1tpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHNpemVJbkNvbmNhdEF4aXNTdHI6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtudW1iZXJPZlRlbnNvcnN9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc307IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcbiAgfWA7XG5cbmNvbnN0IGFzc2lnbk91dHB1dERhdGEgPSAoaW5wdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10sIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICBjb25zdCBudW1iZXJPZlRlbnNvcnMgPSBpbnB1dHMubGVuZ3RoO1xuXG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dHNbaV0uZ2V0QnlJbmRpY2VzKCdpbmRpY2VzJykpO1xuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYWRqdXN0ZWRBeGlzOiBudW1iZXIsXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbiAgZGF0YVR5cGU6IERhdGFUeXBlLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXRWYXJzID0gbmV3IEFycmF5PEluZGljZXNIZWxwZXI+KGlucHV0cy5sZW5ndGgpO1xuXG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gW107XG4gIGNvbnN0IGlucHV0UmFua3MgPSBbXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgIHByZXZpb3VzU3VtICs9IGlucHV0c1tpXS5kaW1zW2FkanVzdGVkQXhpc107XG4gICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgIGlucHV0UmFua3MucHVzaChpbnB1dHNbaV0uZGltcy5sZW5ndGgpO1xuICAgIGlucHV0VmFyc1tpXSA9IGlucHV0VmFyaWFibGUoYGlucHV0JHtpfWAsIGRhdGFUeXBlLCBpbnB1dFJhbmtzW2ldKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJbkNvbmNhdEF4aXNbaV0gfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbaV0uZGltcykpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBpbmRpY2VzQXhpcyA9IG91dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYWRqdXN0ZWRBeGlzKTtcbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpc1N0ciA9IEFycmF5LmZyb20oQXJyYXkoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgpLmtleXMoKSlcbiAgICAubWFwKChpKSA9PiBgdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7aX1gKVxuICAgIC5qb2luKCcsJyk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuXG4gICR7KCgpID0+IHtcbiAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtpfWAsICd1MzInKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KTtcbiAgfSkoKX1cblxuICAke2NhbGN1bGF0ZUlucHV0SW5kZXhJbXBsKHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoLCBzaXplSW5Db25jYXRBeGlzU3RyKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke2luZGljZXNBeGlzfSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke3NpemVJbkNvbmNhdEF4aXMubGVuZ3RofXU+KCR7c2l6ZUluQ29uY2F0QXhpc1N0cn0pO1xuICAgICAgJHtpbmRpY2VzQXhpc30gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7YXNzaWduT3V0cHV0RGF0YShpbnB1dFZhcnMsIG91dHB1dCl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbmNhdCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YWRqdXN0ZWRBeGlzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY29uY2F0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb25jYXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGFkanVzdGVkQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGFkanVzdGVkQXhpcyk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICBvdXRwdXRTaGFwZVthZGp1c3RlZEF4aXNdID0gaW5wdXRzLnJlZHVjZShcbiAgICAoc3VtLCBpbnB1dCkgPT4gc3VtICsgKGlucHV0LmRpbXMubGVuZ3RoID4gYWRqdXN0ZWRBeGlzID8gaW5wdXQuZGltc1thZGp1c3RlZEF4aXNdIDogMCksXG4gICAgMCxcbiAgKTtcbiAgLy8gMCBsZW5ndGggdGVuc29ycyBhcmUgdmFsaWQgZm9yIGNvbmNhdCwgcmVtb3ZlIHRoZW1cbiAgY29uc3Qgbm9uRW1wdHlJbnB1dHMgPSBpbnB1dHMuZmlsdGVyKChpbnB1dCkgPT4gU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcykgPiAwKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKG5vbkVtcHR5SW5wdXRzLCBhZGp1c3RlZEF4aXMsIG91dHB1dFNoYXBlLCBpbnB1dHNbMF0uZGF0YVR5cGUpLCB7XG4gICAgaW5wdXRzOiBub25FbXB0eUlucHV0cyxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb25jYXRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29uY2F0QXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IE1BWF9DTElQLCBNSU5fQ0xJUCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGFscGhhPzogbnVtYmVyO1xuICByZWFkb25seSBiZXRhPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZhdGlvblNuaXBwZXQgPSAoXG4gIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIHZhbHVlVHlwZTogc3RyaW5nLFxuICBiYXNlVHlwZSA9ICdmMzInLFxuKTogc3RyaW5nID0+IHtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24pIHtcbiAgICBjYXNlICdSZWx1JzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgodmFsdWUsICR7dmFsdWVUeXBlfSgwLjApKTtgO1xuICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgcmV0dXJuIGB2YWx1ZSA9ICgke3ZhbHVlVHlwZX0oMS4wKSAvICgke3ZhbHVlVHlwZX0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtcbiAgICBjYXNlICdDbGlwJzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt2YWx1ZVR5cGV9KCR7YmFzZVR5cGV9KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dmFsdWVUeXBlfSgke1xuICAgICAgICBiYXNlVHlwZVxuICAgICAgfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO1xuICAgIGNhc2UgJ0hhcmRTaWdtb2lkJzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgoJHt2YWx1ZVR5cGV9KDAuMCksIG1pbigke3ZhbHVlVHlwZX0oMS4wKSwgJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUgKyAke1xuICAgICAgICBiYXNlVHlwZVxuICAgICAgfSh1bmlmb3Jtcy5iZXRhKSkpO2A7XG4gICAgY2FzZSAnTGVha3lSZWx1JzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBzZWxlY3QoJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUsIHZhbHVlLCB2YWx1ZSA+PSAke3ZhbHVlVHlwZX0oMC4wKSk7YDtcbiAgICBjYXNlICdUYW5oJzpcbiAgICAgIHJldHVybiBgbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO1xuICAgIGNhc2UgJyc6XG4gICAgICByZXR1cm4gJyc7XG4gICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHthdHRyaWJ1dGVzLmFjdGl2YXRpb259YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhID0gKFxuICBhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICBwcm9ncmFtVW5pZm9ybTogUHJvZ3JhbVVuaWZvcm1bXSxcbikgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWF4ISB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWluISB9LFxuICAgICk7XG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEhIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEhIH0sXG4gICAgKTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm0ucHVzaCh7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmFscGhhISB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyA9IChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpID0+IHtcbiAgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdjbGlwX21heCcsIHR5cGU6ICdmMzInIH0sIHsgbmFtZTogJ2NsaXBfbWluJywgdHlwZTogJ2YzMicgfSk7XG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0sIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZjMyJyB9KTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzID0gKFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCxcbik6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb24gYXMgc3RyaW5nKSB8fCAnJztcbiAgaWYgKGFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICBjb25zdCBbYWxwaGEsIGJldGFdID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0pIHx8IFswLjIsIDAuNV07XG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgYWxwaGEsIGJldGEgfTtcbiAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICBjb25zdCBbY2xpcE1pbiwgY2xpcE1heF0gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlciwgbnVtYmVyXSkgfHwgW01JTl9DTElQLCBNQVhfQ0xJUF07XG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgY2xpcE1heCwgY2xpcE1pbiB9O1xuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgY29uc3QgW2FscGhhXSA9IChhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyXSkgfHwgWzAuMDFdO1xuICAgIHJldHVybiB7IGFjdGl2YXRpb24sIGFscGhhIH07XG4gIH1cbiAgcmV0dXJuIHsgYWN0aXZhdGlvbiB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvYWN0aXZhdGlvbl91dGlsLnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5leHBvcnQgY29uc3QgdHlwZVNuaXBwZXQgPSAoY29tcG9uZW50OiBudW1iZXIsIGRhdGFUeXBlOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoIChjb21wb25lbnQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZGF0YVR5cGU7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGB2ZWMzPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGB2ZWM0PCR7ZGF0YVR5cGV9PmA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb21wb25lbnR9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NuaXBwZXQgPSAoaGFzQmlhczogYm9vbGVhbik6IHN0cmluZyA9PiBgXG4gICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpOycgOiAnJ31cbiAgICAgIGA7XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtY29yZS9zcmMvb3BzL2NvbnZfdXRpbC50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuZXhwb3J0IGNvbnN0IHV0aWxGdW5jdGlvbnMgPSAoc3RyaWRlU3RyOiBzdHJpbmcpID0+IGBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke3N0cmlkZVN0cn0ueCksIGkzMigke3N0cmlkZVN0cn0ueSksIGkzMigke3N0cmlkZVN0cn0ueiksIDEpKTtcbn1cbmA7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0RWxlbWVudEF0LFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFZhcmlhYmxlLFxuICBpbnRlcm5hbFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsXG4gIGdldEFjdGl2YXRpb25TbmlwcGV0LFxuICBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxufSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuXG4vLyBIZWxwZXIgdGhhdCBjb252ZXJ0IG91dHB1dCBiYXRjaCBpbmRpY2VzIHRvIGlucHV0IGJhdGNoIGluZGljZXMgdXNpbmcgb25seSB0aGUgcmFuayBhbmRcbi8vIHRoZSBzaGFwZSBpbmZvcm1hdGlvbiBpbiB1bmlmb3JtXG5leHBvcnQgY29uc3QgY29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMgPSAoXG4gIHRhcmdldEluZGljZXNOYW1lOiBzdHJpbmcsXG4gIGlucHV0VmFyaWFibGU6IEluZGljZXNIZWxwZXIsXG4gIGlucHV0QmF0Y2hSYW5rOiBudW1iZXIsXG4gIG91dHB1dEJhdGNoUmFuazogbnVtYmVyLFxuICBiYXRjaEluZGljZXNOYW1lOiBzdHJpbmcsXG4pID0+IHtcbiAgLy8gQXNzdW1lIG91dHB1dEJhdGNoUmFuayA+PSBpbnB1dEJhdGNoUmFuaywgdGhlIGZpcnN0IG91dHB1dEJhdGNoUmFuayAtIGlucHV0QmF0Y2hSYW5rIG9mXG4gIC8vIG91dHB1dEJhdGNoUmFuayBzaG91bGQgYmUgaWdub3JlZC5cbiAgY29uc3QgZXh0ZW5kaW5nSW5wdXRSYW5rID0gb3V0cHV0QmF0Y2hSYW5rIC0gaW5wdXRCYXRjaFJhbms7XG4gIHJldHVybiBgXG4gICAgICAke0FycmF5LmZyb20oeyBsZW5ndGg6IGlucHV0QmF0Y2hSYW5rIH0pXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKF8sIGkpID0+IGBcbiAgICAgIGlmICgke2dldEVsZW1lbnRBdChpbnB1dFZhcmlhYmxlLnNoYXBlLCBpLCBpbnB1dFZhcmlhYmxlLnJhbmspfSAhPSAxKSB7XG4gICAgICAgICR7aW5wdXRWYXJpYWJsZS5pbmRpY2VzU2V0KHRhcmdldEluZGljZXNOYW1lLCBpLCBnZXRFbGVtZW50QXQoYmF0Y2hJbmRpY2VzTmFtZSwgaSArIGV4dGVuZGluZ0lucHV0UmFuaywgb3V0cHV0QmF0Y2hSYW5rKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke2lucHV0VmFyaWFibGUuaW5kaWNlc1NldCh0YXJnZXRJbmRpY2VzTmFtZSwgaSwgMCl9XG4gICAgICB9YCxcbiAgICAgICAgKVxuICAgICAgICAuam9pbignJyl9XG5gO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICByZXNoYXBlZE91dHB1dFNoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGlzQ2hhbm5lbHNMYXN0ID0gZmFsc2UgLyogb25seSB1c2VkIGZvciBjb252MmRCeU1hdE11bCovLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG5cbiAgY29uc3QgTSA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMl07XG4gIGNvbnN0IE4gPSBiU2hhcGVbYlNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBLID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoTik7XG4gIGNvbnN0IGFDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhLKTtcbiAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZ2V0TWF4Q29tcG9uZW50cyhNKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgY29uc3Qgb3V0ZXJEaW1zID0gcmVzaGFwZWRPdXRwdXRTaGFwZSA/IHJlc2hhcGVkT3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpIDogb3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpO1xuICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRlckRpbXMpO1xuICBjb25zdCBvdXRwdXRTaGFwZUluU2hhZGVyID0gW2JhdGNoU2l6ZSwgTSwgTl07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE0gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTiB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBLIH0sXG4gIF07XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dGVyRGltcywgYVNoYXBlLCBiU2hhcGUpKTtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlSW5TaGFkZXIpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBiYXRjaERpbXMgPSBpbnRlcm5hbFZhcmlhYmxlKCdiYXRjaF9kaW1zJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRlckRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgYVNoYXBlLmxlbmd0aCwgYUNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBiU2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiXTtcbiAgICBsZXQgcHJvY2Vzc0JpYXMgPSAnJztcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgY29uc3QgYmlhc0NvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGNvbXBvbmVudHMgOiAxO1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGJpYXNDb21wb25lbnRzKSk7XG4gICAgICBwcm9jZXNzQmlhcyA9IGAke1xuICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IGB2YWx1ZSArPSBiaWFzW2NvbCAvICR7Ymlhc0NvbXBvbmVudHN9XTtgIDogYHZhbHVlICs9ICR7b3V0cHV0LnR5cGUudmFsdWV9KGJpYXNbcm93ICsgaV0pO2BcbiAgICAgIH1gO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhY3RpdmF0aW9uQXR0cmlidXRlcywgdW5pZm9ybXMpO1xuXG4gICAgY29uc3QgY2FsY1Jlc3VsdCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGFfZGF0YTogJHthLnR5cGUudmFsdWV9O2A7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFDb21wb25lbnRzOyBpKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke2l9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7aX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke2NvbXBvbmVudHN9XTtgO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXROdW1iZXI7IGkrKykge1xuICAgICAgICBjYWxjU3RyICs9IGBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke2l9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7YUNvbXBvbmVudHN9XTtgO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYUNvbXBvbmVudHM7IGorKykge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgdmFsdWVzWyR7aX1dID0gZm1hKCR7Yi50eXBlLnZhbHVlfShhX2RhdGEke2FDb21wb25lbnRzID09PSAxID8gJycgOiBgWyR7an1dYH0pLCBiX2RhdGEke2p9LCB2YWx1ZXNbJHtpfV0pO1xcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG5cbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlclxuICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKVxuICAgIC5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcylcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pKSAqICR7Y29tcG9uZW50c307XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pO1xuICAgIGxldCBzdHJpZGUxID0gdW5pZm9ybXMuTSAvICR7b3V0cHV0TnVtYmVyfTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtvdXRwdXROdW1iZXJ9O1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XG5cbiAgICAke291dHB1dFNoYXBlLmxlbmd0aCA9PT0gMiA/ICcnIDogYGxldCBiYXRjaF9pbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCdiYXRjaCcpfTtgfVxuXG4gICAgdmFyIGFfaW5kaWNlczogJHthLnR5cGUuaW5kaWNlc307XG4gICAgJHtjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcygnYV9pbmRpY2VzJywgYSwgYS5yYW5rIC0gMiwgYmF0Y2hEaW1zLnJhbmssICdiYXRjaF9pbmRpY2VzJyl9XG4gICAgJHthLmluZGljZXNTZXQoJ2FfaW5kaWNlcycsIGEucmFuayAtIDIsIDApfVxuICAgICR7YS5pbmRpY2VzU2V0KCdhX2luZGljZXMnLCBhLnJhbmsgLSAxLCAwKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke2EuaW5kaWNlc1RvT2Zmc2V0KCdhX2luZGljZXMnKX07XG5cbiAgICB2YXIgYl9pbmRpY2VzOiAke2IudHlwZS5pbmRpY2VzfTtcbiAgICAke2NvbnZlcnRPdXRwdXRCYXRjaEluZGljZXNUb0lucHV0QmF0Y2hJbmRpY2VzKCdiX2luZGljZXMnLCBiLCBiLnJhbmsgLSAyLCBiYXRjaERpbXMucmFuaywgJ2JhdGNoX2luZGljZXMnKX1cbiAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgYi5yYW5rIC0gMiwgMCl9XG4gICAgJHtiLmluZGljZXNTZXQoJ2JfaW5kaWNlcycsIGIucmFuayAtIDEsIDApfVxuICAgIGxldCBiX29mZnNldCA9ICR7Yi5pbmRpY2VzVG9PZmZzZXQoJ2JfaW5kaWNlcycpfTtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsgPSBrICsgJHthQ29tcG9uZW50c30pIHtcbiAgICAgICR7Y2FsY1Jlc3VsdCgpfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIGxldCBjdXJfaW5kaWNlcyA9ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtvdXRwdXQuaW5kaWNlc1RvT2Zmc2V0KCdjdXJfaW5kaWNlcycpfTtcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KGBvZmZzZXQgLyAke2NvbXBvbmVudHN9YCwgJ3ZhbHVlJyl9O1xuICAgIH1cbiAgfVxuICBgO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdNYXRNdWxOYWl2ZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259OyR7Y29tcG9uZW50c307JHthQ29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7aXNDaGFubmVsc0xhc3R9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBoYXNCaWFzID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL21hdG11bF9wYWNrZWRfd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgaW50ZXJuYWxWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyxcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXG4gIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG59IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHsgY29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMgfSBmcm9tICcuLi9tYXRtdWwtc2hhZGVycyc7XG5cbmltcG9ydCB7IHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuXG5jb25zdCB3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICBgO1xuICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVSZXN1bHRTbmlwcGV0ID0gKHRyYW5zcG9zZUE6IGJvb2xlYW4sIGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICBpZiAodHJhbnNwb3NlQSkge1xuICAgIHJldHVybiBgXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcbiAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnbGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTsnfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XG4gICAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTsnfVxuICAgICAgICB9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTsnfVxuICAgICAgICB9YDtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlID0gKFxuICB3b3JrUGVyVGhyZWFkOiBudW1iZXJbXSxcbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICB0eXBlID0gJ2YzMicsXG4gIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIsXG4gIHRyYW5zcG9zZUEgPSBmYWxzZSxcbiAgdGlsZUlubmVyID0gMzIsXG4gIHNwbGl0SyA9IGZhbHNlLFxuICBzcGxpdGVkRGltSW5uZXIgPSAzMixcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHRpbGVBT3V0ZXIgPSB3b3JrZ3JvdXBTaXplWzFdICogd29ya1BlclRocmVhZFsxXTtcbiAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtncm91cFNpemVbMF0gKiB3b3JrUGVyVGhyZWFkWzBdO1xuICBjb25zdCB0aWxlQVdpZHRoID0gdHJhbnNwb3NlQSA/IHRpbGVBT3V0ZXIgOiB0aWxlSW5uZXI7XG4gIGNvbnN0IHRpbGVBSGlnaHQgPSB0cmFuc3Bvc2VBID8gdGlsZUlubmVyIDogdGlsZUFPdXRlcjtcbiAgY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9IHRpbGVBV2lkdGggLyB3b3JrZ3JvdXBTaXplWzBdO1xuICBjb25zdCByb3dQZXJUaHJlYWRCID0gdGlsZUlubmVyIC8gd29ya2dyb3VwU2l6ZVsxXTtcblxuICBpZiAoXG4gICAgIShcbiAgICAgICgodHJhbnNwb3NlQSAmJiBpbm5lckVsZW1lbnRTaXplID09PSA0ICYmIHdvcmtQZXJUaHJlYWRbMV0gPT09IDQpIHx8XG4gICAgICAgICghdHJhbnNwb3NlQSAmJiAoaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyB8fCBpbm5lckVsZW1lbnRTaXplID09PSA0KSkpICYmXG4gICAgICB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJlxuICAgICAgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJlxuICAgICAgd29ya1BlclRocmVhZFswXSA9PT0gNFxuICAgIClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7dHJhbnNwb3NlQX0gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7d29ya1BlclRocmVhZFsxXX0gbXVzdCBiZSA0LlxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gbXVzdCBiZSAzIG9yIDQuXG4gIHRpbGVBV2lkdGggJHt0aWxlQVdpZHRofSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt3b3JrZ3JvdXBTaXplWzBdfS4gdGlsZUlubmVyICR7dGlsZUlubmVyfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7d29ya2dyb3VwU2l6ZVsxXX0uIGNvbFBlclRocmVhZCAke3dvcmtQZXJUaHJlYWRbMF19IG11c3QgYmUgNC5gKTtcbiAgfVxuICByZXR1cm4gYFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHtpbm5lckVsZW1lbnRTaXplfTwke3R5cGV9PiwgJHt0aWxlQVdpZHRoIC8gaW5uZXJFbGVtZW50U2l6ZX0+LCAke3RpbGVBSGlnaHR9PjtcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHt0eXBlfT4sICR7dGlsZUJPdXRlciAvIHdvcmtQZXJUaHJlYWRbMF19PiwgJHt0aWxlSW5uZXJ9PjtcblxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHt3b3JrUGVyVGhyZWFkWzFdfTtcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFswXX07XG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHtpbm5lckVsZW1lbnRTaXplfTtcbmNvbnN0IHRpbGVJbm5lciA9ICR7dGlsZUlubmVyfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVswXX0sICR7d29ya2dyb3VwU2l6ZVsxXX0sICR7d29ya2dyb3VwU2l6ZVsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XG4gIGxldCBiYXRjaCA9ICR7c3BsaXRLID8gJzAnIDogJ2kzMihnbG9iYWxJZC56KSd9O1xuICAke2JhdGNoRGltcyA/IGBsZXQgYmF0Y2hJbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCd1MzIoYmF0Y2gpJyl9O2AgOiAnJ31cbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt0aWxlQU91dGVyfTtcblxuICBsZXQgbnVtX3RpbGVzID0gJHtzcGxpdEsgPyBgJHtNYXRoLmNlaWwoc3BsaXRlZERpbUlubmVyIC8gdGlsZUlubmVyKX1gIDogJyh1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDEnfTtcbiAgdmFyIGtTdGFydCA9ICR7c3BsaXRLID8gYGkzMihnbG9iYWxJZC56KSAqICR7c3BsaXRlZERpbUlubmVyfWAgOiAnMCd9O1xuXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHt0eXBlfT4sIHJvd1BlclRocmVhZD47XG5cbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHtyb3dQZXJUaHJlYWRCfTtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICAke3dyaXRlRGF0YVRvU3ViQVZlYzRTbmlwcGV0KHRyYW5zcG9zZUEsIGJhdGNoRGltcyl9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Jvd1BlclRocmVhZEJ9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7XG4gICAgICAgICAgICBiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJydcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XG4gICAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnbGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdOyd9XG5cbiAgICAgICAgICAke2NhbGN1bGF0ZVJlc3VsdFNuaXBwZXQodHJhbnNwb3NlQSwgaW5uZXJFbGVtZW50U2l6ZSl9XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgfVxuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XG4gIH1cbn1gO1xufTtcblxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBU25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cbn07XG5cbmNvbnN0IHJlYWREYXRhRnJvbVN1YkFTbmlwcGV0ID0gKHRyYW5zcG9zZUE6IGJvb2xlYW4pID0+XG4gIHRyYW5zcG9zZUEgPyAnbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107JyA6ICdsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTsnO1xuXG4vLyBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzIG1lYW5zIHNlcXVlbnRpYWwgZGF0YSBpbiBtZW1vcnkgaXMgYWNjZXNzZWQgYnlcbi8vIHRocmVhZHMsIGluc3RlYWQgb2YgYSBzaW5nbGUgdGhyZWFkIChkZWZhdWx0IGJlaGF2aW9yKS5cbmV4cG9ydCBjb25zdCBtYWtlTWF0TXVsUGFja2VkU291cmNlID0gKFxuICB3b3JrUGVyVGhyZWFkOiBudW1iZXJbXSxcbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICB0eXBlID0gJ2YzMicsXG4gIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIsXG4gIHRyYW5zcG9zZUEgPSBmYWxzZSxcbiAgdGlsZUlubmVyID0gMzIsXG4gIHNwbGl0SyA9IGZhbHNlLFxuICBzcGxpdGVkRGltSW5uZXIgPSAzMixcbiAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IGZhbHNlLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtQZXJUaHJlYWRbMV0gKiB3b3JrZ3JvdXBTaXplWzFdO1xuICBjb25zdCB0aWxlQk91dGVyID0gd29ya1BlclRocmVhZFswXSAqIHdvcmtncm91cFNpemVbMF07XG4gIGNvbnN0IHRpbGVBV2lkdGggPSB0cmFuc3Bvc2VBID8gdGlsZUFPdXRlciA6IHRpbGVJbm5lcjtcbiAgY29uc3QgdGlsZUFIaWdodCA9IHRyYW5zcG9zZUEgPyB0aWxlSW5uZXIgOiB0aWxlQU91dGVyO1xuXG4gIGlmIChcbiAgICAhKHRpbGVBSGlnaHQgJSB3b3JrZ3JvdXBTaXplWzFdID09PSAwICYmIHRpbGVBV2lkdGggJSB3b3JrZ3JvdXBTaXplWzBdID09PSAwICYmIHRpbGVJbm5lciAlIHdvcmtncm91cFNpemVbMV0gPT09IDApXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB0aWxlQUhpZ2h0ICR7dGlsZUFIaWdodH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7d29ya2dyb3VwU2l6ZVsxXX0sIHRpbGVBV2lkdGggJHt0aWxlQVdpZHRofSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt3b3JrZ3JvdXBTaXplWzBdfSwgdGlsZUlubmVyICR7dGlsZUlubmVyfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt3b3JrZ3JvdXBTaXplWzFdfWAsXG4gICAgKTtcbiAgfVxuICBjb25zdCByb3dQZXJUaHJlYWRBID0gdGlsZUFIaWdodCAvIHdvcmtncm91cFNpemVbMV07XG4gIGNvbnN0IGNvbFBlclRocmVhZEEgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcbiAgY29uc3Qgcm93UGVyVGhyZWFkQiA9IHRpbGVJbm5lciAvIHdvcmtncm91cFNpemVbMV07XG4gIGNvbnN0IG1hdG11bFNuaXBwZXQgPSBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzXG4gICAgPyBgXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt0aWxlQU91dGVyfTtcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke3RpbGVCT3V0ZXJ9O1xuXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3RpbGVBSGlnaHR9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt3b3JrZ3JvdXBTaXplWzFdfSkge1xuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7dGlsZUFXaWR0aH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3dvcmtncm91cFNpemVbMF19KSB7XG4gICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFTbmlwcGV0KHRyYW5zcG9zZUEsIGJhdGNoRGltcyl9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt0aWxlSW5uZXJ9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt3b3JrZ3JvdXBTaXplWzFdfSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3RpbGVCT3V0ZXJ9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt3b3JrZ3JvdXBTaXplWzBdfSkge1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8JHt0eXBlfSwgY29sUGVyVGhyZWFkPjtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7d29ya2dyb3VwU2l6ZVswXX1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke1xuICAgICAgICAgICAgdHJhbnNwb3NlQVxuICAgICAgICAgICAgICA/IGBtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19XTtgXG4gICAgICAgICAgICAgIDogYG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7d29ya2dyb3VwU2l6ZVsxXX1dW2tdO2BcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gK1xuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfTtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt3b3JrZ3JvdXBTaXplWzBdfTtcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYFxuICAgIDogYFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5cbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt0aWxlQU91dGVyfTtcblxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke3Jvd1BlclRocmVhZEF9O1xubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke2NvbFBlclRocmVhZEF9O1xubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke3Jvd1BlclRocmVhZEJ9O1xuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQX07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7Y29sUGVyVGhyZWFkQX07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICR7d3JpdGVEYXRhVG9TdWJBU25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICB9XG4gIH1cbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHt0eXBlfSwgY29sUGVyVGhyZWFkPjtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgJHtyZWFkRGF0YUZyb21TdWJBU25pcHBldCh0cmFuc3Bvc2VBKX1cbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya2dyb3VwQmFycmllcigpO1xufVxuXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgfVxufVxuYDtcblxuICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgJHt0aWxlQVdpZHRofT4sICR7dGlsZUFIaWdodH0+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgJHt0aWxlQk91dGVyfT4sICR7dGlsZUlubmVyfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7dGlsZUlubmVyfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVswXX0sICR7d29ya2dyb3VwU2l6ZVsxXX0sICR7d29ya2dyb3VwU2l6ZVsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7c3BsaXRLID8gJzAnIDogJ2kzMihnbG9iYWxJZC56KSd9O1xuICAgICR7YmF0Y2hEaW1zID8gYGxldCBiYXRjaEluZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ3UzMihiYXRjaCknKX07YCA6ICcnfVxuICAgIGxldCBudW1fdGlsZXMgPSAke1xuICAgICAgc3BsaXRLID8gYCR7TWF0aC5jZWlsKHNwbGl0ZWREaW1Jbm5lciAvIHRpbGVJbm5lcil9YCA6ICcodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxJ1xuICAgIH07XG4gICAgdmFyIGtTdGFydCA9ICR7c3BsaXRLID8gYGkzMihnbG9iYWxJZC56KSAqICR7c3BsaXRlZERpbUlubmVyfWAgOiAnMCd9O1xuXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XG4gICAgJHttYXRtdWxTbmlwcGV0fVxuICB9XG5gO1xufTtcblxuY29uc3QgbWF0TXVsUmVhZFdyaXRlRm5Tb3VyY2UgPSAoXG4gIGNvbXBvbmVudDogbnVtYmVyLFxuICBoYXNCaWFzOiBib29sZWFuLFxuICBhcHBseUFjdGl2YXRpb246IHN0cmluZyxcbiAgdmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10sXG4gIGlzQ2hhbm5lbHNMYXN0ID0gZmFsc2UsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBbYmF0Y2hWYXJpYWJsZSwgYVZhcmlhYmxlLCBiVmFyaWFibGUsIG91dHB1dFZhcmlhYmxlXSA9IHZhcmlhYmxlcztcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUodmFyaWFibGVzWzBdLnR5cGUudGVuc29yKTtcblxuICBjb25zdCBzb3VyY2UgPSBgXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtiYXRjaFZhcmlhYmxlLnR5cGUuaW5kaWNlc30pIC0+ICR7dHlwZVNuaXBwZXQoXG4gICAgICBjb21wb25lbnQsXG4gICAgICBkYXRhVHlwZSxcbiAgICApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxuICAgICAge1xuICAgICAgICB2YXIgYUluZGljZXM6ICR7YVZhcmlhYmxlLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7Y29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMoXG4gICAgICAgICAgJ2FJbmRpY2VzJyxcbiAgICAgICAgICBhVmFyaWFibGUsXG4gICAgICAgICAgYVZhcmlhYmxlLnJhbmsgLSAyLFxuICAgICAgICAgIGJhdGNoVmFyaWFibGUucmFuayxcbiAgICAgICAgICAnYmF0Y2hJbmRpY2VzJyxcbiAgICAgICAgKX1cbiAgICAgICAgJHthVmFyaWFibGUuaW5kaWNlc1NldCgnYUluZGljZXMnLCBhVmFyaWFibGUucmFuayAtIDIsICd1MzIocm93KScpfVxuICAgICAgICAke2FWYXJpYWJsZS5pbmRpY2VzU2V0KCdhSW5kaWNlcycsIGFWYXJpYWJsZS5yYW5rIC0gMSwgJ3UzMihjb2xJbiknKX1cbiAgICAgICAgdmFsdWUgPSAke2FWYXJpYWJsZS5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YmF0Y2hWYXJpYWJsZS50eXBlLmluZGljZXN9KSAtPiAke3R5cGVTbmlwcGV0KFxuICAgICAgY29tcG9uZW50LFxuICAgICAgZGF0YVR5cGUsXG4gICAgKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgICAgdmFyIGJJbmRpY2VzOiAke2JWYXJpYWJsZS50eXBlLmluZGljZXN9O1xuICAgICAgICAke2NvbnZlcnRPdXRwdXRCYXRjaEluZGljZXNUb0lucHV0QmF0Y2hJbmRpY2VzKFxuICAgICAgICAgICdiSW5kaWNlcycsXG4gICAgICAgICAgYlZhcmlhYmxlLFxuICAgICAgICAgIGJWYXJpYWJsZS5yYW5rIC0gMixcbiAgICAgICAgICBiYXRjaFZhcmlhYmxlLnJhbmssXG4gICAgICAgICAgJ2JhdGNoSW5kaWNlcycsXG4gICAgICAgICl9XG4gICAgICAgICR7YlZhcmlhYmxlLmluZGljZXNTZXQoJ2JJbmRpY2VzJywgYlZhcmlhYmxlLnJhbmsgLSAyLCAndTMyKHJvdyknKX1cbiAgICAgICAgJHtiVmFyaWFibGUuaW5kaWNlc1NldCgnYkluZGljZXMnLCBiVmFyaWFibGUucmFuayAtIDEsICd1MzIoY29sSW4pJyl9XG4gICAgICAgIHZhbHVlID0gJHtiVmFyaWFibGUuZ2V0QnlJbmRpY2VzKCdiSW5kaWNlcycpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcbiAgICAgICAgJHtcbiAgICAgICAgICBoYXNCaWFzXG4gICAgICAgICAgICA/IGB2YWx1ZSA9IHZhbHVlICsgJHtpc0NoYW5uZWxzTGFzdCA/ICdiaWFzW2NvbEluXScgOiBgJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oYmlhc1tyb3ddKWB9O2BcbiAgICAgICAgICAgIDogJydcbiAgICAgICAgfVxuICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgJHtvdXRwdXRWYXJpYWJsZS5zZXRCeUluZGljZXMoJ3ZlYzM8dTMyPihjb29yZHMpJywgJ3ZhbHVlJyl9XG4gICAgICB9XG4gICAgfVxuICAgIGA7XG4gIHJldHVybiBzb3VyY2U7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICByZXNoYXBlZE91dHB1dFNoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGlzQ2hhbm5lbHNMYXN0ID0gZmFsc2UgLyogb25seSB1c2VkIGZvciBjb252MmRCeU1hdE11bCovLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG91dGVyRGltc0EgPSBhU2hhcGUuc2xpY2UoMCwgLTIpO1xuICBjb25zdCBvdXRlckRpbXNCID0gYlNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgY29uc3Qgb3V0ZXJEaW1zID0gcmVzaGFwZWRPdXRwdXRTaGFwZSA/IHJlc2hhcGVkT3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpIDogb3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpO1xuICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRlckRpbXMpO1xuICBjb25zdCBkaW1BT3V0ZXIgPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDJdO1xuICBjb25zdCBkaW1Jbm5lciA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGRpbUJPdXRlciA9IGJTaGFwZVtiU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGlzVmVjNCA9IGRpbUlubmVyICUgNCA9PT0gMCAmJiBkaW1CT3V0ZXIgJSA0ID09PSAwO1xuXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gIGNvbnN0IHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs4LCA4LCAxXTtcbiAgY29uc3QgZGlzcGF0Y2ggPSBbXG4gICAgTWF0aC5jZWlsKGRpbUJPdXRlciAvIHdvcmtncm91cFNpemVbMF0gLyBlbGVtZW50c1BlclRocmVhZFswXSksXG4gICAgTWF0aC5jZWlsKGRpbUFPdXRlciAvIHdvcmtncm91cFNpemVbMV0gLyBlbGVtZW50c1BlclRocmVhZFsxXSksXG4gICAgTWF0aC5jZWlsKGJhdGNoU2l6ZSAvIHdvcmtncm91cFNpemVbMl0gLyBlbGVtZW50c1BlclRocmVhZFsyXSksXG4gIF07XG5cbiAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICBjb25zdCBhU2hhcGVUZW1wID0gWy4uLm91dGVyRGltc0EsIGRpbUFPdXRlciwgZGltSW5uZXIgLyBjb21wb25lbnRzXTtcbiAgY29uc3QgYVJhbmsgPSBhU2hhcGVUZW1wLmxlbmd0aDtcbiAgY29uc3QgYlNoYXBlVGVtcCA9IFsuLi5vdXRlckRpbXNCLCBkaW1Jbm5lciwgZGltQk91dGVyIC8gY29tcG9uZW50c107XG4gIGNvbnN0IGJSYW5rID0gYlNoYXBlVGVtcC5sZW5ndGg7XG4gIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyIC8gY29tcG9uZW50c107XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1BT3V0ZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1CT3V0ZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1Jbm5lciB9LFxuICBdO1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMsIGFTaGFwZVRlbXAsIGJTaGFwZVRlbXApKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZVRlbXApKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBiYXRjaFJhbmsgPSBvdXRlckRpbXMubGVuZ3RoO1xuICAgIGNvbnN0IGJhdGNoRGltcyA9IGludGVybmFsVmFyaWFibGUoJ2JhdGNoRGltcycsIGlucHV0c1swXS5kYXRhVHlwZSwgYmF0Y2hSYW5rLCAxKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gICAgY29uc3QgQSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGFSYW5rLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBCID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgYlJhbmssIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlVGVtcC5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW0EsIEJdO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBjb25zdCBiaWFzQ29tcG9uZW50cyA9IGlzQ2hhbm5lbHNMYXN0ID8gY29tcG9uZW50cyA6IDE7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgYmlhc0NvbXBvbmVudHMpKTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMicgfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhY3RpdmF0aW9uQXR0cmlidXRlcywgdW5pZm9ybXMpO1xuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XG4gICAgY29uc3QgZGVjbGFyZUZ1bmN0aW9ucyA9IG1hdE11bFJlYWRXcml0ZUZuU291cmNlKFxuICAgICAgY29tcG9uZW50cyxcbiAgICAgIGhhc0JpYXMsXG4gICAgICBhcHBseUFjdGl2YXRpb24sXG4gICAgICBbYmF0Y2hEaW1zLCBBLCBCLCBvdXRwdXRdLFxuICAgICAgaXNDaGFubmVsc0xhc3QsXG4gICAgKTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlclxuICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKVxuICAgIC5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcylcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAke1xuICAgIGlzVmVjNFxuICAgICAgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcylcbiAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcylcbiAgfVxuICAgICAgICAgICAgICAgICAgIGA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2VsZW1lbnRzUGVyVGhyZWFkfTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259OyR7aXNWZWM0fTske2lzQ2hhbm5lbHNMYXN0fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjJkX21tX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5cbmltcG9ydCB7IGJpYXNTbmlwcGV0LCB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcbmltcG9ydCB7IHV0aWxGdW5jdGlvbnMgfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQgeyBtYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSB9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCBjb252MmRDb21tb25TbmlwcGV0ID0gKFxuICBpc0NoYW5uZWxzTGFzdDogYm9vbGVhbixcbiAgZml0QU91dGVyOiBib29sZWFuLFxuICBmaXRCT3V0ZXI6IGJvb2xlYW4sXG4gIGZpdElubmVyOiBib29sZWFuLFxuICBhZGRCaWFzID0gZmFsc2UsXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBpbm5lckVsZW1lbnRTaXplWCA9IDQsXG4gIGlubmVyRWxlbWVudFNpemVXID0gNCxcbiAgaW5uZXJFbGVtZW50U2l6ZSA9IDQsXG4gIGRhdGFUeXBlID0gJ2YzMicsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBnZXRYU25pcHBldCA9IChpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcbiAgICBzd2l0Y2ggKGlubmVyRWxlbWVudFNpemUpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXhdOyc7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBgcmVzRGF0YSA9IHZlYzM8JHtkYXRhVHlwZX0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXggLyA0XTsnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSArIGNvbEluXTsnO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjb29yZEFTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3RcbiAgICA/IGBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcbiAgICBgO1xuXG4gIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGA7XG5cbiAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJztcbiAgY29uc3QgeFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknO1xuICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XG4gIGNvbnN0IGNvbCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2NvbCcgOiAncm93JztcbiAgY29uc3QgcmVhZFhTbmlwcGV0ID0gYFxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xuICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgbGV0IG91dFJvdyA9ICR7cm93fSAvIG91dFdpZHRoO1xuICAgIGxldCBvdXRDb2wgPSAke3Jvd30gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHtjb2x9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHtjb2x9IC8gaW5DaGFubmVscyAlIGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKTtcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHVuaWZvcm1zLnN0cmlkZVswXSArIHVuaWZvcm1zLmRpbGF0aW9uWzBdICogV1JvdyAtIHVuaWZvcm1zLnBhZFswXTtcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHVuaWZvcm1zLnN0cmlkZVsxXSArIHVuaWZvcm1zLmRpbGF0aW9uWzFdICogV0NvbCAtIHVuaWZvcm1zLnBhZFsxXTtcbiAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eEhlaWdodH0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke3hXaWR0aH0pIHtcbiAgICAgICR7Y29vcmRBU25pcHBldH1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7Z2V0WFNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgpfVxuICAgIH1cbiAgICByZXR1cm4gcmVzRGF0YTtgO1xuXG4gIGNvbnN0IHNhbXBsZVggPSBpc0NoYW5uZWxzTGFzdFxuICAgID8gZml0QU91dGVyICYmIGZpdElubmVyXG4gICAgICA/IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICAke3JlYWRYU25pcHBldH1gXG4gICAgICA6IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke3JlYWRYU25pcHBldH1cbiAgICB9XG4gICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtgXG4gICAgOiBmaXRJbm5lciAmJiBmaXRCT3V0ZXJcbiAgICAgID8gYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgICR7cmVhZFhTbmlwcGV0fWBcbiAgICAgIDogYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2A7XG5cbiAgY29uc3Qgc2FtcGxlVyA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBmaXRJbm5lciAmJiBmaXRCT3V0ZXJcbiAgICAgID8gZ2V0V1NuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcpXG4gICAgICA6IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVXfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXKX1cbiAgICB9XG4gICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKX0oMC4wKTtgXG4gICAgOiBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplV307XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlcikge1xuICAgICAgJHtnZXRXU25pcHBldChpbm5lckVsZW1lbnRTaXplVyl9XG4gICAgfVxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSl9KDAuMCk7YDtcblxuICBjb25zdCByZXNUeXBlID0gdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSwgZGF0YVR5cGUpO1xuICBjb25zdCBhVHlwZSA9IGlzQ2hhbm5lbHNMYXN0ID8gdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKSA6IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSk7XG4gIGNvbnN0IGJUeXBlID0gaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplVywgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKTtcbiAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgcmVzVHlwZSwgZGF0YVR5cGUpO1xuICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2FUeXBlfSB7XG4gICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlWCA6IHNhbXBsZVd9XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtiVHlwZX0ge1xuICAgICAgJHtpc0NoYW5uZWxzTGFzdCA/IHNhbXBsZVcgOiBzYW1wbGVYfVxuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke3Jlc1R5cGV9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICAke2Nvb3JkUmVzU25pcHBldH1cbiAgICAgICR7Ymlhc1NuaXBwZXQoYWRkQmlhcyl9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gO1xuICByZXR1cm4gdXNlckNvZGU7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBkaW1BT3V0ZXI6IG51bWJlcixcbiAgZGltQk91dGVyOiBudW1iZXIsXG4gIGRpbUlubmVyOiBudW1iZXIsXG4gIGhhc0JpYXM6IGJvb2xlYW4sXG4gIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHM6IGJvb2xlYW4sXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgaW5DaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gaW5wdXRzWzBdLmRpbXNbM10gOiBpbnB1dHNbMF0uZGltc1sxXTtcbiAgY29uc3QgYmF0Y2hTaXplID0gb3V0cHV0U2hhcGVbMF07XG4gIGNvbnN0IG91dFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsyXSA6IG91dHB1dFNoYXBlWzNdO1xuICBjb25zdCBvdXRIZWlnaHQgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzFdIDogb3V0cHV0U2hhcGVbMl07XG4gIGNvbnN0IG91dENoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xuICAvLyBUT0RPOiBlbmFibGUgdmVjNCBmb3IgTkNIV1xuICBjb25zdCBpc1ZlYzQgPSBpc0NoYW5uZWxzTGFzdCAmJiAoaW5DaGFubmVscyAlIDQgPT09IDAgfHwgaW5DaGFubmVscyAlIDMgPT09IDApICYmIG91dENoYW5uZWxzICUgNCA9PT0gMDtcblxuICAvLyBUT0RPOiBmaW5lIHR1bmUgc2l6ZVxuICBjb25zdCBkaXNwYXRjaFggPSBpc0NoYW5uZWxzTGFzdCA/IG91dENoYW5uZWxzIDogb3V0V2lkdGggKiBvdXRIZWlnaHQ7XG4gIGNvbnN0IGRpc3BhdGNoWSA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0V2lkdGggKiBvdXRIZWlnaHQgOiBvdXRDaGFubmVscztcbiAgY29uc3Qgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xuICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IGRpbUFPdXRlciA8PSA4ID8gWzQsIDEsIDFdIDogWzQsIDQsIDFdO1xuICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICBNYXRoLmNlaWwoZGlzcGF0Y2hYIC8gd29ya0dyb3VwU2l6ZVswXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSxcbiAgICBNYXRoLmNlaWwoZGlzcGF0Y2hZIC8gd29ya0dyb3VwU2l6ZVsxXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzFdKSxcbiAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya0dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKSxcbiAgXTtcblxuICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gKGlzQ2hhbm5lbHNMYXN0ICYmIGluQ2hhbm5lbHMgJSA0ICE9PSAwID8gMyA6IDQpIDogMTtcbiAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtHcm91cFNpemVbMV0gKiBlbGVtZW50c1BlclRocmVhZFsxXTtcbiAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtHcm91cFNpemVbMF0gKiBlbGVtZW50c1BlclRocmVhZFswXTtcbiAgY29uc3QgdGlsZUlubmVyID0gTWF0aC5tYXgod29ya0dyb3VwU2l6ZVswXSAqIGlubmVyRWxlbWVudFNpemUsIHdvcmtHcm91cFNpemVbMV0pO1xuICBjb25zdCBmaXRBT3V0ZXIgPSBkaW1BT3V0ZXIgJSB0aWxlQU91dGVyID09PSAwO1xuICBjb25zdCBmaXRCT3V0ZXIgPSBkaW1CT3V0ZXIgJSB0aWxlQk91dGVyID09PSAwO1xuICBjb25zdCBmaXRJbm5lciA9IGRpbUlubmVyICUgdGlsZUlubmVyID09PSAwO1xuICBjb25zdCBlbGVtZW50c1NpemUgPSBpc1ZlYzQgPyBbaW5uZXJFbGVtZW50U2l6ZSwgNCwgNF0gOiBbMSwgMSwgMV07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUFPdXRlciB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUJPdXRlciB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUlubmVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMucGFkc1swXSwgYXR0cmlidXRlcy5wYWRzWzFdXSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXG4gIF07XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ2RpbV9hX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9pbm5lcicsIHR5cGU6ICdpMzInIH0sXG4gICAgICB7IG5hbWU6ICdwYWQnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdzdHJpZGUnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbicsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG5cbiAgICAvLyBUT0RPOiBzdXBwb3J0IGNvbXBvbmVudCAyLCAzLlxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcbiAgICBjb25zdCB0ID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSBgXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7aXNWZWM0ID8gJy8gNCcgOiAnJ30sIHZhbHVlKTtcbiAgICAgIH1gO1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKFxuICAgICAgJ3gnLFxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLFxuICAgICAgaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/IDEgOiBpbm5lckVsZW1lbnRTaXplLFxuICAgICk7XG4gICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbeCwgd107XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGJpYXMpO1xuICAgICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgICAgICB9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAke3V0aWxGdW5jdGlvbnMoJ3VuaWZvcm1zLnJlc3VsdF9zdHJpZGVzJyl9XG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxuICAgICAgICAvLyAgb3V0U2hhcGVTdHJpZGVzOiB2ZWMzPGkzMj4sIGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4sIHBhZCA6IHZlYzI8aTMyPiwgc3RyaWRlIDogdmVjMjxpMzI+LFxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICAgICAgICR7Y29udjJkQ29tbW9uU25pcHBldChcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICBmaXRBT3V0ZXIsXG4gICAgICAgICAgZml0Qk91dGVyLFxuICAgICAgICAgIGZpdElubmVyLFxuICAgICAgICAgIGhhc0JpYXMsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICBlbGVtZW50c1NpemVbMF0sXG4gICAgICAgICAgZWxlbWVudHNTaXplWzFdLFxuICAgICAgICAgIGVsZW1lbnRzU2l6ZVsyXSxcbiAgICAgICAgICB0LFxuICAgICAgICApfVxuICAgICAgICAke1xuICAgICAgICAgIGlzVmVjNFxuICAgICAgICAgICAgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya0dyb3VwU2l6ZSwgdCwgdW5kZWZpbmVkLCAhaXNDaGFubmVsc0xhc3QsIHRpbGVJbm5lcilcbiAgICAgICAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICAgICAgICAgICAgICBlbGVtZW50c1BlclRocmVhZCxcbiAgICAgICAgICAgICAgICB3b3JrR3JvdXBTaXplLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICFpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICAgICAgICB0aWxlSW5uZXIsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbnYyRE1hdE11bCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aW5uZXJFbGVtZW50U2l6ZX07JHtpc1ZlYzR9OyR7Zml0QU91dGVyfTske2ZpdEJPdXRlcn07JHtmaXRJbm5lcn07JHt0aWxlQU91dGVyfTske3RpbGVCT3V0ZXJ9OyR7dGlsZUlubmVyfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjNkX25haXZlX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4uL2NvbnYnO1xuaW1wb3J0IHsgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldCB9IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQgeyB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcblxuY29uc3QgYXJyYXlQcm9kdWN0ID0gKGFycjogbnVtYmVyW10pID0+IHtcbiAgbGV0IHByb2R1Y3QgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHByb2R1Y3QgKj0gYXJyW2ldO1xuICB9XG4gIHJldHVybiBwcm9kdWN0O1xufTtcblxuY29uc3QgcGFyc2UzVHVwbGVQYXJhbSA9IChwYXJhbTogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0+XG4gIHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgPyBbcGFyYW0sIHBhcmFtLCBwYXJhbV0gOiBwYXJhbTtcblxuY29uc3QgZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZSA9IChmaWx0ZXJTaXplOiBudW1iZXIsIGRpbGF0aW9uOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICBpZiAoZGlsYXRpb24gPD0gMSkge1xuICAgIHJldHVybiBmaWx0ZXJTaXplO1xuICB9XG5cbiAgcmV0dXJuIGZpbHRlclNpemUgKyAoZmlsdGVyU2l6ZSAtIDEpICogKGRpbGF0aW9uIC0gMSk7XG59O1xuXG5jb25zdCBjb21wdXRlRGVmYXVsdFBhZCA9IChcbiAgaW5wdXRTaGFwZTogW251bWJlciwgbnVtYmVyXSB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBmaWVsZFNpemU6IG51bWJlcixcbiAgc3RyaWRlOiBudW1iZXIsXG4gIGRpbGF0aW9uID0gMSxcbik6IG51bWJlciA9PiB7XG4gIGNvbnN0IGVmZmVjdGl2ZUZpZWxkU2l6ZSA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmllbGRTaXplLCBkaWxhdGlvbik7XG4gIHJldHVybiBNYXRoLmZsb29yKChpbnB1dFNoYXBlWzBdICogKHN0cmlkZSAtIDEpIC0gc3RyaWRlICsgZWZmZWN0aXZlRmllbGRTaXplKSAvIDIpO1xufTtcblxuY29uc3QgY29tcHV0ZU91dHB1dFNoYXBlNEQgPSAoXG4gIGluU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBmaWx0ZXJTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBvdXRDaGFubmVsczogbnVtYmVyLFxuICBzdHJpZGVzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIHplcm9QYWQ/OiBudW1iZXIsXG4pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9PiB7XG4gIGlmICh6ZXJvUGFkID09IG51bGwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB6ZXJvUGFkID0gY29tcHV0ZURlZmF1bHRQYWQoaW5TaGFwZSwgZmlsdGVyU2hhcGVbMF0sIHN0cmlkZXNbMF0pO1xuICB9XG4gIGNvbnN0IG91dFNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCBvdXRDaGFubmVsc107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAzOyBpbmRleCsrKSB7XG4gICAgaWYgKGluU2hhcGVbaW5kZXhdICsgMiAqIHplcm9QYWQgPj0gZmlsdGVyU2hhcGVbaW5kZXhdKSB7XG4gICAgICBvdXRTaGFwZVtpbmRleF0gPSBNYXRoLnRydW5jKChpblNoYXBlW2luZGV4XSAtIGZpbHRlclNoYXBlW2luZGV4XSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZXNbaW5kZXhdICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRTaGFwZTtcbn07XG5cbmNvbnN0IGdldDNEUGFkQW5kT3V0SW5mbyA9IChcbiAgcGFkOiBudW1iZXIgfCBzdHJpbmcgfCBudW1iZXJbXSxcbiAgaW5EZXB0aDogbnVtYmVyLFxuICBpbkhlaWdodDogbnVtYmVyLFxuICBpbldpZHRoOiBudW1iZXIsXG4gIHN0cmlkZURlcHRoOiBudW1iZXIsXG4gIHN0cmlkZUhlaWdodDogbnVtYmVyLFxuICBzdHJpZGVXaWR0aDogbnVtYmVyLFxuICBmaWx0ZXJEZXB0aDogbnVtYmVyLFxuICBmaWx0ZXJIZWlnaHQ6IG51bWJlcixcbiAgZmlsdGVyV2lkdGg6IG51bWJlcixcbik6IHsgcGFkSW5mbzogUGFkSW5mbzNEOyBvdXREZXB0aDogbnVtYmVyOyBvdXRIZWlnaHQ6IG51bWJlcjsgb3V0V2lkdGg6IG51bWJlciB9ID0+IHtcbiAgbGV0IHBhZEluZm86IFBhZEluZm8zRDtcbiAgbGV0IG91dERlcHRoOiBudW1iZXI7XG4gIGxldCBvdXRIZWlnaHQ6IG51bWJlcjtcbiAgbGV0IG91dFdpZHRoOiBudW1iZXI7XG5cbiAgaWYgKHBhZCA9PT0gJ1ZBTElEJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHBhZCA9IDA7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhZCA9PT0gJ251bWJlcicpIHtcbiAgICBwYWRJbmZvID0geyB0b3A6IHBhZCwgYm90dG9tOiBwYWQsIGxlZnQ6IHBhZCwgcmlnaHQ6IHBhZCwgZnJvbnQ6IHBhZCwgYmFjazogcGFkIH07XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBjb21wdXRlT3V0cHV0U2hhcGU0RChcbiAgICAgIFtpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aCwgMV0sXG4gICAgICBbZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdLFxuICAgICAgMSxcbiAgICAgIFtzdHJpZGVEZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aF0sXG4gICAgICBwYWQsXG4gICAgKTtcbiAgICBvdXREZXB0aCA9IG91dFNoYXBlWzBdO1xuICAgIG91dEhlaWdodCA9IG91dFNoYXBlWzFdO1xuICAgIG91dFdpZHRoID0gb3V0U2hhcGVbMl07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYWQpKSB7XG4gICAgaWYgKCFwYWQuZXZlcnkoKHZhbCwgXywgYXJyKSA9PiB2YWwgPT09IGFyclswXSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtwYWR9YCk7XG4gICAgfVxuICAgIHBhZEluZm8gPSB7IHRvcDogcGFkWzBdLCBib3R0b206IHBhZFsxXSwgbGVmdDogcGFkWzJdLCByaWdodDogcGFkWzNdLCBmcm9udDogcGFkWzRdLCBiYWNrOiBwYWRbNV0gfTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTREKFxuICAgICAgW2luRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCAxXSxcbiAgICAgIFtmaWx0ZXJEZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aF0sXG4gICAgICAxLFxuICAgICAgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSxcbiAgICAgIHBhZFswXSxcbiAgICApO1xuICAgIG91dERlcHRoID0gb3V0U2hhcGVbMF07XG4gICAgb3V0SGVpZ2h0ID0gb3V0U2hhcGVbMV07XG4gICAgb3V0V2lkdGggPSBvdXRTaGFwZVsyXTtcbiAgfSBlbHNlIGlmIChwYWQgPT09ICdTQU1FX1VQUEVSJykge1xuICAgIC8vIFRPRE86IHN1cHBvcnQgJ1NBTUVfTE9XRVInLlxuICAgIG91dERlcHRoID0gTWF0aC5jZWlsKGluRGVwdGggLyBzdHJpZGVEZXB0aCk7XG4gICAgb3V0SGVpZ2h0ID0gTWF0aC5jZWlsKGluSGVpZ2h0IC8gc3RyaWRlSGVpZ2h0KTtcbiAgICBvdXRXaWR0aCA9IE1hdGguY2VpbChpbldpZHRoIC8gc3RyaWRlV2lkdGgpO1xuICAgIGNvbnN0IHBhZEFsb25nRGVwdGggPSAob3V0RGVwdGggLSAxKSAqIHN0cmlkZURlcHRoICsgZmlsdGVyRGVwdGggLSBpbkRlcHRoO1xuICAgIGNvbnN0IHBhZEFsb25nSGVpZ2h0ID0gKG91dEhlaWdodCAtIDEpICogc3RyaWRlSGVpZ2h0ICsgZmlsdGVySGVpZ2h0IC0gaW5IZWlnaHQ7XG4gICAgY29uc3QgcGFkQWxvbmdXaWR0aCA9IChvdXRXaWR0aCAtIDEpICogc3RyaWRlV2lkdGggKyBmaWx0ZXJXaWR0aCAtIGluV2lkdGg7XG4gICAgY29uc3QgZnJvbnQgPSBNYXRoLmZsb29yKHBhZEFsb25nRGVwdGggLyAyKTtcbiAgICBjb25zdCBiYWNrID0gcGFkQWxvbmdEZXB0aCAtIGZyb250O1xuICAgIGNvbnN0IHRvcCA9IE1hdGguZmxvb3IocGFkQWxvbmdIZWlnaHQgLyAyKTtcbiAgICBjb25zdCBib3R0b20gPSBwYWRBbG9uZ0hlaWdodCAtIHRvcDtcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5mbG9vcihwYWRBbG9uZ1dpZHRoIC8gMik7XG4gICAgY29uc3QgcmlnaHQgPSBwYWRBbG9uZ1dpZHRoIC0gbGVmdDtcblxuICAgIHBhZEluZm8gPSB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCwgZnJvbnQsIGJhY2sgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtwYWR9YCk7XG4gIH1cbiAgcmV0dXJuIHsgcGFkSW5mbywgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGggfTtcbn07XG5cbnR5cGUgUGFkSW5mbzNEID0ge1xuICB0b3A6IG51bWJlcjtcbiAgbGVmdDogbnVtYmVyO1xuICByaWdodDogbnVtYmVyO1xuICBib3R0b206IG51bWJlcjtcbiAgZnJvbnQ6IG51bWJlcjtcbiAgYmFjazogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgQ29udjNESW5mbyA9IHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG4gIGluRGVwdGg6IG51bWJlcjtcbiAgaW5IZWlnaHQ6IG51bWJlcjtcbiAgaW5XaWR0aDogbnVtYmVyO1xuICBpbkNoYW5uZWxzOiBudW1iZXI7XG4gIG91dERlcHRoOiBudW1iZXI7XG4gIG91dEhlaWdodDogbnVtYmVyO1xuICBvdXRXaWR0aDogbnVtYmVyO1xuICBvdXRDaGFubmVsczogbnVtYmVyO1xuICBkYXRhRm9ybWF0OiAnY2hhbm5lbHNGaXJzdCcgfCAnY2hhbm5lbHNMYXN0JztcbiAgc3RyaWRlRGVwdGg6IG51bWJlcjtcbiAgc3RyaWRlSGVpZ2h0OiBudW1iZXI7XG4gIHN0cmlkZVdpZHRoOiBudW1iZXI7XG4gIGRpbGF0aW9uRGVwdGg6IG51bWJlcjtcbiAgZGlsYXRpb25IZWlnaHQ6IG51bWJlcjtcbiAgZGlsYXRpb25XaWR0aDogbnVtYmVyO1xuICBmaWx0ZXJEZXB0aDogbnVtYmVyO1xuICBmaWx0ZXJIZWlnaHQ6IG51bWJlcjtcbiAgZmlsdGVyV2lkdGg6IG51bWJlcjtcbiAgZWZmZWN0aXZlRmlsdGVyRGVwdGg6IG51bWJlcjtcbiAgZWZmZWN0aXZlRmlsdGVySGVpZ2h0OiBudW1iZXI7XG4gIGVmZmVjdGl2ZUZpbHRlcldpZHRoOiBudW1iZXI7XG4gIHBhZEluZm86IFBhZEluZm8zRDtcbiAgaW5TaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbXB1dGVDb252M0RJbmZvID0gKFxuICBpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBmaWx0ZXJTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgc3RyaWRlczogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBkaWxhdGlvbnM6IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgcGFkOiBudW1iZXIgfCBzdHJpbmcgfCBudW1iZXJbXSxcbiAgZGVwdGh3aXNlID0gZmFsc2UsXG4gIGRhdGFGb3JtYXQ6ICdjaGFubmVsc0ZpcnN0JyB8ICdjaGFubmVsc0xhc3QnID0gJ2NoYW5uZWxzTGFzdCcsXG4pOiBDb252M0RJbmZvID0+IHtcbiAgbGV0IGJhdGNoU2l6ZSwgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIGluQ2hhbm5lbHM7XG4gIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgIFtiYXRjaFNpemUsIGluRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCBpbkNoYW5uZWxzXSA9IGluU2hhcGU7XG4gIH0gZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgW2JhdGNoU2l6ZSwgaW5DaGFubmVscywgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGhdID0gaW5TaGFwZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YUZvcm1hdCAke2RhdGFGb3JtYXR9YCk7XG4gIH1cbiAgY29uc3QgW2ZpbHRlckNoYW5uZWxzLCAsIGZpbHRlckRlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoXSA9IGZpbHRlclNoYXBlO1xuXG4gIGNvbnN0IFtzdHJpZGVEZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aF0gPSBwYXJzZTNUdXBsZVBhcmFtKHN0cmlkZXMpO1xuICBjb25zdCBbZGlsYXRpb25EZXB0aCwgZGlsYXRpb25IZWlnaHQsIGRpbGF0aW9uV2lkdGhdID0gcGFyc2UzVHVwbGVQYXJhbShkaWxhdGlvbnMpO1xuXG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRlcHRoID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJEZXB0aCwgZGlsYXRpb25EZXB0aCk7XG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVySGVpZ2h0LCBkaWxhdGlvbkhlaWdodCk7XG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlcldpZHRoID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJXaWR0aCwgZGlsYXRpb25XaWR0aCk7XG4gIGNvbnN0IHsgcGFkSW5mbywgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGggfSA9IGdldDNEUGFkQW5kT3V0SW5mbyhcbiAgICBwYWQsXG4gICAgaW5EZXB0aCxcbiAgICBpbkhlaWdodCxcbiAgICBpbldpZHRoLFxuICAgIHN0cmlkZURlcHRoLFxuICAgIHN0cmlkZUhlaWdodCxcbiAgICBzdHJpZGVXaWR0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJEZXB0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQsXG4gICAgZWZmZWN0aXZlRmlsdGVyV2lkdGgsXG4gICk7XG5cbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBkZXB0aHdpc2UgPyBmaWx0ZXJDaGFubmVscyAqIGluQ2hhbm5lbHMgOiBmaWx0ZXJDaGFubmVscztcblxuICBsZXQgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbMCwgMCwgMCwgMCwgMF07XG4gIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICBvdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dENoYW5uZWxzLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aF07XG4gIH0gZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICBvdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoLCBvdXRDaGFubmVsc107XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBkYXRhRm9ybWF0LFxuICAgIGluRGVwdGgsXG4gICAgaW5IZWlnaHQsXG4gICAgaW5XaWR0aCxcbiAgICBpbkNoYW5uZWxzLFxuICAgIG91dERlcHRoLFxuICAgIG91dEhlaWdodCxcbiAgICBvdXRXaWR0aCxcbiAgICBvdXRDaGFubmVscyxcbiAgICBwYWRJbmZvLFxuICAgIHN0cmlkZURlcHRoLFxuICAgIHN0cmlkZUhlaWdodCxcbiAgICBzdHJpZGVXaWR0aCxcbiAgICBmaWx0ZXJEZXB0aCxcbiAgICBmaWx0ZXJIZWlnaHQsXG4gICAgZmlsdGVyV2lkdGgsXG4gICAgZWZmZWN0aXZlRmlsdGVyRGVwdGgsXG4gICAgZWZmZWN0aXZlRmlsdGVySGVpZ2h0LFxuICAgIGVmZmVjdGl2ZUZpbHRlcldpZHRoLFxuICAgIGRpbGF0aW9uRGVwdGgsXG4gICAgZGlsYXRpb25IZWlnaHQsXG4gICAgZGlsYXRpb25XaWR0aCxcbiAgICBpblNoYXBlLFxuICAgIG91dFNoYXBlLFxuICAgIGZpbHRlclNoYXBlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBmaWx0ZXJEaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgcGFkczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRhdGFGb3JtYXQ6IHN0cmluZyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnO1xuICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsTGFzdCA/IGlucHV0c1swXS5kaW1zWzNdIDogaW5wdXRzWzBdLmRpbXNbMV07XG4gIC8vIFRPRE86IGVuYWJsZSB2ZWM0LlxuICBjb25zdCBpc1ZlYzQgPSBmYWxzZTtcbiAgY29uc3Qgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzY0LCAxLCAxXTtcbiAgY29uc3QgZGlzcGF0Y2hMYXlvdXQgPSB7IHg6IG91dHB1dFNoYXBlLm1hcCgoXywgaSkgPT4gaSkgfTtcbiAgY29uc3QgZGlzcGF0Y2ggPSBbTWF0aC5jZWlsKGFycmF5UHJvZHVjdChkaXNwYXRjaExheW91dC54Lm1hcCgoZCkgPT4gb3V0cHV0U2hhcGVbZF0pKSAvIHdvcmtHcm91cFNpemVbMF0pLCAxLCAxXTtcblxuICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW2NvbnYzZF9uYWl2ZV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gKGlzQ2hhbm5lbExhc3QgJiYgaW5DaGFubmVscyAlIDQgIT09IDAgPyAzIDogNCkgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYWRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucyB9LFxuICBdO1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcykpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID09PSAzO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHBhZHMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYXR0cmlidXRlcywgdW5pZm9ybXMpO1xuICAgIC8vIFRPRE86IHN1cHBvcnQgY29tcG9uZW50IDIsIDMuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKFxuICAgICAgJ3gnLFxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLFxuICAgICAgaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/IDEgOiBpbm5lckVsZW1lbnRTaXplLFxuICAgICk7XG4gICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ1cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbeCwgd107XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBsZXQgZGVjbGFyZUZ1bmN0aW9ucyA9ICcnO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XG4gICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IGFycmF5PHUzMiwgNT4pIC0+ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0ge1xuICAgICAgICAgIHJldHVybiBiaWFzWyR7aXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgNCwgNSkgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIDUpfSR7XG4gICAgICAgICAgICBpc1ZlYzQgPyAnLyA0JyA6ICcnXG4gICAgICAgICAgfV07XG4gICAgICAgIH1gO1xuICAgIH1cbiAgICBjb25zdCByZXNUeXBlID0gdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSwgdCk7XG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgcmVzVHlwZSwgdCk7XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAgICAgICAgICAgZm4gZ2V0WChkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7eC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7dy5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDAsIHgucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIHgucmFuayAtIDEsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIHgucmFuaylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbGV0IHhGUkNDb3JuZXIgPSB2ZWMzPHUzMj4oJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAxLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAyLCB4LnJhbmspXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICR7aXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMiwgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMywgeC5yYW5rKX0sXG4gICAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMywgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgNCwgeC5yYW5rKVxuICAgICAgICAgICAgICB9KSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuICAgICAgICAgICAgICBsZXQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XG4gICAgICAgICAgICAgIGxldCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcbiAgICAgICAgICAgICAgbGV0IHhDQ29ybmVyID0geEZSQ0Nvcm5lci56O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWSA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAxLCB4LnJhbmspXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDIsIHgucmFuaylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVogPSAke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMiwgeC5yYW5rKVxuICAgICAgICAgICAgICAgICAgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAzLCB4LnJhbmspXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVXID0gJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuaylcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgNCwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVSA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCA0LCB4LnJhbmspXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDEsIHgucmFuaylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9ICh4U2hhcGVVIC8gNCkgKiA0O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAzLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgdmFsdWUgKz0gZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gYGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpJyA6ICcnfTtcbiAgICAgICAgICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAgICAgICAgIHJlc3VsdFtnbG9iYWxfaWR4XSA9IGYzMih2YWx1ZSk7XG4gICAgICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbnYzRE5haXZlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2lzQ2hhbm5lbExhc3R9OyR7aW5uZXJFbGVtZW50U2l6ZX07JHtoYXNCaWFzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuL2NvbnYnO1xuaW1wb3J0IHsgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldCB9IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbi8qKlxuICogbmFpdmUgZ3JvdXBlZCBjb252IGltcGxlbWVudGF0aW9uLCBzdXBwb3J0cyAxZC8yZCBjb252XG4gKiBAcGFyYW0gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gLSBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBzcXVlZXplIHRoZSBvdXRwdXQgc2hhcGUsIG9ubHkgdXNlZCBpbiBjb252MWRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTsnIDogJyc7XG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcblxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3Qgb3V0cHV0Q2hhbm5lbHMgPSBpc0NoYW5uZWxMYXN0ID8gb3V0cHV0U2hhcGVbM10gOiBvdXRwdXRTaGFwZVsxXTtcbiAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IG91dHB1dENoYW5uZWxzIC8gYXR0cmlidXRlcy5ncm91cDtcbiAgY29uc3QgY29tcG9uZW50cyA9IGlzQ2hhbm5lbExhc3QgJiYgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA+PSA0ID8gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRDaGFubmVscykgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5wYWRzWzBdLCBhdHRyaWJ1dGVzLnBhZHNbMV1dIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIFt3U2hhcGVbMF0sIHdTaGFwZVsxXSwgd1NoYXBlWzJdLCB3U2hhcGVbM10gLyBjb21wb25lbnRzXSksXG4gICk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSA6IFsncmFuaycsICdyYW5rJ107XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXSAvIGNvbXBvbmVudHNdKSxcbiAgKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgeFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGlucHV0VmFycyA9IFt4LCB3XTtcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNvbXBvbmVudHMpKTtcbiAgICB9XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogMiB9LFxuICAgICAgeyBuYW1lOiAnb3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cCcsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYXR0cmlidXRlcywgdW5pZm9ybXMpO1xuXG4gICAgY29uc3QgY2FsY3VsYXRlUmVzdWx0ID0gaXNDaGFubmVsTGFzdFxuICAgICAgPyBgXG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMF07IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7eC5nZXQoJ2JhdGNoJywgJ3hIZWlnaHQnLCAneFdpZHRoJywgJ2lucHV0X2NoYW5uZWwnKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7dy5nZXQoJ3dIZWlnaHQnLCAnd1dpZHRoJywgJ3dJbkNoYW5uZWwnLCAnb3V0cHV0X2NoYW5uZWwnKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGBcbiAgICAgIDogYFxuICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0hlaWdodCsrKSB7XG4gICAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVszXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVszXSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHhWYWwgPSAke3guZ2V0KCdiYXRjaCcsICdpbnB1dF9jaGFubmVsJywgJ3hIZWlnaHQnLCAneFdpZHRoJyl9O1xuICAgICAgICAgICAgbGV0IHdWYWwgPSAke3cuZ2V0KCdvdXRwdXRfY2hhbm5lbCcsICd3SW5DaGFubmVsJywgJ3dIZWlnaHQnLCAnd1dpZHRoJyl9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7aXNDaGFubmVsTGFzdCA/IDMgOiAxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtpc0NoYW5uZWxMYXN0ID8gMSA6IDJ9XSwgb3V0cHV0SW5kaWNlc1ske1xuICAgICAgaXNDaGFubmVsTGFzdCA/IDIgOiAzXG4gICAgfV0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgbGV0IGdyb3VwX2lkOiB1MzIgPSBvdXRwdXRfY2hhbm5lbCAqICR7Y29tcG9uZW50c30gLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgIHZhciBpbl9jaGFubmVsX29mZnNldCA9IGdyb3VwX2lkICogdW5pZm9ybXMud19zaGFwZVske2lzQ2hhbm5lbExhc3QgPyAyIDogMX1dO1xuXG4gICAgdmFyIHZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICR7Y2FsY3VsYXRlUmVzdWx0fVxuICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dyb3VwZWRDb252JyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fV8ke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbM10pO1xuICBjb25zdCBvdXRwdXROdW1iZXIgPSBnZXRNYXhDb21wb25lbnRzKG91dHB1dFNoYXBlWzJdKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XG4gIGNvbnN0IHhTaGFwZSA9IFtpbnB1dHNbMF0uZGltc1swXSwgaW5wdXRzWzBdLmRpbXNbMV0sIGlucHV0c1swXS5kaW1zWzJdLCBpbnB1dHNbMF0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xuICBjb25zdCB3U2hhcGUgPSBbaW5wdXRzWzFdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXSwgaW5wdXRzWzFdLmRpbXNbM10gLyBjb21wb25lbnRzXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGVJblNoYWRlciA9IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXSAvIGNvbXBvbmVudHNdO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnN0cmlkZXNbMF0sIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXV0gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5wYWRzWzBdLCBhdHRyaWJ1dGVzLnBhZHNbMV1dIH0sXG4gIF07XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoeFNoYXBlLCB3U2hhcGUsIG91dHB1dFNoYXBlSW5TaGFkZXIpKTtcbiAgY29uc3QgeE51bWJlciA9IChvdXRwdXROdW1iZXIgLSAxKSAqIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXSArIHdTaGFwZVsxXTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVJblNoYWRlci5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgeFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGlucHV0VmFycyA9IFt4LCB3XTtcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNvbXBvbmVudHMpKTtcbiAgICB9XG4gICAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdOycgOiAnJztcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgbGV0IHdpZHRoMCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVszXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWwgPSBnbG9iYWxfaWR4ICUgd2lkdGgwO1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gd2lkdGgwO1xuICAgIGxldCB3aWR0aDEgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0gLyAke291dHB1dE51bWJlcn11O1xuICAgIGxldCBjb2wgPSAoaW5kZXgxICUgd2lkdGgxKSAqICR7b3V0cHV0TnVtYmVyfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7eC50eXBlLnZhbHVlfSwgJHt4TnVtYmVyfT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyfT47XG4gICAgbGV0IGlucHV0X2NoYW5uZWwgPSBvdXRwdXRfY2hhbm5lbDtcbiAgICAvLyBVc2UgY29uc3RhbnQgaW5zdGVhZCBvZiB1bmlmb3JtIGNhbiBnaXZlIGJldHRlciBwZXJmb3JtYW5jZSBmb3IgdydzIGhlaWdodC93aWR0aC5cbiAgICBmb3IgKHZhciB3X2hlaWdodDogdTMyID0gMHU7IHdfaGVpZ2h0IDwgJHt3U2hhcGVbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt4TnVtYmVyfTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7eC5nZXQoJ2JhdGNoJywgJ3UzMih4X2hlaWdodCknLCAndTMyKHhfd2lkdGgpJywgJ2lucHV0X2NoYW5uZWwnKX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7eC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgd193aWR0aDogdTMyID0gMHU7IHdfd2lkdGggPCAke3dTaGFwZVsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7dy5nZXQoJ3dfaGVpZ2h0JywgJ3dfd2lkdGgnLCAnMCcsICdvdXRwdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICR7b3V0cHV0LnNldCgnYmF0Y2gnLCAncm93JywgJ2NvbCArIGknLCAnb3V0cHV0X2NoYW5uZWwnLCAndmFsdWUnKX07XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHcm91cGVkQ29udi1WZWN0b3JpemUnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2NvbXBvbmVudHN9OyR7b3V0cHV0TnVtYmVyfTske3hOdW1iZXJ9OyR7d1NoYXBlWzBdfTske3dTaGFwZVsxXX1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICd0eXBlJ10gOiBbJ3JhbmsnLCAncmFuayddLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFBvb2xDb252VXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYyZF9tbV93ZWJncHUnO1xuaW1wb3J0IHsgY29tcHV0ZUNvbnYzREluZm8sIGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252M2RfbmFpdmVfd2ViZ3B1JztcbmltcG9ydCB7IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuaW1wb3J0IHsgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbywgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyB9IGZyb20gJy4vY29udi1ncm91cGVkJztcbmltcG9ydCB7IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vZnVzZS11dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi9tYXRtdWwtc2hhZGVycyc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZU91dHB1dFNoYXBlID0gKFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhZGp1c3RQYWRzOiByZWFkb25seSBudW1iZXJbXSxcbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGlzQ2hhbm5lbExhc3Q6IGJvb2xlYW4sXG4pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gIGNvbnN0IGlucHV0U3BhdGlhbFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZShpc0NoYW5uZWxMYXN0ID8gMSA6IDIsIGlzQ2hhbm5lbExhc3QgPyAzIDogNCk7XG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTcGF0aWFsU2hhcGUubGVuZ3RoO1xuICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlWzBdO1xuICBjb25zdCBrZXJuZWxTcGF0aWFsU2hhcGUgPSBrZXJuZWxTaGFwZS5zbGljZSgyKTtcbiAgY29uc3QgZGlsYXRlZEtlcm5lbFNoYXBlID0ga2VybmVsU3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArICh2IC0gMSkgKiAoZGlsYXRpb25zW2ldIC0gMSkpO1xuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQgPSBpbnB1dFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyBhZGp1c3RQYWRzW2ldICsgYWRqdXN0UGFkc1tpICsgc3BhdGlhbFJhbmtdKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQubWFwKCh2LCBpKSA9PlxuICAgIE1hdGguZmxvb3IoKHYgLSBkaWxhdGVkS2VybmVsU2hhcGVbaV0gKyBzdHJpZGVzW2ldKSAvIHN0cmlkZXNbaV0pLFxuICApO1xuICBvdXRwdXRTaGFwZS5zcGxpY2UoMCwgMCwgYmF0Y2hTaXplKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGlzQ2hhbm5lbExhc3QgPyAzIDogMSwgMCwgb3V0Q2hhbm5lbHMpO1xuICByZXR1cm4gb3V0cHV0U2hhcGU7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZBdHRyaWJ1dGVzIGV4dGVuZHMgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXV0b1BhZDogc3RyaW5nO1xuICByZWFkb25seSBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbiAgcmVhZG9ubHkgZ3JvdXA6IG51bWJlcjtcbiAgcmVhZG9ubHkga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBwYWRzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHdJc0NvbnN0OiBib29sZWFuO1xufVxuXG4vLyBmb3IgdHJhbnNwb3Npbmcgd2VpZ2h0IHRlbnNvciBmcm9tIFtNLCBDL2dyb3VwLCBLSCwgS1ddIHRvIFtLSCwgS1csIEMvZ3JvdXAsIE1dXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUgPSBbMiwgMywgMSwgMF07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFzdGVyL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyZWF0ZXIgdGhhbiA1RCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDEgOiAxXTtcbiAgY29uc3QgZmlsdGVySW5DaGFubmVsID0gaW5wdXRzWzFdLmRpbXNbMV0gKiBhdHRyaWJ1dGVzLmdyb3VwO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzFdLmRpbXNbMF0gIT09IGlucHV0c1syXS5kaW1zWzBdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzID0gPFQgZXh0ZW5kcyBDb252QXR0cmlidXRlcz4oYXR0cmlidXRlczogVCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBUID0+IHtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCB3ZWxsIHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcywgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gIGlmIChrZXJuZWxTaGFwZS5sZW5ndGggPCBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAga2VybmVsU2hhcGUucHVzaCguLi5BcnJheShpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyIC0ga2VybmVsU2hhcGUubGVuZ3RoKS5maWxsKDApKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGtlcm5lbFNoYXBlW2kgLSAyXSA9PT0gMCkge1xuICAgICAga2VybmVsU2hhcGVbaSAtIDJdID0gaW5wdXRzWzFdLmRpbXNbaV07XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICBpbnB1dHNbMF0uZGltcyxcbiAgICBhdHRyaWJ1dGVzLnN0cmlkZXMsXG4gICAgYXR0cmlidXRlcy5kaWxhdGlvbnMsXG4gICAga2VybmVsU2hhcGUsXG4gICAgcGFkcyxcbiAgICBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnLFxuICAgIGF0dHJpYnV0ZXMuYXV0b1BhZCxcbiAgKTtcblxuICAvLyBhbHdheXMgcmV0dXJuIGEgbmV3IG9iamVjdCBzbyBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgY29uc3QgbmV3QXR0cmlidXRlczogVCA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xuICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHBhZHMgfSk7XG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb252QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJztcbiAgY29uc3QgYXV0b1BhZCA9IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXTtcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgbnVtYmVyW107XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5ncm91cCBhcyBudW1iZXI7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxfc2hhcGUgYXMgbnVtYmVyW107XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMgYXMgbnVtYmVyW107XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgbnVtYmVyW107XG4gIGNvbnN0IHdJc0NvbnN0ID0gKGF0dHJpYnV0ZXMud19pc19jb25zdCBhcyAoKSA9PiBib29sZWFuKSgpO1xuXG4gIHJldHVybiB7XG4gICAgYXV0b1BhZCxcbiAgICBmb3JtYXQsXG4gICAgZGlsYXRpb25zLFxuICAgIGdyb3VwLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgc3RyaWRlcyxcbiAgICB3SXNDb25zdCxcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgICBjYWNoZUtleTogYCR7YXR0cmlidXRlcy5mb3JtYXR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07YCxcbiAgfTtcbn07XG5cbmNvbnN0IGNvbnYyZCA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IHZvaWQgPT4ge1xuICAvLyBjaGVjayBhdHRyaWJ1dGVzXG5cbiAgLy8gY29uc3QgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGZhbHNlOyAvKiBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgcHJlbHUgYWN0aXZhdGlvbiB3ZWlnaHRzICovXG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZShcbiAgICBpbnB1dHNbMF0uZGltcyxcbiAgICBpbnB1dHNbMV0uZGltcyxcbiAgICBhdHRyaWJ1dGVzLmRpbGF0aW9ucyxcbiAgICBhdHRyaWJ1dGVzLnBhZHMsXG4gICAgYXR0cmlidXRlcy5zdHJpZGVzLFxuICAgIGlzQ2hhbm5lbHNMYXN0LFxuICApO1xuICBpZiAoYXR0cmlidXRlcy5ncm91cCAhPT0gMSkge1xuICAgIGNvbnN0IGNvbnZJbnB1dHMgPSBbaW5wdXRzWzBdXTtcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPVxuICAgICAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksIHtcbiAgICAgICAgICBpbnB1dHM6IFsxXSxcbiAgICAgICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxuICAgICAgICB9KVswXTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcbiAgICAgICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgICAgIH1cbiAgICAgIGNvbnZJbnB1dHMucHVzaCh0cmFuc3Bvc2VkV2VpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udklucHV0cy5wdXNoKGlucHV0c1sxXSk7XG4gICAgfVxuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb252SW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgICB9XG4gICAgLy8gTlZJRElBIEdQVSB3aXRoIGFtcGVyZSBhcmNoaXRlY3R1cmUgZmFpbHMgd2l0aCBiZWxvdyAyIGNhc2VzLCBidXQgd2UgY291bGRuJ3QgcmVwcm8gdGhlbSB3aXRoIGFueSBvdGhlclxuICAgIC8vIEdQVXMuIFNvIGp1c3QgZGlzYWJsZSB2ZWN0b3JpemUgb24gTlZJRElBIGFtcGVyZSB0byBlbnN1cmUgYWx3YXlzIGNvcnJlY3Qgb3V0cHV0cy5cbiAgICAvLyBbd2ViZ3B1XUNvbnYgLSBjb252IC0gdmVjdG9yaXplIGdyb3VwIC0gQlxuICAgIC8vIFt3ZWJncHVdQ29udiAtIGNvbnYgLSB2ZWN0b3JpemUgZ3JvdXAgLSBEXG4gICAgY29uc3QgZW5hYmxlR3JvdXBlZENvbnZWZWN0b3JpemUgPSAhY29udGV4dC5hZGFwdGVySW5mby5pc0FyY2hpdGVjdHVyZSgnYW1wZXJlJyk7XG4gICAgaWYgKFxuICAgICAgZW5hYmxlR3JvdXBlZENvbnZWZWN0b3JpemUgJiZcbiAgICAgIGlzQ2hhbm5lbHNMYXN0ICYmXG4gICAgICBpbnB1dHNbMV0uZGltc1swXSA9PT0gYXR0cmlidXRlcy5ncm91cCAmJlxuICAgICAgaW5wdXRzWzFdLmRpbXNbMV0gPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSA9PT0gMVxuICAgICkge1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvKGNvbnZJbnB1dHMsIGF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiksXG4gICAgICAgIHsgaW5wdXRzOiBjb252SW5wdXRzIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbyhjb252SW5wdXRzLCBhdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24pLCB7XG4gICAgICAgIGlucHV0czogY29udklucHV0cyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA9PT0gMztcbiAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXTtcbiAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xuICBjb25zdCBpbnB1dENoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG4gIGNvbnN0IHdlaWdodEhlaWdodCA9IGlucHV0c1sxXS5kaW1zWzJdO1xuICBjb25zdCB3ZWlnaHRXaWR0aCA9IGlucHV0c1sxXS5kaW1zWzNdO1xuXG4gIGNvbnN0IG91dEhlaWdodCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xuICBjb25zdCBvdXRXaWR0aCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xuICBjb25zdCBvdXRDaGFubmVscyA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuXG4gIGNvbnN0IHNhbWVTaXplID1cbiAgICBpc0NoYW5uZWxzTGFzdCAmJlxuICAgIHdlaWdodEhlaWdodCA9PT0gaW5wdXRIZWlnaHQgJiZcbiAgICB3ZWlnaHRXaWR0aCA9PT0gaW5wdXRXaWR0aCAmJlxuICAgIGF0dHJpYnV0ZXMucGFkc1swXSA9PT0gMCAmJlxuICAgIGF0dHJpYnV0ZXMucGFkc1sxXSA9PT0gMDtcbiAgaWYgKFxuICAgIHNhbWVTaXplIHx8XG4gICAgKHdlaWdodEhlaWdodCA9PT0gMSAmJlxuICAgICAgd2VpZ2h0V2lkdGggPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5zdHJpZGVzWzBdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLnN0cmlkZXNbMV0gPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMucGFkc1swXSA9PT0gMCAmJlxuICAgICAgYXR0cmlidXRlcy5wYWRzWzFdID09PSAwKVxuICApIHtcbiAgICAvLyBjb252MmRCeU1hdE11bFxuICAgIGNvbnN0IGJhdGNoID0gb3V0cHV0U2hhcGVbMF07XG4gICAgbGV0IHhSZXNoYXBlZCwgd1Jlc2hhcGVkLCBtYXRtdWxPdXRwdXRTaGFwZTtcbiAgICBjb25zdCBtYXRtdWxJbnB1dHMgPSBbXTtcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPVxuICAgICAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksIHtcbiAgICAgICAgICBpbnB1dHM6IFsxXSxcbiAgICAgICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxuICAgICAgICB9KVswXTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcbiAgICAgICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChzYW1lU2l6ZSkge1xuICAgICAgICBjb25zdCBzaGFyZWREaW0gPSBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGggKiBpbnB1dENoYW5uZWxzO1xuICAgICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbMSwgYmF0Y2gsIHNoYXJlZERpbV0pO1xuICAgICAgICB3UmVzaGFwZWQgPSB0cmFuc3Bvc2VkV2VpZ2h0LnJlc2hhcGUoWzEsIHNoYXJlZERpbSwgb3V0Q2hhbm5lbHNdKTtcbiAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbMSwgYmF0Y2gsIG91dENoYW5uZWxzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFtiYXRjaCwgaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoLCBpbnB1dENoYW5uZWxzXSk7XG4gICAgICAgIHdSZXNoYXBlZCA9IHRyYW5zcG9zZWRXZWlnaHQucmVzaGFwZShbMSwgaW5wdXRDaGFubmVscywgb3V0Q2hhbm5lbHNdKTtcbiAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG91dEhlaWdodCAqIG91dFdpZHRoLCBvdXRDaGFubmVsc107XG4gICAgICB9XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh4UmVzaGFwZWQpO1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2god1Jlc2hhcGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoW2JhdGNoLCBpbnB1dENoYW5uZWxzLCBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGhdKTtcbiAgICAgIHdSZXNoYXBlZCA9IGlucHV0c1sxXS5yZXNoYXBlKFsxLCBvdXRDaGFubmVscywgaW5wdXRDaGFubmVsc10pO1xuICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG91dENoYW5uZWxzLCBvdXRIZWlnaHQgKiBvdXRXaWR0aF07XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh3UmVzaGFwZWQpO1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goeFJlc2hhcGVkKTtcbiAgICB9XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gICAgfVxuICAgIGNvbnN0IE4gPSBtYXRtdWxPdXRwdXRTaGFwZVsyXTtcbiAgICBjb25zdCBLID0gbWF0bXVsSW5wdXRzWzBdLmRpbXNbbWF0bXVsSW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV07XG4gICAgLy8gVHVuZSB0aGUgdGhyZXNob2xkLlxuICAgIGlmIChOIDwgOCAmJiBLIDwgOCkge1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvKFxuICAgICAgICAgIG1hdG11bElucHV0cyxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgICAgIG1hdG11bE91dHB1dFNoYXBlLFxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uLFxuICAgICAgICApLFxuICAgICAgICB7IGlucHV0czogbWF0bXVsSW5wdXRzIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgIGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKFxuICAgICAgICAgIG1hdG11bElucHV0cyxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgICAgIG1hdG11bE91dHB1dFNoYXBlLFxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uLFxuICAgICAgICApLFxuICAgICAgICB7IGlucHV0czogbWF0bXVsSW5wdXRzIH0sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgY29udjJkV2l0aEltMkNvbCgpXG5cbiAgY29uc3Qgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IC8qIGJhY2tlbmQuYWRhcHRlckluZm8uaXNJbnRlbCgpICovIHRydWU7XG5cbiAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XG4gIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPVxuICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLCB7XG4gICAgICBpbnB1dHM6IFsxXSxcbiAgICAgIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV0sXG4gICAgfSlbMF07XG4gIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcbiAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xuICB9XG5cbiAgLy8gU1RFUC4yOiBwcmVwYXJlIHJlc2hhcGVkIGlucHV0c1xuICBjb25zdCBjb252SW5wdXRzID0gW2lucHV0c1swXSwgdHJhbnNwb3NlZFdlaWdodF07XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgY29udklucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gIH1cblxuICAvLyBTVEVQLjM6IGNvbXB1dGUgbWF0bXVsXG4gIGNvbnN0IGRpbUFPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0SGVpZ2h0ICogb3V0V2lkdGggOiBvdXRDaGFubmVscztcbiAgY29uc3QgZGltQk91dGVyID0gaXNDaGFubmVsc0xhc3QgPyBvdXRDaGFubmVscyA6IG91dEhlaWdodCAqIG91dFdpZHRoO1xuICBjb25zdCBkaW1Jbm5lciA9IHdlaWdodEhlaWdodCAqIHdlaWdodFdpZHRoICogaW5wdXRDaGFubmVscztcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvKFxuICAgICAgY29udklucHV0cyxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBvdXRwdXRTaGFwZSxcbiAgICAgIGRpbUFPdXRlcixcbiAgICAgIGRpbUJPdXRlcixcbiAgICAgIGRpbUlubmVyLFxuICAgICAgaGFzQmlhcyxcbiAgICAgIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMsXG4gICAgICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbixcbiAgICApLFxuICAgIHsgaW5wdXRzOiBjb252SW5wdXRzIH0sXG4gICk7XG59O1xuXG5jb25zdCBjb252MWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIGV4dGVuZCB0aGUgaW5wdXQgdG8gMkQgYnkgYWRkaW5nIEggZGltZW5zaW9uXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbnB1dHMgPSBbXG4gICAgY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShcbiAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgPyAvLyBbTiwgVywgQ10gLT4gW04sIEg9MSwgVywgQ11cbiAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV1cbiAgICAgICAgOiAvLyBbTiwgQywgV10gLT4gW04sIEMsIEg9MSwgV11cbiAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV0sXG4gICAgKSxcbiAgICAvL1tGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrV10gLT4gW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtIPTEsIGtXXVxuICAgIGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dKSxcbiAgXTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlucHV0cy5wdXNoKGNvbnRleHQuaW5wdXRzWzJdKTtcbiAgfVxuICBjb25zdCBwYWRzID0gWzAsIGF0dHJpYnV0ZXMucGFkc1swXSwgMCwgYXR0cmlidXRlcy5wYWRzWzFdXTtcbiAgY29uc3Qgc3RyaWRlcyA9IFsxXS5jb25jYXQoYXR0cmlidXRlcy5zdHJpZGVzKTtcbiAgY29uc3QgZGlsYXRpb25zID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLmRpbGF0aW9ucyk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhcbiAgICB7IC4uLmF0dHJpYnV0ZXMsIHBhZHMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIGNvbnYyZChjb250ZXh0LCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgKG91dHB1dFNoYXBlKSA9PlxuICAgIGlzQ2hhbm5lbExhc3QgPyBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXV0gOiBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVszXV0sXG4gICk7XG59O1xuXG5jb25zdCBjb252M2QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnID8gJ2NoYW5uZWxzTGFzdCcgOiAnY2hhbm5lbHNGaXJzdCc7XG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5wdXRzKTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMuYXV0b1BhZCA9PT0gJ05PVFNFVCcgPyBhdHRyaWJ1dGVzLnBhZHMgOiBhdHRyaWJ1dGVzLmF1dG9QYWQ7XG4gIGNvbnN0IGNvbnZJbmZvID0gY29tcHV0ZUNvbnYzREluZm8oXG4gICAgaW5wdXRzWzBdLmRpbXMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBpbnB1dHNbMV0uZGltcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIHBhZHMgYXMgc3RyaW5nIHwgbnVtYmVyW10sXG4gICAgZmFsc2UsXG4gICAgZm9ybWF0LFxuICApO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyhcbiAgICAgIGlucHV0cyxcbiAgICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgIGNvbnZJbmZvLm91dFNoYXBlLFxuICAgICAgW2NvbnZJbmZvLmZpbHRlckRlcHRoLCBjb252SW5mby5maWx0ZXJIZWlnaHQsIGNvbnZJbmZvLmZpbHRlcldpZHRoXSxcbiAgICAgIFtjb252SW5mby5wYWRJbmZvLmZyb250LCBjb252SW5mby5wYWRJbmZvLnRvcCwgY29udkluZm8ucGFkSW5mby5sZWZ0XSxcbiAgICAgIGZvcm1hdCxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgY29udjFkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2UgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgY29udjNkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGNvbnRleHQuaW5wdXRzKTtcbiAgICBjb252MmQoY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL2NvbnZfYmFja3Byb3Bfd2ViZ3B1LnRzXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vLi4vLi4vbG9nJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udi10cmFuc3Bvc2UnO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGU7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzJdIC8gZ3JvdXA7XG4gIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbM107XG4gIGNvbnN0IGFDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBnZXRNYXhDb21wb25lbnRzKGlucHV0Q2hhbm5lbHNQZXJHcm91cCkgOiAxO1xuICBjb25zdCBwYWNrSW5wdXRBczQgPSBpc0NoYW5uZWxzTGFzdCAmJiBvdXRwdXRDaGFubmVsc1Blckdyb3VwID09PSAxICYmIGlucHV0Q2hhbm5lbHNQZXJHcm91cCA+PSA0O1xuICBjb25zdCBpbnB1dENoYW5uZWxzUGVyR3JvdXBJbnQgPSBwYWNrSW5wdXRBczRcbiAgICA/IE1hdGguZmxvb3IoaW5wdXRDaGFubmVsc1Blckdyb3VwIC8gNCkgKiA0XG4gICAgOiBNYXRoLmZsb29yKGlucHV0Q2hhbm5lbHNQZXJHcm91cCAvIGFDb21wb25lbnRzKSAqIGFDb21wb25lbnRzO1xuICBjb25zdCBpbnB1dENoYW5uZWxzUmVtYWluZGVyID0gaW5wdXRDaGFubmVsc1Blckdyb3VwIC0gaW5wdXRDaGFubmVsc1Blckdyb3VwSW50O1xuICBjb25zdCBjb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBnZXRNYXhDb21wb25lbnRzKG91dHB1dENoYW5uZWxzUGVyR3JvdXApIDogMTtcbiAgY29uc3QgYkNvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IChvdXRwdXRDaGFubmVsc1Blckdyb3VwID09PSAxID8gYUNvbXBvbmVudHMgOiBjb21wb25lbnRzKSA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xuICBjb25zdCBkaXNwYXRjaCA9IFtNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0KSwgMSwgMV07XG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjJkX2JhY2twcm9wX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgY29uc3Qgc3RyaWRlcyA9IFthdHRyaWJ1dGVzLnN0cmlkZXNbMF0sIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXV07XG4gIGNvbnN0IGZpbHRlckRpbXMgPSBbYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXSwgYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXV07XG4gIGNvbnN0IGRpbGF0aW9ucyA9IFthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSwgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV1dO1xuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zID0gW1xuICAgIGZpbHRlckRpbXNbMF0gK1xuICAgICAgKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIDw9IDFcbiAgICAgICAgPyAwXG4gICAgICAgIDogKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSAtIDEpKSxcbiAgICBmaWx0ZXJEaW1zWzFdICtcbiAgICAgIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSA8PSAxXG4gICAgICAgID8gMFxuICAgICAgICA6IChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gLSAxKSksXG4gIF07XG4gIGNvbnN0IHBhZHMgPSBbXG4gICAgZWZmZWN0aXZlRmlsdGVyRGltc1swXSAtIDEgLSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLnBhZHNbMF0gKyBhdHRyaWJ1dGVzLnBhZHNbMl0pIC8gMiksXG4gICAgZWZmZWN0aXZlRmlsdGVyRGltc1sxXSAtIDEgLSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLnBhZHNbMV0gKyBhdHRyaWJ1dGVzLnBhZHNbM10pIC8gMiksXG4gIF07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0cmlkZXMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaWxhdGlvbnMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWZmZWN0aXZlRmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRDaGFubmVsc1Blckdyb3VwSW50IH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0Q2hhbm5lbHNQZXJHcm91cCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRDaGFubmVsc1Blckdyb3VwIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSxcbiAgXTtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdHJpZGVzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZmlsdGVyRGltcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ2VmZmVjdGl2ZV9maWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGVmZmVjdGl2ZUZpbHRlckRpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogcGFkcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ2lucHV0X2NoYW5uZWxzX3Blcl9ncm91cF9pbnQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ291dHB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICBjb25zdCByb3dEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDEgOiAyO1xuICAgIGNvbnN0IGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XG4gICAgY29uc3QgY2hhbm5lbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDE7XG5cbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgnVycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBiQ29tcG9uZW50cyk7XG4gICAgY29uc3QgZHkgPSBpbnB1dFZhcmlhYmxlKCdEeScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCBhQ29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbZHksIHddO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIFtvdXRwdXRTaGFwZVtjaGFubmVsRGltXV0ubGVuZ3RoLCBjb21wb25lbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG5cbiAgICBjb25zdCBjYWxjdWxhdGVSZXN1bHQgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgIGxldCBjYWxjU3RyID0gJyc7XG4gICAgICBpZiAocGFja0lucHV0QXM0KSB7XG4gICAgICAgIGlmIChhQ29tcG9uZW50cyA9PT0gNCkge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICBsZXQgeFZhbHVlID0gJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQnKX07XG4gICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0Jyl9O1xuICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7XG4gICAgICAgIHhfb2Zmc2V0ICs9IDF1O1xuICAgICAgICB3X29mZnNldCArPSAxdTtgO1xuICAgICAgICB9IGVsc2UgaWYgKGFDb21wb25lbnRzID09PSAyKSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QodmVjNDwke2RhdGFUeXBlfT4oJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQnKX0sICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0ICsgMXUnKX0pLCB2ZWM0PCR7ZGF0YVR5cGV9Pigke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0Jyl9LCAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0ICsgMXUnKX0pKTtcbiAgICAgICAgICB4X29mZnNldCArPSAydTtcbiAgICAgICAgICB3X29mZnNldCArPSAydTtgO1xuICAgICAgICB9IGVsc2UgaWYgKGFDb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QodmVjNDwke2RhdGFUeXBlfT4oJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQnKX0sICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0ICsgMXUnKX0sICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0ICsgMnUnKX0sICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0ICsgM3UnKX0pLCB2ZWM0PCR7ZGF0YVR5cGV9Pigke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0Jyl9LCAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0ICsgMXUnKX0sICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQgKyAydScpfSwgJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCArIDN1Jyl9KSk7XG4gICAgICAgICAgeF9vZmZzZXQgKz0gNHU7XG4gICAgICAgICAgd19vZmZzZXQgKz0gNHU7YDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsc0xhc3RcbiAgICAgICAgICAgICAgICAgICAgICA/IGR5LmdldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtkeS5pbmRpY2VzVG9PZmZzZXQoYCR7ZHkudHlwZS5pbmRpY2VzfShiYXRjaCwgaWR5UiwgaWR5QywgaW5wdXRDaGFubmVsKWApfSAvICR7YUNvbXBvbmVudHN9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IGR5LmdldCgnYmF0Y2gnLCAnaW5wdXRDaGFubmVsJywgJ2lkeVInLCAnaWR5QycpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICBgO1xuICAgICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICBsZXQgd19vZmZzZXQgPSAke3cuaW5kaWNlc1RvT2Zmc2V0KGAke3cudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9O1xuICAgICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0IC8gJHtiQ29tcG9uZW50c31gKX07XG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGFDb21wb25lbnRzOyBjKyspIHtcbiAgICAgICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgbGV0IHdWYWx1ZSR7Y30gPSAke3cuZ2V0QnlPZmZzZXQoYCR7dy5pbmRpY2VzVG9PZmZzZXQoYCR7dy50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsICsgJHtjfSwgd091dENoYW5uZWwpYCl9IC8gJHtiQ29tcG9uZW50c31gKX07XG4gICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZVske2N9XSAqIHdWYWx1ZSR7Y307YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG4gICAgY29uc3QgY2FsY3VsYXRlUmVtYWluZGVyID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICBpZiAoaW5wdXRDaGFubmVsc1JlbWFpbmRlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIXBhY2tJbnB1dEFzNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2tJbnB1dEFzNCAke3BhY2tJbnB1dEFzNH0gaXMgbm90IHRydWUuYCk7XG4gICAgICB9XG4gICAgICBsZXQgY2FsY1N0ciA9ICcnO1xuICAgICAgaWYgKGFDb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgIGNhbGNTdHIgKz0gJ2RvdFByb2QgPSBkb3RQcm9kJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENoYW5uZWxzUmVtYWluZGVyOyBpKyspIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgICsgJHtkeS5nZXRCeU9mZnNldChgeF9vZmZzZXQgKyAke2l9YCl9ICogJHt3LmdldEJ5T2Zmc2V0KGB3X29mZnNldCArICR7aX1gKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhbGNTdHIgKz0gJzsnO1xuICAgICAgfSBlbHNlIGlmIChhQ29tcG9uZW50cyA9PT0gMikge1xuICAgICAgICBpZiAoaW5wdXRDaGFubmVsc1JlbWFpbmRlciAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnB1dENoYW5uZWxzUmVtYWluZGVyICR7aW5wdXRDaGFubmVsc1JlbWFpbmRlcn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0Jyl9O1xuICAgICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0Jyl9O1xuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBjb25zdCBjb2RlU25pcHBldCA9IGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfWApfTtcbiAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCAwKX07XG4gICAgICAgICAgICBsZXQgZDEgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgY2hhbm5lbERpbSl9O1xuICAgICAgICAgICAgbGV0IHIgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgcm93RGltKX07XG4gICAgICAgICAgICBsZXQgYyA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBjb2xEaW0pfTtcbiAgICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB1bmlmb3Jtcy5wYWRzO1xuICAgICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgICAgICBsZXQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgICAgICB2YXIgZG90UHJvZCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDAuMCk7XG4gICAgICAgICAgICB2YXIgd1I6IHUzMiA9IDA7XG4gICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnggPT0gMSkge1xuICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdSID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5UkNvcm5lciArIHdSKSAlICh1bmlmb3Jtcy5zdHJpZGVzLngpID09IDBcbiAgICAgICAgICAgICAgd1IgPSB1MzIoKChkeVJDb3JuZXIgKyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIDEpIC8gaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkpICogaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkgLSBkeVJDb3JuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IHdSIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLng7IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3UiAlIHVuaWZvcm1zLmRpbGF0aW9ucy54ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlSID0gKCR7ZGF0YVR5cGV9KGR5UkNvcm5lcikgKyAke2RhdGFUeXBlfSh3UikpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XG4gICAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWyR7cm93RGltfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcbiAgICAgICAgICAgICAgICAgIHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG4gICAgICAgICAgICAgIHZhciB3QzogdTMyID0gMDtcbiAgICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy55ID09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdDID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5Q0Nvcm5lciArIHdDKSAlICh1bmlmb3Jtcy5zdHJpZGVzLnkpID09IDBcbiAgICAgICAgICAgICAgICB3QyA9IHUzMigoKGR5Q0Nvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIGR5Q0Nvcm5lcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICg7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdDICUgdW5pZm9ybXMuZGlsYXRpb25zLnkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkYXRhVHlwZX0oZHlDQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdDKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XG4gICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbJHtjb2xEaW19XSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgICBwYWNrSW5wdXRBczRcbiAgICAgICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICAgICAgdmFyIHhfb2Zmc2V0ID0gJHtkeS5pbmRpY2VzVG9PZmZzZXQoYCR7ZHkudHlwZS5pbmRpY2VzfShiYXRjaCwgaWR5UiwgaWR5QywgaW5wdXRDaGFubmVsKWApfSAvICR7YUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgICAgIHZhciB3X29mZnNldCA9ICR7dy5pbmRpY2VzVG9PZmZzZXQoYCR7dy50eXBlLmluZGljZXN9KHdSUGVybSwgd0NQZXJtLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfSAvICR7YkNvbXBvbmVudHN9O1xuICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cF9pbnQ7IGQyID0gZDIgKyAke3BhY2tJbnB1dEFzNCA/IDQgOiBhQ29tcG9uZW50c30pIHtcbiAgICAgICAgICAgICAgICAgICR7Y2FsY3VsYXRlUmVzdWx0KCl9XG4gICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAke3BhY2tJbnB1dEFzNCA/IDQgOiBhQ29tcG9uZW50c307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR7Y2FsY3VsYXRlUmVtYWluZGVyKCl9XG4gICAgICAgICAgICAgICAgd0MgPSB3QyArIHVuaWZvcm1zLnN0cmlkZXMueSAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd1IgPSB3UiArIHVuaWZvcm1zLnN0cmlkZXNbMF0gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7aGFzQmlhcyA/IGAgKyBiaWFzW2QxIC8gJHtjb21wb25lbnRzfV1gIDogJyd9O1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gICAgICAgICAgYDtcblxuICAgIHJldHVybiBgXG4gICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX07XG4gICAgJHtjb2RlU25pcHBldH19YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdDb252VHJhbnNwb3NlMkQnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2FDb21wb25lbnRzfSR7YkNvbXBvbmVudHN9JHtjb21wb25lbnRzfSR7cGFja0lucHV0QXM0fSR7aW5wdXRDaGFubmVsc1JlbWFpbmRlcn1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdIH0sXG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX3dlYmdwdSc7XG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IGNvbXB1dGVUb3RhbFBhZCA9IChcbiAgaW5EaW06IG51bWJlcixcbiAgc3RyaWRlOiBudW1iZXIsXG4gIGFkajogbnVtYmVyLFxuICBrZXJuZWw6IG51bWJlcixcbiAgZGlsYXRpb246IG51bWJlcixcbiAgb3V0U2l6ZTogbnVtYmVyLFxuKSA9PiAoaW5EaW0gLSAxKSAqIHN0cmlkZSArIGFkaiArIChrZXJuZWwgLSAxKSAqIGRpbGF0aW9uICsgMSAtIG91dFNpemU7XG5cbmNvbnN0IGRpc3RyaWJ1dGVQYWRkaW5nID0gKHRvdGFsUGFkOiBudW1iZXIsIGF1dG9QYWQ6IHN0cmluZywgcGFkczogbnVtYmVyW10sIGhlYWQ6IG51bWJlciwgdGFpbDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHNtYWxsUGFkID0gTWF0aC5mbG9vcih0b3RhbFBhZCAvIDIpO1xuICBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICB9IGVsc2UgaWYgKGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJykge1xuICAgIHBhZHNbaGVhZF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSBzbWFsbFBhZDtcbiAgfVxufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGVBbmRQYWRzID0gKFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdXRvUGFkOiBzdHJpbmcsXG4gIGdyb3VwOiBudW1iZXIsXG4gIHBhZHM6IG51bWJlcltdLFxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNDaGFubmVsTGFzdDogYm9vbGVhbixcbiAgb3V0cHV0UGFkZGluZzogbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbikgPT4ge1xuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoIC0gMjtcbiAgY29uc3QgdXBkYXRlT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5sZW5ndGggPT09IDA7XG4gIGlmIChvdXRwdXRQYWRkaW5nLmxlbmd0aCA8IHNwYXRpYWxSYW5rKSB7XG4gICAgb3V0cHV0UGFkZGluZy5wdXNoKC4uLkFycmF5KHNwYXRpYWxSYW5rIC0gb3V0cHV0UGFkZGluZy5sZW5ndGgpLmZpbGwoMCkpO1xuICB9XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbaXNDaGFubmVsTGFzdCA/IDMgOiAxXSAqIGdyb3VwO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGlucHV0U2hhcGUubGVuZ3RoIC0gc3BhdGlhbFJhbmsgLSAoaXNDaGFubmVsTGFzdCA/IDEgOiAwKTsgaSA8IHNwYXRpYWxSYW5rOyArK2ksICsraikge1xuICAgIGNvbnN0IGluU2l6ZSA9IGlucHV0U2hhcGVbal07XG4gICAgY29uc3Qgb3V0U2l6ZSA9IHVwZGF0ZU91dHB1dFNoYXBlID8gaW5TaXplICogc3RyaWRlc1tpXSA6IG91dHB1dFNoYXBlW2ldO1xuICAgIGNvbnN0IHRvdGFsUGFkID0gY29tcHV0ZVRvdGFsUGFkKGluU2l6ZSwgc3RyaWRlc1tpXSwgcGFkc1tpXSwga2VybmVsU2hhcGVbal0sIGRpbGF0aW9uc1tpXSwgb3V0U2l6ZSk7XG4gICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XG4gICAgaWYgKHVwZGF0ZU91dHB1dFNoYXBlKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKFxuICAgICAgICBzdHJpZGVzW2ldICogKGluU2l6ZSAtIDEpICtcbiAgICAgICAgICBvdXRwdXRQYWRkaW5nW2ldICtcbiAgICAgICAgICAoa2VybmVsU2hhcGVbal0gLSAxKSAqIGRpbGF0aW9uc1tpXSArXG4gICAgICAgICAgMSAtXG4gICAgICAgICAgcGFkc1tpXSAtXG4gICAgICAgICAgcGFkc1tpICsgc3BhdGlhbFJhbmtdLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBDb252QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPihcbiAgYXR0cmlidXRlczogVCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4pOiBUID0+IHtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpID09PSAwKSB7XG4gICAga2VybmVsU2hhcGUubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBrZXJuZWxTaGFwZS5zcGxpY2UoMCwgMCwgaW5wdXRzWzFdLmRpbXNbMF0pO1xuICBrZXJuZWxTaGFwZS5zcGxpY2UoaXNDaGFubmVsc0xhc3QgPyAzIDogMSwgMCwgaW5wdXRzWzFdLmRpbXNbMV0pO1xuXG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcuc2xpY2UoKTtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBsZXQgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMuc2xpY2UoKTtcbiAgaWYgKGRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA9PT0gMCkge1xuICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgICBkaWxhdGlvbnMgPSBuZXcgQXJyYXkoc3BhdGlhbFJhbmspLmZpbGwoMSk7XG4gIH1cbiAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgaWYgKHN0cmlkZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPT09IDApIHtcbiAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShzcGF0aWFsUmFuaykuZmlsbCgxKTtcbiAgfVxuICAvLyBJZiBvdXRwdXRTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHBhcmFtZXRlcnNcbiAgLy8gU2ltaWxhcmx5LCBhdXRvbWF0aWNhbGx5IGluZmVyIHBhZHMgaWYgbm90IHNwZWNpZmllZFxuICBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMoXG4gICAgaW5wdXRTaGFwZSxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBkaWxhdGlvbnMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICAgIGF0dHJpYnV0ZXMuZ3JvdXAsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgIG91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzLCBvdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSwgZGlsYXRpb25zLCBzdHJpZGVzIH0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XG4gIGNvbnN0IGF1dG9QYWQgPSBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJywgJ1NBTUVfTE9XRVInXVtcbiAgICB0eXBlb2YgYXR0cmlidXRlcy5hdXRvUGFkID09ICd1bmRlZmluZWQnID8gMCA6IChhdHRyaWJ1dGVzLmF1dG9QYWQgYXMgbnVtYmVyKVxuICBdO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBncm91cCA9IChhdHRyaWJ1dGVzLmdyb3VwIGFzIG51bWJlcikgPz8gMTsgLy8gZGVmYXVsdCB0byAxIHBlciBPTk5YIHNwZWNcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgd0lzQ29uc3QgPSAoYXR0cmlidXRlcy53SXNDb25zdCBhcyAoKSA9PiBib29sZWFuKSgpO1xuICBjb25zdCBvdXRwdXRQYWRkaW5nID0gYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgcmV0dXJuIHtcbiAgICBhdXRvUGFkLFxuICAgIGZvcm1hdCxcbiAgICBkaWxhdGlvbnMsXG4gICAgZ3JvdXAsXG4gICAga2VybmVsU2hhcGUsXG4gICAgb3V0cHV0UGFkZGluZyxcbiAgICBvdXRwdXRTaGFwZSxcbiAgICBwYWRzLFxuICAgIHN0cmlkZXMsXG4gICAgd0lzQ29uc3QsXG4gICAgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gICAgY2FjaGVLZXk6IGAke2F0dHJpYnV0ZXMuZm9ybWF0fTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259O2AsXG4gIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9PcGVyYXRvcnMubWQjQ29udlRyYW5zcG9zZVxuICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0ICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnYnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXQnKTtcbiAgfVxuXG4gIC8vIEZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcbiAgY29uc3QgZGF0YUNoYW5uZWwgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnID8gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMSA6IDFdO1xuICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1swXTtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIGNvbnN0IGZlYXR1cmVNYXBzID0gaW5wdXRzWzFdLmRpbXNbMV0gKiBhdHRyaWJ1dGVzLmdyb3VwO1xuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1syXS5kaW1zWzBdICE9PSBmZWF0dXJlTWFwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICBjb25zdCBkaWxhdGlvbnNTZXQgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGRpbGF0aW9uc1NldCAmJiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgY29uc3Qgc3RyaWRlc1NldCA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIC8vIFdyb25nIHN0cmlkZXMgZGltZW5zaW9uXG4gIGlmIChzdHJpZGVzU2V0ICYmIGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGNvbnN0IHBhZHNTZXQgPSBhdHRyaWJ1dGVzLnBhZHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICBpZiAocGFkc1NldCAmJiBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIG91dHB1dCBwYWRkaW5nIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgJiYgYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nLmxlbmd0aCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgY29uc3Qga2VybmVsU2hhcGVTZXQgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgaWYgKFxuICAgIGtlcm5lbFNoYXBlU2V0ICYmXG4gICAgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IDAgJiZcbiAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMlxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2VybmVsIHNoYXBlJyk7XG4gIH1cblxuICAvLyBhcyB3aXRoIGtlcm5lbFNoYXBlLCBtdXN0IGhhdmUgc2FtZSBudW1iZXIgb2Ygc3BhdGlhbCBkaW1zIGFzIGlucHV0XG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvdXRwdXQgc2hhcGUnKTtcbiAgfVxufTtcblxuY29uc3QgY29udlRyYW5zcG9zZTJkID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogdm9pZCA9PiB7XG4gIC8vIFNURVAuMTogdHJhbnNwb3NlIHdlaWdodFxuICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cbiAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgWzIsIDMsIDAsIDFdKSwge1xuICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxuICAgIH0pWzBdO1xuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgfVxuXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgY29uc3QgY29udlRyYW5zcG9zZUlucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIGNvbnZUcmFuc3Bvc2VJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyhjb252VHJhbnNwb3NlSW5wdXRzLCBhdHRyaWJ1dGVzLCBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiksIHtcbiAgICBpbnB1dHM6IGNvbnZUcmFuc3Bvc2VJbnB1dHMsXG4gIH0pO1xufTtcblxuY29uc3QgY29udlRyYW5zcG9zZTFkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBleHRlbmQgdGhlIGlucHV0IHRvIDJEIGJ5IGFkZGluZyBIIGRpbWVuc2lvblxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcblxuICBjb25zdCBpbnB1dHMgPSBbXG4gICAgY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShcbiAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgPyAvLyBbTiwgVywgQ10gLT4gW04sIEg9MSwgVywgQ11cbiAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV1cbiAgICAgICAgOiAvLyBbTiwgQywgV10gLT4gW04sIEMsIEg9MSwgV11cbiAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV0sXG4gICAgKSxcbiAgICAvL1tGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrV10gLT4gW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtIPTEsIGtXXVxuICAgIGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dKSxcbiAgXTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlucHV0cy5wdXNoKGNvbnRleHQuaW5wdXRzWzJdKTtcbiAgfVxuICBsZXQga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlO1xuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoID09PSAwIHx8IGtlcm5lbFNoYXBlWzBdID09PSAwKSB7XG4gICAga2VybmVsU2hhcGUgPSBbY29udGV4dC5pbnB1dHNbMV0uZGltc1syXV07XG4gIH1cbiAgbGV0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zO1xuICBpZiAoZGlsYXRpb25zLmxlbmd0aCA9PT0gMCB8fCBkaWxhdGlvbnNbMF0gPT09IDApIHtcbiAgICBkaWxhdGlvbnMgPSBbMV07XG4gIH1cbiAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXM7XG4gIGlmIChzdHJpZGVzLmxlbmd0aCA9PT0gMCB8fCBzdHJpZGVzWzBdID09PSAwKSB7XG4gICAgc3RyaWRlcyA9IFsxXTtcbiAgfVxuICBsZXQgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcztcbiAgaWYgKHBhZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcGFkcyA9IFswLCAwXTtcbiAgfVxuICBwYWRzID0gWzAsIHBhZHNbMF0sIDAsIHBhZHNbMV1dO1xuICBzdHJpZGVzID0gWzFdLmNvbmNhdChzdHJpZGVzKTtcbiAgZGlsYXRpb25zID0gWzFdLmNvbmNhdChkaWxhdGlvbnMpO1xuICBrZXJuZWxTaGFwZSA9IFsxXS5jb25jYXQoa2VybmVsU2hhcGUpO1xuICBsZXQgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZztcbiAgb3V0cHV0UGFkZGluZyA9IFswXS5jb25jYXQob3V0cHV0UGFkZGluZyk7XG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoXG4gICAgeyAuLi5hdHRyaWJ1dGVzLCBwYWRzLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBvdXRwdXRQYWRkaW5nIH0sXG4gICAgaW5wdXRzLFxuICApO1xuXG4gIGNvbnZUcmFuc3Bvc2UyZChjb250ZXh0LCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgKG91dHB1dFNoYXBlKSA9PlxuICAgIGlzQ2hhbm5lbExhc3QgPyBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXV0gOiBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVszXV0sXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgY29udlRyYW5zcG9zZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252VHJhbnNwb3NlMWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBjb250ZXh0LmlucHV0cyk7XG4gICAgY29udlRyYW5zcG9zZTJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldEVsZW1lbnRBdCwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBDdW1TdW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgZXhjbHVzaXZlOiBib29sZWFuO1xuICByZWFkb25seSByZXZlcnNlOiBib29sZWFuO1xufVxuY29uc3QgY3JlYXRlQ3Vtc3VtUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0VHlwZTogbnVtYmVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgYXhpc0lucHV0OiBUZW5zb3JWaWV3LFxuICBhdHRyaWJ1dGVzOiBDdW1TdW1BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7IC8vIG91dHB1dFNoYXBlIGlzIHNhbWUgYXMgaW5wdXRTaGFwZS5cbiAgY29uc3QgcmFuayA9IGlucHV0U2hhcGUubGVuZ3RoOyAvLyBpbnB1dC9vdXRwdXQgcmFua1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRUeXBlLCByYW5rKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0VHlwZSwgcmFuayk7XG4gIGNvbnN0IGF4aXNWYWx1ZSA9XG4gICAgYXhpc0lucHV0LmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMiA/IGF4aXNJbnB1dC5nZXRJbnQzMkFycmF5KClbMF0gOiBOdW1iZXIoYXhpc0lucHV0LmdldEJpZ0ludDY0QXJyYXkoKVswXSk7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhheGlzVmFsdWUsIHJhbmspO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGAgaTMyKCR7aW5wdXQuaW5kaWNlc0dldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX0pIGA7XG4gICAgY29uc3QgbWF4ID0gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICd1bmlmb3Jtcy5heGlzJywgcmFuayk7XG4gICAgY29uc3QgbG93ZXJMaW1pdCA9IGF0dHJpYnV0ZXMucmV2ZXJzZSA/IGluZGV4ICsgKGF0dHJpYnV0ZXMuZXhjbHVzaXZlID8gJyArIDEnIDogJycpIDogJzAnO1xuICAgIGNvbnN0IHVwcGVyTGltaXQgPSBhdHRyaWJ1dGVzLnJldmVyc2UgPyBtYXggOiBpbmRleCArIChhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSA/ICcnIDogJyArIDEnKTtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzJywgJ3UzMicpXG4gICAgICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgOiBpMzIgPSAke2xvd2VyTGltaXR9O1xuICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgOiBpMzIgPSAke3VwcGVyTGltaXR9O1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA6IGkzMiA9IGZpcnN0OyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAndTMyKGkpJyl9O1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRJbmRpY2VzJyl9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc3VtJyl9O1xuICAgICAgICAgICAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdDdW1TdW0nLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBpbnB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIGlucHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3Vtc3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDdW1TdW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBjb250ZXh0LmlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dFR5cGUgPSBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgYXhpcyA9IGNvbnRleHQuaW5wdXRzWzFdO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ3Vtc3VtUHJvZ3JhbUluZm8oaW5wdXRUeXBlLCBpbnB1dFNoYXBlLCBheGlzLCBhdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDdW1TdW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgZXhjbHVzaXZlID0gKGF0dHJpYnV0ZXMuZXhjbHVzaXZlIGFzIG51bWJlcikgPT09IDE7XG4gIGNvbnN0IHJldmVyc2UgPSAoYXR0cmlidXRlcy5yZXZlcnNlIGFzIG51bWJlcikgPT09IDE7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBleGNsdXNpdmUsIHJldmVyc2UgfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgZXh0ZW5kcyBGb3JtYXRBdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBibG9ja3NpemU6IG51bWJlcjtcbiAgcmVhZG9ubHkgbW9kZTogc3RyaW5nO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXB0aFRvU3BhY2UgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXB0aFRvU3BhY2UgcmVxdWlyZXMgNEQgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHBlcm1GdW5jdGlvbkJvZHkgPSAocGVybTogbnVtYmVyW10sIHJhbms6IG51bWJlciwgaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJldmVyc2VGdW5jID0gW107XG4gIHJldmVyc2VGdW5jLnB1c2goYGZuIHBlcm0oaTogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtpbnB1dC50eXBlLmluZGljZXN9O2ApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgIHJldmVyc2VGdW5jLnB1c2goaW5wdXQuaW5kaWNlc1NldCgnYScsIHBlcm1baV0sIGBpWyR7aX1dYCkpO1xuICB9XG4gIHJldmVyc2VGdW5jLnB1c2goJ3JldHVybiBhO30nKTtcbiAgcmV0dXJuIHJldmVyc2VGdW5jLmpvaW4oJ1xcbicpO1xufTtcblxuY29uc3QgY3JlYXRlRGVwdGhUb1NwYWNlUHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGxldCBuOiBudW1iZXIsIGg6IG51bWJlciwgdzogbnVtYmVyLCBjOiBudW1iZXI7XG4gIGxldCBzaGFwZTogbnVtYmVyW107XG4gIGxldCBwZXJtOiBudW1iZXJbXTtcbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGJsb2Nrc2l6ZSA9IGF0dHJpYnV0ZXMuYmxvY2tzaXplO1xuICBjb25zdCBpc0RDUm1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgPT09ICdEQ1InO1xuICBpZiAoaXNDaGFubmVsTGFzdCkge1xuICAgIFtuLCBoLCB3LCBjXSA9IGlucHV0VGVuc29yLmRpbXM7XG4gICAgc2hhcGUgPSBpc0RDUm1vZGVcbiAgICAgID8gW24sIGgsIHcsIGJsb2Nrc2l6ZSwgYmxvY2tzaXplLCBjIC8gYmxvY2tzaXplICoqIDJdXG4gICAgICA6IFtuLCBoLCB3LCBjIC8gYmxvY2tzaXplICoqIDIsIGJsb2Nrc2l6ZSwgYmxvY2tzaXplXTtcbiAgICBwZXJtID0gaXNEQ1Jtb2RlID8gWzAsIDEsIDMsIDIsIDQsIDVdIDogWzAsIDEsIDQsIDIsIDUsIDNdO1xuICB9IGVsc2Uge1xuICAgIFtuLCBoLCB3LCBjXSA9IFtpbnB1dFRlbnNvci5kaW1zWzBdLCBpbnB1dFRlbnNvci5kaW1zWzJdLCBpbnB1dFRlbnNvci5kaW1zWzNdLCBpbnB1dFRlbnNvci5kaW1zWzFdXTtcbiAgICBzaGFwZSA9IGlzRENSbW9kZVxuICAgICAgPyBbbiwgYmxvY2tzaXplLCBibG9ja3NpemUsIGMgLyBibG9ja3NpemUgKiogMiwgaCwgd11cbiAgICAgIDogW24sIGMgLyBibG9ja3NpemUgKiogMiwgYmxvY2tzaXplLCBibG9ja3NpemUsIGgsIHddO1xuICAgIHBlcm0gPSBpc0RDUm1vZGUgPyBbMCwgMywgNCwgMSwgNSwgMl0gOiBbMCwgMSwgNCwgMiwgNSwgM107XG4gIH1cbiAgY29uc3QgcmVzaGFwZWRJbnB1dFRlbnNvciA9IGlucHV0VGVuc29yLnJlc2hhcGUoc2hhcGUpO1xuICBjb25zdCByZXNoYXBlZElucHV0UmFuayA9IHJlc2hhcGVkSW5wdXRUZW5zb3IuZGltcy5sZW5ndGg7XG4gIGNvbnN0IGlucHV0RGF0YVR5cGUgPSBpbnB1dFRlbnNvci5kYXRhVHlwZTtcblxuICBjb25zdCByZXNoYXBlZElucHV0ID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0RGF0YVR5cGUsIHJlc2hhcGVkSW5wdXRSYW5rKTtcbiAgY29uc3QgcGVybWVkT3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIHJlc2hhcGVkSW5wdXRSYW5rKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHJlc2hhcGVkSW5wdXQsIHBlcm1lZE91dHB1dCl9XG5cbiAgJHtwZXJtRnVuY3Rpb25Cb2R5KHBlcm0sIHJlc2hhcGVkSW5wdXRSYW5rLCByZXNoYXBlZElucHV0LCBwZXJtZWRPdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7cGVybWVkT3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtwZXJtZWRPdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCByZXNoYXBlZElucHV0LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKSl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0RlcHRoVG9TcGFjZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2lucHV0VGVuc29yLmRpbXN9OyR7YXR0cmlidXRlcy5ibG9ja3NpemV9OyR7YXR0cmlidXRlcy5tb2RlfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlzQ2hhbm5lbExhc3RcbiAgICAgICAgPyBbbiwgaCAqIGJsb2Nrc2l6ZSwgdyAqIGJsb2Nrc2l6ZSwgYyAvIGJsb2Nrc2l6ZSAqKiAyXVxuICAgICAgICA6IFtuLCBjIC8gYmxvY2tzaXplICoqIDIsIGggKiBibG9ja3NpemUsIHcgKiBibG9ja3NpemVdO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IHNoYXBlQmVmb3JlUGVybSA9IHJlc2hhcGVkSW5wdXRUZW5zb3IuZGltcztcbiAgICAgIGNvbnN0IHNoYXBlQWZ0ZXJQZXJtID0gU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShzaGFwZUJlZm9yZVBlcm0sIHBlcm0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhzaGFwZUJlZm9yZVBlcm0sIHNoYXBlQWZ0ZXJQZXJtKSxcbiAgICAgICAgXSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZGVwdGhUb1NwYWNlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZURlcHRoVG9TcGFjZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGJsb2Nrc2l6ZTogYXR0cmlidXRlcy5ibG9ja3NpemUgYXMgbnVtYmVyLFxuICAgIG1vZGU6IGF0dHJpYnV0ZXMubW9kZSBhcyBzdHJpbmcsXG4gICAgZm9ybWF0OiBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVycsXG4gIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVpbnN1bUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBlcXVhdGlvbjogc3RyaW5nO1xufVxuLy8gVGhlIGVxdWF0aW9uIGF0dHJpYnV0ZSB2YWx1ZSBpcyBhIHN0cmluZyB3aGljaCBjb25zaXN0cyBvZiBsZWZ0IGhhbmQgc2lkZSAoTEhTKSBhbmQgb3B0aW9uYWxseSByaWdodCBoYW5kIHNpZGUgKFJIUylcbi8vIHNlcGFyYXRlZCBieSAnLT4nLiBFeC4gXCJpaixqayAtPiBpa1wiIGV4cHJlc3NlcyBtYXRyaXggbXVsdGlwbGljYXRpb25cbi8vICAgICBcImlqLT5qaVwiIGV4cHJlc3NlcyBtYXRyaXggdHJhbnNwb3NlXG4vLyAgICAgIFwiaWktPmlcIiBkaWFnb25hbCBlbGVtZW50cyBvZiBhIHNxdWFyZSBtYXRyaXhcbi8vIExIUyBjb25zaXN0cyBvZiBhIHNlcXVlbmNlIG9mIHRlcm1zIHNlcGFyYXRlZCBieSBjb21tYXMuIEVhY2ggdGVybSBjb3JyZXNwb25kcyB0byBhbiBpbnB1dCB2YXJpYWJsZS5cbi8vIEVhY2ggc3ltYm9sIGNvcnJlc3BvbmRzIHRvIGEgZGltZW5zaW9uIGluIHRoZSBpbnB1dCB2YXJpYWJsZS4gVGhlIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dGVyLCAnYScgdG8gJ3onIG9yICdBJyB0b1xuLy8gJ1onIG9yICcuLi4nIHRvIHJlcHJlc2VudCBhcmJpdHJhcnkgZGltZW5zaW9ucy5cblxuY29uc3Qgc3ltYm9sUGF0dGVybiA9ICdbYS16QS1aXXxcXFxcLlxcXFwuXFxcXC4nOyAvLyBUaGUgcGF0dGVybiBlYWNoIHN5bWJvbCBpbiBlYWNoIHRlcm0gaW4gdGhlIHN5bWJvbGljIGVxdWF0aW9uIHNob3VsZCBtYXRjaFxuY29uc3QgdGVybVBhdHRlcm4gPSAnKCcgKyBzeW1ib2xQYXR0ZXJuICsgJykrJzsgLy8gVGhlIHBhdHRlcm4gZWFjaCB0ZXJtIGluIHRoZSBzeW1ib2xpYyBlcXVhdGlvbiBzaG91bGQgbWF0Y2hcbmNvbnN0IHRlcm1QYXR0ZXJuT25seSA9ICdeJyArIHRlcm1QYXR0ZXJuICsgJyQnOyAvLyBUaGUgcGF0dGVybnMgb25seSBtYXRjaGVzIGEgdGVybSBiZWdpbiB0byBlbmQuXG5jb25zdCBsaHNQYXR0ZXJuID0gJygnICsgdGVybVBhdHRlcm4gKyAnLCkqJyArIHRlcm1QYXR0ZXJuOyAvLyBUaGUgcGF0dGVybiB0aGUgTEhTIHNob3VsZCBtYXRjaFxuY29uc3QgbGhzUGF0dGVybk9ubHkgPSAnXicgKyBsaHNQYXR0ZXJuICsgJyQnOyAvLyBUaGUgcGF0dGVybnMgb25seSBtYXRjaGVzIGEgTEhTIGJlZ2luIHRvIGVuZC5cblxuaW50ZXJmYWNlIFN5bWJvbEluZm8ge1xuICBjb3VudDogbnVtYmVyOyAvLyBTeW1ib2wgY29ycmVzcG9uZGluZyB0byBhIGRpbWVuc2lvbiBvZiBhbiBpbnB1dFxuICBpbnB1dEluZGljZXM6IG51bWJlcltdOyAvLyBOdW1iZXIgb2YgaW5wdXQgdmFyaWFibGVzIHRoZSBzeW1ib2wgY29ycmVzcG9uZHMgdG9cbiAgZGltVmFsdWU6IG51bWJlcjsgLy8gTnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhlIHN5bWJvbCBjb3JyZXNwb25kcyB0b1xufVxuXG5jbGFzcyBFaW5zdW1UZXJtIHtcbiAgY29uc3RydWN0b3IoaW5wdXRJbmRleCA9IC0xKSB7XG4gICAgdGhpcy5zeW1ib2xUb0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyW10+KCk7XG4gICAgdGhpcy5pbnB1dEluZGV4ID0gaW5wdXRJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCBhIHN5bWJvbCB0byB0aGUgdGVybVxuICBhZGRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZS5wdXNoKGluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHN5bWJvbCwgdmFsdWUpO1xuICB9XG5cbiAgc3ltYm9sVG9JbmRpY2VzOiBNYXA8c3RyaW5nLCBudW1iZXJbXT47IC8vIE1hcCBmcm9tIHN5bWJvbCB0byBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dCBjb3JyZXNwb25kaW5nIHRvIHRoZSB0ZXJtXG4gIGlucHV0SW5kZXg6IG51bWJlcjsgLy8gLTEgZm9yIG91dHB1dCBhbmQgMCwgMSwgMiwgLi4uIGZvciBpbnB1dHNcbn1cblxuY2xhc3MgRWluc3VtRXF1YXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZXF1YXRpb246IHN0cmluZyxcbiAgKSB7XG4gICAgdGhpcy5oYXNFbGxpcHNpcyA9IGZhbHNlO1xuICAgIHRoaXMuc3ltYm9sVG9JbmZvID0gbmV3IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+KCk7XG4gICAgdGhpcy5saHMgPSBuZXcgQXJyYXk8RWluc3VtVGVybT4oKTtcbiAgICB0aGlzLm91dHB1dERpbXMgPSBbXTtcbiAgICAvLyBBcyByaHMgbmVlZHMgdG8gYmUgdXBkYXRlZCBhbGxvdyB1c2luZyBsZXQgaW5zdGVhZCBvZiBjb25zdCBmb3IgYm90aCBsaHMgYW5kIHJocy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IFtsaHMsIHJoc10gPSBlcXVhdGlvbi5pbmNsdWRlcygnLT4nKSA/IGVxdWF0aW9uLnNwbGl0KCctPicsIDIpIDogW2VxdWF0aW9uLCAnJ107XG4gICAgaWYgKCFsaHMubWF0Y2goUmVnRXhwKGxoc1BhdHRlcm5Pbmx5KSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFRlcm1zID0gbGhzLnNwbGl0KCcsJyk7XG4gICAgaW5wdXRUZXJtcy5mb3JFYWNoKChpbnB1dFRlcm0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkaW1zID0gaW5wdXRzW2luZGV4XS5kaW1zLnNsaWNlKCk7XG4gICAgICBpZiAoIWlucHV0VGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExIUyB0ZXJtJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlaW5zdW1UZXJtID0gdGhpcy5wcm9jZXNzVGVybShpbnB1dFRlcm0sIHRydWUsIGRpbXMsIGluZGV4KTtcbiAgICAgIHRoaXMubGhzLnB1c2goZWluc3VtVGVybSk7XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBSSFMgaWYgbm90IHNwZWNpZmllZFxuICAgIGlmIChyaHMgPT09ICcnKSB7XG4gICAgICAvLyBDb25zdHJ1Y3QgUkhTIGZyb20gTEhTIHRlcm1zL3N5bWJvbHNcbiAgICAgIHJocyArPSBbLi4udGhpcy5zeW1ib2xUb0luZm8uZW50cmllcygpXVxuICAgICAgICAuZmlsdGVyKChbc3ltLCBpbmZvXSkgPT4gaW5mby5jb3VudCA9PT0gMSB8fCBzeW0gPT09ICcuLi4nKVxuICAgICAgICAubWFwKChbc3ltXSkgPT4gc3ltKVxuICAgICAgICAuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmhzLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybikpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSSFMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIG91dHB1dCBkaW1zXG4gICAgY29uc3QgcmhzU3ltYm9scyA9IHJocy5tYXRjaChSZWdFeHAoc3ltYm9sUGF0dGVybiwgJ2cnKSk7XG4gICAgcmhzU3ltYm9scz8uZm9yRWFjaCgoc3ltYm9sKSA9PiB7XG4gICAgICBpZiAoc3ltYm9sID09PSAnLi4uJykge1xuICAgICAgICB0aGlzLm91dHB1dERpbXMgPSB0aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLnN5bWJvbFRvSW5mby5nZXQoc3ltYm9sKTtcbiAgICAgICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSSFMgc3ltYm9sJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXREaW1zLnB1c2goaW5mby5kaW1WYWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yaHMgPSB0aGlzLnByb2Nlc3NUZXJtKHJocywgZmFsc2UsIHRoaXMub3V0cHV0RGltcyk7XG4gIH0gLy8gRW5kIG9mIEVpbnN1bUVxYXRpb24gY29uc3RydWN0b3JcblxuICAvLyBBZGQgYSBzeW1ib2wgdG8gdGhlIGVxdWF0aW9uXG4gIGFkZFN5bWJvbChzeW1ib2w6IHN0cmluZywgZGltVmFsdWU6IG51bWJlciwgaW5wdXRJbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IGluZm8gPSB0aGlzLnN5bWJvbFRvSW5mby5nZXQoc3ltYm9sKTtcbiAgICBpZiAoaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mby5kaW1WYWx1ZSAhPT0gZGltVmFsdWUgJiYgaW5mby5jb3VudCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mby5jb3VudCsrO1xuICAgICAgICBpbmZvLmlucHV0SW5kaWNlcy5wdXNoKGlucHV0SW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0geyBjb3VudDogMSwgZGltVmFsdWUsIGlucHV0SW5kaWNlczogW2lucHV0SW5kZXhdIH07XG4gICAgfVxuICAgIHRoaXMuc3ltYm9sVG9JbmZvLnNldChzeW1ib2wsIGluZm8pO1xuICB9XG5cbiAgLy8gUHJvY2VzcyBvbmUgaW5wdXQvb3V0cHV0IHRlcm1cbiAgcHJvY2Vzc1Rlcm0odGVybTogc3RyaW5nLCBpc0lucHV0OiBib29sZWFuLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSwgaW5kZXggPSAtMSk6IEVpbnN1bVRlcm0ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBsZXQgZWxsaXBzaXMgPSBmYWxzZTtcbiAgICBsZXQgZWxsaXBzaXNEaW1zID0gW107XG4gICAgbGV0IG5leHREaW0gPSAwO1xuICAgIC8vIEZvciBvdXRwdXQgZW1wdHkgc3RyaW5nIGlzIGFsbG93ZWQgYmVjYXVzZSB0aGUgb3V0cHV0IG1heSBiZSByZWR1Y2VkIHRvIGEgc2NhbGFyIHZhbHVlXG4gICAgaWYgKCF0ZXJtLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybk9ubHkpKSAmJiAhaXNJbnB1dCAmJiB0ZXJtICE9PSAnJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExIUyB0ZXJtJyk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4U3ltYm9scyA9IHRlcm0ubWF0Y2goUmVnRXhwKHN5bWJvbFBhdHRlcm4sICdnJykpO1xuICAgIGNvbnN0IGVpbnN1bVRlcm0gPSBuZXcgRWluc3VtVGVybShpbmRleCk7XG4gICAgLy8gc3ltYm9sIGNhbiBiZSBlaXRoZXIgYSBsZXR0cmUsICdhJyB0byAneicgb3IgJ0EnIHRvICdaJywgb3IgJy4uLidcbiAgICBpbmRleFN5bWJvbHM/LmZvckVhY2goKHN5bWJvbDogc3RyaW5nLCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChzeW1ib2wgPT09ICcuLi4nKSB7XG4gICAgICAgIGlmIChlbGxpcHNpcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybScpO1xuICAgICAgICB9XG4gICAgICAgIGVsbGlwc2lzID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxsaXBzaXNEaW1MZW5ndGggPSByYW5rIC0gaW5kZXhTeW1ib2xzLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChlbGxpcHNpc0RpbUxlbmd0aCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsbGlwc2lzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbGxpcHNpc0RpbXMgPSBkaW1zLnNsaWNlKG5leHREaW0sIG5leHREaW0gKyBlbGxpcHNpc0RpbUxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0VsbGlwc2lzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoICE9PSBlbGxpcHNpc0RpbXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLmVsbGlwc2lzRGltcy50b1N0cmluZygpICE9PSBlbGxpcHNpc0RpbXMudG9TdHJpbmcoKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzSW5wdXQpIHtcbiAgICAgICAgICB0aGlzLmhhc0VsbGlwc2lzID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVsbGlwc2lzRGltcyA9IGVsbGlwc2lzRGltcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsIGV0YyB0byByZXByZXNlbnQgZWxsaXBzaXMgZGltZW5zaW9ucyB0byBhdm9pZCBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZWxsaXBzaXNEaW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgc3ltYm9sID0gU3RyaW5nLmZyb21DaGFyQ29kZSgnMCcuY2hhckNvZGVBdCgwKSArIGopO1xuICAgICAgICAgIGVpbnN1bVRlcm0uYWRkU3ltYm9sKHN5bWJvbCwgaSArIGopO1xuICAgICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVpbnN1bVRlcm0uYWRkU3ltYm9sKHN5bWJvbCwgaSArICh0aGlzLmhhc0VsbGlwc2lzID8gdGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIC0gMSA6IDApKTtcbiAgICAgICAgdGhpcy5hZGRTeW1ib2woc3ltYm9sLCBkaW1zW25leHREaW0rK10sIGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZWluc3VtVGVybTtcbiAgfVxuXG4gIHN5bWJvbFRvSW5mbzogTWFwPHN0cmluZywgU3ltYm9sSW5mbz47IC8vIEFsbCBzeW1ib2xzIGluIHRoZSBlcXVhdGlvblxuICBoYXNFbGxpcHNpczogYm9vbGVhbjsgLy8gVGhlIGVxdWF0aW9uIGhhcyBlbGxpcHNpcyBvciBub3RcbiAgZWxsaXBzaXNEaW1zOiBudW1iZXJbXTsgLy8gVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVxdWF0aW9uIGVsbGlwc2lzIGNvcnJlc3BvbmRzIHRvLlxuICBsaHM6IEVpbnN1bVRlcm1bXTsgLy8gVGVybXMgb24gdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBlcXVhdGlvblxuICByaHM6IEVpbnN1bVRlcm07IC8vIFRlcm0gb24gdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cbiAgb3V0cHV0RGltczogbnVtYmVyW107IC8vIE91dHB1dCBkaW1lbnNpb25zIG9mIHRoZSBlcXVhdGlvblxufSAvLyBFbmQgb2YgY2xhc3MgRWluc3VtRXF1YXRpb25cblxuY29uc3QgYXBwZW5kTWF4ID0gKG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PiBuYW1lICsgJ19tYXgnO1xuXG5jb25zdCBjcmVhdGVFaW5zdW1Qcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRTaGFwZXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPixcbiAgZGF0YVR5cGU6IG51bWJlcixcbiAgZWluc3VtRXF1YXRpb246IEVpbnN1bUVxdWF0aW9uLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHJhbmtzID0gaW5wdXRTaGFwZXMubWFwKChkaW1zKSA9PiBkaW1zLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0VmFycyA9IHJhbmtzLm1hcCgocmFuaywgaW5kZXgpID0+IGlucHV0VmFyaWFibGUoYGlucHV0JHtpbmRleH1gLCBkYXRhVHlwZSwgcmFuaykpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IHVuaWZvcm1zU3ltYm9scyA9IFsuLi5laW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8ua2V5cygpXS5maWx0ZXIoXG4gICAgKHN5bWJvbCkgPT4gIWVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKHN5bWJvbCksXG4gICk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlkeENvcHk6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgaW5pdFByb2QgPSAndmFyIHByb2QgPSAxLjA7JztcbiAgICBjb25zdCBpbml0U3VtID0gJ3ZhciBzdW0gPSAwLjA7JztcbiAgICBjb25zdCB1cGRhdGVTdW0gPSAnc3VtICs9IHByb2Q7JztcbiAgICBjb25zdCByZWR1Y2VPcHNTZXRJbmRpY2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHJlZHVjZU9wc0xvb3BIZWFkZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHJlZHVjZU9wc0xvb3BGb290ZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHJlZHVjZU9wQ29tcHV0ZTogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBpc1JlZHVjZU9wc1dpdGhvdXRMb29wID0gZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLnNpemUgPT09IGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuc2l6ZTtcbiAgICBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZm9yRWFjaCgoaW5mbywgc3ltYm9sKSA9PiB7XG4gICAgICBpZiAoZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoc3ltYm9sKSkge1xuICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk/LlswXTtcbiAgICAgICAgaWYgKG91dHB1dEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlaW5zdW1FcXVhdGlvbi5saHMuZm9yRWFjaCgodGVybSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZm8uaW5wdXRJbmRpY2VzLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0ZXJtLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICAgICAgaWYgKGluZGljZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzeW1ib2wgZXJyb3InKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbmRpY2VzLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWR4Q29weS5wdXNoKFxuICAgICAgICAgICAgICAgICAgYCR7aW5wdXRWYXJzW2ldLmluZGljZXNTZXQoXG4gICAgICAgICAgICAgICAgICAgIGBpbnB1dCR7aX1JbmRpY2VzYCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgb3V0cHV0SW5kZXgpLFxuICAgICAgICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlaW5zdW1FcXVhdGlvbi5saHMuZm9yRWFjaCgodGVybSwgaSkgPT4ge1xuICAgICAgICAgIGlmIChpbmZvLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhpKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRlcm0uc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpO1xuICAgICAgICAgICAgaWYgKGluZGljZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sIGVycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRpY2VzLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIHJlZHVjZU9wc1NldEluZGljZXMucHVzaChgJHtpbnB1dFZhcnNbaV0uaW5kaWNlc1NldChgaW5wdXQke2l9SW5kaWNlc2AsIGluZGV4LCBgJHtzeW1ib2x9YCl9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlZHVjZU9wQ29tcHV0ZS5wdXNoKGBwcm9kICo9ICR7aW5wdXRWYXJzW2ldLmdldEJ5SW5kaWNlcyhgaW5wdXQke2l9SW5kaWNlc2ApfTtgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZWR1Y2VPcHNMb29wSGVhZGVycy5wdXNoKFxuICAgICAgICAgIGBmb3IodmFyICR7c3ltYm9sfTogdTMyID0gMDsgJHtzeW1ib2x9IDwgdW5pZm9ybXMuJHthcHBlbmRNYXgoc3ltYm9sKX07ICR7c3ltYm9sfSsrKSB7YCxcbiAgICAgICAgKTtcbiAgICAgICAgcmVkdWNlT3BzTG9vcEZvb3RlcnMucHVzaCgnfScpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHJlZHVjZU9wcyA9IGlzUmVkdWNlT3BzV2l0aG91dExvb3BcbiAgICAgID8gW1xuICAgICAgICAgIC4uLmlkeENvcHksXG4gICAgICAgICAgYGxldCBzdW0gPSAke2lucHV0VmFycy5tYXAoKGlucHV0VmFyLCBpKSA9PiBpbnB1dFZhci5nZXRCeUluZGljZXMoYGlucHV0JHtpfUluZGljZXNgKSkuam9pbignICogJyl9O2AsXG4gICAgICAgIF1cbiAgICAgIDogW1xuICAgICAgICAgIC4uLmlkeENvcHksXG4gICAgICAgICAgaW5pdFN1bSxcbiAgICAgICAgICAuLi5yZWR1Y2VPcHNMb29wSGVhZGVycyxcbiAgICAgICAgICAuLi5yZWR1Y2VPcHNTZXRJbmRpY2VzLFxuICAgICAgICAgIGluaXRQcm9kLFxuICAgICAgICAgIC4uLnJlZHVjZU9wQ29tcHV0ZSxcbiAgICAgICAgICB1cGRhdGVTdW0sXG4gICAgICAgICAgLi4ucmVkdWNlT3BzTG9vcEZvb3RlcnMsXG4gICAgICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zU3ltYm9scy5tYXAoKHN5bWJvbCkgPT4gKHsgbmFtZTogYCR7YXBwZW5kTWF4KHN5bWJvbCl9YCwgdHlwZTogJ3UzMicgfSkpKVxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICR7aW5wdXRWYXJzLm1hcCgoX3ZhciwgaSkgPT4gYHZhciBpbnB1dCR7aX1JbmRpY2VzOiAke2lucHV0VmFyc1tpXS50eXBlLmluZGljZXN9O2ApLmpvaW4oJ1xcbicpfVxuICAgICAgICAgICAgJHtyZWR1Y2VPcHMuam9pbignXFxuJyl9O1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc3VtJyl9O1xuICAgICAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdFaW5zdW0nLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGVpbnN1bUVxdWF0aW9uLmVxdWF0aW9uLCBpbnB1dERlcGVuZGVuY2llczogaW5wdXRTaGFwZXMubWFwKCgpID0+ICdyYW5rJykgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XG4gICAgICAvLyBUaGUgc3ltYm9scyBmcm9tIHVuaWZvcm1TeW1ib2xzIGFycmF5IGFyZSBndWFyYW50ZWVkIHRvIGV4aXN0IGluIGVpbnN1bUVxdWF0aW9ucy5zeW1ib2xUb0luZm8gbWFwLiBUaGVcbiAgICAgIC8vIGZpbHRlciBpcyBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCBkaW1WYWx1ZSBpcyBuZXZlciAwLlxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zSW5pdDogUHJvZ3JhbVVuaWZvcm1bXSA9IHVuaWZvcm1zU3ltYm9sc1xuICAgICAgICAuZmlsdGVyKChzeW1ib2wpID0+IGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5oYXMoc3ltYm9sKSlcbiAgICAgICAgLm1hcCgoc3ltYm9sKSA9PiAoeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5nZXQoc3ltYm9sKT8uZGltVmFsdWUgfHwgMCB9KSk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXNJbml0LnB1c2goeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSk7XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBpbnB1dFNoYXBlc1xuICAgICAgICAubWFwKChkaW1zLCBfKSA9PiBbLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoZGltcyldKVxuICAgICAgICAucmVkdWNlKChhY2MsIGlucHV0UHJvZ3JhbVVuaWZvcm1zKSA9PiBhY2MuY29uY2F0KGlucHV0UHJvZ3JhbVVuaWZvcm1zKSwgcHJvZ3JhbVVuaWZvcm1zSW5pdCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZWluc3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBFaW5zdW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGVpbnN1bUVxdWF0aW9uID0gbmV3IEVpbnN1bUVxdWF0aW9uKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLmVxdWF0aW9uKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBlaW5zdW1FcXVhdGlvbi5vdXRwdXREaW1zO1xuICBjb25zdCBpbnB1dFNoYXBlcyA9IGNvbnRleHQuaW5wdXRzLm1hcCgoaW5wdXQsIF8pID0+IGlucHV0LmRpbXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWluc3VtUHJvZ3JhbUluZm8oaW5wdXRTaGFwZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBlaW5zdW1FcXVhdGlvbiwgb3V0cHV0U2hhcGUpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBFaW5zdW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgZXF1YXRpb24gPSAoYXR0cmlidXRlcy5lcXVhdGlvbiBhcyBzdHJpbmcpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgZXF1YXRpb24gfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBhbmQgcmVxdWlyZXMgMiBpbnB1dC4nKTtcbiAgfVxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHNoYXBlID0gQXJyYXkuZnJvbShpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpLCBOdW1iZXIpO1xuXG4gIGxldCBzaGFwZUluZGV4ID0gc2hhcGUubGVuZ3RoIDwgaW5wdXRTaGFwZS5sZW5ndGggPyAwIDogc2hhcGUubGVuZ3RoIC0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGxldCBpbnB1dFNoYXBlSW5kZXggPSBpbnB1dFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCA/IDAgOiBpbnB1dFNoYXBlLmxlbmd0aCAtIHNoYXBlLmxlbmd0aDtcbiAgZm9yICg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGggJiYgaW5wdXRTaGFwZUluZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsrc2hhcGVJbmRleCwgKytpbnB1dFNoYXBlSW5kZXgpIHtcbiAgICBpZiAoXG4gICAgICBzaGFwZVtzaGFwZUluZGV4XSAhPT0gaW5wdXRTaGFwZVtpbnB1dFNoYXBlSW5kZXhdICYmXG4gICAgICBzaGFwZVtzaGFwZUluZGV4XSAhPT0gMSAmJlxuICAgICAgaW5wdXRTaGFwZVtpbnB1dFNoYXBlSW5kZXhdICE9PSAxXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0Jyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFNoYXBlID0gKHNoYXBlMTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlMjogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGRpZmYgPSBzaGFwZTEubGVuZ3RoIC0gc2hhcGUyLmxlbmd0aDtcbiAgY29uc3Qgc2hhcGU6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgKytpKSB7XG4gICAgc2hhcGUucHVzaChzaGFwZTFbaV0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUyLmxlbmd0aDsgKytpKSB7XG4gICAgc2hhcGUucHVzaChzaGFwZTJbaV0gPT09IDEgPyBzaGFwZTFbaSArIGRpZmZdIDogc2hhcGUyW2ldKTtcbiAgfVxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT5cbiAgaW5wdXRTaGFwZS5sZW5ndGggPiBzaGFwZS5sZW5ndGggPyBnZXRBZGp1c3RlZFNoYXBlKGlucHV0U2hhcGUsIHNoYXBlKSA6IGdldEFkanVzdGVkU2hhcGUoc2hhcGUsIGlucHV0U2hhcGUpO1xuXG5jb25zdCBjcmVhdGVFeHBhbmRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2hhcGUpO1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaXNCb29sT3JTY2FsYXIgPSBkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCB8fCBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKSA9PT0gMTtcbiAgY29uc3QgaUNvbXBvbmVudHMgPVxuICAgIGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sID8gNCA6IGlucHV0U2hhcGUubGVuZ3RoID4gMCAmJiBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV0gJSA0ID09PSAwID8gNCA6IDE7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc0Jvb2xPclNjYWxhclxuICAgID8gNFxuICAgIDogb3V0cHV0U2hhcGUubGVuZ3RoID4gMCAmJiBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSAlIDQgPT09IDBcbiAgICAgID8gNFxuICAgICAgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGlDb21wb25lbnRzKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcbiAgICBpZiAoZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4gYFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHt4fXVgKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7eH0gPSAke2lucHV0LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7eH0gPSBvZmZzZXQke3h9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7eH0gPSBvZmZzZXQke3h9ICUgNHU7XG4gICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtpbnB1dC5nZXRCeU9mZnNldChgaW5kZXgke3h9YCl9W2NvbXBvbmVudCR7eH1dKTtcbiAgICAgICAgYDtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfTtcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDAsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDMsICd1MzInKX1cbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnZGF0YScpfVxuICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfWApfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtpbnB1dC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICBsZXQgZGF0YSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KCR7aW5wdXQuZ2V0QnlPZmZzZXQoYGlucHV0T2Zmc2V0IC8gJHtpQ29tcG9uZW50c31gKX0pO1xuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdkYXRhJyl9XG4gICAgICB9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAke2Fzc2lnbm1lbnR9YDtcbiAgfTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXG4gIF07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0V4cGFuZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7b3V0cHV0U2hhcGUubGVuZ3RofTske2lDb21wb25lbnRzfSR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGV4cGFuZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFeHBhbmRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cyksIHsgaW5wdXRzOiBbMF0gfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG4gIFdPUktHUk9VUF9TSVpFLFxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgKiBhcyB1bmFyeSBmcm9tICcuL3VuYXJ5LW9wJztcblxuLy8gR0VMVSBpcyBkZWZpbmVkIGFzIFk9MC41KlgqKDErdGFuaCgwLjc5Nzg4NSpYKzAuMDM1Njc3KlgqWCpYKSksIHdoZXJlIFggbWF5IHByZS1hZGQgYSBiaWFzLlxuXG5jb25zdCBjcmVhdGVGYXN0R2VsdVByb2dyYW1JbmZvID0gKGlucHV0VGVuc29yczogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0VGVuc29yc1swXS5kYXRhVHlwZTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0VGVuc29yc1swXS5kaW1zKTtcbiAgY29uc3QgYmlhc0xlbmd0aCA9IFNoYXBlVXRpbC5zaXplKGlucHV0VGVuc29yc1sxXS5kaW1zKTtcbiAgLy8gY2FuIG9ubHkgdXNlIHZlYzQgd2hlbiBiaWFzIGxlbmd0aCBpcyBtdWx0aXBsZSBvZiA0XG4gIGNvbnN0IHVzZVZlYzQgPSBiaWFzTGVuZ3RoICUgNCA9PT0gMDtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGRhdGFUeXBlLCBbMV0sIDQpO1xuICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgZGF0YVR5cGUsIFsxXSwgNCk7XG4gICAgY29uc3QgeSA9IG91dHB1dFZhcmlhYmxlKCd5JywgZGF0YVR5cGUsIFsxXSwgNCk7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfdmVjX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmlhc19zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuXG4gICAgY29uc3Qgc2luZ2xlRWxlbWVudEJpYXMgPSAoaTogMCB8IDEgfCAyIHwgMykgPT4gYFxuICAgICAgbGV0IGJpYXMke2l9X29mZnNldDogdTMyID0gKGdsb2JhbF9pZHggKiA0ICsgJHtpfSkgJSB1bmlmb3Jtcy5iaWFzX3NpemU7XG4gICAgICBsZXQgYmlhcyR7aX0gPSAke2JpYXMuZ2V0QnlPZmZzZXQoYGJpYXMke2l9X29mZnNldCAvIDRgKX1bYmlhcyR7aX1fb2Zmc2V0ICUgNF07YDtcbiAgICBjb25zdCBiaWFzR2V0RXhwcmVzc2lvbiA9IHVzZVZlYzRcbiAgICAgID8gYFxuICAgICAgbGV0IGJpYXMgPSAke2JpYXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHggJSAodW5pZm9ybXMuYmlhc19zaXplIC8gNCknKX07YFxuICAgICAgOiBgJHtzaW5nbGVFbGVtZW50QmlhcygwKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDEpfSR7c2luZ2xlRWxlbWVudEJpYXMoMil9JHtzaW5nbGVFbGVtZW50QmlhcygzKX1cbiAgICAgIGxldCBiaWFzID0gJHt4LnR5cGUudmFsdWV9KGJpYXMwLCBiaWFzMSwgYmlhczIsIGJpYXMzKTtgO1xuXG4gICAgcmV0dXJuIGAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHgsIGJpYXMsIHkpfVxuXG4gICAgJHt1bmFyeS5mYXN0R2VsdUltcGwodGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShkYXRhVHlwZSkpfVxuXG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdPUktHUk9VUF9TSVpFKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF92ZWNfc2l6ZScpfVxuXG4gICAgICBsZXQgeCA9ICR7eC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICR7Ymlhc0dldEV4cHJlc3Npb259XG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xuICAgICAgJHt5LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgdW5hcnkuZmFzdEdlbHVFeHByZXNzaW9uKCd4X2luJykpfVxuICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0Zhc3RHZWx1V2l0aEJpYXMnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3VzZVZlYzR9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ10gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0cykgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDQpIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBiaWFzTGVuZ3RoIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIFdPUktHUk9VUF9TSVpFIC8gNCkgfSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBmYXN0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBpZiAoY29udGV4dC5pbnB1dHMubGVuZ3RoIDwgMiB8fCBTaGFwZVV0aWwuc2l6ZShjb250ZXh0LmlucHV0c1sxXS5kaW1zKSA9PT0gMCkge1xuICAgIHVuYXJ5LmZhc3RHZWx1KGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVGYXN0R2VsdVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2F0aGVyQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGF4aXM6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcblxuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShheGlzLCAxLCAuLi5pbmRpY2VzU2hhcGUpO1xuXG4gIGNvbnN0IGF4aXNEaW1MaW1pdCA9IGlucHV0U2hhcGVbYXhpc107XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wgPyA0IDogMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzKTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBheGlzRGltTGltaXQgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpcyB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgb3V0cHV0U2hhcGUpLFxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBpbnB1dFZhcmlhYmxlKCdkYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dEluZGljZXMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcblxuICAgIGNvbnN0IGNhbGNEYXRhSW5kaWNlcyA9ICh4OiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgaW5kaWNlc1JhbmsgPSBpbmRpY2VzU2hhcGUubGVuZ3RoO1xuICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGluZGljZXNJbmRpY2VzJHt4fSAgPSAke2luZGljZXMudHlwZS5pbmRpY2VzfSgwKTtgO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzUmFuazsgaSsrKSB7XG4gICAgICAgIGNhbGNTdHIgKz0gYCR7aW5kaWNlc1JhbmsgPiAxID8gYGluZGljZXNJbmRpY2VzJHt4fVske2l9XWAgOiBgaW5kaWNlc0luZGljZXMke3h9YH0gPSAke1xuICAgICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCA+IDEgPyBgb3V0cHV0SW5kaWNlcyR7eH1bdW5pZm9ybXMuYXhpcyArICR7aX1dYCA6IGBvdXRwdXRJbmRpY2VzJHt4fWBcbiAgICAgICAgfTtgO1xuICAgICAgfVxuICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgdmFyIGlkeCR7eH0gPSAke2luZGljZXMuZ2V0QnlJbmRpY2VzKGBpbmRpY2VzSW5kaWNlcyR7eH1gKX07XG4gICAgICAgICAgaWYgKGlkeCR7eH0gPCAwKSB7XG4gICAgICAgICAgICBpZHgke3h9ID0gaWR4JHt4fSArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzJHt4fSA6ICR7ZGF0YS50eXBlLmluZGljZXN9O1xuICAgICAgICBgO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IGF4aXMpIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGAke2lucHV0UmFuayA+IDEgPyBgZGF0YUluZGljZXMke3h9WyR7aX1dYCA6IGBkYXRhSW5kaWNlcyR7eH1gfSA9IHUzMihpZHgke3h9KTtgO1xuICAgICAgICAgIGogKz0gaW5kaWNlc1Jhbms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgJHtpbnB1dFJhbmsgPiAxID8gYGRhdGFJbmRpY2VzJHt4fVske2l9XWAgOiBgZGF0YUluZGljZXMke3h9YH0gPSAke1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoID4gMSA/IGBvdXRwdXRJbmRpY2VzJHt4fVske2p9XWAgOiBgb3V0cHV0SW5kaWNlcyR7eH1gXG4gICAgICAgICAgfTtgO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4gYFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHt4fXVgKX07XG4gICAgICAgICAgJHtjYWxjRGF0YUluZGljZXMoeCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtkYXRhLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke3h9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7eH0gPSBvZmZzZXQke3h9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7eH0gPSBvZmZzZXQke3h9ICUgNHU7XG4gICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtkYXRhLmdldEJ5T2Zmc2V0KGBpbmRleCR7eH1gKX1bY29tcG9uZW50JHt4fV0pO1xuICAgICAgICBgO1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9O1xuICAgICAgICB2YXIgdmFsdWUgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAwLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAxLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAyLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAzLCAndTMyJyl9XG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XG4gICAgICBgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAke2NhbGNEYXRhSW5kaWNlcygnJyl9O1xuICAgICAgbGV0IHZhbHVlID0gJHtkYXRhLmdldEJ5SW5kaWNlcygnZGF0YUluZGljZXMnKX07XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgICAgIGA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICAke3NoYWRlckhlbHBlclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXNEaW1MaW1pdCcsICdpMzInKVxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzJywgJ3UzMicpXG4gICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGRhdGEsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2F0aGVyJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnXSB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuXG5leHBvcnQgY29uc3QgZ2F0aGVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlck5EQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGJhdGNoRGltczogbnVtYmVyO1xufVxuXG5jb25zdCBjb21wdXRlU2xpY2VPZmZzZXRzID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5kaWNlc0RhdGE6IFRlbnNvclZpZXcsXG4gIHNpemVzRnJvbVNsaWNlRGltc0RhdGE6IG51bWJlcltdLFxuICBiYXRjaERpbXM6IG51bWJlcixcbiAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgbnVtU2xpY2VzOiBudW1iZXIsXG4gIG51bVNsaWNlc1BlckJhdGNoOiBudW1iZXIsXG4gIGlucHV0QmF0Y2hTdHJpZGU6IG51bWJlcixcbiAgbnVtU2xpY2VEaW1zOiBudW1iZXIsXG4pID0+IHtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1TbGljZXMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmF0Y2hEaW1zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0RGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaXplc0Zyb21TbGljZURpbXNEYXRhIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG51bVNsaWNlc1BlckJhdGNoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0QmF0Y2hTdHJpZGUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbnVtU2xpY2VEaW1zIH0sXG4gIF07XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbbnVtU2xpY2VzXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5kaWNlc0RhdGEuZGltcywgb3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlc19kYXRhJywgaW5kaWNlc0RhdGEuZGF0YVR5cGUsIGluZGljZXNEYXRhLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhJywgRGF0YVR5cGUudWludDMyLCAxLCAxKTtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbaW5kaWNlcywgb3V0cHV0XTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdiYXRjaF9kaW1zJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2lucHV0X2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBpbnB1dERpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YScsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHNpemVzRnJvbVNsaWNlRGltc0RhdGEubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdudW1fc2xpY2VzX3Blcl9iYXRjaCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdpbnB1dF9iYXRjaF9zdHJpZGUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnbnVtX3NsaWNlX2RpbXMnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMubnVtX3NsaWNlc19wZXJfYmF0Y2g7XG4gICAgbGV0IGJhc2Vfb2Zmc2V0ID0gYmF0Y2hfaWR4ICogdW5pZm9ybXMuaW5wdXRfYmF0Y2hfc3RyaWRlO1xuXG4gICAgbGV0IHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7XG4gICAgdmFyIHJlbGF0aXZlX3NsaWNlX29mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgZGltX2lkeCA9IDB1OyBkaW1faWR4IDwgdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7IGRpbV9pZHggKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzX2RhdGFbZGltX2lkeCArIHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXRdLngpO1xuICAgICAgbGV0IGlucHV0X2RpbV9pZHggPSB1bmlmb3Jtcy5iYXRjaF9kaW1zICsgZGltX2lkeDtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgJHtcbiAgICAgICAgICBpbnB1dERpbXMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICA/ICdpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltcyk7J1xuICAgICAgICAgICAgOiAnaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pOydcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJHtcbiAgICAgICAgc2l6ZXNGcm9tU2xpY2VEaW1zRGF0YS5sZW5ndGggPT09IDFcbiAgICAgICAgICA/ICdyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpOydcbiAgICAgICAgICA6ICdyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGFbZGltX2lkeF0pOydcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFbZ2xvYmFsX2lkeF0gPSAgYmFzZV9vZmZzZXQgKyB1MzIocmVsYXRpdmVfc2xpY2Vfb2Zmc2V0KTtcbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnY29tcHV0ZVNsaWNlT2Zmc2V0cycsXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtpbnB1dERpbXMubGVuZ3RofV8ke3NpemVzRnJvbVNsaWNlRGltc0RhdGEubGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1sxXS5kYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwobnVtU2xpY2VzIC8gNjQpIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtpbmRpY2VzRGF0YV0sIG91dHB1dHM6IFstMV0gfSxcbiAgKVswXTtcbn07XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJORCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyTkRBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG51bVNsaWNlRGltcyA9IGluZGljZXNTaGFwZVtpbmRpY2VzU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG51bVNsaWNlcyA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oaW5kaWNlc1NoYXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHNsaWNlU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dFNoYXBlLCBhdHRyaWJ1dGVzLmJhdGNoRGltcyArIG51bVNsaWNlRGltcyk7XG4gIGNvbnN0IG51bUJhdGNoZXMgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGlucHV0U2hhcGUsIGF0dHJpYnV0ZXMuYmF0Y2hEaW1zKTtcbiAgY29uc3QgaW5wdXRCYXRjaFN0cmlkZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dFNoYXBlLCBhdHRyaWJ1dGVzLmJhdGNoRGltcyk7XG4gIGNvbnN0IG51bVNsaWNlc1BlckJhdGNoID0gbnVtU2xpY2VzIC8gbnVtQmF0Y2hlcztcbiAgY29uc3Qgc2l6ZXNGcm9tU2xpY2VEaW1zID0gbmV3IEFycmF5KG51bVNsaWNlRGltcyk7XG4gIGxldCBydW5uaW5nUHJvZHVjdCA9IHNsaWNlU2l6ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TbGljZURpbXM7ICsraSkge1xuICAgIHNpemVzRnJvbVNsaWNlRGltc1tudW1TbGljZURpbXMgLSAxIC0gaV0gPSBydW5uaW5nUHJvZHVjdDtcbiAgICBydW5uaW5nUHJvZHVjdCAqPSBpbnB1dFNoYXBlW2F0dHJpYnV0ZXMuYmF0Y2hEaW1zICsgbnVtU2xpY2VEaW1zIC0gMSAtIGldO1xuICB9XG5cbiAgY29uc3QgaW5wdXRTbGljZU9mZnNldHMgPSBjb21wdXRlU2xpY2VPZmZzZXRzKFxuICAgIGNvbnRleHQsXG4gICAgaW5wdXRzWzFdLFxuICAgIHNpemVzRnJvbVNsaWNlRGltcyxcbiAgICBhdHRyaWJ1dGVzLmJhdGNoRGltcyxcbiAgICBpbnB1dFNoYXBlLFxuICAgIG51bVNsaWNlcyxcbiAgICBudW1TbGljZXNQZXJCYXRjaCxcbiAgICBpbnB1dEJhdGNoU3RyaWRlLFxuICAgIG51bVNsaWNlRGltcyxcbiAgKTtcblxuICBjb25zdCBsYXN0SW5kaWNlc0RpbWVuc2lvbiA9IGF0dHJpYnV0ZXMuYmF0Y2hEaW1zICsgbnVtU2xpY2VEaW1zO1xuICBpZiAobGFzdEluZGljZXNEaW1lbnNpb24gPiBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5kaWNlcyBtdXN0IG5vdCBiZSBsYXJnZXIgdGhhbiByYW5rIG9mIGlucHV0IHRlbnNvcicpO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbmRpY2VzU2hhcGUuc2xpY2UoMCwgLTEpLmNvbmNhdChpbnB1dFNoYXBlLnNsaWNlKGxhc3RJbmRpY2VzRGltZW5zaW9uKSk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNsaWNlU2l6ZSB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dFNsaWNlT2Zmc2V0cy5kaW1zLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdkYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdzbGljZV9vZmZzZXRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dFNsaWNlT2Zmc2V0cy5kaW1zLmxlbmd0aCk7XG5cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXJcbiAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpXG4gICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdzbGljZV9zaXplJywgJ3UzMicpXG4gICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgaW5kaWNlcywgb3V0cHV0KX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICBsZXQgc2xpY2Vfb2Zmc2V0ID0gc2xpY2Vfb2Zmc2V0c1tnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgfWA7XG4gIH07XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnR2F0aGVyTkQnLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10gfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtpbnB1dHNbMF0sIGlucHV0U2xpY2VPZmZzZXRzXSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyTkRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyTkRBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYmF0Y2hEaW1zID0gYXR0cmlidXRlcy5iYXRjaF9kaW1zIGFzIG51bWJlcjtcbiAgcmV0dXJuIHtcbiAgICBiYXRjaERpbXMsXG4gICAgY2FjaGVLZXk6ICcnLFxuICB9O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBnYXRoZXJBeGlzOiBudW1iZXI7XG4gIHF1YW50aXplQXhpczogbnVtYmVyO1xuICBibG9ja1NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJCbG9ja1F1YW50aXplZCByZXF1aXJlcyAzIG9yIDQgaW5wdXRzLicpO1xuICB9XG4gIGNvbnN0IHF1YW50aXplQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMucXVhbnRpemVBeGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBibG9ja1NpemUgPSBhdHRyaWJ1dGVzLmJsb2NrU2l6ZTtcbiAgY29uc3QgZGF0YSA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2NhbGVzID0gaW5wdXRzWzJdO1xuICBjb25zdCB6ZXJvUG9pbnQgPSBpbnB1dHMubGVuZ3RoID09PSA0ID8gaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xuICBpZiAoXG4gICAgc2NhbGVzLmRpbXMubGVuZ3RoICE9PSBkYXRhLmRpbXMubGVuZ3RoIHx8XG4gICAgIWRhdGEuZGltc1xuICAgICAgLm1hcCgoZCwgaSkgPT4gKGkgPT09IHF1YW50aXplQXhpcyA/IE1hdGguY2VpbChkIC8gYmxvY2tTaXplKSA9PT0gc2NhbGVzLmRpbXNbaV0gOiBkID09PSBzY2FsZXMuZGltc1tpXSkpXG4gICAgICAucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdTY2FsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBnYXRoZXJBeGlzLicsXG4gICAgKTtcbiAgfVxuICAvLyBUT0RPIFVuY29tbWVudCB0aGUgZm9sbG93aW5nIGNoZWNrIG9uY2UgdGhlIHRlc3QgY2FzZSBjcmVhdGlvbiBjb2RlIGlzIGZpeGVkIHRvIGNyZWF0ZSBkYXRhIGNvcnJlY3RseSBhbGlnbmVkLlxuICAvLyBjb25zdCBpbmRpY2VzID0gaW5wdXRzWzFdO1xuICAvLyBjb25zdCB2YWxpZEluZGV4ID0gKGluZGV4OiBudW1iZXIpID0+IGluZGV4ID49IDAgJiYgaW5kZXggPCBkYXRhLmRpbXNbYXR0cmlidXRlcy5nYXRoZXJBeGlzXTtcbiAgLy8gaWYgKGluZGljZXMuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyICYmIGluZGljZXMuZ2V0SW50MzJBcnJheSgpLnNvbWUoKHYpID0+ICF2YWxpZEluZGV4KHYpKSB8fFxuICAvLyAgICAgaW5kaWNlcy5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50NjQgJiYgaW5kaWNlcy5nZXRCaWdJbnQ2NEFycmF5KCkuc29tZSgodikgPT4gIXZhbGlkSW5kZXgoTnVtYmVyKHYpKSkpIHtcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ0luZGljZXMgbXVzdCBiZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgZ2F0aGVyQXhpcy4nKTtcbiAgLy8gfVxuICBpZiAoemVyb1BvaW50KSB7XG4gICAgaWYgKHplcm9Qb2ludC5kYXRhVHlwZSAhPT0gZGF0YS5kYXRhVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgdGhlIGlucHV0IHRlbnNvci4nKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgemVyb1BvaW50LmRpbXMubGVuZ3RoICE9PSBzY2FsZXMuZGltcy5sZW5ndGggfHxcbiAgICAgICF6ZXJvUG9pbnQuZGltcy5tYXAoKGQsIGkpID0+IGQgPT09IHNjYWxlcy5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1plcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBxdWFudGl6ZUF4aXMuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJCbG9ja1F1YW50aXplZFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZ2F0aGVyQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuZ2F0aGVyQXhpcywgaW5wdXRSYW5rKTtcbiAgY29uc3QgcXVhbnRpemVBeGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5xdWFudGl6ZUF4aXMsIGlucHV0UmFuayk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGdhdGhlckF4aXMsIDEsIC4uLmluZGljZXNTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFR5cGUgPSBpbnB1dHNbMl0uZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaXNTaWduZWQgPSBpbnB1dFR5cGUgPT09IERhdGFUeXBlLmludDQ7IC8vIGlucHV0IGRhdGEgdHlwZSBpcyBlaXRoZXIgaW50NCBvciB1aW50NC5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHF1YW50aXplQXhpcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnYXRoZXJBeGlzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoLi4uaW5wdXRzLm1hcCgoaW5wdXQsIF8pID0+IGlucHV0LmRpbXMpLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBzY2FsZXMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgemVyb1BvaW50ID1cbiAgICAgIGlucHV0cy5sZW5ndGggPiAzID8gaW5wdXRWYXJpYWJsZSgnemVyb1BvaW50JywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXRUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2RhdGEsIGluZGljZXMsIHNjYWxlc107XG4gICAgaWYgKHplcm9Qb2ludCkge1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnQpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdxdWFudGl6ZV9heGlzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2dhdGhlcl9heGlzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2Jsb2NrX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgdmFyIGluZGljZXNfaW5kaWNlcyA9ICR7aW5kaWNlcy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKGluZGljZXNTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2luZGljZXNTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmdhdGhlcl9heGlzICsgaScpfTtcbiAgICAgICAgICAgICR7aW5kaWNlcy5pbmRpY2VzU2V0KCdpbmRpY2VzX2luZGljZXMnLCAnaScsICdpbmRleCcpfTtcbiAgICAgICAgICB9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBpbmRpY2VzX2luZGljZXMgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICd1bmlmb3Jtcy5nYXRoZXJfYXhpcycpfTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgIHZhciBkYXRhX2luZGljZXMgPSAke2RhdGEudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmdhdGhlcl9heGlzOyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICAgICR7ZGF0YS5pbmRpY2VzU2V0KCdkYXRhX2luZGljZXMnLCAnaScsICdpbmRleCcpfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhfZnJvbV9pbmRpY2VzID0gJHtpbmRpY2VzLmdldEJ5SW5kaWNlcygnaW5kaWNlc19pbmRpY2VzJyl9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke2lucHV0U2hhcGVbZ2F0aGVyQXhpc119O1xuICAgICAgICB9XG4gICAgICAgICR7ZGF0YS5pbmRpY2VzU2V0KCdkYXRhX2luZGljZXMnLCAndW5pZm9ybXMuZ2F0aGVyX2F4aXMnLCAndTMyKGluZGV4X2Zyb21faW5kaWNlcyknKX07XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIDE7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgYGkgKyAke2luZGljZXNTaGFwZS5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke2RhdGEuaW5kaWNlc1NldCgnZGF0YV9pbmRpY2VzJywgJ2knLCAnaW5kZXgnKX07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFfb2Zmc2V0ID0gJHtkYXRhLmluZGljZXNUb09mZnNldCgnZGF0YV9pbmRpY2VzJyl9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtkYXRhLmdldEJ5T2Zmc2V0KCdkYXRhX29mZnNldCAvIDgnKX07XG4gICAgICAgIGxldCBwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSA9IChwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA+PiAoNCAqIChkYXRhX2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YV92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgnIDogJ3VucGFjazR4VTgnfSh1MzIocGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEpKTtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhID0gcXVhbnRpemVkX2RhdGFfdmVjW2RhdGFfaW5kZXggLyAyXTtcbiAgICAgICAgdmFyIHNjYWxlX2luZGljZXMgPSBkYXRhX2luZGljZXM7XG4gICAgICAgIGxldCBxdWFudGl6ZV9heGlzX2luZGV4ID0gJHtzY2FsZXMuaW5kaWNlc0dldCgnZGF0YV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAke3NjYWxlcy5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnLCAncXVhbnRpemVfYXhpc19pbmRleCcpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtzY2FsZXMuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKCF6ZXJvUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAndmFyIHplcm9fcG9pbnQgPSAwJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kaWNlcyA9IHNjYWxlX2luZGljZXM7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7emVyb1BvaW50LmluZGljZXNUb09mZnNldCgnemVyb19wb2ludF9pbmRpY2VzJyl9O1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9IHplcm9fcG9pbnRfb2Zmc2V0ICUgODtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfb2Zmc2V0IC8gOCcpfTtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF84Yml0X3plcm9fcG9pbnRzID0gKHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID4+ICg0ICogKHplcm9fcG9pbnRfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4JyA6ICd1bnBhY2s0eFU4J30odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAvIDJdO2A7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfTtcbiAgICAgICAgbGV0IGRlcXVhbnRpemVkX2RhdGEgPSAke3RlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUob3V0cHV0VHlwZSl9KHF1YW50aXplZF9kYXRhIC0gemVyb19wb2ludCkgKiBzY2FsZTtcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnZGVxdWFudGl6ZWRfZGF0YScpfTtcbiAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2lucHV0c1xuICAgICAgICAuZmlsdGVyKChfLCBpKSA9PiBpICE9PSAxKVxuICAgICAgICAubWFwKChpbnB1dCkgPT4gaW5wdXQuZGltcy5qb2luKCdfJykpXG4gICAgICAgIC5qb2luKCc7Jyl9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpbnB1dHMubGVuZ3RoIH0sIChfdiwgX2kpID0+ICdyYW5rJyksXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXRUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJCbG9ja1F1YW50aXplZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyQmxvY2tRdWFudGl6ZWRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzID0gKFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbik6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyLFxuICAgIGdhdGhlckF4aXM6IGF0dHJpYnV0ZXMuZ2F0aGVyQXhpcyBhcyBudW1iZXIsXG4gICAgcXVhbnRpemVBeGlzOiBhdHRyaWJ1dGVzLnF1YW50aXplQXhpcyBhcyBudW1iZXIsXG4gIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dE91dHB1dERhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcblxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgaW5kaWNlc0RhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5kaWNlc1NoYXBlLnNsaWNlKDApO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBpbnB1dFJhbmspO1xuICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlc0lucHV0JywgaW5kaWNlc0RhdGFUeXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0T3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXhpc0RpbUxpbWl0IH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcbiAgXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5kaWNlc1NoYXBlLCBvdXRwdXRTaGFwZSkpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG5cbiAgLy8gaW50NjQgaW5kaWNlcyB3b3VsZCBiZSB0cmVhdGVkIGFzIGxpdHRsZSBlbmRpYW4gaTMyIHdpdGggYXNzdW1wdGlvbiB0aGV5IGZhbGwgaW4gaTMyIGxpbWl0c1xuICAvLyBUaGF0IGFzc3VtcHRpb24gaXMgc2FmZSBhcyBpdCdzIG5vdCBwb3NzaWJsZSB0byBhbGxvY2F0ZSA+MmdiIGJ1ZmZlciBmb3IgaW5wdXQgdGVuc29yXG4gIC8vIElucHV0IGRhdGEgd2lsbCBiZSB0cmVhdGVkIGFzIHUzMiBvciB0d28gdTMyIGZvciA4LWJ5dGUgdGVuc29yc1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgIHZhciBpZHggPSAke2luZGljZXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtpbnB1dC50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaWR4KScpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XG5cbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHYXRoZXJFbGVtZW50cycsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJFbGVtZW50cyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgR2VtbVV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFpZCBpbnB1dCBudW1iZXIuJyk7XG4gIH1cblxuICAvLyAnQycgY2FuIGJlIG9mIGRpbWVuc2lvbmFsaXR5IDAsIDEgb3IgMiBvbmx5XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUgb2YgQycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzFdLmRhdGFUeXBlIHx8IChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzJdLmRhdGFUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWQnKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBHZW1tQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHRyYW5zQTogYm9vbGVhbjtcbiAgdHJhbnNCOiBib29sZWFuO1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG59XG5cbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IFtNLCBOLCBLXSA9IEdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGFTaGFwZSxcbiAgICBhdHRyaWJ1dGVzLnRyYW5zQSxcbiAgICBiU2hhcGUsXG4gICAgYXR0cmlidXRlcy50cmFuc0IsXG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGlucHV0c1syXS5kaW1zIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtNLCBOXTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICB9XG4gIGNvbnN0IHRpbGVTaXplID0gMTY7XG4gIGNvbnN0IG51bVRpbGVOID0gTWF0aC5jZWlsKE4gLyB0aWxlU2l6ZSk7XG4gIGNvbnN0IG51bVRpbGVNID0gTWF0aC5jZWlsKE0gLyB0aWxlU2l6ZSk7XG4gIC8vIFRPRE86IEZpbmQgdGhlIGNvbmRpdGlvbiB3aGVuIHRvIHVzZSB0aGUgbmFpdmUgb25lLlxuICBjb25zdCB1c2VTaGFyZWQgPSB0cnVlO1xuXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdXNlU2hhcmVkID8gbnVtVGlsZU4gOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE0gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTiB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBLIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYmV0YSB9LFxuICBdO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBsZXQgbGluZSA9ICcnO1xuICAgIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW24gKiB1bmlmb3Jtcy5LICsga107JztcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07JztcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW24gKiB1bmlmb3Jtcy5LICsga107JztcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dOyc7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsY3VsYXRlQWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhID09PSAxID8gJycgOiAndmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7JztcbiAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMpO1xuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBhLnR5cGUudmFsdWU7XG4gICAgbGV0IGM6IEluZGljZXNIZWxwZXIgfCBudWxsID0gbnVsbDtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbYSwgYl07XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGMgPSBpbnB1dFZhcmlhYmxlKCdjJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgICAgdmFyaWFibGVzLnB1c2goYyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0KTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0sXG4gICAgICB7IG5hbWU6ICdiZXRhJywgdHlwZTogJ2YzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuXG4gICAgbGV0IG0gPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuTjtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xuXG4gICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICR7bGluZX1cbiAgICB9XG5cbiAgICAke2NhbGN1bGF0ZUFscGhhfVxuICAgICR7KCgpID0+IHtcbiAgICAgIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBsZXQgY09mZnNldCA9ICR7Yy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgndmVjMihtLCBuKScsIG91dHB1dCl9OyB2YWx1ZSArPSAke1xuICAgICAgICAgIGRhdGFUeXBlXG4gICAgICAgIH0odW5pZm9ybXMuYmV0YSkgKiAke2MuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9KSgpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICB9YDtcbiAgfTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2VTaGFyZWQgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMpO1xuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgbGV0IGM6IEluZGljZXNIZWxwZXIgfCBudWxsID0gbnVsbDtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbYSwgYl07XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGMgPSBpbnB1dFZhcmlhYmxlKCdjJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgICAgdmFyaWFibGVzLnB1c2goYyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0KTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdudW1fdGlsZV9uJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgfSxcbiAgICAgIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZjMyJyB9LFxuICAgIF07XG5cbiAgICBsZXQgY2FsY1Jlc3VsdCA9ICcnO1xuICAgIGxldCBmaWxsV29ya2dyb3VwTWVtb3J5ID0gJyc7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBmaWxsV29ya2dyb3VwTWVtb3J5ID0gYFxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5NICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7YS50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2IudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgO1xuICAgICAgY2FsY1Jlc3VsdCA9IGB2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107YDtcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgZmlsbFdvcmtncm91cE1lbW9yeSA9IGBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2EudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtiLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYDtcbiAgICAgIGNhbGNSZXN1bHQgPSBgdmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO2A7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGZpbGxXb3JrZ3JvdXBNZW1vcnkgPSBgXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHthLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk4pIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Yi50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICBjYWxjUmVzdWx0ID0gYHZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltsb2NhbF9pZC54XVtrXTtgO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgZmlsbFdvcmtncm91cE1lbW9yeSA9IGBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2EudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtiLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYDtcbiAgICAgIGNhbGNSZXN1bHQgPSBgdmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO2A7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsY3VsYXRlQWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhID09PSAxID8gJycgOiAndmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7JztcblxuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZV9hOiBhcnJheTxhcnJheTwke2EudHlwZS5zdG9yYWdlfSwgJHt0aWxlU2l6ZX0+LCAke3RpbGVTaXplfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYjogYXJyYXk8YXJyYXk8JHtiLnR5cGUuc3RvcmFnZX0sICR7dGlsZVNpemV9PiwgJHt0aWxlU2l6ZX0+O1xuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW3RpbGVTaXplLCB0aWxlU2l6ZSwgMV0pfVxuICAgIGxldCB0aWxlX2NvbF9zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7dGlsZVNpemV9O1xuICAgIGxldCB0aWxlX3Jvd19zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7dGlsZVNpemV9O1xuICAgIGxldCBudW1fdGlsZXMgPSAodW5pZm9ybXMuSyAtIDEpIC8gJHt0aWxlU2l6ZX0gKyAxO1xuICAgIHZhciBrX3N0YXJ0ID0gMHU7XG4gICAgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgZm9yICh2YXIgdDogdTMyID0gMHU7IHQgPCBudW1fdGlsZXM7IHQrKykge1xuICAgICAgJHtmaWxsV29ya2dyb3VwTWVtb3J5fVxuICAgICAga19zdGFydCA9IGtfc3RhcnQgKyAke3RpbGVTaXplfTtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke3RpbGVTaXplfTsgaysrKSB7XG4gICAgICAgICR7Y2FsY1Jlc3VsdH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICAke2NhbGN1bGF0ZUFscGhhfVxuICAgIGxldCBtID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgIGxldCBuID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICR7KCgpID0+IHtcbiAgICAgIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBsZXQgY09mZnNldCA9ICR7Yy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgndmVjMihtLCBuKScsIG91dHB1dCl9OyB2YWx1ZSArPSAke1xuICAgICAgICAgIG91dHB1dC50eXBlLnZhbHVlXG4gICAgICAgIH0odW5pZm9ybXMuYmV0YSkgKiAke2MuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9KSgpfVxuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgb3V0cHV0W20gKiB1bmlmb3Jtcy5OICsgbl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIGlmICh1c2VTaGFyZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0dlbW1TaGFyZWQnLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogbnVtVGlsZU4gKiBudW1UaWxlTSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZTogZ2V0U2hhZGVyU291cmNlU2hhcmVkLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHZW1tJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2VtbUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCB0cmFuc0EgPSBhdHRyaWJ1dGVzLnRyYW5zQSBhcyBib29sZWFuO1xuICBjb25zdCB0cmFuc0IgPSBhdHRyaWJ1dGVzLnRyYW5zQiBhcyBib29sZWFuO1xuICBjb25zdCBhbHBoYSA9IGF0dHJpYnV0ZXMuYWxwaGEgYXMgbnVtYmVyO1xuICBjb25zdCBiZXRhID0gYXR0cmlidXRlcy5iZXRhIGFzIG51bWJlcjtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc0EsXG4gICAgdHJhbnNCLFxuICAgIGFscGhhLFxuICAgIGJldGEsXG4gICAgY2FjaGVLZXk6IGAke2F0dHJpYnV0ZXMudHJhbnNBfTske2F0dHJpYnV0ZXMudHJhbnNCfTske2F0dHJpYnV0ZXMuYWxwaGEgPT09IDF9YCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW1tID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHZW1tQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHZW1tUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmxldCBbaWR4TiwgaWR4QywgaWR4SCwgaWR4V10gPSBbMCwgMSwgMiwgM107IC8vIE5DSFdcbnR5cGUgTW9kZSA9ICdiaWxpbmVhcicgfCAnbmVhcmVzdCcgfCAnYmljdWJpYyc7XG50eXBlIFBhZGRpbmdNb2RlID0gJ3plcm9zJyB8ICdib3JkZXInIHwgJ3JlZmxlY3Rpb24nO1xudHlwZSBGb3JtYXQgPSAnTkhXQycgfCAnTkNIVyc7XG5leHBvcnQgaW50ZXJmYWNlIEdyaWRTYW1wZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBhbGlnbkNvcm5lcnM6IG51bWJlcjtcbiAgbW9kZTogTW9kZTtcbiAgcGFkZGluZ01vZGU6IFBhZGRpbmdNb2RlO1xuICBmb3JtYXQ6IEZvcm1hdDtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb25seSA0LUQgdGVuc29yIGlzIHN1cHBvcnRlZC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCB0byBncmlkIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbGFzdCBkaW1lbnNpb24gb2YgZ3JpZCBtdXN0IGJlIGVxdWFsIHRvICR7aW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMn1gKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1swXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dyaWQgYmF0Y2ggc2l6ZSBtdXN0IG1hdGNoIGlucHV0IGJhdGNoIHNpemUnKTtcbiAgfVxufTtcblxuY29uc3QgZ3NHZXRDdWJpY0NvZWZmcyA9IGBcbiAgZm4gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4OiBmMzIpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgbGV0IGN1YmljX2FscGhhID0gLTAuNzVmO1xuICAgIGxldCB4X2FicyA9IGFicyh4KTtcbiAgICB2YXIgY29lZmZzOiB2ZWM0PGYzMj47XG4gICAgY29lZmZzWzBdID0gKCgoY3ViaWNfYWxwaGEgKiAoeF9hYnMgKyAxKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSArIDggKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgY29lZmZzWzFdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqIHhfYWJzIC0gKGN1YmljX2FscGhhICsgMykpICogeF9hYnMgKiB4X2FicyArIDEpO1xuICAgIGNvZWZmc1syXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiAoMSAtIHhfYWJzKSAtIChjdWJpY19hbHBoYSArIDMpKSAqICgxIC0geF9hYnMpICogKDEgLSB4X2FicykgKyAxKTtcbiAgICBjb2VmZnNbM10gPSAoKChjdWJpY19hbHBoYSAqICgyIC0geF9hYnMpIC0gNSAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpICsgOCAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5gO1xuXG5jb25zdCBnc0JpY3ViaWNJbnRlcnBvbGF0ZSA9IChkYXRhVHlwZTogc3RyaW5nKTogc3RyaW5nID0+IGBcbiAgZm4gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwOiBtYXQ0eDQ8JHtkYXRhVHlwZX0+LCB4OiBmMzIsIHk6IGYzMikgLT4gJHtkYXRhVHlwZX0ge1xuICAgIHZhciB2OiB2ZWM0PGYzMj47XG4gICAgdmFyIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZbaV0gPSBjb2VmZnNbMF0gKiBwW2ldWzBdICsgY29lZmZzWzFdICogcFtpXVsxXSArIGNvZWZmc1syXSAqIHBbaV1bMl0gKyBjb2VmZnNbM10gKiBwW2ldWzNdO1xuICAgIH1cbiAgICBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHkpO1xuICAgIGxldCBwaXhlbCA9ICR7ZGF0YVR5cGV9KGNvZWZmc1swXSAqIHZbMF0gKyBjb2VmZnNbMV0gKiB2WzFdICsgY29lZmZzWzJdICogdlsyXSArIGNvZWZmc1szXSAqIHZbM10pO1xuICAgIHJldHVybiBwaXhlbDtcbiAgfVxuYDtcblxuY29uc3QgZ3NEZW5vcm1hbGl6ZSA9IChhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogc3RyaW5nID0+IGBcbiAgZm4gZ3NfZGVub3JtYWxpemUobjogZjMyLCBsZW5ndGg6IGkzMikgLT4gZjMyIHtcbiAgICAke1xuICAgICAgYXR0cmlidXRlcy5hbGlnbkNvcm5lcnMgPT09IDBcbiAgICAgICAgPyBgXG4gICAgLy8gYWxpZ25Db3JuZXJzOiBmYWxzZSA9PiBbLTEsIDFdIHRvIFstMC41LCBsZW5ndGggLSAwLjVdXG4gICAgcmV0dXJuICgobiArIDEuMCkgKiBmMzIobGVuZ3RoKSAtIDEuMCkgLyAyLjA7XG4gICAgYFxuICAgICAgICA6IGBcbiAgICAvLyBhbGlnbkNvcm5lcnM6IHRydWUgPT4gWy0xLCAxXSB0byBbMCwgbGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gKG4gKyAxLjApIC8gMi4wICogKGYzMihsZW5ndGggLSAxKSk7XG4gICAgYFxuICAgIH1cbiAgfVxuYDtcblxuY29uc3QgZ3NSZWZsZWN0ID0gKGF0dHJpYnV0ZXM6IEdyaWRTYW1wZUF0dHJpYnV0ZXMpOiBzdHJpbmcgPT4gYFxuICAke1xuICAgIGF0dHJpYnV0ZXMucGFkZGluZ01vZGUgPT09ICdyZWZsZWN0aW9uJ1xuICAgICAgPyBgXG4gICAgICBmbiBnc19yZWZsZWN0KHg6IGkzMiwgeF9taW46IGYzMiwgeF9tYXg6IGYzMikgLT4gdTMyIHtcbiAgICAgICAgdmFyIGR4ID0gMC4wO1xuICAgICAgICB2YXIgZnggPSBmMzIoeCk7XG4gICAgICAgIGxldCByYW5nZSA9IHhfbWF4IC0geF9taW47XG4gICAgICAgIGlmIChmeCA8IHhfbWluKSB7XG4gICAgICAgICAgZHggPSB4X21pbiAtIGZ4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmeCA+IHhfbWF4KSB7XG4gICAgICAgICAgZHggPSBmeCAtIHhfbWF4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdTMyKGZ4KTtcbiAgICAgIH1gXG4gICAgICA6ICcnXG4gIH1cbmA7XG5cbmNvbnN0IHBpeGVsQXRHcmlkID0gKGlucHV0OiBJbmRpY2VzSGVscGVyLCBkYXRhVHlwZTogc3RyaW5nLCBhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogc3RyaW5nID0+XG4gIGBcbiAgZm4gcGl4ZWxfYXRfZ3JpZChyOiBpMzIsIGM6IGkzMiwgSDogaTMyLCBXOiBpMzIsIGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgYm9yZGVyOiB2ZWM0PGYzMj4pIC0+ICR7ZGF0YVR5cGV9IHtcbiAgICAgdmFyIHBpeGVsID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgIHZhciBpbmRpY2VzID0gdmVjNDx1MzI+KDApO1xuICAgICBpbmRpY2VzWyR7aWR4Tn1dID0gYmF0Y2g7XG4gICAgIGluZGljZXNbJHtpZHhDfV0gPSBjaGFubmVsO2AgK1xuICAoKCkgPT4ge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlcy5wYWRkaW5nTW9kZSkge1xuICAgICAgY2FzZSAnemVyb3MnOlxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGlmIChyID49IDAgJiYgciA8IEggJiYgYyA+PTAgJiYgYyA8IFcpIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtpZHhIfV0gPSB1MzIocik7XG4gICAgICAgICAgICBpbmRpY2VzWyR7aWR4V31dID0gdTMyKGMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHtkYXRhVHlwZX0oMCk7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgY2FzZSAnYm9yZGVyJzpcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBpbmRpY2VzWyR7aWR4SH1dID0gdTMyKGNsYW1wKHIsIDAsIEggLSAxKSk7XG4gICAgICAgICAgaW5kaWNlc1ske2lkeFd9XSA9IHUzMihjbGFtcChjLCAwLCBXIC0gMSkpO1xuICAgICAgICBgO1xuICAgICAgY2FzZSAncmVmbGVjdGlvbic6XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgaW5kaWNlc1ske2lkeEh9XSA9IGdzX3JlZmxlY3QociwgYm9yZGVyWzFdLCBib3JkZXJbM10pO1xuICAgICAgICAgIGluZGljZXNbJHtpZHhXfV0gPSBnc19yZWZsZWN0KGMsIGJvcmRlclswXSwgYm9yZGVyWzJdKTtcbiAgICAgICAgYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZyBtb2RlICR7YXR0cmlidXRlcy5wYWRkaW5nTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKSArXG4gIGBcbiAgICByZXR1cm4gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2luZGljZXMnKX07XG4gIH1cbmA7XG5cbmNvbnN0IGNvbXB1dGVQaXhlbCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGRhdGFUeXBlOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IEdyaWRTYW1wZUF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cbiAgKCgpID0+IHtcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHBpeGVsX2F0X2dyaWQoaTMyKHJvdW5kKHkpKSwgaTMyKHJvdW5kKHgpKSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcbiAgICAgICAgYDtcbiAgICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgeDEgPSBpMzIoZmxvb3IoeCkpO1xuICAgICAgICAgIGxldCB5MSA9IGkzMihmbG9vcih5KSk7XG4gICAgICAgICAgbGV0IHgyID0geDEgKyAxO1xuICAgICAgICAgIGxldCB5MiA9IHkxICsgMTtcblxuICAgICAgICAgIGxldCBwMTEgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDEyID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAyMSA9IHBpeGVsX2F0X2dyaWQoeTIsIHgxLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7aWR4Tn1dLCBpbmRpY2VzWyR7aWR4Q31dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjIgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcblxuICAgICAgICAgIGxldCBkeDIgPSAke2RhdGFUeXBlfShmMzIoeDIpIC0geCk7XG4gICAgICAgICAgbGV0IGR4MSA9ICR7ZGF0YVR5cGV9KHggLSBmMzIoeDEpKTtcbiAgICAgICAgICBsZXQgZHkyID0gJHtkYXRhVHlwZX0oZjMyKHkyKSAtIHkpO1xuICAgICAgICAgIGxldCBkeTEgPSAke2RhdGFUeXBlfSh5IC0gZjMyKHkxKSk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGR5MiAqIChkeDIgKiBwMTEgKyBkeDEgKiBwMTIpICsgZHkxICogKGR4MiAqIHAyMSArIGR4MSAqIHAyMik7XG4gICAgICAgIGA7XG4gICAgICBjYXNlICdiaWN1YmljJzpcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgeDAgPSBpMzIoZmxvb3IoeCkpIC0gMTtcbiAgICAgICAgICBsZXQgeTAgPSBpMzIoZmxvb3IoeSkpIC0gMTtcbiAgICAgICAgICB2YXIgcDogbWF0NHg0PCR7ZGF0YVR5cGV9PjtcbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IDQ7IGgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCA0OyB3KyspIHtcbiAgICAgICAgICAgICAgcFtoXVt3XSA9IHBpeGVsX2F0X2dyaWQoaCArIHkwLCB3ICsgeDAsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGR4ID0geCAtIGYzMih4MCArIDEpO1xuICAgICAgICAgIGxldCBkeSA9IHkgLSBmMzIoeTAgKyAxKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwLCBkeCwgZHkpO1xuICAgICAgICBgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtb2RlICR7YXR0cmlidXRlcy5tb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpICsgYCR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3Jlc3VsdCcpfWA7XG5cbmNvbnN0IGNyZWF0ZUdyaWRTYW1wbGVQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIC8vIGRpc2NhcmQgbGFzdCBkaW1lbnNpb24gZm9yIHVzaW5nIHZlYzIgdG8gYWNjZXNzIGdyaWQgZGF0YVxuICBjb25zdCBncmlkU2hhcGUgPSBbaW5wdXRzWzFdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXV07XG4gIGNvbnN0IGdyaWQgPSBpbnB1dFZhcmlhYmxlKCdncmlkJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBncmlkU2hhcGUubGVuZ3RoLCAyKTtcbiAgbGV0IG91dHB1dFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdXTtcbiAgaWYgKGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycpIHtcbiAgICBvdXRwdXRTaGFwZSA9IFtpbnB1dHNbMF0uZGltc1swXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdLCBpbnB1dHNbMF0uZGltc1szXV07XG4gICAgW2lkeE4sIGlkeEMsIGlkeEgsIGlkeFddID0gWzAsIDMsIDEsIDJdO1xuICB9XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBncmlkU2hhcGUsIG91dHB1dFNoYXBlKSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHgsIGdyaWQsIG91dHB1dCl9XG4gICR7Z3NHZXRDdWJpY0NvZWZmc31cbiAgJHtnc0JpY3ViaWNJbnRlcnBvbGF0ZShkYXRhVHlwZSl9XG4gICR7Z3NEZW5vcm1hbGl6ZShhdHRyaWJ1dGVzKX1cbiAgJHtnc1JlZmxlY3QoYXR0cmlidXRlcyl9XG4gICR7cGl4ZWxBdEdyaWQoeCwgZGF0YVR5cGUsIGF0dHJpYnV0ZXMpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICBsZXQgSF9pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7aWR4SH1dKTtcbiAgICAgIGxldCBXX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtpZHhXfV0pO1xuXG4gICAgICAke1xuICAgICAgICBhdHRyaWJ1dGVzLmFsaWduQ29ybmVycyA9PT0gMFxuICAgICAgICAgID8gYFxuICAgICAgbGV0IHhfbWluID0gLTAuNTtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDAuNTtcbiAgICAgIGxldCB5X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAwLjU7XG4gICAgICBgXG4gICAgICAgICAgOiBgXG4gICAgICBsZXQgeF9taW4gPSAwLjA7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAxLjA7XG4gICAgICBsZXQgeV9taW4gPSAwLjA7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAxLjA7XG4gICAgICBgXG4gICAgICB9O1xuICAgICAgbGV0IGJvcmRlciA9IHZlYzQ8ZjMyPih4X21pbiwgeV9taW4sIHhfbWF4LCB5X21heCk7XG5cbiAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgdmFyIGdyaWRfaW5kaWNlcyA9IHZlYzM8dTMyPihpbmRpY2VzWyR7aWR4Tn1dLCBpbmRpY2VzWyR7aWR4SH1dLCBpbmRpY2VzWyR7aWR4V31dKTtcbiAgICAgIGxldCBueHkgPSAke2dyaWQuZ2V0QnlJbmRpY2VzKCdncmlkX2luZGljZXMnKX07XG4gICAgICB2YXIgeCA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMF0pLCBXX2luKTtcbiAgICAgIHZhciB5ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVsxXSksIEhfaW4pO1xuXG4gICAgICAke2NvbXB1dGVQaXhlbChvdXRwdXQsIGRhdGFUeXBlLCBhdHRyaWJ1dGVzKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR3JpZFNhbXBsZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxuICAgIGdldFJ1bkRhdGE6IChpbnB1dHMpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdyaWRTYW1wbGUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdyaWRTYW1wZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR3JpZFNhbXBsZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHcmlkU2FtcGxlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdyaWRTYW1wZUF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhbGlnbkNvcm5lcnM6IGF0dHJpYnV0ZXMuYWxpZ25fY29ybmVycyBhcyBudW1iZXIsXG4gICAgbW9kZTogYXR0cmlidXRlcy5tb2RlIGFzIE1vZGUsXG4gICAgcGFkZGluZ01vZGU6IGF0dHJpYnV0ZXMucGFkZGluZ19tb2RlIGFzIFBhZGRpbmdNb2RlLFxuICAgIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0LFxuICB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIEdwdURhdGFUeXBlLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgYXBwbHlBdHRlbnRpb24sXG4gIEF0dGVudGlvbkF0dHJzLFxuICBBdHRlbnRpb25NYXNrVHlwZSxcbiAgQXR0ZW50aW9uUGFyYW1ldGVycyxcbiAgQXR0ZW50aW9uUWt2Rm9ybWF0LFxufSBmcm9tICcuL2F0dGVudGlvbic7XG5pbXBvcnQgeyBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZSB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5jb25zdCBnZXRJbnB1dCA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgaTogbnVtYmVyKSA9PlxuICBpbnB1dHMubGVuZ3RoID4gaSAmJiBpbnB1dHNbaV0uZGltcy5sZW5ndGggPiAwID8gaW5wdXRzW2ldIDogdW5kZWZpbmVkO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcbiAgY29uc3QgcXVlcnkgPSBpbnB1dHNbMF07XG4gIGNvbnN0IGtleSA9IGdldElucHV0KGlucHV0cywgMSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0SW5wdXQoaW5wdXRzLCAyKTtcbiAgY29uc3QgYmlhcyA9IGdldElucHV0KGlucHV0cywgMyk7XG4gIGNvbnN0IGtleVBhZGRpbmdNYXNrID0gZ2V0SW5wdXQoaW5wdXRzLCA0KTtcbiAgY29uc3QgYXR0ZW50aW9uQmlhcyA9IGdldElucHV0KGlucHV0cywgNSk7XG4gIGNvbnN0IHBhc3RLZXkgPSBnZXRJbnB1dChpbnB1dHMsIDYpO1xuICBjb25zdCBwYXN0VmFsdWUgPSBnZXRJbnB1dChpbnB1dHMsIDcpO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBOb3RhdGlvbnM6XG4gIC8vICAgIEI6IGJhdGNoX3NpemVcbiAgLy8gICAgTjogbnVtX2hlYWRzXG4gIC8vICAgIEg6IGhlYWRfc2l6ZSBvZiBRIGFuZCBLXG4gIC8vICAgIEhfdjogaGVhZF9zaXplIG9mIFZcbiAgLy8gICAgRDogaGlkZGVuX3NpemUgZm9yIFEgYW5kIEssIHdoZXJlIEQgPSBOICogSFxuICAvLyAgICBEX3Y6IGhpZGRlbl9zaXplIG9mIFYsIHdoZXJlIERfdiA9IE4gKiBIX3ZcbiAgLy8gICAgUzogcV9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICAgUDogcGFzdF9zZXF1ZW5jZV9sZW5ndGggb2Yga3YgY2FjaGVcbiAgLy8gICAgTDoga3Zfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgIFQ6IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IFAgKyBMXG4gIC8vICAgIE06IG1heF9zZXF1ZW5jZV9sZW5ndGggb2Yga3YgY2FjaGUgd2hlbiBwYXN0IGFuZCBwcmVzZW50IHNoYXJlIGJ1ZmZlclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gTXVsdGlIZWFkQXR0ZW50aW9uIGlucHV0czpcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vICBRX0tfVl9CU05IIC0gbm8gcGFja2luZzpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBEKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiAoQiwgTCwgRF92KVxuICAvLyAgUV9LX1ZfQlNOSF9CTlNIX0JOU0ggLSBjcm9zcyBhdHRlbnRpb24gKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBMID09IFQsIEQgPT0gRF92KTpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBOLCBMLCBIKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiAoQiwgTiwgTCwgSF92KVxuICAvLyAgUV9LVl9CU05IX0JTTjJIIC0gcGFja2VkIGt2IChrdiBjYWNoZSBpcyBub3QgdXNlZCwgYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2KTpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLL1YpICAgICA6IChCLCBMLCBOLCAyLCBIKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAgICAgICAgICAgOiBOb25lXG4gIC8vICBRS1ZfQlNOM0ggLSBwYWNrZWQgcWt2IChrdiBjYWNoZSBpcyBub3QgdXNlZCwgUyA9PSBMLCBEID09IERfdik6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRL0svVikgICA6IChCLCBTLCBOLCAzLCBIKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAgICAgICAgICAgOiBOb25lXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICA6IE5vbmVcbiAgLy9cbiAgLy8gIE90aGVyIGlucHV0czpcbiAgLy8gICAgIGJpYXMgICAgICAgICAgICAgKFEvSy9WKSAgIDogTm9uZSBvciAoRCArIEQgKyBEX3YpXG4gIC8vICAgICBrZXlfcGFkZGluZ19tYXNrIChLL1YpICAgICA6IChCKSBvciAoMyAqIEIgKyAyKSBvciAoQiwgVCkgb3IgKEIsIFMsIFQpXG4gIC8vICAgICBhdHRlbnRpb25fYmlhcyAgICAgICAgICAgICA6IE5vbmUgb3IgKEIsIE4sIFMsIFQpLCAoMSwgTiwgUywgVCksIChCLCAxLCBTLCBUKSBvciAoMSwgMSwgUywgVClcbiAgLy8gICAgIHBhc3Rfa2V5ICAgICAgICAgICAgICAgICAgIDogKEIsIE4sIFAsIEgpIG9yIE5vbmUuIFBhc3Qgc3RhdGUgaXMgb25seSBhbGxvd2VkIGZvciBRX0tfVl9CU05ILlxuICAvLyAgICAgcGFzdF92YWx1ZSAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUCwgSCkgb3IgTm9uZS4gUGFzdCBzdGF0ZSBpcyBvbmx5IGFsbG93ZWQgZm9yIFFfS19WX0JTTkguXG4gIC8vXG4gIC8vICBOb3QgU3VwcG9ydGVkOlxuICAvLyAgICAga2V5X3BhZGRpbmdfbWFzaywgcGFja2VkIGt2LCBwYWNrZWQgcWt2LCBhbmQgYnJvYWRjYXN0IGZvciBhdHRlbnRpb25fYmlhcy5cblxuICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IHF1ZXJ5LmRpbXNbMF07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gcXVlcnkuZGltc1sxXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IHF1ZXJ5LmRpbXMubGVuZ3RoID09PSAzID8gcXVlcnkuZGltc1syXSA6IGF0dHJpYnV0ZXMubnVtSGVhZHMgKiBxdWVyeS5kaW1zWzRdO1xuICBsZXQga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xuXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xuICBsZXQgbWF4U2VxdWVuY2VMZW5ndGggPSAwO1xuICBjb25zdCBoZWFkU2l6ZSA9IE1hdGguZmxvb3IoaGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpO1xuICBpZiAocGFzdEtleSAmJiBwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdEtleS5kaW1zKSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0VmFsdWUuZGltcykpIHtcbiAgICBpZiAocGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3RLZXkuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8IHBhc3RLZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBwYXN0S2V5LmRpbXNbM10gIT09IGhlYWRTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBwYXN0VmFsdWUuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8XG4gICAgICBwYXN0VmFsdWUuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fFxuICAgICAgcGFzdFZhbHVlLmRpbXNbM10gIT09IGhlYWRTaXplXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7XG4gICAgfVxuICAgIGlmIChwYXN0S2V5LmRpbXNbMl0gIT09IHBhc3RWYWx1ZS5kaW1zWzJdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChwYXN0X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICB9XG4gICAgaWYgKHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gICAgbWF4U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gIH0gZWxzZSBpZiAoKHBhc3RLZXkgJiYgU2hhcGVVdGlsLnNpemUocGFzdEtleS5kaW1zKSkgfHwgKHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0VmFsdWUuZGltcykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO1xuICB9XG5cbiAgbGV0IHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xuICBpZiAoa2V5ICYmIFNoYXBlVXRpbC5zaXplKGtleS5kaW1zKSA+IDApIHtcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7XG4gICAgfVxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPCAzIHx8IGtleS5kaW1zLmxlbmd0aCA+IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0ga2V5LmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa2V5LmRpbXNbMl0gIT09IHF1ZXJ5LmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTtcbiAgICAgIH1cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU05IO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgICBpZiAoa2V5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IDIgfHwga2V5LmRpbXNbNF0gIT09IGhlYWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7XG4gICAgICB9XG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucUt2QlNOSHhCU04ySDtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ga2V5X2RpbXMuc2l6ZSgpID09IDQgKGNyb3NzLWF0dGVudGlvbiB3aXRoIHBhc3Rfa2V5KVxuICAgICAgaWYgKGtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtcbiAgICAgIH1cblxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnVua25vd247IC8vIFFfS19WX0JTTkhfQk5TSF9CTlNIXG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHBhY2tlZCBRS1ZcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHF1ZXJ5LmRpbXNbM10gIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgIH1cblxuICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU04zSDtcbiAgfVxuXG4gIGlmIChiaWFzICYmIFNoYXBlVXRpbC5zaXplKGJpYXMuZGltcykgPiAwKSB7XG4gICAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUgJiYga2V5LmRpbXNbM10gPT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIGt2U2VxdWVuY2VMZW5ndGg7XG5cbiAgbGV0IG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGlmIChrZXlQYWRkaW5nTWFzayAmJiBTaGFwZVV0aWwuc2l6ZShrZXlQYWRkaW5nTWFzay5kaW1zKSA+IDApIHtcbiAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2tVbmtub3duO1xuICAgIGNvbnN0IG1hc2tEaW1zID0ga2V5UGFkZGluZ01hc2suZGltcztcbiAgICBpZiAobWFza0RpbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobWFza0RpbXNbMF0gPT09IGJhdGNoU2l6ZSkge1xuICAgICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2sxZEtleVNlcUxlbjtcbiAgICAgIH0gZWxzZSBpZiAobWFza0RpbXNbMF0gPT09IDMgKiBiYXRjaFNpemUgKyAyKSB7XG4gICAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazFES2V5U2VxTGVuU3RhcnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDIgJiYgbWFza0RpbXNbMF0gPT09IGJhdGNoU2l6ZSAmJiBtYXNrRGltc1sxXSA9PT0gdG90YWxTZXF1ZW5jZUxlbmd0aCkge1xuICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMmRLZXlQYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobWFza1R5cGUgPT09IEF0dGVudGlvbk1hc2tUeXBlLm1hc2tVbmtub3duKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5X3BhZGRpbmdfbWFza1wiIHNoYXBlIHNoYWxsIGJlIChiYXRjaF9zaXplKSBvciAoYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hc2sgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgbGV0IHBhc3NQYXN0SW5LdiA9IGZhbHNlO1xuICBsZXQgdkhpZGRlblNpemUgPSBoaWRkZW5TaXplO1xuICBpZiAodmFsdWUgJiYgU2hhcGVVdGlsLnNpemUodmFsdWUuZGltcykgPiAwKSB7XG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoICE9PSAzICYmIHZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IHZhbHVlLmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgICAgfVxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBRX0tfVl9CU05IX0JOU0hfQk5TSFxuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgICAgfVxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzFdICogdmFsdWUuZGltc1szXTtcbiAgICAgIHBhc3NQYXN0SW5LdiA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnJvYWRjYXN0UmVzUG9zQmlhcyA9IGZhbHNlO1xuXG4gIGlmIChrZXlQYWRkaW5nTWFzayAmJiBTaGFwZVV0aWwuc2l6ZShrZXlQYWRkaW5nTWFzay5kaW1zKSA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBwYWRkaW5nIG1hc2sgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgaWYgKGF0dGVudGlvbkJpYXMgJiYgU2hhcGVVdGlsLnNpemUoYXR0ZW50aW9uQmlhcy5kaW1zKSA+IDApIHtcbiAgICBpZiAoYXR0ZW50aW9uQmlhcy5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBzdXBwb3J0IGJyb2FkY2FzdGluZyB0aGUgZmlyc3QgYW5kIHNlY29uZCBkaW1lbnNpb25zIG9mIGF0dGVudGlvbl9iaWFzLlxuICAgIGlmIChcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8XG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1syXSAhPT0gc2VxdWVuY2VMZW5ndGggfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1szXSAhPT0gdG90YWxTZXF1ZW5jZUxlbmd0aFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmF0Y2hTaXplLFxuICAgIHNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcbiAgICBrdlNlcXVlbmNlTGVuZ3RoLFxuICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgsXG4gICAgbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgaW5wdXRIaWRkZW5TaXplOiAwLFxuICAgIGhpZGRlblNpemUsXG4gICAgdkhpZGRlblNpemUsXG4gICAgaGVhZFNpemUsXG4gICAgdkhlYWRTaXplOiBNYXRoLmZsb29yKHZIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyksXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXG4gICAgaXNVbmlkaXJlY3Rpb25hbDogZmFsc2UsXG4gICAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogZmFsc2UsXG4gICAgbWFza0ZpbHRlclZhbHVlOiBhdHRyaWJ1dGVzLm1hc2tGaWx0ZXJWYWx1ZSxcbiAgICBtYXNrVHlwZSxcbiAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzLFxuICAgIHBhc3NQYXN0SW5LdixcbiAgICBxa3ZGb3JtYXQsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uQXR0cnMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgLi4uYXR0cmlidXRlcyB9KTtcblxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcGVybTogWzAsIDIsIDEsIDNdIH0pO1xuXG5jb25zdCBhZGRCaWFzVHJhbnNwb3NlID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgcWt2OiBUZW5zb3JWaWV3LFxuICBiaWFzOiBUZW5zb3JWaWV3LFxuICBiYXRjaFNpemU6IG51bWJlcixcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgaGlkZGVuU2l6ZTogbnVtYmVyLFxuICBiaWFzT2Zmc2V0OiBudW1iZXIsXG4pID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgaGlkZGVuU2l6ZV07XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBiaWFzT2Zmc2V0IH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGhpZGRlblNpemUgfSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncWt2X3dpdGhfYmlhcycsIHFrdi5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IHFrdklucHV0ID0gaW5wdXRWYXJpYWJsZSgncWt2JywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3QgYmlhc0lucHV0ID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2JpYXNfb2Zmc2V0JywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMocWt2SW5wdXQsIGJpYXNJbnB1dCwgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgYmlhc19vZmZzZXRfaWR4ID0gKGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgKyB1bmlmb3Jtcy5iaWFzX29mZnNldDtcblxuICAgIHFrdl93aXRoX2JpYXNbZ2xvYmFsX2lkeF0gPSBxa3ZbZ2xvYmFsX2lkeF0gKyBiaWFzW2JpYXNfb2Zmc2V0X2lkeF07XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ011bHRpSGVhZEF0dGVudGlvbkFkZEJpYXMnLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ10gfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogcWt2LmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbcWt2LCBiaWFzXSwgb3V0cHV0czogWy0xXSB9LFxuICApWzBdO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxuICBudW1IZWFkczogbnVtYmVyLFxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBoZWFkU2l6ZTogbnVtYmVyLFxuICBpbnB1dDogVGVuc29yVmlldyxcbiAgYmlhcz86IFRlbnNvclZpZXcsXG4gIGJpYXNPZmZzZXQ/OiBudW1iZXIsXG4pID0+IHtcbiAgLy8gY29uc3QgbmV3RGltcyA9IFtdO1xuXG4gIGxldCByZXNoYXBlZElucHV0ID0gaW5wdXQ7XG4gIGlmICghKGJpYXMgJiYgU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA+IDApKSB7XG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXNoYXBlZElucHV0ID0gaW5wdXQucmVzaGFwZShbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIGhlYWRTaXplXSk7XG4gICAgfVxuICAgIGlmIChudW1IZWFkcyA9PT0gMSB8fCBzZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHJlc2hhcGVkSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLCB7XG4gICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0XSxcbiAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgfSlbMF07XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNlcXVlbmNlTGVuZ3RoID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZEJpYXNSZXNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZC4gUGxlYXNlIGV4cG9ydCB5b3VyIG1vZGVsIHdpdGggcGFja2VkIFFLViBvciBLVicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNoYXBlZElucHV0ID0gYWRkQmlhc1RyYW5zcG9zZShcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGJpYXMsXG4gICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgICAgIG51bUhlYWRzICogaGVhZFNpemUsXG4gICAgICAgIGJpYXNPZmZzZXQhLFxuICAgICAgKTtcbiAgICAgIHJlc2hhcGVkSW5wdXQgPSByZXNoYXBlZElucHV0LnJlc2hhcGUoW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzLCBoZWFkU2l6ZV0pO1xuICAgICAgaWYgKG51bUhlYWRzID09PSAxIHx8IHNlcXVlbmNlTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZXNoYXBlZElucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksIHtcbiAgICAgICAgaW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sXG4gICAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgICB9KVswXTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBtdWx0aUhlYWRBdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgcXVlcnkgPSBjb250ZXh0LmlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDEpO1xuICBjb25zdCB2YWx1ZSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCAyKTtcbiAgY29uc3QgYmlhcyA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCAzKTtcbiAgY29uc3Qga2V5UGFkZGluZ01hc2sgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNCk7XG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNSk7XG4gIGNvbnN0IHBhc3RLZXkgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNik7XG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA3KTtcbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgaWYgKGtleT8uZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8vIGFwcGx5QXR0ZW50aW9uIGV4cGVjdHMgQk5TSCBpbnB1dHNcbiAgY29uc3Qga3ZCTlNIID0ga2V5ICYmIHZhbHVlICYmIGtleS5kaW1zLmxlbmd0aCA9PT0gNCAmJiB2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gNDtcblxuICBjb25zdCBRID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgIGNvbnRleHQsXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICBwYXJhbXMubnVtSGVhZHMsXG4gICAgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhcmFtcy5oZWFkU2l6ZSxcbiAgICBxdWVyeSxcbiAgICBiaWFzLFxuICAgIDAsXG4gICk7XG5cbiAgaWYgKGt2Qk5TSCkge1xuICAgIHJldHVybiBhcHBseUF0dGVudGlvbihjb250ZXh0LCBRLCBrZXksIHZhbHVlLCBrZXlQYWRkaW5nTWFzaywgdW5kZWZpbmVkLCBwYXN0S2V5LCBwYXN0VmFsdWUsIGF0dGVudGlvbkJpYXMsIHBhcmFtcyk7XG4gIH1cbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgfVxuICBjb25zdCBLID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgIGNvbnRleHQsXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICBwYXJhbXMubnVtSGVhZHMsXG4gICAgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGgsXG4gICAgcGFyYW1zLmhlYWRTaXplLFxuICAgIGtleSxcbiAgICBiaWFzLFxuICAgIHBhcmFtcy5oaWRkZW5TaXplLFxuICApO1xuXG4gIGNvbnN0IFYgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgY29udGV4dCxcbiAgICBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIHBhcmFtcy5udW1IZWFkcyxcbiAgICBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbXMudkhlYWRTaXplLFxuICAgIHZhbHVlLFxuICAgIGJpYXMsXG4gICAgMiAqIHBhcmFtcy5oaWRkZW5TaXplLFxuICApO1xuXG4gIGFwcGx5QXR0ZW50aW9uKGNvbnRleHQsIFEsIEssIFYsIGtleVBhZGRpbmdNYXNrLCB1bmRlZmluZWQsIHBhc3RLZXksIHBhc3RWYWx1ZSwgYXR0ZW50aW9uQmlhcywgcGFyYW1zKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSwgVGVuc29ySW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEVsZW1lbnRBdCxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbiAgcmVhZG9ubHkgbnVtT3V0cHV0czogbnVtYmVyO1xuICByZWFkb25seSBzcGxpdFNpemVzOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgaW5wdXRzJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVNwbGl0QXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMsXG4pOiBTcGxpdEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBzcGxpdFNpemVzOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgbnVtT3V0cHV0czogbnVtYmVyID0gYXR0cmlidXRlcy5udW1PdXRwdXRzO1xuICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gPiAwKSB7XG4gICAgaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBzcGxpdFNpemVzLnB1c2goTnVtYmVyKHYpKSk7XG4gICAgbnVtT3V0cHV0cyA9IHNwbGl0U2l6ZXMubGVuZ3RoO1xuICB9XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBudW1PdXRwdXRzLCBheGlzOiBhdHRyaWJ1dGVzLmF4aXMsIHNwbGl0U2l6ZXMgfSk7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIpOiBzdHJpbmcgPT4gYFxuZm4gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7bnVtYmVyT2ZUZW5zb3JzfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpcycsICdpJywgbnVtYmVyT2ZUZW5zb3JzKX0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcbn1gO1xuY29uc3Qgd3JpdGVCdWZmZXJEYXRhSW1wbCA9IChvdXRwdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10pID0+IHtcbiAgY29uc3QgbnVtYmVyT2ZUZW5zb3JzID0gb3V0cHV0cy5sZW5ndGg7XG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXRzW2ldLnNldEJ5SW5kaWNlcygnaW5kaWNlcycsICdpbnB1dFtnbG9iYWxfaWR4XScpO1xuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7b3V0cHV0c1swXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtjb2RlTGluZXMuam9pbignXFxuJyl9XG4gICAgICB9YDtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTcGxpdFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dHMgPSBuZXcgQXJyYXk8SW5kaWNlc0hlbHBlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IHNpemVJblNwbGl0QXhpcyA9IG5ldyBBcnJheTxudW1iZXI+KGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIGNvbnN0IG91dHB1dHNUZW5zb3JJbmZvOiBUZW5zb3JJbmZvW10gPSBbXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRTaXplIH1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubnVtT3V0cHV0czsgaSsrKSB7XG4gICAgcHJldmlvdXNTdW0gKz0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xuICAgIHNpemVJblNwbGl0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW2F4aXNdID0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xuICAgIG91dHB1dFNoYXBlcy5wdXNoKG91dHB1dFNoYXBlKTtcbiAgICBvdXRwdXRzW2ldID0gb3V0cHV0VmFyaWFibGUoYG91dHB1dCR7aX1gLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICBvdXRwdXRzVGVuc29ySW5mby5wdXNoKHsgZGltczogb3V0cHV0U2hhcGVzW2ldLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH0pO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaXplSW5TcGxpdEF4aXMgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCAuLi5vdXRwdXRTaGFwZXMpLFxuICApO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXJcbiAgICAucmVnaXN0ZXJVbmlmb3JtKCdpbnB1dF9zaXplJywgJ3UzMicpXG4gICAgLnJlZ2lzdGVyVW5pZm9ybSgnc2l6ZV9pbl9zcGxpdF9heGlzJywgJ3UzMicsIHNpemVJblNwbGl0QXhpcy5sZW5ndGgpXG4gICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIC4uLm91dHB1dHMpfVxuICAke2NhbGN1bGF0ZU91dHB1dEluZGV4SW1wbChzaXplSW5TcGxpdEF4aXMubGVuZ3RoKX1cbiAgJHt3cml0ZUJ1ZmZlckRhdGFJbXBsKG91dHB1dHMpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLmlucHV0X3NpemUnKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtpbnB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgdmFyIGluZGV4ID0gJHtpbnB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYXhpcyl9O1xuICAgIGxldCBvdXRwdXRfbnVtYmVyID0gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXgpO1xuICAgIGlmIChvdXRwdXRfbnVtYmVyICE9IDApIHtcbiAgICAgIGluZGV4IC09ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnb3V0cHV0X251bWJlciAtIDF1Jywgc2l6ZUluU3BsaXRBeGlzLmxlbmd0aCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbmRpY2VzJywgYXhpcywgJ2luZGV4Jyl9O1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XG4gIH1gO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTcGxpdCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBvdXRwdXRzVGVuc29ySW5mbyxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKGlucHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNwbGl0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9XG4gICAgY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVNwbGl0QXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3BsaXRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogU3BsaXRBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYXhpcyA9IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXI7XG4gIGNvbnN0IHNwbGl0U2l6ZXM6IG51bWJlcltdID0gYXR0cmlidXRlcy5zcGxpdFNpemVzIGFzIG51bWJlcltdO1xuICBjb25zdCBudW1PdXRwdXRzID0gKGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIpIDwgMCA/IHNwbGl0U2l6ZXMubGVuZ3RoIDogKGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIpO1xuICBpZiAobnVtT3V0cHV0cyAhPT0gc3BsaXRTaXplcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ3RoIG11c3QgYmUgZXF1YWwnKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpcywgbnVtT3V0cHV0cywgc3BsaXRTaXplcyB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBXT1JLR1JPVVBfU0laRSB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgaW50ZXJsZWF2ZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG51bUhlYWRzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHJvdGFyeUVtYmVkZGluZ0RpbTogbnVtYmVyO1xuICByZWFkb25seSBzY2FsZTogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBbaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGVdID0gaW5wdXRzO1xuICBjb25zdCB7IG51bUhlYWRzLCByb3RhcnlFbWJlZGRpbmdEaW0gfSA9IGF0dHJpYnV0ZXM7XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAneCcgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucywgZ290ICR7aW5wdXQuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKFxuICAgICFTaGFwZVV0aWwuYXJlRXF1YWwocG9zaXRpb25JZHMuZGltcywgW10pICYmXG4gICAgIVNoYXBlVXRpbC5hcmVFcXVhbChwb3NpdGlvbklkcy5kaW1zLCBbMV0pICYmXG4gICAgcG9zaXRpb25JZHMuZGltcy5sZW5ndGggIT09IDJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBpcyBleHBlY3RlZCB0byBoYXZlIDAsIDEsIG9yIDIgZGltZW5zaW9ucywgZ290ICR7cG9zaXRpb25JZHMuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKGNvc0NhY2hlLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7Y29zQ2FjaGUuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKHNpbkNhY2hlLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnc2luX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7c2luQ2FjaGUuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKCFTaGFwZVV0aWwuYXJlRXF1YWwoY29zQ2FjaGUuZGltcywgc2luQ2FjaGUuZGltcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dHMgJ2Nvc19jYWNoZScgYW5kICdzaW5fY2FjaGUnIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO1xuICB9XG5cbiAgaWYgKHJvdGFyeUVtYmVkZGluZ0RpbSA+IDAgJiYgbnVtSGVhZHMgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bV9oZWFkcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHJvdGFyeV9lbWJlZGRpbmdfZGltIGlzIHNwZWNpZmllZCcpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMl07XG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gY29zQ2FjaGUuZGltc1swXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dC5kaW1zLCAxKSAvIHNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBoZWFkU2l6ZSA9IHJvdGFyeUVtYmVkZGluZ0RpbSA9PT0gMCA/IGNvc0NhY2hlLmRpbXNbMV0gKiAyIDogaGlkZGVuU2l6ZSAvIG51bUhlYWRzO1xuICBpZiAocm90YXJ5RW1iZWRkaW5nRGltID4gaGVhZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdGFyeV9lbWJlZGRpbmdfZGltIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhlYWRfc2l6ZScpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uSWRzLmRpbXMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKGJhdGNoU2l6ZSAhPT0gcG9zaXRpb25JZHMuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzBdfWApO1xuICAgIH1cbiAgICBpZiAoc2VxdWVuY2VMZW5ndGggIT09IHBvc2l0aW9uSWRzLmRpbXNbMV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDEgc2hvdWxkIGJlIG9mIHNpemUgc2VxdWVuY2VfbGVuZ3RoLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzFdfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoZWFkU2l6ZSAvIDIgIT09IGNvc0NhY2hlLmRpbXNbMV0gJiYgcm90YXJ5RW1iZWRkaW5nRGltIC8gMiAhPT0gY29zQ2FjaGUuZGltc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnB1dCAnY29zX2NhY2hlJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgc2FtZSBhcyBoZWFkX3NpemUgLyAyIG9yIHJvdGFyeV9lbWJlZGRpbmdfZGltIC8gMiwgZ290ICR7XG4gICAgICAgIGNvc0NhY2hlLmRpbXNbMV1cbiAgICAgIH1gLFxuICAgICk7XG4gIH1cblxuICBpZiAoc2VxdWVuY2VMZW5ndGggPiBtYXhTZXF1ZW5jZUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHsgaW50ZXJsZWF2ZWQsIG51bUhlYWRzLCByb3RhcnlFbWJlZGRpbmdEaW0sIHNjYWxlIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dHNbMF0uZGltc1swXTtcbiAgY29uc3QgYmF0Y2hTdHJpZGUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRzWzBdLmRpbXMsIDEpO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDJdO1xuICBjb25zdCBoaWRkZW5TaXplID0gYmF0Y2hTdHJpZGUgLyBzZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgaGFsZlJvdGFyeUVtYmVkZGluZ0RpbSA9IGlucHV0c1syXS5kaW1zWzFdO1xuICBjb25zdCBoZWFkU2l6ZSA9IHJvdGFyeUVtYmVkZGluZ0RpbSA9PT0gMCA/IGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0gKiAyIDogaGlkZGVuU2l6ZSAvIG51bUhlYWRzO1xuXG4gIC8vIFJvdGFyeSBlbWJlZGRpbmdzIHdpbGwgYmUgY2FsY3VsYXRlZCBpbiBhIHBhaXItd2lzZSBmYXNoaW9uLiBJbiBhY2NvcmRhbmNlLCB1c2UgdGhlIHNoYXBlXG4gIC8vIFtiYXRjaCBzaXplLCBzZXF1ZW5jZSBsZW5ndGgsIG51bSBvZiBoZWFkcywgbnVtIG9mIHBhaXJzIHRvIHJvdGF0ZSArIG51bSBvZiBkaW1zIHRvIGNvcHldXG4gIC8vIHRvIHVuZm9sZCB0aGUgZ2xvYmFsIGluZGV4IGluIHNoYWRlci5cbiAgY29uc3QgZ2xvYmFsU2hhcGUgPSBuZXcgQXJyYXk8bnVtYmVyPihcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgaGlkZGVuU2l6ZSAvIGhlYWRTaXplLFxuICAgIGhlYWRTaXplIC0gaGFsZlJvdGFyeUVtYmVkZGluZ0RpbSxcbiAgKTtcbiAgY29uc3QgZ2xvYmFsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhnbG9iYWxTaGFwZSk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IHNjYWxlIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGdsb2JhbFNoYXBlIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGdsb2JhbFN0cmlkZXMgfSxcblxuICAgIC8vIHN0cmlkZXMgZm9yIGFkZHJlc3NpbmcgdGhlIGlucHV0L291dHB1dCB0ZW5zb3IsIGluIHBlcm11dGF0ZWQgb3JkZXIgdG8gYWxpZ24gd2l0aCB0aGUgdW5mb2xkZWQgZ2xvYmFsIGluZGV4LFxuICAgIC8vIGkuZS4gQlNOSFxuICAgIC4uLihpbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDNcbiAgICAgID8gbmV3IEFycmF5PFByb2dyYW1Vbmlmb3JtPih7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2JhdGNoU3RyaWRlLCBoaWRkZW5TaXplLCBoZWFkU2l6ZSwgMV0gfSlcbiAgICAgIDogW10pLFxuICAgIC4uLihpbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDRcbiAgICAgID8gbmV3IEFycmF5PFByb2dyYW1Vbmlmb3JtPih7XG4gICAgICAgICAgdHlwZTogRGF0YVR5cGUudWludDMyLFxuICAgICAgICAgIGRhdGE6IFtiYXRjaFN0cmlkZSwgaGVhZFNpemUsIHNlcXVlbmNlTGVuZ3RoICogaGVhZFNpemUsIDFdLFxuICAgICAgICB9KVxuICAgICAgOiBbXSksXG5cbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMsIGlucHV0c1syXS5kaW1zLCBpbnB1dHNbM10uZGltcywgaW5wdXRzWzBdLmRpbXMpLFxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgcG9zaXRpb25JZHMgPSBpbnB1dFZhcmlhYmxlKCdwb3NpdGlvbl9pZHMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgY29zQ2FjaGUgPSBpbnB1dFZhcmlhYmxlKCdjb3NfY2FjaGUnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3Qgc2luQ2FjaGUgPSBpbnB1dFZhcmlhYmxlKCdzaW5fY2FjaGUnLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcblxuICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKFtcbiAgICAgIHsgbmFtZTogJ3NjYWxlJywgdHlwZTogJ2YzMicgfSxcbiAgICAgIHsgbmFtZTogJ2dsb2JhbF9zaGFwZScsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFNoYXBlLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnZ2xvYmFsX3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBnbG9iYWxTdHJpZGVzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnaW5wdXRfb3V0cHV0X3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBnbG9iYWxTdHJpZGVzLmxlbmd0aCB9LFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgcG9zaXRpb25JZHMsIGNvc0NhY2hlLCBzaW5DYWNoZSwgb3V0cHV0KX1cblxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoV09SS0dST1VQX1NJWkUpfVxuICAgICAgICAgIGxldCBoYWxmX3JvdGFyeV9lbWJfZGltID0gdW5pZm9ybXMuJHtjb3NDYWNoZS5uYW1lfV9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgYnNuaCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlcyAlIHVuaWZvcm1zLmdsb2JhbF9zaGFwZTtcbiAgICAgICAgICBsZXQgc2l6ZSA9IHVuaWZvcm1zLmdsb2JhbF9zaGFwZVswXSAqIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzWzBdO1xuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3NpemUnKX1cblxuICAgICAgICAgIGlmIChic25oWzNdIDwgaGFsZl9yb3RhcnlfZW1iX2RpbSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkc19pZHggPVxuICAgICAgICAgICAgICAgICR7cG9zaXRpb25JZHMuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ2JzbmgueHknLCBvdXRwdXRWYXJpYWJsZSgnJywgcG9zaXRpb25JZHMudHlwZS50ZW5zb3IsIDIpKX07XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWQgPVxuICAgICAgICAgICAgICAgIHUzMigke3Bvc2l0aW9uSWRzLmdldEJ5T2Zmc2V0KCdwb3NpdGlvbl9pZHNfaWR4Jyl9KSArIHNlbGVjdCgwLCBic25oWzFdLCBwb3NpdGlvbl9pZHNfaWR4ID09IDApO1xuICAgICAgICAgICAgbGV0IGkgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgc2VsZWN0KDAsIGJzbmhbM10sICR7aW50ZXJsZWF2ZWR9KTtcbiAgICAgICAgICAgIGxldCBqID0gaSArIHNlbGVjdChoYWxmX3JvdGFyeV9lbWJfZGltLCAxLCAke2ludGVybGVhdmVkfSk7XG4gICAgICAgICAgICBsZXQgcmUgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdpJyl9ICogJHtjb3NDYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX0gLVxuICAgICAgICAgICAgICAgICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2onKX0gKiAke3NpbkNhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdpJywgJ3JlJyl9XG4gICAgICAgICAgICBsZXQgaW0gPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdpJyl9ICogJHtzaW5DYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX0gK1xuICAgICAgICAgICAgICAgICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2onKX0gKiAke2Nvc0NhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdqJywgJ2ltJyl9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIGhhbGZfcm90YXJ5X2VtYl9kaW07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaycsIGlucHV0LmdldEJ5T2Zmc2V0KCdrJykpfVxuICAgICAgICAgIH1cbiAgICAgICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnUm90YXJ5RW1iZWRkaW5nJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICAgICAgaW50ZXJsZWF2ZWQsXG4gICAgICB9KS5jYWNoZUtleSxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuaycsICdyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXRzWzBdLmRpbXMsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShnbG9iYWxTaGFwZSkgLyBXT1JLR1JPVVBfU0laRSkgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCByb3RhcnlFbWJlZGRpbmcgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuXG5pbXBvcnQgeyBhcHBseUF0dGVudGlvbiwgQXR0ZW50aW9uTWFza1R5cGUsIEF0dGVudGlvblBhcmFtZXRlcnMsIEF0dGVudGlvblFrdkZvcm1hdCB9IGZyb20gJy4vYXR0ZW50aW9uJztcbmltcG9ydCB7IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyB9IGZyb20gJy4vbXVsdGloZWFkLWF0dGVudGlvbic7XG5pbXBvcnQgeyBjcmVhdGVTcGxpdFByb2dyYW1JbmZvLCBTcGxpdEF0dHJpYnV0ZXMgfSBmcm9tICcuL3NwbGl0JztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuaW1wb3J0IHsgUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcywgY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8gfSBmcm9tICcuL3JvdGFyeS1lbWJlZGRpbmcnO1xuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybXNBcnJheVR5cGUgfSBmcm9tICcuL2NvbW1vbic7XG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwUXVlcnlBdHRlbnRpb25BdHRyaWJ1dGVzIHtcbiAgbnVtSGVhZHM6IG51bWJlcjtcbiAga3ZOdW1IZWFkczogbnVtYmVyO1xuICBzY2FsZTogbnVtYmVyO1xuICBzb2Z0Y2FwOiBudW1iZXI7XG4gIGRvUm90YXJ5OiBudW1iZXI7XG4gIHJvdGFyeUludGVybGVhdmVkOiBudW1iZXI7XG4gIHNtb290aFNvZnRtYXg6IGJvb2xlYW47XG4gIGxvY2FsV2luZG93U2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlcyxcbik6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5kb1JvdGFyeSAmJiBpbnB1dHMubGVuZ3RoIDw9IDcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZCcpO1xuICB9XG4gIGNvbnN0IHF1ZXJ5ID0gaW5wdXRzWzBdO1xuICBjb25zdCBrZXkgPSBpbnB1dHNbMV07XG4gIGNvbnN0IHZhbHVlID0gaW5wdXRzWzJdO1xuICBjb25zdCBwYXN0S2V5ID0gaW5wdXRzWzNdO1xuICBjb25zdCBwYXN0VmFsdWUgPSBpbnB1dHNbNF07XG4gIGlmIChhdHRyaWJ1dGVzLmRvUm90YXJ5ICE9PSAwICYmIGlucHV0cy5sZW5ndGggPD0gNykge1xuICAgIHRocm93IG5ldyBFcnJvcignY29zX2Nhc3QgYW5kIHNpbl9jYWNoZSBhcmUgZXhwZWN0ZWQgaWYgZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub24temVybycpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLmxvY2FsV2luZG93U2l6ZSAhPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMuc29mdGNhcCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMucm90YXJ5SW50ZXJsZWF2ZWQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMuc21vb3RoU29mdG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU21vb3RoIHNvZnRtYXggaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxuXG4gIC8vICAgICBwYXN0X2tleSAgICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHBhc3RfdmFsdWUgICAgICAgICAgICAgICAgIDogKEIsIE4sIFMqLCBIKVxuICAvLyBXaGVuIG5vIHBhY2tpbmcgZm9yIHEvay92OlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIEQpIG9yIChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIEwsIERfdikgb3IgKEIsIE4sIFMqLCBIKVxuICAvLyBXaGVuIHBhY2tlZCBrdiBpcyB1c2VkOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIE4sIDIsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcbiAgLy8gV2hlbiBwYWNrZWQgcWt2IGlzIHVzZWQ6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBMLCBOLCAzLCBIKSBvciAoQiwgUywgMypEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiBOb25lXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcblxuICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGNvbnN0IGRtbWhhUGFja2luZyA9IGZhbHNlO1xuICBjb25zdCBiYXRjaFNpemUgPSBxdWVyeS5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IHF1ZXJ5LmRpbXNbMV07XG4gIGxldCBoaWRkZW5TaXplID1cbiAgICBxdWVyeS5kaW1zLmxlbmd0aCA9PT0gMyA/IChkbW1oYVBhY2tpbmcgPyBxdWVyeS5kaW1zWzJdIC8gMyA6IHF1ZXJ5LmRpbXNbMl0pIDogYXR0cmlidXRlcy5udW1IZWFkcyAqIHF1ZXJ5LmRpbXNbNF07XG4gIGxldCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG5cbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGNvbnN0IHBhY2tlZFFLViA9ICFrZXkgfHwga2V5LmRpbXMubGVuZ3RoID09PSAwO1xuICBjb25zdCBoZWFkU2l6ZSA9ICFwYWNrZWRRS1ZcbiAgICA/IE1hdGguZmxvb3IoaGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpXG4gICAgOiBNYXRoLmZsb29yKGhpZGRlblNpemUgLyAoYXR0cmlidXRlcy5udW1IZWFkcyArIDIgKiBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMpKTtcbiAgaWYgKHBhY2tlZFFLVikge1xuICAgIGhpZGRlblNpemUgPSBoZWFkU2l6ZSAqIGF0dHJpYnV0ZXMubnVtSGVhZHM7XG4gIH1cbiAgY29uc3QgaGFzUGFzdEtleSA9IHBhc3RLZXkgJiYgcGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gMDtcbiAgY29uc3QgaGFzUGFzdFZhbHVlID0gcGFzdFZhbHVlICYmIHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gMDtcbiAgLy8gQ3VycmVudGx5IHRoZSBvbm54cnVudGltZSBHUUEgc3BlY2lmaWNhdGlvbiBvbmx5IHN1cHBvcnQga2V5L3ZhbHVlIEJOU0ggZm9ybWF0LlxuICBjb25zdCBpc1Bhc3RrdkJTTkggPVxuICAgIGhhc1Bhc3RLZXkgJiZcbiAgICBwYXN0S2V5LmRpbXMubGVuZ3RoID09PSA0ICYmXG4gICAgcGFzdEtleS5kaW1zWzBdID09PSBiYXRjaFNpemUgJiZcbiAgICBwYXN0S2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyAmJlxuICAgIHBhc3RLZXkuZGltc1syXSA9PT0gYXR0cmlidXRlcy5rdk51bUhlYWRzICYmXG4gICAgcGFzdEtleS5kaW1zWzNdID09PSBoZWFkU2l6ZTtcblxuICBpZiAoaXNQYXN0a3ZCU05IKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCU05IIHBhc3RLZXkvcGFzdFZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBpZiAoaGFzUGFzdEtleSAmJiBoYXNQYXN0VmFsdWUpIHtcbiAgICBpZiAocGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gIH0gZWxzZSBpZiAoaGFzUGFzdEtleSB8fCBoYXNQYXN0VmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XG4gIH1cblxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2Qk5TSDtcbiAgaWYgKGtleSAmJiBrZXkuZGltcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKHF1ZXJ5LmRpbXNbMl0gJSBrZXkuZGltc1syXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7XG4gICAgICB9XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gMiB8fCBrZXkuZGltc1s0XSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtcbiAgICAgIH1cbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ga2V5X2RpbXMuc2l6ZSgpID09IDQgKGNyb3NzLWF0dGVudGlvbiB3aXRoIHBhc3Rfa2V5KVxuICAgICAgaWYgKGtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtcbiAgICAgIH1cbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcGFja2VkIFFLVlxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggPT09IDUgJiYgKHF1ZXJ5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcXVlcnkuZGltc1szXSAhPT0gMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgIH1cblxuICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU04zSDtcbiAgfVxuXG4gIGNvbnN0IG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGxldCBwYXNzUGFzdEluS3YgPSBmYWxzZTtcbiAgbGV0IHZIaWRkZW5TaXplID0gYXR0cmlidXRlcy5rdk51bUhlYWRzID8gaGVhZFNpemUgKiBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMgOiBoaWRkZW5TaXplO1xuICBpZiAodmFsdWUgJiYgdmFsdWUuZGltcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoICE9PSAzICYmIHZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IHZhbHVlLmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgICAgfVxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1syXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgICAgfVxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzFdICogdmFsdWUuZGltc1szXTtcbiAgICAgIHBhc3NQYXN0SW5LdiA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlcWxMZW5zID0gaW5wdXRzLmxlbmd0aCA+IDQgPyBpbnB1dHNbNV0gOiB1bmRlZmluZWQ7XG4gIGlmIChzZXFsTGVucyAmJiBzZXFsTGVucy5kaW1zLmxlbmd0aCAhPT0gMSAmJiBzZXFsTGVucy5kaW1zWzBdICE9PSBiYXRjaFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwic2VxbGVuc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24gYW5kIHRoZSBzYW1lIGRpbSAwIGFzIGJhdGNoX3NpemUnKTtcbiAgfVxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gLTE7XG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gLTE7XG4gIGNvbnN0IGJyb2FkY2FzdFJlc1Bvc0JpYXMgPSBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcbiAgICBoaWRkZW5TaXplLFxuICAgIHZIaWRkZW5TaXplLFxuICAgIGhlYWRTaXplLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyksXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXG4gICAga3ZOdW1IZWFkczogYXR0cmlidXRlcy5rdk51bUhlYWRzLFxuICAgIG5SZXBzOiBhdHRyaWJ1dGVzLm51bUhlYWRzIC8gYXR0cmlidXRlcy5rdk51bUhlYWRzLFxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXMsXG4gICAgcGFzc1Bhc3RJbkt2LFxuICAgIHFrdkZvcm1hdCxcbiAgfTtcbn07XG5cbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZTogVHJhbnNwb3NlQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IFswLCAyLCAxLCAzXSB9KTtcblxuY29uc3QgbWF5YmVUcmFuc3Bvc2VUb0JOU0ggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0OiBUZW5zb3JWaWV3LCBwYXJhbXM6IEF0dGVudGlvblBhcmFtZXRlcnMpID0+IHtcbiAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcbiAgY29uc3QgbnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyE7XG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCA9PT0gMyAmJiBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCAhPT0gMCkge1xuICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIHBhcmFtcy5oZWFkU2l6ZV0pO1xuICAgIHJlc2hhcGVkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLCB7XG4gICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0XSxcbiAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgfSlbMF07XG4gIH1cblxuICByZXR1cm4gcmVzaGFwZWRJbnB1dDtcbn07XG5cbmNvbnN0IGdlbmVyYXRlUG9zaXRpb25JZHNQcm9ncmFtSW5mbyA9IChcbiAgYmF0Y2hTaXplOiBudW1iZXIsXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4gIHNlcUxlbnM6IFRlbnNvclZpZXcsXG4gIHRvdGFsU2VxTGVuOiBUZW5zb3JWaWV3LFxuKSA9PiB7XG4gIGNvbnN0IG91dHB1dERhdGFUeXBlID0gRGF0YVR5cGUuaW50NjQ7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplICogc2VxdWVuY2VMZW5ndGhdO1xuICBjb25zdCBvdXRwdXRTaXplID0gYmF0Y2hTaXplICogc2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBiYXRjaFNpemUgfSxcbiAgXTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgc2VxTGVuc0lucHV0SGVscGVyID0gaW5wdXRWYXJpYWJsZSgnc2VxX2xlbnMnLCBzZXFMZW5zLmRhdGFUeXBlLCBzZXFMZW5zLmRpbXMpO1xuICAgIGNvbnN0IHRvdGFsU2VxTGVuSW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd0b3RhbF9zZXFfbGVucycsIHRvdGFsU2VxTGVuLmRhdGFUeXBlLCB0b3RhbFNlcUxlbi5kaW1zKTtcbiAgICBjb25zdCBwb3NpdGlvbklkc0hlbHBlciA9IG91dHB1dFZhcmlhYmxlKCdwb3NfaWRzJywgb3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdiYXRjaF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhzZXFMZW5zSW5wdXRIZWxwZXIsIHRvdGFsU2VxTGVuSW5wdXRIZWxwZXIsIHBvc2l0aW9uSWRzSGVscGVyKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7dG90YWxTZXFMZW5JbnB1dEhlbHBlci5nZXRCeU9mZnNldCgnMCcpfSk7XG4gICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID0gdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgIGxldCBpc19maXJzdF9wcm9tcHQgPSAhaXNfc3Vic2VxdWVudF9wcm9tcHQgJiYgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoID09IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcbiAgICBsZXQgc2VxdWVuY2VfaWR4ID0gaTMyKGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGgpO1xuICAgIHZhciBwb3NfaWQ6IGkzMiA9IDA7XG4gICAgbGV0IHNlcWxlbiA9ICR7c2VxTGVuc0lucHV0SGVscGVyLmdldEJ5T2Zmc2V0KCdiYXRjaF9pZHgnKX07XG4gICAgbGV0IHRvdGFsX3NlcWxlbiA9IHNlcWxlbiArIDE7XG4gICAgaWYgKGlzX2ZpcnN0X3Byb21wdCkge1xuICAgICAgaWYgKHNlcXVlbmNlX2lkeCA8IHRvdGFsX3NlcWxlbikge1xuICAgICAgICBwb3NfaWQgPSBzZXF1ZW5jZV9pZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NfaWQgPSAxO1xuICAgICAgfVxuICAgICAgJHtwb3NpdGlvbklkc0hlbHBlci5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdwb3NfaWQnKX1cbiAgICB9IGVsc2UgaWYgKGlzX3N1YnNlcXVlbnRfcHJvbXB0KSB7XG4gICAgICBsZXQgcGFzdF9zZXFsZW4gPSB0b3RhbF9zZXFsZW4gLSBpMzIodW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICAgIGlmIChwYXN0X3NlcWxlbiArIHNlcXVlbmNlX2lkeCA8IHRvdGFsX3NlcWxlbikge1xuICAgICAgICBwb3NfaWQgPSBwYXN0X3NlcWxlbiArIHNlcXVlbmNlX2lkeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc19pZCA9IDE7XG4gICAgICB9XG4gICAgICAke3Bvc2l0aW9uSWRzSGVscGVyLnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3Bvc19pZCcpfVxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsX2lkeCA8IHVuaWZvcm1zLmJhdGNoX3NpemUpIHtcbiAgICAgICR7cG9zaXRpb25JZHNIZWxwZXIuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc2VxbGVuJyl9XG4gICAgfTtcbiAgfVxuICBgO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHZW5lcmF0ZVBvc2l0aW9uSWRzJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtiYXRjaFNpemV9OyR7c2VxdWVuY2VMZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ3JvdXBRdWVyeUF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBpZiAoY29udGV4dC5pbnB1dHNbMV0/LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBjb25zdCBxID0gY29udGV4dC5pbnB1dHNbMF07XG4gIGNvbnN0IGsgPSBjb250ZXh0LmlucHV0c1sxXSAmJiBjb250ZXh0LmlucHV0c1sxXS5kaW1zLmxlbmd0aCA+IDAgPyBjb250ZXh0LmlucHV0c1sxXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdiA9IGNvbnRleHQuaW5wdXRzWzJdICYmIGNvbnRleHQuaW5wdXRzWzJdLmRpbXMubGVuZ3RoID4gMCA/IGNvbnRleHQuaW5wdXRzWzJdIDogdW5kZWZpbmVkO1xuICBjb25zdCBwYXN0S2V5ID0gY29udGV4dC5pbnB1dHNbM10gJiYgY29udGV4dC5pbnB1dHNbM10uZGltcy5sZW5ndGggIT09IDAgPyBjb250ZXh0LmlucHV0c1szXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgcGFzdFZhbHVlID0gY29udGV4dC5pbnB1dHNbNF0gJiYgY29udGV4dC5pbnB1dHNbNF0uZGltcy5sZW5ndGggIT09IDAgPyBjb250ZXh0LmlucHV0c1s0XSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgc2VxTGVucyA9IGNvbnRleHQuaW5wdXRzLmxlbmd0aCA+IDQgPyBjb250ZXh0LmlucHV0c1s1XSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0ID0gY29udGV4dC5pbnB1dHMubGVuZ3RoID4gNSA/IGNvbnRleHQuaW5wdXRzWzZdIDogdW5kZWZpbmVkO1xuICBjb25zdCBrdk51bUhlYWRzID0gcGFyYW1zLmt2TnVtSGVhZHMgPyBwYXJhbXMua3ZOdW1IZWFkcyA6IHBhcmFtcy5udW1IZWFkcztcblxuICAvLyBUT0RPIFJlbW92ZSBleHBsaWNpdCBzcGxpdCBvcGVyYXRpb24gYW5kIHVzZSBpbmRleGluZyBpbiBBdHRlbnRpb24gaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgb3ZlcmhlYWQuXG5cbiAgY29uc3Qgc3BsaXRBdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF4aXM6IDIsXG4gICAgbnVtT3V0cHV0czogMyxcbiAgICBzcGxpdFNpemVzOiBbcGFyYW1zLm51bUhlYWRzICogcGFyYW1zLmhlYWRTaXplLCBrdk51bUhlYWRzICogcGFyYW1zLmhlYWRTaXplLCBrdk51bUhlYWRzICogcGFyYW1zLmhlYWRTaXplXSxcbiAgfSk7XG4gIGNvbnN0IFtxdWVyeSwga2V5LCB2YWx1ZV0gPVxuICAgICFrICYmICF2XG4gICAgICA/IGNvbnRleHQuY29tcHV0ZShjcmVhdGVTcGxpdFByb2dyYW1JbmZvKFtxXSwgc3BsaXRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFtxXSwgb3V0cHV0czogWy0xLCAtMSwgLTFdIH0pXG4gICAgICA6IFtxLCBrISwgdiFdO1xuICBsZXQgcVJvdGFyeTogVGVuc29yVmlldyB8IHVuZGVmaW5lZDtcbiAgbGV0IGtSb3Rhcnk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQ7XG4gIGlmIChhdHRyaWJ1dGVzLmRvUm90YXJ5KSB7XG4gICAgY29uc3QgcG9zSWRzID0gY29udGV4dC5jb21wdXRlKFxuICAgICAgZ2VuZXJhdGVQb3NpdGlvbklkc1Byb2dyYW1JbmZvKHBhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCwgc2VxTGVucyEsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCEpLFxuICAgICAgeyBpbnB1dHM6IFtzZXFMZW5zISwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0IV0sIG91dHB1dHM6IFstMV0gfSxcbiAgICApWzBdO1xuICAgIGNvbnN0IGNvc0NhY2hlID0gY29udGV4dC5pbnB1dHNbN107XG4gICAgY29uc3Qgc2luQ2FjaGUgPSBjb250ZXh0LmlucHV0c1s4XTtcbiAgICBjb25zdCBxUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgICBpbnRlcmxlYXZlZDogYXR0cmlidXRlcy5yb3RhcnlJbnRlcmxlYXZlZCAhPT0gMCxcbiAgICAgIG51bUhlYWRzOiBwYXJhbXMubnVtSGVhZHMsXG4gICAgICByb3RhcnlFbWJlZGRpbmdEaW06IDAsXG4gICAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcbiAgICB9KTtcbiAgICBjb25zdCBpbnB1dHMgPSBbcXVlcnksIHBvc0lkcywgY29zQ2FjaGUsIHNpbkNhY2hlXTtcbiAgICBjb25zdCBvdXRwdXRzID0gWy0xXTtcbiAgICBxUm90YXJ5ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvKGlucHV0cywgcVJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpLCB7XG4gICAgICBpbnB1dHMsXG4gICAgICBvdXRwdXRzLFxuICAgIH0pWzBdO1xuICAgIGlucHV0cy5zcGxpY2UoMCwgMSwga2V5KTtcbiAgICBjb25zdCBrUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgICBpbnRlcmxlYXZlZDogYXR0cmlidXRlcy5yb3RhcnlJbnRlcmxlYXZlZCAhPT0gMCxcbiAgICAgIG51bUhlYWRzOiBwYXJhbXMua3ZOdW1IZWFkcyEsXG4gICAgICByb3RhcnlFbWJlZGRpbmdEaW06IDAsXG4gICAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcbiAgICB9KTtcbiAgICBrUm90YXJ5ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvKGlucHV0cywga1JvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpLCB7XG4gICAgICBpbnB1dHMsXG4gICAgICBvdXRwdXRzLFxuICAgIH0pWzBdO1xuICB9XG4gIGNvbnN0IFEgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgY29udGV4dCxcbiAgICBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIHBhcmFtcy5udW1IZWFkcyxcbiAgICBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFyYW1zLmhlYWRTaXplLFxuICAgIGF0dHJpYnV0ZXMuZG9Sb3RhcnkgPyBxUm90YXJ5ISA6IHF1ZXJ5LFxuICAgIHVuZGVmaW5lZCxcbiAgICAwLFxuICApO1xuICBjb25zdCBLID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0goY29udGV4dCwgYXR0cmlidXRlcy5kb1JvdGFyeSA/IGtSb3RhcnkhIDoga2V5LCBwYXJhbXMpO1xuICBjb25zdCBWID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0goY29udGV4dCwgdmFsdWUsIHBhcmFtcyk7XG5cbiAgYXBwbHlBdHRlbnRpb24oXG4gICAgY29udGV4dCxcbiAgICBRLFxuICAgIEssXG4gICAgVixcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIHBhc3RLZXksXG4gICAgcGFzdFZhbHVlLFxuICAgIHVuZGVmaW5lZCxcbiAgICBwYXJhbXMsXG4gICAgc2VxTGVucyxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXG4gICk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHN1bVZlY3RvcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFuY2VOb3JtQXR0cmlidXRlcyB7XG4gIGVwc2lsb246IG51bWJlcjtcbiAgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XG59XG5cbmNvbnN0IGNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdCA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBzY2FsZTogVGVuc29yVmlldyxcbiAgYmlhczogVGVuc29yVmlldyxcbiAgbjogbnVtYmVyLFxuICBoOiBudW1iZXIsXG4gIGM6IG51bWJlcixcbiAgZXBzaWxvbjogbnVtYmVyLFxuKSA9PiB7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGgpO1xuICBjb25zdCBmMzJUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICdmMzInIDogYHZlYyR7Y29tcG9uZW50c31mYDtcbiAgY29uc3Qgd2dUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICd2ZWMyZicgOiBgbWF0Mngke2NvbXBvbmVudHN9ZmA7XG4gIGNvbnN0IHVuaXRzT2ZXb3JrID0gbiAqIGM7XG4gIGxldCB3b3JrZ3JvdXBTaXplID0gNjQ7XG4gIGlmICh1bml0c09mV29yayA9PT0gMSkge1xuICAgIHdvcmtncm91cFNpemUgPSAyNTY7XG4gIH1cbiAgY29uc3QgaW5wdXRTaGFwZSA9IFtuLCBjLCBoIC8gY29tcG9uZW50c107XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW24sIGMsIDJdO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICd0eXBlJywgJ3R5cGUnXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgMywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMpO1xuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgYmlhcy5kaW1zKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIDMsIDIpO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFt4LCBzLCBiLCBvdXRwdXRdO1xuICAgIHJldHVybiBgXG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQgOiBhcnJheTwke3dnVHlwZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xuICBjb25zdCB3b3JrZ3JvdXBfc2l6ZSA9ICR7d29ya2dyb3VwU2l6ZX11O1xuICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCh3b3JrZ3JvdXBTaXplKX1cbiAgICBsZXQgYmF0Y2ggPSB3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBjaGFubmVsID0gd29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgaGlnaHQgPSB1bmlmb3Jtcy54X3NoYXBlWzJdO1xuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxuICAgIHZhciBzdW0gPSAke2YzMlR5cGV9KDApO1xuICAgIHZhciBzcXVhcmVkX3N1bSA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsX2lkeDsgaCA8IGhpZ2h0OyBoICs9IHdvcmtncm91cF9zaXplKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke2YzMlR5cGV9KCR7eC5nZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcpfSk7XG4gICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSAke3dnVHlwZX0oc3VtLCBzcXVhcmVkX3N1bSk7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBfc2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gKyB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsX2lkeCA9PSAwKSB7XG4gICAgICBsZXQgc3VtX2ZpbmFsID0gJHtzdW1WZWN0b3IoJ3dvcmtncm91cF9zaGFyZWRbMF1bMF0nLCBjb21wb25lbnRzKX0gLyBmMzIoaGlnaHQgKiAke2NvbXBvbmVudHN9KTtcbiAgICAgIGxldCBzcXVhcmVkX3N1bV9maW5hbCA9ICR7c3VtVmVjdG9yKCd3b3JrZ3JvdXBfc2hhcmVkWzBdWzFdJywgY29tcG9uZW50cyl9IC8gZjMyKGhpZ2h0ICogJHtjb21wb25lbnRzfSk7XG5cbiAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRfc3VtX2ZpbmFsIC0gc3VtX2ZpbmFsICogc3VtX2ZpbmFsICsgZjMyKCR7ZXBzaWxvbn0pKTtcbiAgICAgIGxldCBjaGFubmVsX3NjYWxlID0gaW52X3N0ZF9kZXYgKiBmMzIoc2NhbGVbY2hhbm5lbF0pO1xuICAgICAgbGV0IGNoYW5uZWxfc2hpZnQgPSBmMzIoYmlhc1tjaGFubmVsXSkgLSBzdW1fZmluYWwgKiBjaGFubmVsX3NjYWxlO1xuICAgICAgb3V0cHV0W3dvcmtncm91cF9pbmRleF0gPSB2ZWMyZihjaGFubmVsX3NjYWxlLCBjaGFubmVsX3NoaWZ0KTtcbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdCcsXG4gICAgICAvLyBUT0RPOiB1c2UgZXBzaWxvbiBhcyB1bmlmb3JtLiBDdXJyZW50bHkgZXBzaWxvbiBhcyB1bmlmb3JtIGZhaWxzIHRlc3RfaW5zdGFuY2Vub3JtX2Vwc2lsb24uXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfTske2Vwc2lsb259OyR7d29ya2dyb3VwU2l6ZX1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiB1bml0c09mV29yayB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbaW5wdXQsIHNjYWxlLCBiaWFzXSwgb3V0cHV0czogWy0xXSB9LFxuICApWzBdO1xufTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2VOb3JtUHJvZ3JhbUluZm8gPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyxcbikgPT4ge1xuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gIGNvbnN0IGF4aXMgPSAyO1xuICBjb25zdCBOID0geFNoYXBlWzBdO1xuICBjb25zdCBDID0geFNoYXBlWzFdO1xuICBjb25zdCBIID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEgpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcbiAgLy8gY29tcHV0ZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0LlxuICBjb25zdCBjaGFubmVsU2NhbGVTaGlmdCA9IGNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdChcbiAgICBjb250ZXh0LFxuICAgIGlucHV0c1swXSxcbiAgICBpbnB1dHNbMV0sXG4gICAgaW5wdXRzWzJdLFxuICAgIE4sXG4gICAgSCxcbiAgICBDLFxuICAgIGF0dHJpYnV0ZXMuZXBzaWxvbixcbiAgKTtcblxuICBjb25zdCBpbnB1dFNoYXBlID0gW04sIEMsIEggLyBjb21wb25lbnRzXTtcbiAgY29uc3Qgc2NhbGVTaGFwZSA9IFtOLCBDXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAnbm9uZSddO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZV9zaGlmdCcsIERhdGFUeXBlLmZsb2F0LCBzY2FsZVNoYXBlLmxlbmd0aCwgMik7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFt4LCBzY2FsZSwgb3V0cHV0XTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XG4gICAgICBsZXQgc2NhbGVfc2hpZnQgPSAke3NjYWxlLmdldEJ5SW5kaWNlcygndmVjMjx1MzI+KGJhdGNoLCBjaGFubmVsKScpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7eC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfSAqICR7b3V0cHV0LnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LngpICsgJHtvdXRwdXQudHlwZS52YWx1ZX0oc2NhbGVfc2hpZnQueSk7XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgfWA7XG4gIH07XG5cbiAgY29udGV4dC5jb21wdXRlKFxuICAgIHtcbiAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb24nLFxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBzY2FsZVNoYXBlLCBpbnB1dFNoYXBlKSxcbiAgICAgICAgXSxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtpbnB1dHNbMF0sIGNoYW5uZWxTY2FsZVNoaWZ0XSB9LFxuICApO1xufTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2VOb3JtTkhXQ1Byb2dyYW1JbmZvID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMsXG4pID0+IHtcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICBjb25zdCBOID0geFNoYXBlWzBdO1xuICBjb25zdCBDID0geFNoYXBlW3hTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgSCA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIDEpIC8gQztcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoQyk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihDIC8gY29tcG9uZW50cykgfSxcbiAgXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuXG4gIC8vIDEuIHRyYW5zcG9zZSB4IGZyb20gTkhXQyB0byBOQ0hXXG4gIGxldCBuZWVkVHJhbnNwb3NlID0gZmFsc2U7XG4gIGNvbnN0IHRyYW5zcG9zZWRYUGVybSA9IFswLCB4U2hhcGUubGVuZ3RoIC0gMV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeFNoYXBlLmxlbmd0aCAtIDI7IGkrKykge1xuICAgIG5lZWRUcmFuc3Bvc2UgPSBuZWVkVHJhbnNwb3NlIHx8IHhTaGFwZVtpICsgMV0gIT09IDE7XG4gICAgdHJhbnNwb3NlZFhQZXJtLnB1c2goaSArIDEpO1xuICB9XG5cbiAgbmVlZFRyYW5zcG9zZSA9IG5lZWRUcmFuc3Bvc2UgJiYgeFNoYXBlW3hTaGFwZS5sZW5ndGggLSAxXSAhPT0gMTtcblxuICBjb25zdCB0cmFuc3Bvc2VkWCA9IG5lZWRUcmFuc3Bvc2VcbiAgICA/IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgdHJhbnNwb3NlZFhQZXJtKSwge1xuICAgICAgICBpbnB1dHM6IFtjb250ZXh0LmlucHV0c1swXV0sXG4gICAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgICB9KVswXVxuICAgIDogY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShBcnJheS5mcm9tKHsgbGVuZ3RoOiB4U2hhcGUubGVuZ3RoIH0sIChfLCBpKSA9PiB4U2hhcGVbdHJhbnNwb3NlZFhQZXJtW2ldXSkpO1xuICAvLyAyLiBjb21wdXRlIGNoYW5uZWwgc2NhbGUgYW5kIGNoYW5uZWwgc2hpZnQuXG4gIGNvbnN0IGNoYW5uZWxTY2FsZVNoaWZ0ID0gY29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0KFxuICAgIGNvbnRleHQsXG4gICAgdHJhbnNwb3NlZFgsXG4gICAgaW5wdXRzWzFdLFxuICAgIGlucHV0c1syXSxcbiAgICBOLFxuICAgIEgsXG4gICAgQyxcbiAgICBhdHRyaWJ1dGVzLmVwc2lsb24sXG4gICk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgY29uc3Qgc2NhbGVUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICd2ZWMyZicgOiBgbWF0JHtjb21wb25lbnRzfXgyZmA7XG4gICAgY29uc3Qgc2NhbGVEYXRhID0gKG51bTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IG51bSA9PT0gMCA/ICd4JyA6ICd5JztcbiAgICAgIGNvbnN0IGYzMlR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ2YzMicgOiBgdmVjJHtjb21wb25lbnRzfWZgO1xuICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gYCR7ZGF0YVR5cGV9KCR7ZjMyVHlwZX0oc2NhbGUuJHtpbmRleH0pKWA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gYHZlYzI8JHtkYXRhVHlwZX0+KCR7ZjMyVHlwZX0oc2NhbGVbMF0uJHtpbmRleH0sIHNjYWxlWzFdLiR7aW5kZXh9KSlgO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGB2ZWM0PCR7ZGF0YVR5cGV9Pigke2YzMlR5cGV9KHNjYWxlWzBdLiR7aW5kZXh9LCBzY2FsZVsxXS4ke2luZGV4fSwgc2NhbGVbMl0uJHtpbmRleH0sIHNjYWxlWzNdLiR7aW5kZXh9KSlgO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBjb21wb2VudHMgJHtjb21wb25lbnRzfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IG91dHB1dEhlbHBlciA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKTtcblxuICAgIHJldHVybiBgXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke2lucHV0SGVscGVyLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlX2lucHV0IDogYXJyYXk8JHtzY2FsZVR5cGV9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke291dHB1dEhlbHBlci50eXBlLnN0b3JhZ2V9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHtIOiB1MzIsIEMgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICBsZXQgY3VycmVudF9pbWFnZV9udW1iZXIgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLkMgKiB1bmlmb3Jtcy5IKTtcbiAgICBsZXQgY3VycmVudF9jaGFubmVsX251bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IHNjYWxlX29mZnNldCA9IGN1cnJlbnRfaW1hZ2VfbnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRfY2hhbm5lbF9udW1iZXI7XG4gICAgbGV0IHNjYWxlID0gc2NhbGVfaW5wdXRbc2NhbGVfb2Zmc2V0XTtcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7c2NhbGVEYXRhKDApfSwgJHtzY2FsZURhdGEoMSl9KTtcbiAgfWA7XG4gIH07XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uTkhXQycsXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbaW5wdXRzWzBdLCBjaGFubmVsU2NhbGVTaGlmdF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpbnN0YW5jZU5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycpIHtcbiAgICBjcmVhdGVJbnN0YW5jZU5vcm1OSFdDUHJvZ3JhbUluZm8oY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY2FzdFRvRjMyLFxuICBmaWxsVmVjdG9yLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBzdW1WZWN0b3IsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuaW50ZXJmYWNlIExheWVyTm9ybUF0dHJpYnV0ZXMge1xuICBzaW1wbGlmaWVkOiBib29sZWFuO1xuICBheGlzOiBudW1iZXI7XG4gIGVwc2lsb246IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy4nKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlTGF5ZXJOb3JtUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBMYXllck5vcm1BdHRyaWJ1dGVzLFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xuXG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzY2FsZSA9IGlucHV0c1sxXTtcbiAgY29uc3QgYmlhcyA9ICFzaW1wbGlmaWVkICYmIGlucHV0c1syXTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgeFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG5vcm1Db3VudCA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcbiAgY29uc3Qgbm9ybVNpemUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcblxuICBjb25zdCBzY2FsZVNpemUgPSBTaGFwZVV0aWwuc2l6ZShzY2FsZS5kaW1zKTtcbiAgY29uc3QgYmlhc1NpemUgPSBiaWFzID8gU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA6IDA7XG4gIGlmIChzY2FsZVNpemUgIT09IG5vcm1TaXplIHx8IChiaWFzICYmIGJpYXNTaXplICE9PSBub3JtU2l6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke25vcm1TaXplfS5cbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7c2NhbGVTaXplfSBhbmQgYmlhcyBzaXplIG9mICR7Ymlhc1NpemV9YCk7XG4gIH1cblxuICBjb25zdCBtZWFuSW52U3RkRGV2RGltOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHhTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgYXhpcykge1xuICAgICAgbWVhbkludlN0ZERldkRpbS5wdXNoKHhTaGFwZVtpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCgxKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMobm9ybVNpemUpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbm9ybUNvdW50IH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogbm9ybVNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihub3JtU2l6ZSAvIGNvbXBvbmVudHMpIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9uIH0sXG4gIF07XG4gIGlmIChiaWFzKSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGNvbnN0IGhhc01lYW5EYXRhT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAxO1xuICBjb25zdCBoYXNJbnZTdGRPdXRwdXQgPSBvdXRwdXRDb3VudCA+IDI7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbXG4gICAgICBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgY29tcG9uZW50cyksXG4gICAgICBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIHNjYWxlLmRhdGFUeXBlLCBzY2FsZS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICBdO1xuICAgIGlmIChiaWFzKSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgYmlhcy5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgfVxuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKSk7XG4gICAgaWYgKGhhc01lYW5EYXRhT3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnbWVhbl9kYXRhX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgfVxuICAgIGlmIChoYXNJbnZTdGRPdXRwdXQpIHtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnZfc3RkX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnbm9ybV9jb3VudCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdub3JtX3NpemUnLCB0eXBlOiAnZjMyJyB9LFxuICAgICAgeyBuYW1lOiAnbm9ybV9zaXplX3ZlY3Rvcml6ZWQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZXBzaWxvbicsIHR5cGU6ICdmMzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm5vcm1fY291bnQnKX1cbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkO1xuICAgIHZhciBtZWFuX3ZlY3RvciA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuICAgIHZhciBtZWFuX3NxdWFyZV92ZWN0b3IgPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICd4W2ggKyBvZmZzZXRdJyl9O1xuICAgICAgbWVhbl92ZWN0b3IgKz0gdmFsdWU7XG4gICAgICBtZWFuX3NxdWFyZV92ZWN0b3IgKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IG1lYW4gPSAke3N1bVZlY3RvcignbWVhbl92ZWN0b3InLCBjb21wb25lbnRzKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemU7XG4gICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtzdW1WZWN0b3IoJ21lYW5fc3F1YXJlX3ZlY3RvcicsIGNvbXBvbmVudHMpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZSAke1xuICAgICAgc2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbiAqIG1lYW4nXG4gICAgfSArIHVuaWZvcm1zLmVwc2lsb24pO1xuXG4gICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBqKyspIHtcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAneFtqICsgb2Zmc2V0XScpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAnc2NhbGVbal0nKX07XG4gICAgICBvdXRwdXRbaiArIG9mZnNldF0gPSAke3ZhcmlhYmxlc1swXS50eXBlLnZhbHVlfSgoZjMyaW5wdXQgJHtzaW1wbGlmaWVkID8gJycgOiAnLSBtZWFuJ30pICogaW52X3N0ZF9kZXYgKiBmMzJzY2FsZVxuICAgICAgICAke2JpYXMgPyBgKyAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ2JpYXNbal0nKX1gIDogJyd9XG4gICAgICApO1xuICAgIH1cblxuICAgICR7aGFzTWVhbkRhdGFPdXRwdXQgPyAnbWVhbl9kYXRhX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW4nIDogJyd9O1xuICAgICR7aGFzSW52U3RkT3V0cHV0ID8gJ2ludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXYnIDogJyd9O1xuICB9YDtcbiAgfTtcbiAgY29uc3Qgb3V0cHV0cyA9IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dO1xuICBpZiAoaGFzTWVhbkRhdGFPdXRwdXQpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XG4gIH1cbiAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0xheWVyTm9ybWFsaXphdGlvbicsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c307JHtvdXRwdXRDb3VudH07JHtzaW1wbGlmaWVkfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHMsXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChub3JtQ291bnQgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgbGF5ZXJOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50KSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vbWF0bXVsLXNoYWRlcnMnO1xuaW1wb3J0IHsgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdE11bCByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXSAhPT0gaW5wdXRzWzFdLmRpbXNbaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBtYXRNdWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXMsIHRydWUpO1xuICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtcbiAgfVxuICBjb25zdCBOID0gb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IEsgPSBjb250ZXh0LmlucHV0c1swXS5kaW1zW2NvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV07XG4gIGlmIChOIDwgOCAmJiBLIDwgOCkge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB7IGFjdGl2YXRpb246ICcnIH0sIG91dHB1dFNoYXBlKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgTSA9IG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDJdO1xuICAgIGNvbnN0IGJhdGNoQSA9IFNoYXBlVXRpbC5zaXplKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwgLTIpKTtcbiAgICBjb25zdCBiYXRjaEIgPSBTaGFwZVV0aWwuc2l6ZShjb250ZXh0LmlucHV0c1sxXS5kaW1zLnNsaWNlKDAsIC0yKSk7XG4gICAgaWYgKGJhdGNoQSAhPT0gMSAmJiBNID09PSAxICYmIGJhdGNoQiA9PT0gMSkge1xuICAgICAgLy8gT3B0aW1pemF0aW9uIGZvciBiYXRjaGVkIHZlYy1tYXQtbXVsXG4gICAgICBjb25zdCByZXNoYXBlZEEgPSBjb250ZXh0LmlucHV0c1swXS5yZXNoYXBlKFsxLCBiYXRjaEEsIEtdKTtcbiAgICAgIGNvbnN0IHJlc2hhcGVkQiA9IGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoWzEsIEssIE5dKTtcbiAgICAgIGNvbnN0IG1hdG11bE91dHB1dFNoYXBlID0gWzEsIGJhdGNoQSwgTl07XG4gICAgICBjb25zdCBtYXRtdWxJbnB1dHMgPSBbcmVzaGFwZWRBLCByZXNoYXBlZEJdO1xuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKG1hdG11bElucHV0cywgeyBhY3RpdmF0aW9uOiAnJyB9LCBvdXRwdXRTaGFwZSwgbWF0bXVsT3V0cHV0U2hhcGUpLCB7XG4gICAgICAgIGlucHV0czogbWF0bXVsSW5wdXRzLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgeyBhY3RpdmF0aW9uOiAnJyB9LCBvdXRwdXRTaGFwZSkpO1xuICAgIH1cbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbi8vICBUT0RPIHN1cHBvcnQgcXVhbnRpemF0aW9uIGJpdHMgbm90IGVxdWFsIHRvIDRcbmV4cG9ydCBpbnRlcmZhY2UgTWF0TXVsTkJpdHNBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgazogbnVtYmVyO1xuICBuOiBudW1iZXI7XG4gIGFjY3VyYWN5TGV2ZWw6IG51bWJlcjtcbiAgYml0czogbnVtYmVyO1xuICBibG9ja1NpemU6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDMgfHwgaW5wdXRzLmxlbmd0aCA+IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMnKTtcbiAgfVxuICBjb25zdCBhID0gaW5wdXRzWzBdO1xuICBjb25zdCBhUmFuayA9IGEuZGltcy5sZW5ndGg7XG4gIGlmIChhLmRpbXNbYVJhbmsgLSAxXSAhPT0gYXR0cmlidXRlcy5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGFzdCBkaW0gb2YgaW5wdXQgc2hhcGUgZG9lcyBub3QgbWF0Y2ggdGhlIGsgdmFsdWUnKTtcbiAgfVxuICBjb25zdCBuQmxvY2tzUGVyQ29sID0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5rICsgYXR0cmlidXRlcy5ibG9ja1NpemUgLSAxKSAvIGF0dHJpYnV0ZXMuYmxvY2tTaXplKTtcbiAgY29uc3QgYmxvYlNpemUgPSAoYXR0cmlidXRlcy5ibG9ja1NpemUgLyA4KSAqIGF0dHJpYnV0ZXMuYml0cztcbiAgY29uc3QgYiA9IGlucHV0c1sxXTtcbiAgaWYgKCFTaGFwZVV0aWwuYXJlRXF1YWwoYi5kaW1zLCBbYXR0cmlidXRlcy5uLCBuQmxvY2tzUGVyQ29sLCBibG9iU2l6ZV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemUnKTtcbiAgfVxuICBjb25zdCBzY2FsZXMgPSBpbnB1dHNbMl07XG4gIGNvbnN0IHNjYWxlc1NoYXBlID0gc2NhbGVzLmRpbXM7XG4gIGlmIChTaGFwZVV0aWwuc2l6ZShzY2FsZXNTaGFwZSkgIT09IGF0dHJpYnV0ZXMubiAqIG5CbG9ja3NQZXJDb2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxlcyBpbnB1dCBzaXplIGVycm9yLicpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgY29uc3QgemVyb1BvaW50cyA9IGlucHV0c1szXTtcbiAgICBjb25zdCB6ZXJvUG9pbnRzU2hhcGUgPSB6ZXJvUG9pbnRzLmRpbXM7XG5cbiAgICAvLyBUaGlzIGFzc3VtZXMgemVybyBwb2ludHMgYXJlIHBhY2tlZC5cbiAgICAvLyBVbnBhY2sgZm9ybWF0ICh6ZXJvIHBvaW50IGhhcyBzYW1lIGRhdGEgdHlwZSBhbmQgc2hhcGUgYXMgc2NhbGUpIGlzIG5vdCBzdXBwb3J0ZWQgYnkgd2ViZ3B1LlxuICAgIGNvbnN0IGV4cGVjdGVkWmVyb1BvaW50c1NpemUgPVxuICAgICAgYXR0cmlidXRlcy5uICogKGF0dHJpYnV0ZXMuYml0cyA9PT0gOCA/IG5CbG9ja3NQZXJDb2wgOiBNYXRoLmZsb29yKChuQmxvY2tzUGVyQ29sICogYXR0cmlidXRlcy5iaXRzICsgNykgLyA4KSk7XG4gICAgaWYgKFNoYXBlVXRpbC5zaXplKHplcm9Qb2ludHNTaGFwZSkgIT09IGV4cGVjdGVkWmVyb1BvaW50c1NpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignemVyb1BvaW50cyBpbnB1dCBzaXplIGVycm9yLicpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdE11bE5CaXRzUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgYVJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZGltQU91dGVyID0gaW5wdXRTaGFwZVthUmFuayAtIDJdO1xuICBjb25zdCBkaW1Jbm5lciA9IGF0dHJpYnV0ZXMuaztcbiAgY29uc3QgZGltQk91dGVyID0gYXR0cmlidXRlcy5uO1xuICBjb25zdCBiYXRjaERpbXMgPSBpbnB1dFNoYXBlLnNsaWNlKDAsIGFSYW5rIC0gMik7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGJhdGNoRGltcyk7XG4gIGNvbnN0IGJsb2JTaXplID0gaW5wdXRzWzFdLmRpbXNbMl07XG4gIGNvbnN0IGJsb2JTaXplSW5Xb3JkcyA9IGJsb2JTaXplIC8gNDtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGFDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhhdHRyaWJ1dGVzLmspO1xuICBjb25zdCBiQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYmxvYlNpemVJbldvcmRzKTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoZGltQk91dGVyKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBiYXRjaERpbXMuY29uY2F0KFtkaW1BT3V0ZXIsIGRpbUJPdXRlcl0pO1xuICBjb25zdCBvdXRwdXROdW1iZXIgPSBkaW1BT3V0ZXIgPiAxICYmIChkaW1CT3V0ZXIgLyBjb21wb25lbnRzKSAlIDIgPT09IDAgPyAyIDogMTtcbiAgY29uc3QgZGlzcGF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcblxuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gNjQ7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIGNvbnN0IGlucHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGFDb21wb25lbnRzXTtcbiAgY29uc3QgYlNoYXBlID0gU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbMV0uZGltcykuc2xpY2UoKTtcbiAgYlNoYXBlLnNwbGljZSgtMSwgMSwgYmxvYlNpemVJbldvcmRzIC8gYkNvbXBvbmVudHMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlVGVtcCkpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGUpKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1szXS5kaW1zKSkpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyIC8gY29tcG9uZW50c107XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlVGVtcCkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGVUZW1wLmxlbmd0aDtcbiAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRSYW5rLCBhQ29tcG9uZW50cyk7XG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBEYXRhVHlwZS51aW50MzIsIGJTaGFwZS5sZW5ndGgsIGJDb21wb25lbnRzKTtcbiAgICBjb25zdCBzY2FsZXMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbYSwgYiwgc2NhbGVzXTtcbiAgICBjb25zdCB6ZXJvUG9pbnRzID1cbiAgICAgIGlucHV0cy5sZW5ndGggPT09IDQgPyBpbnB1dFZhcmlhYmxlKCd6ZXJvX3BvaW50cycsIERhdGFUeXBlLnVpbnQzMiwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoemVyb1BvaW50cykge1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlVGVtcC5sZW5ndGg7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0UmFuaywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICAgIGNvbnN0IHFEcURhdGFUeXBlID0gKCgpID0+IHtcbiAgICAgIHN3aXRjaCAoYUNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBgYXJyYXk8JHtkYXRhVHlwZX0sIDg+YDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBgbWF0NHgyPCR7ZGF0YVR5cGV9PmA7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gYG1hdDJ4NDwke2RhdGFUeXBlfT5gO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHthQ29tcG9uZW50c30tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIE51bWJlciBvZiBxdWFudGl6ZWQgdmFsdWVzIHBlciB1MzIgd29yZCBhbmQgcGFzc2VzIG5lZWRlZCAoZWFjaCBwYXNzIGV4dHJhY3RzIDggdmFsdWVzKS5cbiAgICBjb25zdCB2YWx1ZXNQZXJXb3JkID0gTWF0aC5mbG9vcigzMiAvIGF0dHJpYnV0ZXMuYml0cyk7IC8vIFE0PTgsIFEyPTE2XG4gICAgY29uc3QgcGFzc2VzUGVyV29yZCA9IE1hdGguZmxvb3IodmFsdWVzUGVyV29yZCAvIDgpOyAvLyBRND0xLCBRMj0yXG5cbiAgICBjb25zdCBwcm9jZXNzT25lV29yZCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSAnJztcbiAgICAgIGZvciAobGV0IHBhc3MgPSAwOyBwYXNzIDwgcGFzc2VzUGVyV29yZDsgcGFzcysrKSB7XG4gICAgICAgIC8vIEVhY2ggcGFzcyBwcm9jZXNzZXMgOCB2YWx1ZXMgZnJvbSB0aGUgY3VycmVudCB1MzIgd29yZC5cbiAgICAgICAgLy8gRm9yIFE0IChwYXNzPTApOiBzaGlmdCBieSAwIGFuZCA0LiBGb3IgUTIgKHBhc3MgMDogc2hpZnQgMCwyOyBwYXNzIDE6IHNoaWZ0IDQsNikuXG4gICAgICAgIGNvbnN0IGxvd2VyU2hpZnQgPSBwYXNzICogYXR0cmlidXRlcy5iaXRzICogNDsgLy8gYml0IG9mZnNldCBmb3IgbG93ZXIgZ3JvdXAgd2l0aGluIGVhY2ggYnl0ZVxuICAgICAgICBjb25zdCB1cHBlclNoaWZ0ID0gbG93ZXJTaGlmdCArIGF0dHJpYnV0ZXMuYml0cztcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgLy8gcmV1c2UgYSBkYXRhIChwYXNzICR7cGFzc30pXG4gICAgICAgICAgICB2YXIgaW5wdXRfb2Zmc2V0JHtwYXNzID4gMCA/IHBhc3MgOiAnJ30gPSAke3Bhc3MgPT09IDAgPyBhLmluZGljZXNUb09mZnNldChgJHthLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgd29yZF9vZmZzZXQpYCkgOiBgaW5wdXRfb2Zmc2V0YH07XG4gICAgICAgICAgICB2YXIgYV9kYXRhJHtwYXNzID4gMCA/IHBhc3MgOiAnJ306ICR7cURxRGF0YVR5cGV9O1xuICAgICAgICAgICAgZm9yICh2YXIgaiR7cGFzcyA+IDAgPyBwYXNzIDogJyd9OiB1MzIgPSAwOyBqJHtwYXNzID4gMCA/IHBhc3MgOiAnJ30gPCAkezggLyBhQ29tcG9uZW50c307IGoke3Bhc3MgPiAwID8gcGFzcyA6ICcnfSsrKSB7XG4gICAgICAgICAgICAgIGFfZGF0YSR7cGFzcyA+IDAgPyBwYXNzIDogJyd9W2oke3Bhc3MgPiAwID8gcGFzcyA6ICcnfV0gPSAke2EuZ2V0QnlPZmZzZXQoYGlucHV0X29mZnNldCR7cGFzcyA+IDAgPyBwYXNzIDogJyd9YCl9O1xuICAgICAgICAgICAgICBpbnB1dF9vZmZzZXQke3Bhc3MgPiAwID8gcGFzcyA6ICcnfSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29tcG9uZW50cyAqIG91dHB1dE51bWJlcjsgYysrKSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtiQ29tcG9uZW50cyA9PT0gMSA/IGBiJHtjfV9kYXRhYCA6IGBiJHtjfV9kYXRhW2ldYH07XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmJpdHMgPT09IDJcbiAgICAgICAgICAgICAgICA/IGB7XG4gICAgICAgICAgICAgIGxldCBoYWxmX3dvcmQgPSBiX3ZhbHVlID4+ICR7cGFzcyAqIDE2fXU7XG4gICAgICAgICAgICAgIGxldCBieXRlX2xvID0gaGFsZl93b3JkICYgMHhGRnU7XG4gICAgICAgICAgICAgIGxldCBieXRlX2hpID0gKGhhbGZfd29yZCA+PiA4dSkgJiAweEZGdTtcbiAgICAgICAgICAgICAgbGV0IHNwcmVhZF93b3JkID0gKGJ5dGVfbG8gJiAweEZ1KSB8ICgoYnl0ZV9sbyA+PiA0dSkgPDwgOHUpIHwgKChieXRlX2hpICYgMHhGdSkgPDwgMTZ1KSB8ICgoYnl0ZV9oaSA+PiA0dSkgPDwgMjR1KTtcbiAgICAgICAgICAgICAgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoc3ByZWFkX3dvcmQgJiBiX21hc2spO1xuICAgICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoc3ByZWFkX3dvcmQgPj4gMnUpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIH1gXG4gICAgICAgICAgICAgICAgOiBgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gJHtsb3dlclNoaWZ0fXUpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+ICR7dXBwZXJTaGlmdH11KSAmIGJfbWFzayk7YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYl9xdWFudGl6ZWRfdmFsdWVzID0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICB7IGxlbmd0aDogNCB9LFxuICAgICAgICAgICAgICAoXywgaSkgPT4gYCR7ZGF0YVR5cGV9KGJfdmFsdWVfbG93ZXJbJHtpfV0pLCAke2RhdGFUeXBlfShiX3ZhbHVlX3VwcGVyWyR7aX1dKWAsXG4gICAgICAgICAgICApLmpvaW4oJywgJyl9KTtcbiAgICAgICAgICAgIGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cURxRGF0YVR5cGV9KCR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiA4IH0sXG4gICAgICAgICAgICAgICAgICAoXywgaSkgPT4gYChiX3F1YW50aXplZF92YWx1ZXNbJHtpfV0gLSAke3plcm9Qb2ludHMgPyBgemVyb19wb2ludCR7Y31gIDogJ3plcm9fcG9pbnQnfSkgKiBzY2FsZSR7Y31gLFxuICAgICAgICAgICAgICAgICkuam9pbignLCAnKX0pO2A7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheSg4KVxuICAgICAgICAgICAgICAgICAgLmZpbGwoYCR7emVyb1BvaW50cyA/IGB6ZXJvX3BvaW50JHtjfWAgOiAnemVyb19wb2ludCd9YClcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9KSkgKiBzY2FsZSR7Y307YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke291dHB1dE51bWJlcn0gKyAke01hdGguZmxvb3IoYyAvIGNvbXBvbmVudHMpfV0ke2NvbXBvbmVudHMgPiAxID8gYFske2MgJSBjb21wb25lbnRzfV1gIDogJyd9ICs9ICR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgeyBsZW5ndGg6IDggLyBhQ29tcG9uZW50cyB9LFxuICAgICAgICAgICAgICAoXywgaSkgPT5cbiAgICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICAgIGFDb21wb25lbnRzID09PSAxXG4gICAgICAgICAgICAgICAgICAgID8gYGFfZGF0YSR7cGFzcyA+IDAgPyBwYXNzIDogJyd9WyR7aX1dICogYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV1gXG4gICAgICAgICAgICAgICAgICAgIDogYGRvdChhX2RhdGEke3Bhc3MgPiAwID8gcGFzcyA6ICcnfVske2l9XSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV0pYFxuICAgICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgKS5qb2luKCcgKyAnKX07XG4gICAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlU2NhbGVBbmRaZXJvUG9pbnQgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgIGxldCBjYWxjU3RyID0gYFxuICAgICAgICAgICAgdmFyIGNvbF9pbmRleCA9IGNvbCAqICR7Y29tcG9uZW50c307XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICB6ZXJvUG9pbnRzXG4gICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZXNfcGVyX2J5dGU6IHUzMiA9ICR7TWF0aC5mbG9vcig4IC8gYXR0cmlidXRlcy5iaXRzKX11O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuQmxvY2tzUGVyQ29sICsgemVyb19wb2ludF92YWx1ZXNfcGVyX2J5dGUgLSAxdSkgLyB6ZXJvX3BvaW50X3ZhbHVlc19wZXJfYnl0ZTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfY291bnQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmRfaW5kZXg6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0OiB1MzI7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9zdWJfb2Zmc2V0OiB1MzIgPSBibG9jayAlIHplcm9fcG9pbnRfdmFsdWVzX3Blcl9ieXRlO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgXG4gICAgICAgICAgICAgICAgOiBgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzICR7TWF0aC5wb3coMiwgYXR0cmlidXRlcy5iaXRzIC0gMSl9IGZvciB1bnNpZ25lZCAke2F0dHJpYnV0ZXMuYml0c30tYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHtNYXRoLnBvdygyLCBhdHRyaWJ1dGVzLmJpdHMgLSAxKS50b0ZpeGVkKDEpfSk7YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29tcG9uZW50cyAqIG91dHB1dE51bWJlcjsgYysrKSB7XG4gICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgbGV0IHNjYWxlJHtjfSA9ICR7c2NhbGVzLmdldEJ5T2Zmc2V0KGBjb2xfaW5kZXggKiBuQmxvY2tzUGVyQ29sICsgYmxvY2tgKX07XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICB6ZXJvUG9pbnRzXG4gICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBjb2xfaW5kZXggKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgLyB6ZXJvX3BvaW50X3ZhbHVlc19wZXJfYnl0ZSk7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfc3ViX29mZnNldCAqICR7YXR0cmlidXRlcy5iaXRzfXUpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X3dvcmRfaW5kZXgnKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtjfSA9ICR7ZGF0YVR5cGV9KCh6ZXJvX3BvaW50X3dvcmQpICYgJHthdHRyaWJ1dGVzLmJpdHMgPT09IDIgPyAnMHgzdScgOiAnMHhGdSd9KTtgXG4gICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZUJEYXRhID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICBsZXQgY2FsY1N0ciA9IGBjb2xfaW5kZXggPSBjb2wgKiAke2NvbXBvbmVudHN9O2A7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbXBvbmVudHMgKiBvdXRwdXROdW1iZXI7IGMrKykge1xuICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgIGxldCBiJHtjfV9kYXRhID0gJHtiLmdldEJ5SW5kaWNlcyhgJHtiLnR5cGUuaW5kaWNlc30oY29sX2luZGV4LCBibG9jaywgd29yZClgKX07XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO1xuICAgICAgfVxuICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICB2YXIgYl92YWx1ZTogdTMyO1xuICAgICAgICAgICAgbGV0IGJfbWFzazogdTMyID0gJHthdHRyaWJ1dGVzLmJpdHMgPT09IDIgPyAnMHgwMzAzMDMwM3UnIDogJzB4MEYwRjBGMEZ1J307XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV9sb3dlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfdXBwZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3F1YW50aXplZF92YWx1ZXM6ICR7cURxRGF0YVR5cGV9O1xuICAgICAgICAgICAgdmFyIGJfZGVxdWFudGl6ZWRfdmFsdWVzOiAke3FEcURhdGFUeXBlfTtgO1xuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICByZXR1cm4gYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXIgKiB3b3JrZ3JvdXBTaXplfT47XG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbd29ya2dyb3VwU2l6ZSwgMSwgMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgKGdsb2JhbF9pZHggLyAke3dvcmtncm91cFNpemV9KSAqICR7b3V0cHV0TnVtYmVyfWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuQmxvY2tzUGVyQ29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcblxuICAgICAgICAgIGZvciAodmFyIGJsb2NrID0gbG9jYWxfaWQueDsgYmxvY2sgPCBuQmxvY2tzUGVyQ29sOyBibG9jayArPSAke3dvcmtncm91cFNpemV9KSB7XG4gICAgICAgICAgICAvL3Byb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQ6IHUzMiA9IGJsb2NrICogJHthdHRyaWJ1dGVzLmJsb2NrU2l6ZSAvIGFDb21wb25lbnRzfTtcbiAgICAgICAgICAgICR7cHJlcGFyZVNjYWxlQW5kWmVyb1BvaW50KCl9XG4gICAgICAgICAgICBmb3IgKHZhciB3b3JkOiB1MzIgPSAwOyB3b3JkIDwgJHtibG9iU2l6ZUluV29yZHN9OyB3b3JkICs9ICR7YkNvbXBvbmVudHN9KSB7XG4gICAgICAgICAgICAgICR7cHJlcGFyZUJEYXRhKCl9XG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2JDb21wb25lbnRzfTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJHtwcm9jZXNzT25lV29yZCgpfVxuICAgICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7dmFsdWVzUGVyV29yZCAvIGFDb21wb25lbnRzfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICBpZiAobG9jYWxfaWQueCA8ICR7b3V0cHV0TnVtYmVyfSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtvdXRwdXQudHlwZS52YWx1ZX0gPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgIHZhciB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldDogdTMyID0gbG9jYWxfaWQueDtcbiAgICAgICAgICAgIGZvciAodmFyIGI6IHUzMiA9IDB1OyBiIDwgJHt3b3JrZ3JvdXBTaXplfXU7IGIrKykge1xuICAgICAgICAgICAgICBvdXRwdXRfdmFsdWUgKz0gd29ya2dyb3VwX3NoYXJlZFt3b3JrZ3JvdXBfc2hhcmVkX29mZnNldF07XG4gICAgICAgICAgICAgIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0ICs9ICR7b3V0cHV0TnVtYmVyfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5SW5kaWNlcyhgJHtvdXRwdXQudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBjb2wgKyBsb2NhbF9pZC54KWAsICdvdXRwdXRfdmFsdWUnKX07XG4gICAgICAgICAgfVxuICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnTWF0TXVsTkJpdHMnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmJsb2NrU2l6ZX07JHthdHRyaWJ1dGVzLmJpdHN9OyR7YUNvbXBvbmVudHN9OyR7YkNvbXBvbmVudHN9OyR7Y29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7d29ya2dyb3VwU2l6ZX1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoJ3JhbmsnKSxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoU2l6ZSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbi8vIEN1cnJlbnRseSwgb25seSBzdXBwb3J0IGJsb2NrU2l6ZSA9IDMyLlxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdE11bE5CaXRzQmxvY2tTaXplMzJQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBhUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBkaW1BT3V0ZXIgPSBpbnB1dFNoYXBlW2FSYW5rIC0gMl07XG4gIGNvbnN0IGRpbUlubmVyID0gYXR0cmlidXRlcy5rO1xuICBjb25zdCBkaW1CT3V0ZXIgPSBhdHRyaWJ1dGVzLm47XG4gIGNvbnN0IGJhdGNoRGltcyA9IGlucHV0U2hhcGUuc2xpY2UoMCwgYVJhbmsgLSAyKTtcbiAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUoYmF0Y2hEaW1zKTtcbiAgY29uc3QgYmxvYlNpemUgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3QgYmxvYlNpemVJbldvcmRzID0gYmxvYlNpemUgLyA0O1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGF0dHJpYnV0ZXMuayk7XG4gIGNvbnN0IGJDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhibG9iU2l6ZUluV29yZHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGJhdGNoRGltcy5jb25jYXQoW2RpbUFPdXRlciwgZGltQk91dGVyXSk7XG5cbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDEyODtcbiAgY29uc3Qgd29ya2dyb3VwWSA9IGRpbUJPdXRlciAlIDggPT09IDAgPyA4IDogZGltQk91dGVyICUgNCA9PT0gMCA/IDQgOiAxO1xuICBjb25zdCB3b3JrZ3JvdXBYID0gd29ya2dyb3VwU2l6ZSAvIHdvcmtncm91cFk7XG4gIGNvbnN0IHZhbHVlc1BlcldvcmRCczMyID0gTWF0aC5mbG9vcigzMiAvIGF0dHJpYnV0ZXMuYml0cyk7IC8vIFE0PTgsIFEyPTE2XG4gIGNvbnN0IHRpbGVTaXplID0gd29ya2dyb3VwWCAqIGJDb21wb25lbnRzICogdmFsdWVzUGVyV29yZEJzMzI7IC8vIGVhY2ggdWludDMyIGhhcyB2YWx1ZXNQZXJXb3JkIGRhdGEuXG4gIGNvbnN0IGFMZW5ndGhQZXJUaWxlID0gdGlsZVNpemUgLyBhQ29tcG9uZW50cztcbiAgY29uc3QgYmxvY2tzUGVyVGlsZSA9IHRpbGVTaXplIC8gYXR0cmlidXRlcy5ibG9ja1NpemU7XG4gIGNvbnN0IGRpc3BhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIHdvcmtncm91cFk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIGNvbnN0IGlucHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGFDb21wb25lbnRzXTtcbiAgY29uc3QgYlNoYXBlID0gU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbMV0uZGltcykuc2xpY2UoKTtcbiAgYlNoYXBlLnNwbGljZSgtMSwgMSwgYmxvYlNpemVJbldvcmRzIC8gYkNvbXBvbmVudHMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlVGVtcCkpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGUpKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1szXS5kaW1zKSkpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZVRlbXAubGVuZ3RoO1xuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmssIGFDb21wb25lbnRzKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIERhdGFUeXBlLnVpbnQzMiwgYlNoYXBlLmxlbmd0aCwgYkNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiLCBzY2FsZXNdO1xuICAgIGNvbnN0IHplcm9Qb2ludHMgPVxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgIGlmICh6ZXJvUG9pbnRzKSB7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHplcm9Qb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGVUZW1wLmxlbmd0aDtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRSYW5rKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgIGNvbnN0IHJlYWRBID0gKCkgPT4ge1xuICAgICAgc3dpdGNoIChhQ29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtgO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiBzdWJfYTogYXJyYXk8JHthLnR5cGUudmFsdWV9LCAke2FMZW5ndGhQZXJUaWxlfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke3dvcmtncm91cFh9PiwgJHt3b3JrZ3JvdXBZfT47XG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbd29ya2dyb3VwWCwgd29ya2dyb3VwWSwgMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgd29ya2dyb3VwX2luZGV4ICogJHt3b3JrZ3JvdXBZfWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuX2Jsb2Nrc19wZXJfY29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgbnVtX3RpbGVzID0gIChuX2Jsb2Nrc19wZXJfY29sIC0gMSkgLyAke2Jsb2Nrc1BlclRpbGV9ICsgMTtcblxuICAgICAgICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgICAgICAgIGZvciAodmFyIHRpbGU6IHUzMiA9IDA7IHRpbGUgPCBudW1fdGlsZXM7IHRpbGUgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGFfY29sX3N0YXJ0ID0gdGlsZSAqICR7YUxlbmd0aFBlclRpbGV9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHthTGVuZ3RoUGVyVGlsZX07IGFfb2Zmc2V0ICs9ICR7d29ya2dyb3VwU2l6ZX0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBhX2NvbCA9IGFfY29sX3N0YXJ0ICsgYV9vZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChhX2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMl0pXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke2EuZ2V0QnlJbmRpY2VzKGAke2EudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBhX2NvbClgKX07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHthLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICAgIC8vIGVhY2ggdGhyZWFkIHByb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICBsZXQgYl9yb3cgPSBjb2wgKyBsb2NhbF9pZC55O1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGlsZSAqICR7YmxvY2tzUGVyVGlsZX0gKyBsb2NhbF9pZC54O1xuICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgemVyb1BvaW50c1xuICAgICAgICAgICAgICAgID8gYFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWVzX3Blcl9ieXRlOiB1MzIgPSAke01hdGguZmxvb3IoOCAvIGF0dHJpYnV0ZXMuYml0cyl9dTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobl9ibG9ja3NfcGVyX2NvbCArIHplcm9fcG9pbnRfdmFsdWVzX3Blcl9ieXRlIC0gMXUpIC8gemVyb19wb2ludF92YWx1ZXNfcGVyX2J5dGU7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlX2NvdW50ID0gYl9yb3cgKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgLyB6ZXJvX3BvaW50X3ZhbHVlc19wZXJfYnl0ZSk7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9zdWJfb2Zmc2V0OiB1MzIgPSBibG9jayAlIHplcm9fcG9pbnRfdmFsdWVzX3Blcl9ieXRlO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X3N1Yl9vZmZzZXQgKiAke2F0dHJpYnV0ZXMuYml0c311KTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmQgPSAke3plcm9Qb2ludHMuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfd29yZF9pbmRleCcpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2RhdGFUeXBlfSgoemVyb19wb2ludF93b3JkKSAmICR7YXR0cmlidXRlcy5iaXRzID09PSAyID8gJzB4M3UnIDogJzB4RnUnfSk7YFxuICAgICAgICAgICAgICAgIDogYFxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyAke01hdGgucG93KDIsIGF0dHJpYnV0ZXMuYml0cyAtIDEpfSBmb3IgdW5zaWduZWQgJHthdHRyaWJ1dGVzLmJpdHN9LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7ZGF0YVR5cGV9KCR7TWF0aC5wb3coMiwgYXR0cmlidXRlcy5iaXRzIC0gMSkudG9GaXhlZCgxKX0pO2BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7c2NhbGVzLmdldEJ5T2Zmc2V0KGBiX3JvdyAqIG5fYmxvY2tzX3Blcl9jb2wgKyBibG9ja2ApfTtcbiAgICAgICAgICAgIGxldCBiX2RhdGEgPSAke2IuZ2V0QnlJbmRpY2VzKGAke2IudHlwZS5pbmRpY2VzfShiX3JvdywgYmxvY2ssIDApYCl9O1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0ID0gbG9jYWxfaWQueCAqICR7YXR0cmlidXRlcy5ibG9ja1NpemUgLyBhQ29tcG9uZW50c307XG4gICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtiQ29tcG9uZW50c307IGkrKykge1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZSA9ICR7YkNvbXBvbmVudHMgPT09IDEgPyBgYl9kYXRhYCA6IGBiX2RhdGFbaV1gfTtcbiAgICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhc3Nlc1BlcldvcmRCczMyID0gTWF0aC5mbG9vcih2YWx1ZXNQZXJXb3JkQnMzMiAvIDgpO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcGFzcyA9IDA7IHBhc3MgPCBwYXNzZXNQZXJXb3JkQnMzMjsgcGFzcysrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsb3dlclNoaWZ0ID0gcGFzcyAqIGF0dHJpYnV0ZXMuYml0cyAqIDQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1cHBlclNoaWZ0ID0gbG93ZXJTaGlmdCArIGF0dHJpYnV0ZXMuYml0cztcbiAgICAgICAgICAgICAgICAgIGNvZGUgKz0gYFxuICAgICAgICAgICAgICAke3JlYWRBKCl9XG4gICAgICAgICAgICAgIHske1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYml0cyA9PT0gMlxuICAgICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICAgICAgbGV0IGhhbGZfd29yZCA9IGJfdmFsdWUgPj4gJHtwYXNzICogMTZ9dTtcbiAgICAgICAgICAgICAgICBsZXQgYnl0ZV9sbyA9IGhhbGZfd29yZCAmIDB4RkZ1O1xuICAgICAgICAgICAgICAgIGxldCBieXRlX2hpID0gKGhhbGZfd29yZCA+PiA4dSkgJiAweEZGdTtcbiAgICAgICAgICAgICAgICBsZXQgc3ByZWFkX3dvcmQgPSAoYnl0ZV9sbyAmIDB4RnUpIHwgKChieXRlX2xvID4+IDR1KSA8PCA4dSkgfCAoKGJ5dGVfaGkgJiAweEZ1KSA8PCAxNnUpIHwgKChieXRlX2hpID4+IDR1KSA8PCAyNHUpO1xuICAgICAgICAgICAgICAgIGxldCBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChzcHJlYWRfd29yZCAmIDB4MDMwMzAzMDN1KTtcbiAgICAgICAgICAgICAgICBsZXQgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKHNwcmVhZF93b3JkID4+IDJ1KSAmIDB4MDMwMzAzMDN1KTtgXG4gICAgICAgICAgICAgICAgICA6IGBcbiAgICAgICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gJHtsb3dlclNoaWZ0fXUpICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICAgIGxldCBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiAke3VwcGVyU2hpZnR9dSkgJiAweDBGMEYwRjBGdSk7YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJfcXVhbnRpemVkX3ZhbHVlcyA9IG1hdDJ4NDwke2RhdGFUeXBlfT4oJHtBcnJheS5mcm9tKFxuICAgICAgICAgICAgICAgICAgeyBsZW5ndGg6IDQgfSxcbiAgICAgICAgICAgICAgICAgIChfLCBpKSA9PiBgJHtkYXRhVHlwZX0oYl92YWx1ZV9sb3dlclske2l9XSksICR7ZGF0YVR5cGV9KGJfdmFsdWVfdXBwZXJbJHtpfV0pYCxcbiAgICAgICAgICAgICAgICApLmpvaW4oJywgJyl9KTtcbiAgICAgICAgICAgICAgICBsZXQgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gbWF0Mng0PCR7ZGF0YVR5cGV9Pigke0FycmF5KDgpLmZpbGwoJ3plcm9fcG9pbnQnKS5qb2luKCcsJyl9KSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdICs9ICR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiAyIH0sXG4gICAgICAgICAgICAgICAgICAoXywgaSkgPT4gYCR7YGRvdChhX2RhdGEke2l9LCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XSlgfWAsXG4gICAgICAgICAgICAgICAgKS5qb2luKCcgKyAnKX07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4IC8gYUNvbXBvbmVudHN9O2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICAgICAgICB9KSgpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb2NhbF9pZHggPCAke3dvcmtncm91cFl9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHt3b3JrZ3JvdXBYfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWR4KWAsICdvdXRwdXRfdmFsdWUnKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCbG9ja3dpc2VNYXRNdWxOQml0czMyJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5ibG9ja1NpemV9OyR7YUNvbXBvbmVudHN9OyR7YkNvbXBvbmVudHN9OyR7d29ya2dyb3VwWH07JHt3b3JrZ3JvdXBZfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogQXJyYXkoaW5wdXRzLmxlbmd0aCkuZmlsbCgncmFuaycpLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hTaXplIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IG1hdE11bE5CaXRzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoXG4gICAgYXR0cmlidXRlcy5ibG9ja1NpemUgPT09IDMyICYmXG4gICAgY29udGV4dC5hZGFwdGVySW5mby5pc1ZlbmRvcignaW50ZWwnKSAmJlxuICAgIGNvbnRleHQuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoJ2dlbi0xMmxwJylcbiAgKSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdE11bE5CaXRzQmxvY2tTaXplMzJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1hdE11bE5CaXRzQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PE1hdE11bE5CaXRzQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBQYWRBdHRyaWJ1dGVzIHtcbiAgLy8gMC1jb25zdGFudCwgMS1yZWZsZWN0LCAyLWVkZ2UsIDMtd3JhcFxuICByZWFkb25seSBtb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG4gIHJlYWRvbmx5IHBhZHM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGUgbXVzdCBiZSBmbG9hdCBvciBmbG9hdDE2LicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gMikge1xuICAgIGxldCB2YWxpZFBhZHMgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggKiAyID09PSBpbnB1dHNbMV0uZGltc1swXTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFsaWRQYWRzID0gaW5wdXRzWzNdLmRpbXNbMF0gKiAyID09PSBpbnB1dHNbMV0uZGltc1swXTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZFBhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhZHMgc2hvdWxkIGJlIGEgMUQgdGVuc29yIG9mIHNoYXBlIFsyICogaW5wdXRfcmFua10gb3IgWzIgKiBudW1fYXhlc10uJyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBnZXRQYWRDb25zdGFudCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRSZWZsZWN0ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSAtIDEpO1xuICAgICAgICAgICAgICAgICAgayA9IGsgJSBfMm5fMTtcbiAgICAgICAgICAgICAgICAgIGlmKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZEVkZ2UgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICBrID0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkV3JhcCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xuICAgICAgICAgICAgICAgICAgayAtPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFNuaXBwZXQgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHN0cmluZyA9PiB7XG4gIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGdldFBhZENvbnN0YW50KG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZ2V0UGFkUmVmbGVjdChvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGdldFBhZEVkZ2Uob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBnZXRQYWRXcmFwKG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlUGFkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnBhZFNoYXBlKGlucHV0c1swXS5kaW1zLnNsaWNlKCksIGF0dHJpYnV0ZXMucGFkcyk7XG4gIGNvbnN0IGlucHV0RGltcyA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHMgfSxcbiAgXTtcblxuICBjb25zdCBpc1ZhbHVlRnJvbUlucHV0ID0gaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhO1xuICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAwKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBpc1ZhbHVlRnJvbUlucHV0ID8gaW5wdXRzWzJdLmRhdGFUeXBlIDogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMudmFsdWUgfSk7XG4gIH1cblxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXREaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgIGNvbnN0IHBhZFNuaXBwZXQgPSBnZXRQYWRTbmlwcGV0KG91dHB1dCwgaW5wdXREaW1zLmxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggfSxcbiAgICBdO1xuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcbiAgICAgIHVuaWZvcm1zLnB1c2goeyBuYW1lOiAnY29uc3RhbnRfdmFsdWUnLCB0eXBlOiAoaXNWYWx1ZUZyb21JbnB1dCA/IGRhdGFUeXBlIDogJ2YzMicpIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgwKTtcbiAgICAgICAgICAgICR7cGFkU25pcHBldH1cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdQYWQnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMubW9kZX0ke2lzVmFsdWVGcm9tSW5wdXR9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBiaWdJbnQ2NFBhZHMgPSBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpO1xuICAgIGNvbnN0IHZhbHVlID1cbiAgICAgIGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YVxuICAgICAgICA/IGlucHV0c1syXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNlxuICAgICAgICAgID8gaW5wdXRzWzJdLmdldFVpbnQxNkFycmF5KClbMF1cbiAgICAgICAgICA6IGlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXVxuICAgICAgICA6IDAuMDtcblxuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgICBjb25zdCB1cGRhdGVQYWRzID0gbmV3IEludDMyQXJyYXkoMiAqIGlucHV0UmFuaykuZmlsbCgwKTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA0KSB7XG4gICAgICBjb25zdCBheGVzID0gaW5wdXRzWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVQYWRzW051bWJlcihheGVzW2ldKV0gPSBOdW1iZXIoYmlnSW50NjRQYWRzW2ldKTtcbiAgICAgICAgdXBkYXRlUGFkc1tOdW1iZXIoYXhlc1tpXSkgKyBpbnB1dFJhbmtdID0gTnVtYmVyKGJpZ0ludDY0UGFkc1tpICsgYXhlcy5sZW5ndGhdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmlnSW50NjRQYWRzLmZvckVhY2goKHYsIGkpID0+ICh1cGRhdGVQYWRzW051bWJlcihpKV0gPSBOdW1iZXIodikpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRzOiBudW1iZXJbXSA9IFtdO1xuICAgIHVwZGF0ZVBhZHMuZm9yRWFjaCgodikgPT4gcGFkcy5wdXNoKHYpKTtcblxuICAgIHJldHVybiB7IG1vZGU6IGF0dHJpYnV0ZXMubW9kZSwgdmFsdWUsIHBhZHMgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUGFkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFBvb2xDb252VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbi8vIFRPRE86IHN1cHBvcnQ6XG4vLyAtIGNlaWxfbW9kZSAgICAgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfY2VpbFwiXG4vLyAtIHN0b3JhZ2Vfb3JkZXIgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfc3RyaWRlc1wiXG4vLyAtIFtNYXhQb29sXSBkaWxhdGlvbnMgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfZGlsYXRpb25zXCJcbi8vIC0gW01heFBvb2xdIG91dHB1dFsxXSAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9wYWRzXCJcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQgJiYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzIHwgTWF4UG9vbEF0dHJpYnV0ZXM+KFxuICBpbnB1dDogVGVuc29yVmlldyxcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbik6IFtBdHRyaWJ1dGVUeXBlLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IGlucHV0LmRpbXMuc2xpY2UoKTtcbiAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNwbGljZSgxLCAwLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QucG9wKCkhKTsgLy8gTW92ZSBjaGFubmVsIHRvIHRoZSBzZWNvbmQgcG9zaXRpb24uXG4gIH1cbiAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xuICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCwga2VybmVsU2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkcyk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IFBvb2xDb252VXRpbC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKFxuICAgIGlzR2xvYmFsT3BlcmF0b3IsXG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LFxuICAgIHN0cmlkZXMsXG4gICAgZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICApO1xuXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGhhc0RpbGF0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleSB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdCA9IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3Quc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnB1c2gob3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnNwbGljZSgxLCAxKVswXSk7XG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgOiBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0XTtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1BbmRQYWRJbmZvID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbik6IFtQcm9ncmFtVW5pZm9ybVtdLCBVbmlmb3Jtc0FycmF5VHlwZSwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbl0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtlcm5lbFNpemUgfSxcbiAgXTtcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgIHsgbmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIHsgbmFtZTogJ2tlcm5lbFNpemUnLCB0eXBlOiAndTMyJyB9LFxuICBdO1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGNvbnN0IGt3ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHN3ID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgY29uc3QgcHdFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnRFbmROb3RaZXJvID0gISEocHdTdGFydCArIHB3RW5kKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrdyB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN3IH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcHdTdGFydCB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHB3RW5kIH0sXG4gICAgKTtcbiAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgeyBuYW1lOiAna3cnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnc3cnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAncHdTdGFydCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwd0VuZCcsIHR5cGU6ICd1MzInIH0sXG4gICAgKTtcblxuICAgIGxldCBwaFN0YXJ0RW5kTm90WmVybyA9IGZhbHNlO1xuICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qga2ggPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBzaCA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBwaFN0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMl07XG4gICAgICBjb25zdCBwaEVuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMl07XG4gICAgICBwaFN0YXJ0RW5kTm90WmVybyA9ICEhKHBoU3RhcnQgKyBwaEVuZCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtoIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaCB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhTdGFydCB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhFbmQgfSxcbiAgICAgICk7XG5cbiAgICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICAgIHsgbmFtZTogJ2toJywgdHlwZTogJ3UzMicgfSxcbiAgICAgICAgeyBuYW1lOiAnc2gnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgICB7IG5hbWU6ICdwaFN0YXJ0JywgdHlwZTogJ3UzMicgfSxcbiAgICAgICAgeyBuYW1lOiAncGhFbmQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCB0cnVlLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrZXJuZWxTdHJpZGVzIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5wYWRzIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgKTtcbiAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgeyBuYW1lOiAna2VybmVsU3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGtlcm5lbFN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggfSxcbiAgICApO1xuXG4gICAgY29uc3QgaGFzUGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKHN1bSwgY3VyKSA9PiBzdW0gKyBjdXIpO1xuICAgIHJldHVybiBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgISFoYXNQYWRzLCBmYWxzZSwgZmFsc2VdO1xuICB9XG59O1xuXG5jb25zdCBnZW5lcmF0ZVBvb2xpbmdDb2RlID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICB4OiBJbmRpY2VzSGVscGVyLFxuICByYW5rOiBudW1iZXIsXG4gIG91dHB1dFNoYXBlUmFuazogbnVtYmVyLFxuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlLFxuICBvcDE6IHN0cmluZyxcbiAgb3AyOiBzdHJpbmcsXG4gIHN0YXJ0OiBudW1iZXIsXG4gIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgaGFzUGFkczogYm9vbGVhbixcbiAgcHdTdGFydEVuZE5vdFplcm86IGJvb2xlYW4sXG4gIHBoU3RhcnRFbmROb3RaZXJvOiBib29sZWFuLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHgudHlwZS50ZW5zb3IsIG91dHB1dFNoYXBlUmFuayk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIDw9IDIpIHtcbiAgICBsZXQgY29kZVcgPSAnJztcbiAgICBsZXQgY29kZUggPSAnJztcbiAgICBsZXQgY29kZUhFbmQgPSAnJztcbiAgICBjb25zdCBkaW1JZHhXID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDIgOiAxKTtcbiAgICBpZiAocHdTdGFydEVuZE5vdFplcm8pIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhXfV0gPSBpbmRpY2VzWyR7ZGltSWR4V31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeFd9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhXfV1cbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7ZGltSWR4V31dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhXfV0gPSBpbmRpY2VzWyR7ZGltSWR4V31dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBkaW1JZHhIID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDMgOiAyKTtcbiAgICAgIGlmIChwaFN0YXJ0RW5kTm90WmVybykge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtkaW1JZHhIfV0gPCAwIHx8IHhJbmRpY2VzWyR7ZGltSWR4SH1dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtkaW1JZHhIfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZUggPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeEh9XSA9IGluZGljZXNbJHtkaW1JZHhIfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb2RlSEVuZCA9IGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICB9XG5cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KCR7c3RhcnR9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgICR7Y29kZUh9XG4gICAgICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgICAgICR7Y29kZUhFbmR9XG4gICAgICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlc1JhbmsgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBwYWRzUmFuayA9IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGg7XG4gICAgbGV0IHBhZENvZGUgPSAnJztcbiAgICBpZiAoaGFzUGFkcykge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gdW5pZm9ybXMueF9zaGFwZVtqXSkge1xuICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcbiAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke3N0cmlkZXNSYW5rfT47XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oJHtzdGFydH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke3N0cmlkZXNSYW5rIC0gMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMua2VybmVsU3RyaWRlcycsICdqJywgc3RyaWRlc1JhbmspfTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICogJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmtlcm5lbFN0cmlkZXMnLCAnaicsIHN0cmlkZXNSYW5rKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtzdHJpZGVzUmFuayAtIDF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7cmFuayAtIHN0cmlkZXNSYW5rfXU7IGogPCAke3Jhbmt9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke2dldEVsZW1lbnRBdChcbiAgICAgICAgICAgICAgICAgICAgJ3VuaWZvcm1zLnN0cmlkZXMnLFxuICAgICAgICAgICAgICAgICAgICBgaiAtICR7cmFuayAtIHN0cmlkZXNSYW5rfXVgLFxuICAgICAgICAgICAgICAgICAgICBzdHJpZGVzUmFuayxcbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dV0gLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsICdqIC0gMnUnLCBwYWRzUmFuayl9O1xuICAgICAgICAgICAgICAgICAgJHtwYWRDb2RlfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb29sQ29tbW9uQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5jb25zdCBjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBQb29sQ29tbW9uQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthdHRyaWJ1dGVzLmNlaWxNb2RlfTske2F0dHJpYnV0ZXMuYXV0b1BhZH07JHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aH1gO1xuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZH1gO1xuXG5jb25zdCBjcmVhdGVNYXhQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cbiAgYCR7Y3JlYXRlU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyl9OyR7YXR0cmlidXRlcy5zdG9yYWdlT3JkZXJ9OyR7YXR0cmlidXRlcy5kaWxhdGlvbnN9YDtcblxuY29uc3QgcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFBvb2xDb21tb25BdHRyaWJ1dGVzID0+ICh7XG4gIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J10sXG4gIGF1dG9QYWQ6IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXSxcbiAgY2VpbE1vZGU6IGF0dHJpYnV0ZXMuY2VpbF9tb2RlIGFzIG51bWJlcixcbiAga2VybmVsU2hhcGU6IGF0dHJpYnV0ZXMua2VybmVsX3NoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gIHN0cmlkZXM6IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICBwYWRzOiBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG59KTtcblxuZXhwb3J0IGludGVyZmFjZSBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBQb29sQ29tbW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgY291bnRJbmNsdWRlUGFkOiBib29sZWFuO1xufVxuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShcbiAgICBpbnB1dCxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGlzR2xvYmFsT3BlcmF0b3IsXG4gICk7XG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgY29uc3QgZGF0YVR5cGUgPSB4LnR5cGUudmFsdWU7XG5cbiAgY29uc3Qgb3AxID0gJ3ZhbHVlICs9IHhfdmFsOyc7XG4gIGxldCBvcDIgPSAnJztcbiAgaWYgKGFkanVzdGVkQXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWQpIHtcbiAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A7XG4gIH0gZWxzZSB7XG4gICAgb3AyICs9IGB2YWx1ZSAvPSAke2RhdGFUeXBlfShpMzIodW5pZm9ybXMua2VybmVsU2l6ZSkgLSBwYWQpO2A7XG4gIH1cbiAgY29uc3QgW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIGhhc1BhZHMsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb10gPSBnZXRVbmlmb3JtQW5kUGFkSW5mbyhcbiAgICBvdXRwdXRTaGFwZSxcbiAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMsIG91dHB1dFNoYXBlKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJ107XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtoYXNQYWRzfTske3B3U3RhcnRFbmROb3RaZXJvfTske3BoU3RhcnRFbmROb3RaZXJvfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0LmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxuICAgICAgZ2VuZXJhdGVQb29saW5nQ29kZShcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICB4LFxuICAgICAgICBpbnB1dC5kaW1zLmxlbmd0aCxcbiAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoLFxuICAgICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICAgICAgIG9wMSxcbiAgICAgICAgb3AyLFxuICAgICAgICAwLjAsXG4gICAgICAgIHVuaWZvcm1zLFxuICAgICAgICBoYXNQYWRzLFxuICAgICAgICBwd1N0YXJ0RW5kTm90WmVybyxcbiAgICAgICAgcGhTdGFydEVuZE5vdFplcm8sXG4gICAgICApLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gKGF0dHJpYnV0ZXMuY291bnRfaW5jbHVkZV9wYWQgYXMgbnVtYmVyKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZSdcbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2wnKTtcbiAgfVxuICBjb25zdCBhdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSB7IGNvdW50SW5jbHVkZVBhZCwgLi4uYXR0ciwgY2FjaGVLZXk6ICcnIH07XG4gIHJldHVybiB7IC4uLmF2ZXJhZ2VQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZUF2ZXJhZ2VQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXZlcmFnZVBvb2xBdHRyaWJ1dGVzKSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmNvbnN0IGdsb2JhbFBvb2xBdHRyaWJ1dGVzID0ge1xuICBhdXRvUGFkOiAnJyxcbiAgY2VpbE1vZGU6IDAsXG4gIGNvdW50SW5jbHVkZVBhZDogZmFsc2UsXG4gIGtlcm5lbFNoYXBlOiBbXSxcbiAgc3RyaWRlczogW10sXG4gIHBhZHM6IFtdLFxuICBzdG9yYWdlT3JkZXI6IDAsXG4gIGRpbGF0aW9uczogW10sXG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnR2xvYmFsQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgdHJ1ZSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBNYXhQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBzdG9yYWdlT3JkZXI6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiBudW1iZXJbXTtcbn1cblxuY29uc3QgY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuICBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgW2FkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGVdID0gZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlKFxuICAgIGlucHV0LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgKTtcbiAgY29uc3Qgb3AxID0gYFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgO1xuICBjb25zdCBvcDIgPSAnJztcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuICBjb25zdCBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXSA9IGdldFVuaWZvcm1BbmRQYWRJbmZvKFxuICAgIG91dHB1dFNoYXBlLFxuICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXQuZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxuICAgICAgICBzaGFkZXJIZWxwZXIsXG4gICAgICAgIHgsXG4gICAgICAgIGlucHV0LmRpbXMubGVuZ3RoLFxuICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGgsXG4gICAgICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgICAgb3AxLFxuICAgICAgICBvcDIsXG4gICAgICAgIGlucHV0LmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gLTY1NTA0IDogLTFlNSxcbiAgICAgICAgdW5pZm9ybXMsXG4gICAgICAgIGhhc1BhZHMsXG4gICAgICAgIHB3U3RhcnRFbmROb3RaZXJvLFxuICAgICAgICBwaFN0YXJ0RW5kTm90WmVybyxcbiAgICAgICksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgbWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3RvcmFnZU9yZGVyID0gYXR0cmlidXRlcy5zdG9yYWdlX29yZGVyIGFzIG51bWJlcjtcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xuICBpZiAoc3RvcmFnZU9yZGVyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgfVxuICBjb25zdCBtYXhQb29sQXR0cmlidXRlcyA9IHsgc3RvcmFnZU9yZGVyLCBkaWxhdGlvbnMsIC4uLmF0dHIsIGNhY2hlS2V5OiAnJyB9O1xuICByZXR1cm4geyAuLi5tYXhQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhtYXhQb29sQXR0cmlidXRlcykgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbygnR2xvYmFsTWF4UG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcXVhbnRpemVMaW5lYXIgcmVxdWlyZXMgMiBvciAzIGlucHV0cy4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMV0uZGltcyA9PT0gaW5wdXRzWzJdLmRpbXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3gtc2NhbGUgYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyICYmIGlucHV0cy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAwICYmIGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgaW5wdXQgbXVzdCBiZSBhIHNjYWxhciwgYSAxRCB0ZW5zb3IsIG9yIGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yLicpO1xuICB9XG4gIC8vIHZhbGlkYXRlIHNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0IHNoYXBlc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICAvLyB6ZXJvLXBvaW50IGlucHV0IHR5cGUgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIGlucHV0IGRhdGEgdHlwZS5cbiAgICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigneCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuJyk7XG4gICAgfVxuICAgIC8vIFNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcbiAgICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMl0uZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rLicpO1xuICAgIH1cbiAgICBpZiAoIWlucHV0c1sxXS5kaW1zLm1hcCgoZCwgaSkgPT4gZCA9PT0gaW5wdXRzWzJdLmRpbXNbaV0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLicpO1xuICAgIH1cbiAgfVxuICAvLyBWYWxpZGF0ZSBibG9ja1NpemVcbiAgaWYgKGF0dHJpYnV0ZXMuYmxvY2tTaXplID4gMCkge1xuICAgIC8vIEJsb2NrIHF1bmF0aXphdGlvblxuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggPT09IDAgfHwgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMV0uZGltc1swXSA9PT0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tTaXplIG11c3QgYmUgc2V0IG9ubHkgZm9yIGJsb2NrIHF1YW50aXphdGlvbi4nKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIWlucHV0c1sxXS5kaW1zLm1hcCgoZCwgaSkgPT4gaSA9PT0gYXR0cmlidXRlcy5heGlzIHx8IGQgPT09IGlucHV0c1swXS5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGJsb2NrIHF1bmF0aXphdGlvbiwgc2NhbGUgaW5wdXQgc2hhcGUgdG8gbWF0Y2ggdGhlIGlucHV0IHNoYXBlIGV4Y2VwdCBmb3IgdGhlIGF4aXMnKTtcbiAgICB9XG4gICAgLy8gU2NhbGUgaW5wdXQgcmFuayBzaG91bGQgYmUgc2FtZSBhcyB0aGUgaW5wdXQgcmFua1xuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay4nKTtcbiAgICB9XG4gICAgY29uc3QgZEkgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmF4aXNdO1xuICAgIGNvbnN0IHNpID0gaW5wdXRzWzFdLmRpbXNbYXR0cmlidXRlcy5heGlzXTtcbiAgICBpZiAoYXR0cmlidXRlcy5ibG9ja1NpemUgPCBNYXRoLmNlaWwoZEkgLyBzaSkgfHwgYXR0cmlidXRlcy5ibG9ja1NpemUgPiBNYXRoLmNlaWwoZEkgLyAoc2kgLSAxKSAtIDEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NrU2l6ZSBtdXN0IGJlIHdpdGggaW4gdGhlIHJhbmdlIFtjZWlsKGRJIC8gU2kpLCBjZWlsKGRJIC8gKFNpIC0gMSkgLSAxKV0uJyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVEZXF1YW50aXplTGluZWFyUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlzU2lnbmVkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4O1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zOyAvLyBvdXRwdXQgc2hhcGUgaXMgc2FtZSBhcyB0aGUgaW5wdXQgc2hhcGVcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7IC8vIG91dHB1dCB0eXBlIGlzIHNhbWUgYXMgdGhlIHRoZSBzY2FsZSBpbnB1dCB0eXBlXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IGlzUGFja2VkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4IHx8IGlucHV0VHlwZSA9PT0gRGF0YVR5cGUudWludDg7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpc1BhY2tlZCA/IFtNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXRzWzBdLmRpbXMpIC8gNCldIDogaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHNjYWxlU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgemVyb1BvaW50SW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gMiA/IGlucHV0c1syXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgemVyb1BvaW50U2hhcGUgPSB6ZXJvUG9pbnRJbnB1dFxuICAgID8gaXNQYWNrZWRcbiAgICAgID8gW01hdGguY2VpbChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRJbnB1dC5kaW1zKSAvIDQpXVxuICAgICAgOiB6ZXJvUG9pbnRJbnB1dC5kaW1zXG4gICAgOiB1bmRlZmluZWQ7XG4gIC8vIFNjYWxlcyBpbnB1dCBpcyBhIHNjYWxlciBmb3IgcGVyLXRlbnNvci9wZXItbGF5ZXIgcXVhbnRpemF0aW9uLCAxLUQgdGVuc29yIGZvciBwZXItYXhpcyBxdWFudGl6YXRpb25cbiAgLy8gb3IgdGVuc29yIHdpdGggc2FtZSByYW5rIGFzIGlucHV0IGZvciBibG9ja2VkIHF1YW50aXphdGlvbi5cbiAgY29uc3QgcGVyTGF5ZXJRdWFudGl6YXRpb24gPSBzY2FsZVNoYXBlLmxlbmd0aCA9PT0gMCB8fCAoc2NhbGVTaGFwZS5sZW5ndGggPT09IDEgJiYgc2NhbGVTaGFwZVswXSA9PT0gMSk7XG4gIGNvbnN0IHBlckF4aXNRdWFudGl6YXRpb24gPSBwZXJMYXllclF1YW50aXphdGlvbiA9PT0gZmFsc2UgJiYgc2NhbGVTaGFwZS5sZW5ndGggPT09IDE7XG4gIC8vIExlZnQgdW5uZWNlc3NhcnkgY29tbWVudGVkLW91dCBhc3NpZ25tZW50IGZvciBkb2N1bWVudGF0aW9uXG4gIC8vIGNvbnN0IGJsb2NrUXVhbnRpemF0aW9uID0gcGVyTGF5ZXJRdWFudGl6YXRpb24gPT09IGZhbHNlICYmIHBlckF4aXNRdWFudGl6YXRpb24gPT09IGZhbHNlO1xuICBjb25zdCBtYXhDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaXplKTtcbiAgY29uc3QgdXNlQ29tcG9uZW50cyA9IHBlckxheWVyUXVhbnRpemF0aW9uICYmICghaXNQYWNrZWQgfHwgbWF4Q29tcG9uZW50cyA9PT0gNCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VDb21wb25lbnRzID8gbWF4Q29tcG9uZW50cyA6IDE7XG4gIGNvbnN0IGlucHV0Q29tcG9uZW50ID0gdXNlQ29tcG9uZW50cyAmJiAhaXNQYWNrZWQgPyBtYXhDb21wb25lbnRzIDogMTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlzUGFja2VkID8gRGF0YVR5cGUudWludDMyIDogaW5wdXRUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgaW5wdXRDb21wb25lbnQpO1xuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgZGF0YVR5cGUsIHNjYWxlU2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgemVyb1BvaW50ID0gemVyb1BvaW50SW5wdXRcbiAgICA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnQnLCBpc1BhY2tlZCA/IERhdGFUeXBlLnVpbnQzMiA6IGlucHV0VHlwZSwgemVyb1BvaW50U2hhcGUhLmxlbmd0aClcbiAgICA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtpbnB1dCwgc2NhbGVdO1xuICBpZiAoemVyb1BvaW50KSB7XG4gICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnQpO1xuICB9XG4gIGNvbnN0IGlucHV0U2hhcGVzID0gW2lucHV0U2hhcGUsIHNjYWxlU2hhcGVdO1xuICBpZiAoemVyb1BvaW50SW5wdXQpIHtcbiAgICBpbnB1dFNoYXBlcy5wdXNoKHplcm9Qb2ludFNoYXBlISk7XG4gIH1cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIC8gY29tcG9uZW50cyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoLi4uaW5wdXRTaGFwZXMsIG91dHB1dFNoYXBlKSxcbiAgXTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYXhpcycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdibG9ja19zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAvLyBTZXQgaW5wdXQgeFxuICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAvIDQnKX07XG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoaW5wdXQpJyA6ICd1bnBhY2s0eFU4KGlucHV0KSd9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAke2NvbXBvbmVudHMgPT09IDEgPyAneF92ZWNbZ2xvYmFsX2lkeCAlIDRdJyA6ICd4X3ZlYyd9O2A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYGxldCB4X3ZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIHNjYWxlIGlucHV0IGlzIGEgc2NhbGFyICgpXG4gICAgICAgICAgICAgIHJldHVybiBgbGV0IHNjYWxlX3ZhbHVlPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCcwJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVyQXhpc1F1YW50aXphdGlvbikge1xuICAgICAgICAgICAgICAvLyBzY2FsZSBpbnB1dCBpcyBhIDFEIHRlbnNvclxuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtzY2FsZS5nZXRCeU9mZnNldCgnc2NhbGVfaW5kZXgnKX07YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJsb2NrIHF1YW50aXphdGlvbi4gU2NhbGUgaW5wdXQgcmFuayBpcyBzYW1lIGFzIGlucHV0L291dHB1dCByYW5rLlxuICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgdmFyIHNjYWxlX2luZGljZXM6ICR7c2NhbGUudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtzY2FsZS5pbmRpY2VzR2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAgICAgJHtzY2FsZS5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAnaW5kZXgnKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7c2NhbGUuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgemVyby1wb2ludCBpbnB1dFxuICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh6ZXJvUG9pbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1wb2ludCBpbnB1dCBpcyBhIHNjYWxhclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCcwJyl9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoemVyb19wb2ludF9pbnB1dCknIDogJ3VucGFjazR4VTgoemVyb19wb2ludF9pbnB1dCknfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJzAnKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJBeGlzUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1wb2ludCBpbnB1dCBpcyBhIDFEIHRlbnNvclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCAvIDQnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCcpfTtgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9ja2VkUXVhbnRpemF0aW9uLiBUaGUgemVyby1wb2ludCBpbnB1dCBzaGFwZSBpcyBzYW1lIGFzIHRoZSBpbnB1dCBzaGFwZSBleGNlcHQgYWxvbmcgYXhpcy5cbiAgICAgICAgICAgICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtzY2FsZS5pbmRpY2VzVG9PZmZzZXQoJ3NjYWxlX2luZGljZXMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9vZmZzZXQgLyA0Jyl9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt6ZXJvUG9pbnQuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtpc1BhY2tlZCA/IChpc1NpZ25lZCA/ICdpMzInIDogJ3UzMicpIDogaW5wdXQudHlwZS52YWx1ZX0oMCk7YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpfTtcbiAgICAgIC8vIENvbXB1dGUgYW5kIHdyaXRlIG91dHB1dFxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBgJHtvdXRwdXQudHlwZS52YWx1ZX0oeF92YWx1ZSAtIHplcm9fcG9pbnRfdmFsdWUpICogc2NhbGVfdmFsdWVgKX07XG4gICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRGVxdWFudGl6ZUxpbmVhcicsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogemVyb1BvaW50ID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIGNvbXBvbmVudHMgLyA2NCksIHk6IDEsIHo6IDEgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZXF1YW50aXplTGluZWFyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZURlcXVhbnRpemVMaW5lYXJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIsIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c0NvbnRlbnQgPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBzYW1lU3RhcnRMaW1pdCA9IHN0YXJ0ID09PSBsaW1pdDtcbiAgY29uc3QgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwID0gc3RhcnQgPCBsaW1pdCAmJiBkZWx0YSA8IDA7XG4gIGNvbnN0IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0YXJ0ID4gbGltaXQgJiYgZGVsdGEgPiAwO1xuXG4gIGlmIChzYW1lU3RhcnRMaW1pdCB8fCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgfHwgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIik7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8gPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlciwgZGF0YVR5cGU6IERhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBudW1FbGVtZW50cyA9IE1hdGguYWJzKE1hdGguY2VpbCgobGltaXQgLSBzdGFydCkgLyBkZWx0YSkpO1xuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbbnVtRWxlbWVudHNdO1xuICBjb25zdCBvdXRwdXRTaXplID0gbnVtRWxlbWVudHM7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogZGF0YVR5cGUsIGRhdGE6IHN0YXJ0IH0sXG4gICAgeyB0eXBlOiBkYXRhVHlwZSwgZGF0YTogZGVsdGEgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IHdnc2xUeXBlID0gb3V0cHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzdGFydCcsIHR5cGU6IHdnc2xUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgIHsgbmFtZTogJ2RlbHRhJywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7d2dzbFR5cGV9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7ZGF0YVR5cGV9YCB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHJhbmdlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBsaW1pdCA9IDA7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXTtcbiAgICBsaW1pdCA9IGNvbnRleHQuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXTtcbiAgICBkZWx0YSA9IGNvbnRleHQuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXTtcbiAgfSBlbHNlIGlmIChjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xuICAgIGxpbWl0ID0gY29udGV4dC5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF07XG4gICAgZGVsdGEgPSBjb250ZXh0LmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcbiAgfVxuICBpZiAoZW52LndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCkge1xuICAgIHZhbGlkYXRlSW5wdXRzQ29udGVudChzdGFydCwgbGltaXQsIGRlbHRhKTtcbiAgfVxuXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSYW5nZVByb2dyYW1JbmZvKHN0YXJ0LCBsaW1pdCwgZGVsdGEsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKSwgeyBpbnB1dHM6IFtdIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBhdG9taWNPdXRwdXRWYXJpYWJsZSxcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBTY2F0dGVyTkRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVkdWN0aW9uOiBzdHJpbmc7XG59XG5cbnR5cGUgUmVkdWN0aW9uVHlwZSA9ICdpMzInIHwgJ3UzMicgfCAnZjMyJztcblxuY29uc3QgYXRvbWljUmVkdWN0aW9uU25pcHBldCA9IChyZWR1Y3Rpb246IHN0cmluZywgcHRyOiBzdHJpbmcsIHY6IHN0cmluZywgdHlwZTogUmVkdWN0aW9uVHlwZSkgPT4ge1xuICBpZiAocmVkdWN0aW9uICE9PSAnbm9uZScgJiYgdHlwZSAhPT0gJ2kzMicgJiYgdHlwZSAhPT0gJ3UzMicgJiYgdHlwZSAhPT0gJ2YzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dHlwZX0gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHJlZHVjdGlvbiAke3JlZHVjdGlvbn0uYCk7XG4gIH1cblxuICBjb25zdCBmbG9hdFN0YXJ0ID0gYHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGxvb3Age1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlRjMyID1gO1xuICBjb25zdCBmbG9hdEVuZCA9IGA7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBiaXRjYXN0PGkzMj4obmV3VmFsdWVGMzIpO1xuICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsoJiR7cHRyfSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIHJlcy5leGNoYW5nZWQge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzLm9sZF92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1gO1xuXG4gIHN3aXRjaCAocmVkdWN0aW9uKSB7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gYCR7cHRyfT0ke3Z9O2A7XG4gICAgY2FzZSAnYWRkJzpcbiAgICAgIGlmICh0eXBlID09PSAnaTMyJyB8fCB0eXBlID09PSAndTMyJykge1xuICAgICAgICByZXR1cm4gYGF0b21pY0FkZCgmJHtwdHJ9LCBiaXRjYXN0PCR7dHlwZX0+KCR7dn0pKTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXRvbWljQWRkIG9ubHkgc3VwcG9ydHMgdWludC9pbnQgdHlwZS4gRm9yIGZsb2F0LCB3ZSB1c2VcbiAgICAgICAgLy8gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhayB0byBzaW11bGF0ZS5cbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgJHtmbG9hdFN0YXJ0fWJpdGNhc3Q8JHt0eXBlfT4ob2xkVmFsdWUpICsgKCR7dn0pJHtmbG9hdEVuZH1gO1xuICAgICAgfVxuICAgIGNhc2UgJ21heCc6XG4gICAgICBpZiAodHlwZSA9PT0gJ2kzMicgfHwgdHlwZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgcmV0dXJuIGBhdG9taWNNYXgoJiR7cHRyfSwgYml0Y2FzdDwke3R5cGV9Pigke3Z9KSk7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGF0b21pY01heCBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXG4gICAgICAgIC8vIGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsgdG8gc2ltdWxhdGUuXG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgJHtmbG9hdFN0YXJ0fW1heChiaXRjYXN0PGYzMj4ob2xkVmFsdWUpLCAoJHt2fSkpJHtmbG9hdEVuZH1gO1xuICAgICAgfVxuICAgIGNhc2UgJ21pbic6XG4gICAgICBpZiAodHlwZSA9PT0gJ2kzMicgfHwgdHlwZSA9PT0gJ3UzMicpIHtcbiAgICAgICAgcmV0dXJuIGBhdG9taWNNaW4oJiR7cHRyfSwgYml0Y2FzdDwke3R5cGV9Pigke3Z9KSk7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGF0b21pY01pbiBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXG4gICAgICAgIC8vIGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsgdG8gc2ltdWxhdGUuXG4gICAgICAgIHJldHVybiBgJHtmbG9hdFN0YXJ0fW1pbihiaXRjYXN0PCR7dHlwZX0+KG9sZFZhbHVlKSwgKCR7dn0pKSR7ZmxvYXRFbmR9YDtcbiAgICAgIH1cbiAgICBjYXNlICdtdWwnOlxuICAgICAgLy8gYXRvbWljTXVsIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIHVzZSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrIHRvIHNpbXVsYXRlLlxuICAgICAgcmV0dXJuIGAke2Zsb2F0U3RhcnR9KGJpdGNhc3Q8JHt0eXBlfT4ob2xkVmFsdWUpICogKCR7dn0pKSR7ZmxvYXRFbmR9YDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZHVjdGlvbiAke3JlZHVjdGlvbn0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlU2NhdHRlck5EUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNjYXR0ZXJOREF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgLy8gVE9ETzogc3VwcG9ydCBib29sIHdpdGggY29tcG9uZW50cyA0LlxuICBjb25zdCBjb21wb25lbnRzID0gMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGluZGljZXNTaGFwZSwgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDEpIC8gY29tcG9uZW50cyk7XG4gIGNvbnN0IGxhc3RJbmRleERpbWVuc2lvbiA9IGluZGljZXNTaGFwZVtpbmRpY2VzU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IG51bVVwZGF0ZXNFbGVtZW50cyA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dFNoYXBlLCBsYXN0SW5kZXhEaW1lbnNpb24pO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBsYXN0SW5kZXhEaW1lbnNpb24gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbnVtVXBkYXRlc0VsZW1lbnRzIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzFdLmRpbXMsIGlucHV0c1syXS5kaW1zLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2luZGljZXMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgdXBkYXRlcyA9IGlucHV0VmFyaWFibGUoJ3VwZGF0ZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgIGF0dHJpYnV0ZXMucmVkdWN0aW9uICE9PSAnbm9uZScgJiYgYXR0cmlidXRlcy5yZWR1Y3Rpb24gIT09ICcnXG4gICAgICAgID8gYXRvbWljT3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKVxuICAgICAgICA6IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG5cbiAgICByZXR1cm4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnbGFzdF9pbmRleF9kaW1lbnNpb24nLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnbnVtX3VwZGF0ZXNfZWxlbWVudHMnLCAndTMyJylcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5kaWNlcywgdXBkYXRlcywgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgbGV0IGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtcbiAgICAgIGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IGBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlcztcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlO2BcbiAgICAgICAgOiBgXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXNbaSAtIGluZGljZXNfc3RhcnRdO1xuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbaSAtIGluZGljZXNfc3RhcnRdO2BcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGlmIChpbmRleCA+PSBpMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IGkzMihkaW1fdmFsdWUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluZGV4IDwgLWkzMihkaW1fdmFsdWUpKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ICs9IGkzMihkaW1fdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBkYXRhX29mZnNldCArPSB1MzIoKHUzMihpbmRleCkgKiBlbGVtZW50X2NvdW50X2RpbSkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDB1OyBpIDwgdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHM7IGkrKykge1xuICAgIGxldCB2YWx1ZSA9IHVwZGF0ZXNbdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHMgKiBnbG9iYWxfaWR4ICsgaV07XG4gICAgJHthdG9taWNSZWR1Y3Rpb25TbmlwcGV0KFxuICAgICAgYXR0cmlidXRlcy5yZWR1Y3Rpb24sXG4gICAgICAnb3V0cHV0W2RhdGFfb2Zmc2V0ICsgaV0nLFxuICAgICAgJ3ZhbHVlJyxcbiAgICAgIG91dHB1dC50eXBlLnZhbHVlIGFzIFJlZHVjdGlvblR5cGUsXG4gICAgKX1cbiAgfVxuXG4gICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU2NhdHRlck5EJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1fJHthdHRyaWJ1dGVzLnJlZHVjdGlvbn1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU2NhdHRlck5EQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNjYXR0ZXJOREF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcmVkdWN0aW9uOiBhdHRyaWJ1dGVzLnJlZHVjdGlvbiBhcyBzdHJpbmcgfSk7XG5cbmV4cG9ydCBjb25zdCBzY2F0dGVyTkQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNjYXR0ZXJOREF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNjYXR0ZXJORFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSwge1xuICAgIGlucHV0czogW2NvbnRleHQuaW5wdXRzWzFdLCBjb250ZXh0LmlucHV0c1syXV0sXG4gICAgb3V0cHV0czogW10sXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG59IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9XG4gIHwgJ2hhbGZfcGl4ZWwnXG4gIHwgJ2FzeW1tZXRyaWMnXG4gIHwgJ3B5dG9yY2hfaGFsZl9waXhlbCdcbiAgfCAndGZfaGFsZl9waXhlbF9mb3Jfbm4nXG4gIHwgJ2FsaWduX2Nvcm5lcnMnXG4gIHwgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSdcbiAgfCAnaGFsZl9waXhlbF9zeW1tZXRyaWMnO1xuXG50eXBlIEtlZXBBc3BlY3RSYXRpb1BvbGljeSA9ICdzdHJldGNoJyB8ICdub3Rfc21hbGxlcicgfCAnbm90X2xhcmdlcic7XG5cbnR5cGUgTW9kZSA9ICduZWFyZXN0JyB8ICdsaW5lYXInIHwgJ2N1YmljJztcblxudHlwZSBOZWFyZXN0TW9kZSA9ICdyb3VuZF9wcmVmZXJfZmxvb3InIHwgJ3JvdW5kX3ByZWZlcl9jZWlsJyB8ICdmbG9vcicgfCAnY2VpbCcgfCAnc2ltcGxlJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXNpemVBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYW50aWFsaWFzOiBudW1iZXI7XG4gIGF4ZXM6IG51bWJlcltdO1xuICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU7XG4gIGN1YmljQ29lZmZBOiBudW1iZXI7XG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcjtcbiAga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIG1vZGU6IE1vZGU7XG4gIG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZTtcbn1cblxuY29uc3QgdmFsaWRhdGVTY2FsZXMgPSAoc2NhbGVzOiBudW1iZXJbXSwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBzY2FsZXMuZXZlcnkoXG4gICAgKHZhbHVlKSA9PlxuICAgICAgdmFsdWUgPiAwIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlJyk7XG4gICAgICB9KSxcbiAgKTtcbiAgLy8gQ2hlY2sgc2NhbGVzIGRpbXMgYmFzZWQgb24gbW9kZTogTElORUFSLCBDVUJJQ1xuICBpZiAoc2NhbGVzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnbGluZWFyJykge1xuICAgICAgaWYgKFxuICAgICAgICAhKFxuICAgICAgICAgIHNjYWxlcy5sZW5ndGggPT09IDIgfHxcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAzIHx8XG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKSB8fFxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA1ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZvciBsaW5lYXIgbW9kZSwgUmVzaXplIHJlcXVpcmVzIHNjYWxlcyB0byBiZSAyRCwgM0QsIDREIHdpdGggZWl0aGVyIHR3byBvdXRlcm1vc3Qgb3Igb25lIGlubmVybW9zdCBhbmRcbiAgICAgICAgICAgIG9uZSBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDEsIG9yIDVEIHdpdGggdHdvIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09ICdjdWJpYycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAyIHx8XG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBjdWJpYyBtb2RlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB1cGRhdGVTY2FsZXMgPSAoc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgYXhlcy5ldmVyeShcbiAgICAodmFsdWUpID0+XG4gICAgICAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IHJhbmspIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmsnKTtcbiAgICAgIH0pLFxuICApO1xuICBjb25zdCBuZXdTY2FsZXMgPSBuZXcgQXJyYXkocmFuaykuZmlsbCgxLjApO1xuICBheGVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gKG5ld1NjYWxlc1t2YWx1ZV0gPSBzY2FsZXNbaW5kZXhdKSk7XG4gIHJldHVybiBuZXdTY2FsZXM7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsXG4gIG9wc2V0VmVyc2lvbjogbnVtYmVyLFxuICBzY2FsZXM6IG51bWJlcltdLFxuICBzaXplczogbnVtYmVyW10sXG4gIHJvaTogbnVtYmVyW10sXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgW3JvaUlucHV0SW5kZXgsIHNjYWxlc0lucHV0SW5kZXgsIHNpemVzSW5wdXRJbmRleF0gPVxuICAgIG9wc2V0VmVyc2lvbiA+IDEwID8gWzEsIDIsIDNdIDogWy0xLCBpbnB1dHMubGVuZ3RoID4gMSA/IDEgOiAtMSwgLTFdO1xuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAocm9pSW5wdXRJbmRleCA+IDAgJiYgaW5wdXRzLmxlbmd0aCA+IHJvaUlucHV0SW5kZXggJiYgaW5wdXRzW3JvaUlucHV0SW5kZXhdLmRpbXMubGVuZ3RoID4gMCkge1xuICAgIGlucHV0c1tyb2lJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gcm9pLnB1c2godmFsdWUpKTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemUnKTtcbiAgfVxuXG4gIGlmIChcbiAgICBzY2FsZXNJbnB1dEluZGV4ID4gMCAmJlxuICAgIGlucHV0cy5sZW5ndGggPiBzY2FsZXNJbnB1dEluZGV4ICYmXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmRpbXMubGVuZ3RoID09PSAxICYmXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmRpbXNbMF0gPiAwXG4gICkge1xuICAgIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2NhbGVzLnB1c2godmFsdWUpKTtcbiAgICBpZiAoXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSAwICYmXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSByYW5rICYmXG4gICAgICBvcHNldFZlcnNpb24gPj0gMTggJiZcbiAgICAgIHNjYWxlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGhcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVNjYWxlcyhzY2FsZXMsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcy5heGVzLCByYW5rKS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IChzY2FsZXNbaW5kZXhdID0gdmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgaWYgKFxuICAgIHNpemVzSW5wdXRJbmRleCA+IDAgJiZcbiAgICBpbnB1dHMubGVuZ3RoID4gc2l6ZXNJbnB1dEluZGV4ICYmXG4gICAgaW5wdXRzW3NpemVzSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPT09IDEgJiZcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5kaW1zWzBdID4gMFxuICApIHtcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHNpemVzLnB1c2goTnVtYmVyKHZhbHVlKSkpO1xuICAgIGlmIChzaXplcy5sZW5ndGggIT09IDAgJiYgc2l6ZXMubGVuZ3RoICE9PSByYW5rICYmIG9wc2V0VmVyc2lvbiA+PSAxOCAmJiBzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDAgJiYgc2NhbGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgaWYgKHNpemVzLmxlbmd0aCAhPT0gMCAmJiBzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjYWxlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNpemVzICE9PSAndW5kZWZpbmVkJyAmJiBzY2FsZXMubGVuZ3RoID4gMCAmJiBzaXplcy5sZW5ndGggPiByYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldFNhZmVJbnRlZ2VyRGl2aXNpb24gPSAoYTogc3RyaW5nLCBiOiBzdHJpbmcsIGM6IHN0cmluZywgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgbGV0IGJpZyA9ICgke2F9KSAqICgke2J9KTtcbiAgbGV0IHdob2xlID0gJHtkVHlwZX0oYmlnIC8gKCR7Y30pKTtcbiAgbGV0IGZyYWN0ID0gJHtkVHlwZX0oYmlnICUgKCR7Y30pKSAvICR7ZFR5cGV9KCR7Y30pO1xuICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbmA7XG5cbmNvbnN0IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSA9IChcbiAgY29vcmRpbmF0ZVRyYW5zZmVyTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsXG4gIGRUeXBlOiBzdHJpbmcsXG4pOiBzdHJpbmcgPT5cbiAgYGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHtkVHlwZX0geyBgICtcbiAgKCgpID0+IHtcbiAgICBzd2l0Y2ggKGNvb3JkaW5hdGVUcmFuc2Zlck1vZGUpIHtcbiAgICAgIGNhc2UgJ2FzeW1tZXRyaWMnOlxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGlmICh4U2NhbGUgPCAxLjAgfHwgZmxvb3IoeFNjYWxlKSAhPSB4U2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAke2RUeXBlfSh4UmVzaXplZCkgLyAke2RUeXBlfSh4U2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke2dldFNhZmVJbnRlZ2VyRGl2aXNpb24oJ3hSZXNpemVkJywgJ2xlbmd0aE9yaWdpbmFsJywgJ2xlbmd0aFJlc2l6ZWQnLCBkVHlwZSl9XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgY2FzZSAncHl0b3JjaF9oYWxmX3BpeGVsJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSAtIDAuNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgIGNhc2UgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJzpcbiAgICAgICAgcmV0dXJuIGByZXR1cm4gKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpO2A7XG4gICAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAke2dldFNhZmVJbnRlZ2VyRGl2aXNpb24oJ3hSZXNpemVkJywgJ2xlbmd0aE9yaWdpbmFsIC0gMScsICdsZW5ndGhSZXNpemVkIC0gMScsIGRUeXBlKX1cbiAgICAgICAgICAgICAgICAgIH1gO1xuICAgICAgY2FzZSAndGZfY3JvcF9hbmRfcmVzaXplJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7ZFR5cGV9KHJvaVN0YXJ0KSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCR7ZFR5cGV9KHhSZXNpemVkKSAqICR7ZFR5cGV9KHJvaUVuZCAtIHJvaVN0YXJ0KSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke2RUeXBlfShyb2lTdGFydCArIHJvaUVuZCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfWA7XG4gICAgICBjYXNlICdoYWxmX3BpeGVsX3N5bW1ldHJpYyc6XG4gICAgICAgIHJldHVybiBgY29uc3Qgb3V0cHV0V2lkdGggPSAke2RUeXBlfXhTY2FsZSAqICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9ICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpKSAtIDAuNTtgO1xuICAgICAgY2FzZSAnaGFsZl9waXhlbCc6XG4gICAgICAgIHJldHVybiBgcmV0dXJuICgoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkpIC0gMC41O2A7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtjb29yZGluYXRlVHJhbnNmZXJNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpICtcbiAgJ30nO1xuXG5jb25zdCBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwgPSAobmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlLCBvcHNldFZlcnNpb246IG51bWJlciwgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBgZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtkVHlwZX0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtkVHlwZX0ge2AgK1xuICAoKCkgPT4ge1xuICAgIHN3aXRjaCAobmVhcmVzdE1vZGUpIHtcbiAgICAgIGNhc2UgJ3JvdW5kX3ByZWZlcl9jZWlsJzpcbiAgICAgICAgcmV0dXJuICdpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgXFxcbiAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgIH0nO1xuICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICByZXR1cm4gJ3JldHVybiBmbG9vcih4T3JpZ2luYWwpOyc7XG4gICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgcmV0dXJuICdyZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyc7XG4gICAgICBjYXNlICdyb3VuZF9wcmVmZXJfZmxvb3InOlxuICAgICAgICByZXR1cm4gJ2lmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyBcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgfSc7XG4gICAgICBjYXNlICdzaW1wbGUnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKG9wc2V0VmVyc2lvbiA8IDExKSB7XG4gICAgICAgICAgcmV0dXJuICdpZiAoaXNEb3duU2FtcGxlKSBcXFxuICAgICAgICAgICAgICAgICAgICB7IFxcXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyBcXFxuICAgICAgICAgICAgICAgICAgICB9JztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke25lYXJlc3RNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpICtcbiAgJ30nO1xuXG5jb25zdCB1cGRhdGVSb0kgPSAocm9pOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3Qgcm9pVG1wID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyYW5rKS5maWxsKDEpKTtcbiAgY29uc3Qgcm9pTG9jYWwgPSByb2kubGVuZ3RoID09PSAwID8gcm9pVG1wIDogcm9pLnNsaWNlKCk7XG4gIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIHJvaVRtcFt2XSA9IHJvaUxvY2FsW2ldO1xuICAgICAgcm9pVG1wW2kgKyByYW5rXSA9IHJvaUxvY2FsW2F4ZXMubGVuZ3RoICsgaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvaVRtcDtcbiAgfVxuICByZXR1cm4gcm9pTG9jYWw7XG59O1xuXG5jb25zdCBpbml0T3V0cHV0U2hhcGUgPSAoXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogbnVtYmVyW10gPT4ge1xuICBsZXQgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGlmIChzaXplcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgaW5wdXRTaGFwZS5mb3JFYWNoKCh2KSA9PiBvdXRwdXRTaGFwZS5wdXNoKHYpKTtcbiAgICAgIGlmIChNYXRoLm1heCguLi5heGVzKSA+IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXhlcyBpcyBvdXQgb2YgYm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGF4ZXMuZm9yRWFjaCgodiwgaSkgPT4gKG91dHB1dFNoYXBlW3ZdID0gc2l6ZXNbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZXMuZm9yRWFjaCgodikgPT4gb3V0cHV0U2hhcGUucHVzaCh2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+IE1hdGgucm91bmQodmFsdWUgKiBzY2FsZXNbaW5kZXhdKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXRTaGFwZTtcbn07XG5cbmNvbnN0IGFkanVzdE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IHNjYWxlSW5Qb2xpY3kgPSAoKCkgPT4ge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vdF9sYXJnZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IE1hdGgubWluKC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NQVhfVkFMVUUpXG4gICAgICAgICAgOiBNYXRoLm1pbiguLi5zY2FsZXMsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgY2FzZSAnbm90X3NtYWxsZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICA/IE1hdGgubWF4KC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NSU5fVkFMVUUpXG4gICAgICAgICAgOiBNYXRoLm1heCguLi5zY2FsZXMsIE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHthdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKTtcbiAgc2NhbGVzLmZpbGwoMS4wLCAwLCBzY2FsZXMubGVuZ3RoKTtcbiAgY29uc3QgYWRqdXN0ZWRPdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IChzY2FsZXNbdl0gPSBzY2FsZUluUG9saWN5KSk7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IChhZGp1c3RlZE91dHB1dFNoYXBlW3ZdID0gTWF0aC5yb3VuZChpbnB1dFNoYXBlW3ZdICogc2NhbGVzW3ZdKSkpO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlcy5maWxsKHNjYWxlSW5Qb2xpY3ksIDAsIHNjYWxlcy5sZW5ndGgpO1xuICAgIGFkanVzdGVkT3V0cHV0U2hhcGUuZm9yRWFjaCgodiwgaSkgPT4gKGFkanVzdGVkT3V0cHV0U2hhcGVbaV0gPSBNYXRoLnJvdW5kKHYgKiBzY2FsZXNbaV0pKSk7XG4gIH1cbiAgcmV0dXJuIGFkanVzdGVkT3V0cHV0U2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9IChcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXNMZW5ndGg6IG51bWJlcixcbiAgcm9pTGVuZ3RoOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke1xuICAgICAgb3V0cHV0LnR5cGUudmFsdWVcbiAgICB9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2NhbGVzJywgJ2knLCBzY2FsZXNMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCBgaSArICR7aW5wdXRTaGFwZS5sZW5ndGh9YCwgcm9pTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtvdXRwdXQudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsX2luZGljZXM7XG4gICAgfWA7XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXNMZW5ndGg6IG51bWJlcixcbiAgcm9pTGVuZ3RoOiBudW1iZXIsXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNjYWxlcycsICdpJywgc2NhbGVzTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCAnaScsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciByb2lfaGkgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgYGkgKyAke2lucHV0U2hhcGUubGVuZ3RofWAsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5vdXRwdXRfc2hhcGUnLCAnaScsIG91dHB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHt1c2VFeHRyYXBvbGF0aW9ufSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHtvdXRwdXQudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kgLSAxKSkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIoZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKG9yaWdpbmFsX2lkeCwgc2NhbGUgPCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKG9yaWdpbmFsX2lkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2luZGV4Jyl9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICB9YDtcbmNvbnN0IGNoZWNrSW5wdXRJbmRpY2VzID0gKGlucHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyA9PiBgXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9KSAtPiBib29sIHtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7aW5wdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtpbnB1dC5pbmRpY2VzR2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knKX07XG4gICAgICAgIGlmIChpbnB1dF9pbmRleCA8IDAgfHwgaW5wdXRfaW5kZXggPj0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9YDtcblxuY29uc3Qgc2V0Q2hhbm5lbEFuZEJhdGNoSW5kaWNlcyA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIGNoYW5uZWxJZHg6IG51bWJlcixcbiAgYmF0Y2hJZHg6IG51bWJlcixcbiAgc3BhY2lhbERpbXM6IG51bWJlcixcbik6IHN0cmluZyA9PlxuICBpbnB1dC5yYW5rID4gc3BhY2lhbERpbXNcbiAgICA/IGBcbiAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBjaGFubmVsSWR4LCAnY2hhbm5lbCcpfTtcbiAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBiYXRjaElkeCwgJ2JhdGNoJyl9O1xuYFxuICAgIDogJyc7XG5cbmNvbnN0IGJpbGluZWFySW50ZXJwb2xhdGlvbiA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcbiAgY29uc3QgW2JhdGNoSWR4LCBoZWlnaHRJZHgsIHdpZHRoSWR4LCBjaGFubmVsSWR4XSA9XG4gICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgPyBbLTEsIDAsIDEsIC0xXSA6IGlzTmNodyA/IFswLCAyLCAzLCAxXSA6IFswLCAxLCAyLCAzXTtcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICByZXR1cm4gYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBoZWlnaHRJZHgsIGBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAyKX1cbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgcm93OiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7aGVpZ2h0SWR4fV07XG4gICAgICB2YXIgY29sOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7d2lkdGhJZHh9XTtcbiAgICAgICR7XG4gICAgICAgIHVzZUV4dHJhcG9sYXRpb25cbiAgICAgICAgICA/IGBpZiAocm93IDwgMCB8fCByb3cgPiAoJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAoJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgfWBcbiAgICAgICAgICA6ICcnXG4gICAgICB9O1xuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKTtcbiAgICAgIGNvbCA9IG1heCgwLCBtaW4oY29sLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKTtcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7aW5wdXRTaGFwZS5sZW5ndGggPiAyID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtjaGFubmVsSWR4fV0pYCA6ICcwJ307XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke2lucHV0U2hhcGUubGVuZ3RoID4gMiA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7YmF0Y2hJZHh9XSlgIDogJzAnfTtcbiAgICAgIHZhciB4MTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xuICAgICAgdmFyIHgyMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcbiAgICAgIHZhciB4MjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiAke2RUeXBlfSA9IGFicyhyb3cgLSAke2RUeXBlfShyb3cxKSk7XG4gICAgICB2YXIgZHgyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShyb3cyKSAtIHJvdyk7XG4gICAgICB2YXIgZHkxOiAke2RUeXBlfSA9IGFicyhjb2wgLSAke2RUeXBlfShjb2wxKSk7XG4gICAgICB2YXIgZHkyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShjb2wyKSAtIGNvbCk7XG4gICAgICBpZiAocm93MSA9PSByb3cyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGNvbDEgPT0gY29sMikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcbiAgICB9YDtcbn07XG5cbmNvbnN0IGJpY3ViaWNJbnRlcnBvbGF0aW9uID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICByb2k6IHJlYWRvbmx5IG51bWJlcltdLFxuICBjdWJpY0NvZWZmQTogbnVtYmVyLFxuICB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcixcbiAgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW4sXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpczJEID0gaW5wdXRTaGFwZS5sZW5ndGggPT09IDI7XG4gIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gIGNvbnN0IFtoZWlnaHRJZHgsIHdpZHRoSWR4XSA9IGlzMkQgPyBbMCwgMV0gOiBpc05jaHcgPyBbMiwgM10gOiBbMSwgMl07XG4gIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgY29uc3QgY3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSAoaWR4OiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGlkeCA9PT0gaGVpZ2h0SWR4ID8gJ3JvdycgOiAnY29sJztcbiAgICByZXR1cm4gYFxuICAgICAgZm4gJHtkaXJlY3Rpb259Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7XG4gICAgICAgIG91dHB1dC50eXBlLmluZGljZXNcbiAgICAgIH0pIC0+ICR7ZFR5cGV9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgaWR4KX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHtkVHlwZX0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCAke3NjYWxlc1tpZHhdfSxcbiAgICAgICAgJHtvdXRwdXRTaGFwZVtpZHhdfSwgJHtpbnB1dFNoYXBlW2lkeF19LCAke3JvaVtpZHhdfSwgJHtyb2lbaWR4XX0gKyAke2lucHV0U2hhcGUubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcblxuICAgICAgICBpZiAoJHt1c2VFeHRyYXBvbGF0aW9ufSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciAke2RpcmVjdGlvbn06ICR7ZFR5cGV9ID0gb3JpZ2luYWxJZHggKyAke2RUeXBlfShpKTtcbiAgICAgICAgICBpZiAoJHtkaXJlY3Rpb259IDwgMCB8fCAke2RpcmVjdGlvbn0gPj0gJHtpbnB1dFNoYXBlW2lkeF19KSB7XG4gICAgICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChleGNsdWRlT3V0c2lkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgY29lZnNbaSArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7YDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh1c2VFeHRyYXBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O2A7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2RpcmVjdGlvbn0gPSBtYXgoMCwgbWluKCR7ZGlyZWN0aW9ufSwgJHtpbnB1dFNoYXBlW2lkeF19IC0gMSkpO2A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCl9O1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0X2luZGljZXNfY29weTogJHtpbnB1dC50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXNfY29weScsIGlkeCwgYHUzMigke2RpcmVjdGlvbn0pYCl9O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHtcbiAgICAgICAgICAgIGlkeCA9PT0gaGVpZ2h0SWR4XG4gICAgICAgICAgICAgID8gaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzX2NvcHknKVxuICAgICAgICAgICAgICA6ICdyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcyknXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xuICAgICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGBcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGhlaWdodElkeCl9O1xuICAgICR7Y3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24od2lkdGhJZHgpfTtcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogJHtkVHlwZX0pIC0+IGFycmF5PCR7ZFR5cGV9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHtkVHlwZX0sIDQ+ID0gYXJyYXk8JHtkVHlwZX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHtkVHlwZX0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7ZFR5cGV9ID0gMi4wIC0gYWJzUztcbiAgICB2YXIgb25lUGx1c0Fic1M6ICR7ZFR5cGV9ID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7Y3ViaWNDb2VmZkF9ICogb25lUGx1c0Fic1MgLSA1ICogJHtjdWJpY0NvZWZmQX0pICogb25lUGx1c0Fic1MgKyA4ICogJHtcbiAgICAgIGN1YmljQ29lZmZBXG4gICAgfSkgKiBvbmVQbHVzQWJzUyAtIDQgKiAke2N1YmljQ29lZmZBfTtcbiAgICBjb2VmZnNbMV0gPSAoKCR7Y3ViaWNDb2VmZkF9ICsgMikgKiBhYnNTIC0gKCR7Y3ViaWNDb2VmZkF9ICsgMykpICogYWJzUyAqIGFic1MgKyAxO1xuICAgIGNvZWZmc1syXSA9ICgoJHtjdWJpY0NvZWZmQX0gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke2N1YmljQ29lZmZBfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke2N1YmljQ29lZmZBfSAqIHR3b01pbnVzQWJzUyAtIDUgKiAke2N1YmljQ29lZmZBfSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHtcbiAgICAgIGN1YmljQ29lZmZBXG4gICAgfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7ZFR5cGV9LCA0PiwgY29lZnM6IGFycmF5PCR7ZFR5cGV9LCA0PikgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHtkVHlwZX0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XG4gIH1cblxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGA7XG59O1xuXG5jb25zdCB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpc05jaHcgPSB0cnVlO1xuICBjb25zdCBbYmF0Y2hJZHgsIGRlcHRoSWR4LCBoZWlnaHRJZHgsIHdpZHRoSWR4LCBjaGFubmVsSWR4XSA9XG4gICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgPyBbLTEsIDAsIDEsIDIsIC0xXSA6IGlzTmNodyA/IFswLCAyLCAzLCA0LCAxXSA6IFswLCAxLCAyLCAzLCA0XTtcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICByZXR1cm4gYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBkZXB0aDp1MzIsIGhlaWdodDogdTMyLCB3aWR0aDogdTMyKSAtPiAke2RUeXBlfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgZGVwdGhJZHgsIGBtYXgoMCwgbWluKGRlcHRoLCAke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGhlaWdodElkeCwgYG1heCgwLCBtaW4oaGVpZ2h0LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSlgKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCB3aWR0aElkeCwgYG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzKGlucHV0LCBjaGFubmVsSWR4LCBiYXRjaElkeCwgMyl9XG4gICAgICByZXR1cm4gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske2RlcHRoSWR4fV07XG4gICAgICB2YXIgaGVpZ2h0OiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7aGVpZ2h0SWR4fV07XG4gICAgICB2YXIgd2lkdGg6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHt3aWR0aElkeH1dO1xuICAgICAgJHtcbiAgICAgICAgdXNlRXh0cmFwb2xhdGlvblxuICAgICAgICAgID8gYGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtpbnB1dFNoYXBlW2RlcHRoSWR4XX0gLSAxKSB8fCBoZWlnaHQgPCAwIHx8IGhlaWdodCA+ICgke1xuICAgICAgICAgICAgICBpbnB1dFNoYXBlW2hlaWdodElkeF1cbiAgICAgICAgICAgIH0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSkge1xuICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgfWBcbiAgICAgICAgICA6ICcnXG4gICAgICB9O1xuXG4gICAgZGVwdGggPSBtYXgoMCwgbWluKGRlcHRoLCAke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSk7XG4gICAgICB3aWR0aCA9IG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke2lucHV0U2hhcGUubGVuZ3RoID4gMyA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7Y2hhbm5lbElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDMgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XG5cbiAgICAgIHZhciB4MTExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MTIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKGRlcHRoIC0gJHtkVHlwZX0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoaGVpZ2h0IC0gJHtkVHlwZX0oaGVpZ2h0MSkpO1xuICAgICAgdmFyIGR5MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHtkVHlwZX0gPSBhYnMod2lkdGggLSAke2RUeXBlfSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHdpZHRoMikgLSB3aWR0aCk7XG4gICAgICBpZiAoZGVwdGgxID09IGRlcHRoMikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQxID09IGhlaWdodDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGgxID09IHdpZHRoMikge1xuICAgICAgICBkejEgPSAwLjU7XG4gICAgICAgIGR6MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExMSAqIGR4MiAqIGR5MiAqIGR6MiArIHgxMTIgKiBkeDIgKiBkeTIgKiBkejEgKyB4MTIxICogZHgyICogZHkxICpkejIgKyB4MTIyICogZHgyICogZHkxICogZHoxICtcbiAgICAgICAgICAgICAgeDIxMSAqIGR4MSAqIGR5MiAqIGR6MiArIHgyMTIgKiBkeDEgKiBkeTIgKiBkejEgKyB4MjIxICogZHgxICogZHkxICpkejIgKyB4MjIyICogZHgxICogZHkxICogZHoxKTtcbiAgICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvID0gKFxuICBpbnB1dFRlbnNvcjogVGVuc29yVmlldyxcbiAgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyxcbiAgb3BzZXRWZXJzaW9uOiBudW1iZXIsXG4gIHNjYWxlc0lucHV0OiByZWFkb25seSBudW1iZXJbXSxcbiAgc2l6ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICByb2lJbnB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dFRlbnNvci5kaW1zO1xuICBjb25zdCByb2kgPSB1cGRhdGVSb0kocm9pSW5wdXQsIGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuXG4gIGxldCBvdXRwdXRTaGFwZSA9IGluaXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBzY2FsZXNJbnB1dCwgc2l6ZXMsIGF0dHJpYnV0ZXMuYXhlcyk7XG4gIGxldCBzY2FsZXMgPSBzY2FsZXNJbnB1dC5zbGljZSgpO1xuICBpZiAoc2NhbGVzSW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgc2NhbGVzID0gaW5wdXRTaGFwZS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gKHZhbHVlID09PSAwID8gMS4wIDogb3V0cHV0U2hhcGVbaW5kZXhdIC8gdmFsdWUpKTtcbiAgICBpZiAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kgIT09ICdzdHJldGNoJykge1xuICAgICAgb3V0cHV0U2hhcGUgPSBhZGp1c3RPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBzY2FsZXMsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUZW5zb3IuZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCBub1NjYWxlID0gaW5wdXRTaGFwZS5sZW5ndGggPT09IG91dHB1dFNoYXBlLmxlbmd0aCAmJiBpbnB1dFNoYXBlLmV2ZXJ5KChkLCBpKSA9PiBkID09PSBvdXRwdXRTaGFwZVtpXSk7XG4gIGNvbnN0IHVzZUV4dHJhcG9sYXRpb24gPSBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgY29uc3QgZXh0cmFwb2xhdGlvblZhbHVlID0gYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWU7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke1xuICAgICAgICBub1NjYWxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogYFxuICAgICAgJHtnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSwgZGF0YVR5cGUpfTtcbiAgICAgICR7KCgpID0+IHtcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICR7Y2hlY2tJbnB1dEluZGljZXMoaW5wdXQsIGlucHV0U2hhcGUpfTtcbiAgICAgICAgICAgICAgJHtnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSwgb3BzZXRWZXJzaW9uLCBkYXRhVHlwZSl9O1xuICAgICAgICAgICAgICAke2NhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlLFxuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlLFxuICAgICAgICAgICAgICAgIHNjYWxlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcm9pLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB1c2VFeHRyYXBvbGF0aW9uLFxuICAgICAgICAgICAgICApfTtcbiAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgJHtjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXQsIGlucHV0U2hhcGUsIG91dHB1dFNoYXBlLCBzY2FsZXMubGVuZ3RoLCByb2kubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtiaWxpbmVhckludGVycG9sYXRpb24oaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgdXNlRXh0cmFwb2xhdGlvbiwgZXh0cmFwb2xhdGlvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUsIHVzZUV4dHJhcG9sYXRpb24sIGV4dHJhcG9sYXRpb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0xpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpfTtcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgY2FzZSAnY3ViaWMnOlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2JpY3ViaWNJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgICBpbnB1dFNoYXBlLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICAgICAgICBzY2FsZXMsXG4gICAgICAgICAgICAgICAgICByb2ksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmN1YmljQ29lZmZBLFxuICAgICAgICAgICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbixcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSxcbiAgICAgICAgICAgICAgICApfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0N1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICBgO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXNpemUgbW9kZScpO1xuICAgICAgICB9XG4gICAgICB9KSgpfTtcbiAgICAgIGBcbiAgICAgIH1cbiAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NjYWxlcycsICdmMzInLCBzY2FsZXMubGVuZ3RoKVxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdyb2knLCAnZjMyJywgcm9pLmxlbmd0aClcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgJHtcbiAgICAgICAgICBub1NjYWxlXG4gICAgICAgICAgICA/ICdvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTsnXG4gICAgICAgICAgICA6IGBcbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgICAgICAgICByZXR1cm4gYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHthdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAgICByZXR1cm4gYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7XG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQgPyAnYmlsaW5lYXJJbnRlcnBvbGF0aW9uJyA6ICd0cmlsaW5lYXJJbnRlcnBvbGF0aW9uJ1xuICAgICAgICAgICAgICB9KG91dHB1dF9pbmRpY2VzKTtgO1xuICAgICAgICAgICAgY2FzZSAnY3ViaWMnOlxuICAgICAgICAgICAgICByZXR1cm4gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTsnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2l6ZSBtb2RlOiAke2F0dHJpYnV0ZXMubW9kZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9O1xuYFxuICAgICAgICB9XG4gICAgICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSZXNpemUnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fXwke29wc2V0VmVyc2lvbn18JHtcbiAgICAgICAgc2NhbGVzLmxlbmd0aCA+IDAgPyAoYXR0cmlidXRlcy5tb2RlID09PSAnY3ViaWMnID8gc2NhbGVzIDogc2NhbGVzLmxlbmd0aCkgOiAnJ1xuICAgICAgfXwke3NpemVzLmxlbmd0aCA+IDAgPyBzaXplcyA6ICcnfXwke3JvaS5sZW5ndGggPiAwID8gcm9pIDogJyd9fCR7bm9TY2FsZX18JHtcbiAgICAgICAgYXR0cmlidXRlcy5tb2RlID09PSAnbmVhcmVzdCcgPyBpbnB1dFNoYXBlLmxlbmd0aCA6IGlucHV0U2hhcGVcbiAgICAgIH1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddLFxuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IHNjYWxlcyB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiByb2kgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmNvbnN0IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogbnVtYmVyID0+IHtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlciA9IGNvbnRleHQuY3VzdG9tRGF0YUJ1ZmZlcjtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KGN1c3RvbURhdGFCdWZmZXIsIGN1c3RvbURhdGFCdWZmZXIuYnl0ZU9mZnNldCwgMSk7XG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGN1c3RvbURhdGFCdWZmZXIzMlswXTtcbiAgcmV0dXJuIG9wc2V0VmVyc2lvbjtcbn07XG5cbmV4cG9ydCBjb25zdCByZXNpemUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3Qgc2NhbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaXplczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgcm9pOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIE5vdGUgdGhhdCBzY2FsZXMgaW4gcmVzaXplIGFyZSBhbHdheXMgZjMyLiByb2kgY2FuIGJlIGYzMiBvciBmMTYuXG4gIC8vIFRPRE86IEN1cnJlbnRseSB0aGlzIGNvZGUgZG9lcyBub3Qgc3VwcG9ydCBmMTYgZm9yIHJvaSB3aGVuIHBhc3NlZCBhcyBvcHRpb25hbCBpbnB1dC5cblxuICBjb25zdCBvcHNldFZlcnNpb24gPSBnZXRPcHNldFZlcnNpb25Gcm9tQ3VzdG9tRGF0YUJ1ZmZlcihjb250ZXh0KTtcbiAgaWYgKGF0dHJpYnV0ZXMuYW50aWFsaWFzICE9PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkJyk7XG4gIH1cbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbiwgc2NhbGVzLCBzaXplcywgcm9pKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzLCBvcHNldFZlcnNpb24sIHNjYWxlcywgc2l6ZXMsIHJvaSksIHtcbiAgICBpbnB1dHM6IFswXSxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUmVzaXplQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFudGlhbGlhcyA9IGF0dHJpYnV0ZXMuYW50aWFsaWFzIGFzIG51bWJlcjtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6IENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGFzIENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlO1xuICBjb25zdCBjdWJpY0NvZWZmQSA9IGF0dHJpYnV0ZXMuY3ViaWNDb2VmZkEgYXMgbnVtYmVyO1xuICBjb25zdCBleGNsdWRlT3V0c2lkZSA9IChhdHRyaWJ1dGVzLmV4Y2x1ZGVPdXRzaWRlIGFzIG51bWJlcikgIT09IDA7XG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlIGFzIG51bWJlcjtcbiAgY29uc3Qga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSBhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSBhcyBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIGNvbnN0IG1vZGU6IE1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgYXMgTW9kZTtcbiAgLy8gSWYgbmVhcmVzdE1vZGUgaXMgbm90IHNwZWNpZmllZCwgdXNlIHNpbXBsZSBtb2RlLlxuICBjb25zdCBuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGUgPSAoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSA9PT0gJycgPyAnc2ltcGxlJyA6IGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUpIGFzIE5lYXJlc3RNb2RlO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhbnRpYWxpYXMsXG4gICAgYXhlcyxcbiAgICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcbiAgICBjdWJpY0NvZWZmQSxcbiAgICBleGNsdWRlT3V0c2lkZSxcbiAgICBleHRyYXBvbGF0aW9uVmFsdWUsXG4gICAga2VlcEFzcGVjdFJhdGlvUG9saWN5LFxuICAgIG1vZGUsXG4gICAgbmVhcmVzdE1vZGUsXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjYXN0VG9GMzIsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHN1bVZlY3RvcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNraXBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcbiAgZXBzaWxvbjogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQ6IFRlbnNvclZpZXcgPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNraXA6IFRlbnNvclZpZXcgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGdhbW1hOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzJdO1xuXG4gIGlmIChpbnB1dC5kYXRhVHlwZSAhPT0gc2tpcC5kYXRhVHlwZSB8fCBpbnB1dC5kYXRhVHlwZSAhPT0gZ2FtbWEuZGF0YVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIDJEIG9yIDNEJyk7XG4gIH1cblxuICBpZiAoc2tpcC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBza2lwLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgYmUgMkQgb3IgM0QnKTtcbiAgfVxuXG4gIGNvbnN0IGhpZGRlblNpemUgPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgfVxuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAyXSAhPT0gc2VxdWVuY2VMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGdhbW1hLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYW1tYSBtdXN0IGJlIDFEJyk7XG4gIH1cbiAgaWYgKGdhbW1hLmRpbXNbZ2FtbWEuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiAzKSB7XG4gICAgY29uc3QgYmV0YTogVGVuc29yVmlldyA9IGlucHV0c1szXTtcbiAgICBpZiAoYmV0YS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZXRhIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJldGEuZGltc1tiZXRhLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgY29uc3QgYmlhczogVGVuc29yVmlldyA9IGlucHV0c1s0XTtcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaWFzIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJpYXMuZGltc1tiaWFzLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVNraXBMYXllck5vcm1Qcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzLFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBpc1RyYWluaW5nOiBib29sZWFuLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xuXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IGlucHV0U2l6ZTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGlucHV0U2hhcGUuc2xpY2UoLTEpWzBdO1xuICBjb25zdCBtZWFuSW52U3RkRGV2RGltID0gaXNUcmFpbmluZyA/IGlucHV0U2hhcGUuc2xpY2UoMCwgLTEpLmNvbmNhdCgxKSA6IFtdO1xuICBjb25zdCBoYXNCZXRhSW5wdXQgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHMubGVuZ3RoID4gMztcbiAgY29uc3QgaGFzQmlhc0lucHV0ID0gaW5wdXRzLmxlbmd0aCA+IDQ7XG4gIGNvbnN0IGhhc01lYW5PdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMTtcbiAgY29uc3QgaGFzSW52U3RkRGV2T3V0cHV0ID0gaXNUcmFpbmluZyAmJiBvdXRwdXRDb3VudCA+IDI7XG4gIGNvbnN0IGhhc0lucHV0U2tpcEJpYXNTdW1PdXRwdXQgPSBvdXRwdXRDb3VudCA+IDM7XG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSA2NDtcblxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoaWRkZW5TaXplKTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogY29tcG9uZW50cyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9uIH0sXG4gIF07XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHVuaWZvcm1zQXJyYXk6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnY29tcG9uZW50cycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2YzMicgfSxcbiAgICBdO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtcbiAgICAgIGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgIGlucHV0VmFyaWFibGUoJ3NraXAnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgIGlucHV0VmFyaWFibGUoJ2dhbW1hJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cyksXG4gICAgXTtcbiAgICBpZiAoaGFzQmV0YUlucHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiZXRhJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBpZiAoaGFzQmlhc0lucHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgIGlmIChoYXNNZWFuT3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnbWVhbl9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW52U3RkRGV2T3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW52X3N0ZF9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCkge1xuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2lucHV0X3NraXBfYmlhc19zdW0nLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgY29uc3QgdmVjRGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xuICAgIHJldHVybiBgXG5cbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXNBcnJheSkuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcblxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt3b3JrZ3JvdXBTaXplLCAxLCAxXSl9XG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XG4gICAgICAgIGxldCBpeSA9IGdsb2JhbF9pZC54IC8gJHt3b3JrZ3JvdXBTaXplfTtcblxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xuICAgICAgICB2YXIgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAvICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XG4gICAgICAgIGlmIChpeCA9PSAke3dvcmtncm91cFNpemUgLSAxfSkge1xuICAgICAgICAgIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLSBzdHJpZGUgKiBpeDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke2hhc0JpYXNJbnB1dCA/ICdiaWFzW29mZnNldDFkICsgaV0nIDogZGF0YVR5cGUgKyAnKDAuMCknfTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID8gJ2lucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTsnIDogJyd9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAndmFsdWUnKX07XG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlICogZjMyX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke3dvcmtncm91cFNpemV9O1xuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZV9zaXplID0gY3Vycl9zaXplICsgKHJlZHVjZV9zaXplICYgMSk7XG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBzdW1fc3F1YXJlZF9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xuICAgICAgICBsZXQgc3F1YXJlX3N1bSA9IHN1bV9zcXVhcmVkX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IG1lYW4gPSAke3N1bVZlY3Rvcignc3VtJywgY29tcG9uZW50cyl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtzdW1WZWN0b3IoJ3NxdWFyZV9zdW0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7XG4gICAgICAgICAgc2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbiAqIG1lYW4nXG4gICAgICAgIH0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtoYXNNZWFuT3V0cHV0ID8gJ21lYW5fb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjsnIDogJyd9XG4gICAgICAgICR7aGFzSW52U3RkRGV2T3V0cHV0ID8gJ2ludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7JyA6ICcnfVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gJHtzaW1wbGlmaWVkID8gJycgOiBgLSAke2RhdGFUeXBlfShtZWFuKWB9KSAqXG4gICAgICAgICAgICAke2RhdGFUeXBlfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke2hhc0JldGFJbnB1dCA/ICcrIGJldGFbb2Zmc2V0MWQgKyBpXScgOiAnJ307XG4gICAgICAgIH1cbiAgICAgIH1gO1xuICB9O1xuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV07XG4gIGlmIChvdXRwdXRDb3VudCA+IDEpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XG4gIH1cbiAgaWYgKG91dHB1dENvdW50ID4gMikge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcbiAgfVxuICBpZiAob3V0cHV0Q291bnQgPiAzKSB7XG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHtoYXNNZWFuT3V0cHV0fTske2hhc0ludlN0ZERldk91dHB1dH07JHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaW5wdXRzLm1hcCgoX2lucHV0LCBfaW5kZXgpID0+ICd0eXBlJyksXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHMsXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7XG4gICAgICAgIHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gaGlkZGVuU2l6ZSksXG4gICAgICB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNraXBMYXllck5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IGluaXRpYWxpemUgaXNUcmFpbmluZyBmcm9tIENvbXB1dGVDb250ZXh0XG4gIGNvbnN0IGlzVHJhaW5pbmcgPSBmYWxzZTtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICAvLyBNZWFuIGFuZCBJbnZTdGREZXYgYXJlIG9ubHkgdXNlZCBpbiB0cmFpbmluZyBtb2RlIGFuZCBhcmUgbm90IHJlcXVpcmVkIGZvciBpbmZlcmVuY2UuXG4gIC8vIFRoZXkgYXJlIGFkZGVkIGhlcmUgZm9yIGNvbXBsZXRlbmVzcyBvbmx5LlxuICBjb25zdCBvdXRwdXRzID0gWzBdO1xuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDEpIHtcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDEgOiAtMyk7XG4gIH1cbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAyKSB7XG4gICAgb3V0cHV0cy5wdXNoKGlzVHJhaW5pbmcgPyAyIDogLTMpO1xuICB9XG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMykge1xuICAgIG91dHB1dHMucHVzaCgzKTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU2tpcExheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50LCBpc1RyYWluaW5nKSwge1xuICAgIG91dHB1dHMsXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtLCBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0RWxlbWVudEF0LFxuICBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG4gIHJlYWRvbmx5IGVuZHM6IG51bWJlcltdO1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggfHwgYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gIH1cbiAgaW5wdXRzLnNsaWNlKDEpLmZvckVhY2goKF8sIGlkeCkgPT4ge1xuICAgIGlmIChpbnB1dHNbaWR4ICsgMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmIGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgcmVhZElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpZHg6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaW5wdXQ6IG51bWJlcltdID0gW107XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gaWR4KSB7XG4gICAgaWYgKGlucHV0c1tpZHhdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgaW5wdXRzW2lkeF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goKHYpID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dHNbaWR4XS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIGlucHV0c1tpZHhdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBpbnB1dC5wdXNoKE51bWJlcih2KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7aWR4fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNsaWNlQXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMsXG4pOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzdGFydHM6IG51bWJlcltdID0gcmVhZElucHV0KGlucHV0cywgMSk7XG4gICAgY29uc3QgZW5kczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAyKTtcbiAgICBsZXQgYXhlczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAzKTtcbiAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF4ZXMgPSBbLi4uQXJyYXkoaW5wdXRzWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgc3RhcnRzLCBlbmRzLCBheGVzIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59O1xuXG5jb25zdCBmaXhTdGFydEVuZFZhbHVlcyA9IChcbiAgdmFsdWU6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzdGVwczogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBudW1iZXIgPT4ge1xuICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIG5ld1ZhbHVlICs9IGlucHV0U2hhcGVbYXhlc1tpbmRleF1dO1xuICB9XG4gIGlmIChzdGVwc1tpbmRleF0gPCAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG5ld1ZhbHVlLCBpbnB1dFNoYXBlW2F4ZXNbaW5kZXhdXSAtIDEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dKSk7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwgPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogc3RyaW5nID0+XG4gIGBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtpbnB1dFNoYXBlLmxlbmd0aCAtIDF9OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGVwcycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzaWduc19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNpZ25zJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnN0YXJ0cycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gb3V0cHV0X2luZGV4ICogc3RlcHNfaSArIHN0YXJ0c19pICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0X2luZGV4IC8gaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfaW5kZXggJSBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaWYgKHNpZ25zX2kgPCAwKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIGlucHV0X2luZGV4IC0gMXUgKyBzdGFydHNfaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2luZGV4Jyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICAgIH1gO1xuXG5jb25zdCBjcmVhdGVTbGljZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGF4ZXMgPVxuICAgIGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwXG4gICAgICA/IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpXG4gICAgICA6IFsuLi5BcnJheShpbnB1dFNoYXBlLmxlbmd0aCkua2V5cygpXTtcbiAgbGV0IHN0ZXBzID0gcmVhZElucHV0KGlucHV0cywgNCk7XG4gIHN0ZXBzLmZvckVhY2goXG4gICAgKHN0ZXApID0+XG4gICAgICBzdGVwICE9PSAwIHx8XG4gICAgICAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0ZXAgY2Fubm90IGJlIDAnKTtcbiAgICAgIH0pLFxuICApO1xuICBpZiAoc3RlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgc3RlcHMgPSBBcnJheShheGVzLmxlbmd0aCkuZmlsbCgxKTtcbiAgfVxuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cy5tYXAoKHN0YXJ0LCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhzdGFydCwgaSwgaW5wdXRTaGFwZSwgYXhlcywgc3RlcHMpKTtcblxuICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzLm1hcCgoZW5kLCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhlbmQsIGksIGlucHV0U2hhcGUsIGF4ZXMsIHN0ZXBzKSk7XG5cbiAgaWYgKGF4ZXMubGVuZ3RoICE9PSBzdGFydHMubGVuZ3RoIHx8IGF4ZXMubGVuZ3RoICE9PSBlbmRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzJyk7XG4gIH1cblxuICBpZiAoYXhlcy5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIWF4ZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgc3RhcnRzLnNwbGljZShpLCAwLCAwKTtcbiAgICAgICAgZW5kcy5zcGxpY2UoaSwgMCwgaW5wdXRTaGFwZVtpXSk7XG4gICAgICAgIHN0ZXBzLnNwbGljZShpLCAwLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc2lnbnMgPSBzdGVwcy5tYXAoKHN0ZXApID0+IE1hdGguc2lnbihzdGVwKSk7XG4gIC8vIENvbnZlcnQgbmVnYXRpdmUgc3RlcHMgdG8gcG9zaXRpdmUgc3RlcHMgYW5kIHJldmVyc2Ugc3RhcnRzIGFuZCBlbmRzXG4gIHN0ZXBzLmZvckVhY2goKHN0ZXAsIGksIGFycmF5KSA9PiB7XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBjb25zdCBudW1TdGVwcyA9IChlbmRzW2ldIC0gc3RhcnRzW2ldKSAvIHN0ZXA7XG4gICAgICBjb25zdCBuZXdFbmQgPSBzdGFydHNbaV07XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ld0VuZCArIG51bVN0ZXBzICogc3RlcHNbaV07XG4gICAgICBzdGFydHNbaV0gPSBuZXdTdGFydDtcbiAgICAgIGVuZHNbaV0gPSBuZXdFbmQ7XG4gICAgICBhcnJheVtpXSA9IC1zdGVwO1xuICAgIH1cbiAgfSk7XG4gIC8vIE91dHB1dCByYW5rIGlzIGV4cGVjdGVkIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQgcmFuay5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xuICBheGVzLmZvckVhY2goKGF4aXMsIF8pID0+IHtcbiAgICBvdXRwdXRTaGFwZVtheGlzXSA9IE1hdGguY2VpbCgoZW5kc1theGlzXSAtIHN0YXJ0c1theGlzXSkgLyBzdGVwc1theGlzXSk7XG4gIH0pO1xuICBjb25zdCBvdXRwdXRUZW5zb3JJbmZvOiBUZW5zb3JJbmZvID0geyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICB7IG5hbWU6ICdvdXRwdXRTaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICB7IG5hbWU6ICdzdGFydHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGFydHMubGVuZ3RoIH0sXG4gICAgeyBuYW1lOiAnc2lnbnMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBzaWducy5sZW5ndGggfSxcbiAgICB7IG5hbWU6ICdzdGVwcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0ZXBzLmxlbmd0aCB9LFxuICBdO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGFydHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBzaWducyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGVwcyB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgICAke2NhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwoaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJykpfVxuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NsaWNlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtzaWducy5sZW5ndGh9XyR7c3RhcnRzLmxlbmd0aH1fJHtzdGVwcy5sZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbb3V0cHV0VGVuc29ySW5mb10sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBjcmVhdGVTbGljZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcbiAgLy8gaWYgKFNoYXBlVXRpbC5zaXplKHByb2dyYW0ub3V0cHV0c1swXS5kaW1zKSA+IDApIHtcbiAgLy8gICBjb250ZXh0LmNvbXB1dGUocHJvZ3JhbUluZm9Mb2FkZXIsIHtpbnB1dHM6IFswXX0pO1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIFRPRE86IHN1cHBvcnQgZW1wdHkgb3V0cHV0XG4gIC8vICAgdGhyb3cgbmV3IEVycm9yKCdzbGljZTogb3V0cHV0IHNpemUgaXMgMCcpO1xuICAvLyB9XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTbGljZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cyBhcyBudW1iZXJbXTtcbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHN0YXJ0cywgZW5kcywgYXhlcyB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcbi8vIHBlcmZvcm1hbmNlIGxpbWl0YXRpb25zIHdoZW4gdGhlIHJlZHVjZWQgYXhpcyBpcyBsb25nLiBOZWVkIHRvIGFkZFxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuaW1wb3J0IHtcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgc3VtVmVjdG9yLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvZnRtYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCBjcmVhdGVTb2Z0bWF4UHJvZ3JhbUluZm8gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gY29udGV4dC5pbnB1dHNbMF07XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuICBjb25zdCBpc1RyYW5zcG9zZVJlcXVpcmVkID0gYXhpcyA8IGlucHV0U2hhcGUubGVuZ3RoIC0gMTtcbiAgbGV0IHRyYW5zcG9zZWRJbnB1dDogVGVuc29yVmlldztcbiAgbGV0IHBlcm06IG51bWJlcltdID0gW107XG5cbiAgaWYgKGlzVHJhbnNwb3NlUmVxdWlyZWQpIHtcbiAgICBwZXJtID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRSYW5rIH0sIChfLCBpKSA9PiBpKTtcbiAgICBwZXJtW2F4aXNdID0gaW5wdXRSYW5rIC0gMTtcbiAgICBwZXJtW2lucHV0UmFuayAtIDFdID0gYXhpcztcblxuICAgIHRyYW5zcG9zZWRJbnB1dCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dCwgcGVybSksIHtcbiAgICAgIGlucHV0czogW2lucHV0XSxcbiAgICAgIG91dHB1dHM6IFstMV0sXG4gICAgfSlbMF07XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3NlZElucHV0ID0gaW5wdXQ7XG4gIH1cblxuICBjb25zdCB0cmFuc3Bvc2VkSW5wdXRTaGFwZSA9IHRyYW5zcG9zZWRJbnB1dC5kaW1zO1xuICBjb25zdCBjb2xzID0gdHJhbnNwb3NlZElucHV0U2hhcGVbaW5wdXRSYW5rIC0gMV07XG4gIGNvbnN0IHJvd3MgPSBvdXRwdXRTaXplIC8gY29scztcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoY29scyk7XG4gIGNvbnN0IHBhY2tlZENvbHMgPSBjb2xzIC8gY29tcG9uZW50cztcbiAgbGV0IFdHID0gNjQ7XG4gIC8vIElmIG9ubHkgb25lIHdvcmtncm91cCBpcyBkaXNwYXRjaGVkLCBpbmNyZWFzZSB3b3JrZ3JvdXBTaXplIHRvIGltcHJvdmUgcGFyYWxsZWxpc20uXG4gIGlmIChyb3dzID09PSAxKSB7XG4gICAgV0cgPSAyNTY7XG4gIH1cbiAgY29uc3QgbWF4VmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGNvbXBvbmVudHMgPT09IDQpIHtcbiAgICAgIHJldHVybiBgbWF4KG1heCgke25hbWV9LngsICR7bmFtZX0ueSksIG1heCgke25hbWV9LnosICR7bmFtZX0udykpYDtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcbiAgICAgIHJldHVybiBgbWF4KCR7bmFtZX0ueCwgJHtuYW1lfS55KWA7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCAke25hbWV9LnopYDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCB0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUsIHRyYW5zcG9zZWRJbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIHRyYW5zcG9zZWRJbnB1dC5kYXRhVHlwZSwgdHJhbnNwb3NlZElucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gIC8vIDYuMi40IGluIHdnc2wgc3BlY1xuICBjb25zdCB0aHJlYWRNYXhEZWNsID1cbiAgICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUodHJhbnNwb3NlZElucHV0LmRhdGFUeXBlKSA9PT0gJ2YzMidcbiAgICAgID8gYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzhmKTtgXG4gICAgICA6IGB2YXIgdGhyZWFkTWF4ID0gJHt2YWx1ZVR5cGV9KC02NTUwNC4waCk7YDtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke3ZhbHVlVHlwZX07XG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dTdW1TaGFyZWQgOiAke3ZhbHVlVHlwZX07XG4gICAgICB2YXI8d29ya2dyb3VwPiB0aHJlYWRTaGFyZWQgOiBhcnJheTwke3ZhbHVlVHlwZX0sICR7V0d9PjtcblxuICAgICAgZm4gZ2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIpIC0+ICR7dmFsdWVUeXBlfSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke3ZhbHVlVHlwZX0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdwYWNrZWRDb2xzJywgJ2kzMicpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXRyl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke1dHfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke3RocmVhZE1heERlY2x9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7dmFsdWVUeXBlfSgke21heFZlY3RvcigndGhyZWFkU2hhcmVkWzBdJywgY29tcG9uZW50cyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7dmFsdWVUeXBlfSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7c3VtVmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgLy8gbWF4IG9wZXJhdGlvbiBwcm90ZWN0cyBhZ2FpbnN0IE5hTiBzaW5jZSBhbGwgdmFsdWVzIHNob3VsZCBiZSA+PTBcbiAgICAgICAgICB2YWx1ZSA9IG1heCh2YWx1ZSwgJHt2YWx1ZVR5cGV9KDAuMCkpO1xuICAgICAgICAgIHNldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1gO1xuICBjb25zdCByZXN1bHQgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ1NvZnRtYXgnLFxuICAgICAgLy8gTm90ZSB0aGF0IGluIEpTRVAsIFdHIHNpemUgaXMgbm90IGluY2x1ZGVkIGluIGNhY2hlIGJ5IGRlZmF1bHQsIGJ1dCBXZWJHUFUgRVAgaXQgaXMuXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfTske1dHfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogdHJhbnNwb3NlZElucHV0U2hhcGUsIGRhdGFUeXBlOiB0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogcm93cyB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBwYWNrZWRDb2xzIH1dLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBpbnB1dHM6IFt0cmFuc3Bvc2VkSW5wdXRdLFxuICAgICAgb3V0cHV0czogW2lzVHJhbnNwb3NlUmVxdWlyZWQgPyAtMSA6IDBdLFxuICAgIH0sXG4gIClbMF07XG5cbiAgaWYgKGlzVHJhbnNwb3NlUmVxdWlyZWQpIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzdWx0LCBwZXJtKSwge1xuICAgICAgaW5wdXRzOiBbcmVzdWx0XSxcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNvZnRtYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY3JlYXRlU29mdG1heFByb2dyYW1JbmZvKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IGdldFJlcGVhdHMgPSAocmVwZWF0c1RlbnNvclZpZXc6IFRlbnNvclZpZXcpOiByZWFkb25seSBudW1iZXJbXSA9PlxuICBBcnJheS5mcm9tKHJlcGVhdHNUZW5zb3JWaWV3LmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0ICYmXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2ICYmXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQzMiAmJlxuICAgIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUudWludDMyXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGZsb2F0MTYsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EJyk7XG4gIH1cblxuICBjb25zdCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSA9IGdldFJlcGVhdHMoaW5wdXRzWzFdKTtcblxuICBpZiAocmVwZWF0cy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvcicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcmVwZWF0czogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIG91dHB1dFNoYXBlLnB1c2goaW5wdXRTaGFwZVtpXSAqIHJlcGVhdHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dFNoYXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgc2hhcGU/OiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSA9IHNoYXBlID09IG51bGwgPyBnZXRSZXBlYXRzKGlucHV0c1sxXSkgOiBzaGFwZTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCByZXBlYXRzKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke2lucHV0LmluZGljZXMoLi4uaW5wdXRTaGFwZSl9O1xuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2lucHV0LmluZGljZXNHZXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9ICAlIGlucHV0X2RpbV9pO1xuXG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2RpbV92YWx1ZScpfVxuICAgICAgfVxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKSl9XG4gICAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnVGlsZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7cmVwZWF0c31gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIG91dHB1dFNoYXBlKSxcbiAgICAgIF0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHRpbGUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVGlsZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgY3JlYXRlV2hlcmVPcFByb2dyYW1TaGFkZXIgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGlzQnJvYWRjYXN0OiBib29sZWFuLFxuICB0eXBlT3V0cHV0OiBudW1iZXIsXG4pID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9kYXRhJywgdHlwZU91dHB1dCwgZGltc091dHB1dC5sZW5ndGgsIDQpO1xuICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYV9kYXRhJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIDQpO1xuICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYl9kYXRhJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIDQpO1xuICBjb25zdCBjID0gaW5wdXRWYXJpYWJsZSgnY19kYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIDQpO1xuXG4gIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gIGNvbnN0IGV4cHJlc3Npb24gPSAoYTogc3RyaW5nLCBiOiBzdHJpbmcsIGM6IHN0cmluZykgPT4gYHNlbGVjdCgke2J9LCAke2F9LCAke2N9KWA7XG4gIGlmICghaXNCcm9hZGNhc3QpIHtcbiAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgZXhwcmVzc2lvbihhLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksIGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4ge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkEgPSBgYV9kYXRhW2luZGV4X2Eke3h9XVtjb21wb25lbnRfYSR7eH1dYDtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25CID0gYGJfZGF0YVtpbmRleF9iJHt4fV1bY29tcG9uZW50X2Ike3h9XWA7XG4gICAgICBjb25zdCBleHByZXNzaW9uQyA9IGBib29sKGNfZGF0YVtpbmRleF9jJHt4fV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHt4fSAqIDgpKSlgO1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9hJHt4fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Ike3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYyR7eH0gPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Eke3h9ID0gb2Zmc2V0X2Eke3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYiR7eH0gPSBvZmZzZXRfYiR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9jJHt4fSA9IG9mZnNldF9jJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9hJHt4fSA9IG9mZnNldF9hJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9iJHt4fSA9IG9mZnNldF9iJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9jJHt4fSA9IG9mZnNldF9jJHt4fSAlIDR1O1xuICAgICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtleHByZXNzaW9uKGV4cHJlc3Npb25BLCBleHByZXNzaW9uQiwgZXhwcmVzc2lvbkMpfSk7XG4gICAgICAgICAgYDtcbiAgICB9O1xuICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDApfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDEpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDIpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDMpfVxuICAgICAgICAgIGA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGMsIGEsIGIsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZVdoZXJlT3BQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZGltc0EgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgZGltc0IgPSBpbnB1dHNbMl0uZGltcztcbiAgY29uc3QgZGltc0MgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgb3V0cHV0RGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7XG5cbiAgY29uc3QgaXNCcm9hZGNhc3QgPSAhKFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQSwgZGltc0IpICYmIFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQiwgZGltc0MpKTtcbiAgbGV0IG91dHB1dFNoYXBlID0gZGltc0E7XG4gIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoZGltc0EpO1xuICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcblxuICBpZiAoaXNCcm9hZGNhc3QpIHtcbiAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShkaW1zQSwgZGltc0IsIGZhbHNlKSEsIGRpbXNDLCBmYWxzZSk7XG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XG4gICAgfVxuICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIH1cblxuICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdXaGVyZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZVdoZXJlT3BQcm9ncmFtU2hhZGVyKHNoYWRlckhlbHBlciwgaW5wdXRzLCBvdXRwdXRTaGFwZSwgaXNCcm9hZGNhc3QsIG91dHB1dERhdGFUeXBlKSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogdmVjIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHZlY1NpemUgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoZGltc0MsIGRpbXNBLCBkaW1zQiwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB3aGVyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlV2hlcmVPcFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBhcmdNYXgsIGFyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvYXJnbWlubWF4JztcbmltcG9ydCB7IGF0dGVudGlvbiB9IGZyb20gJy4vb3BzL2F0dGVudGlvbic7XG5pbXBvcnQgeyBiYXRjaE5vcm0gfSBmcm9tICcuL29wcy9iYXRjaC1ub3JtJztcbmltcG9ydCB7IGJpYXNBZGQgfSBmcm9tICcuL29wcy9iaWFzLWFkZCc7XG5pbXBvcnQgeyBiaWFzU3BsaXRHZWx1IH0gZnJvbSAnLi9vcHMvYmlhcy1zcGxpdC1nZWx1JztcbmltcG9ydCAqIGFzIGJpbmFyeU9wcyBmcm9tICcuL29wcy9iaW5hcnktb3AnO1xuaW1wb3J0IHsgY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb25jYXQnO1xuaW1wb3J0IHsgY29udiwgcGFyc2VDb252QXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbnYnO1xuaW1wb3J0IHsgY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbnYtdHJhbnNwb3NlJztcbmltcG9ydCB7IGN1bXN1bSwgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY3Vtc3VtJztcbmltcG9ydCB7IGRlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZGVwdGgtdG8tc3BhY2UnO1xuaW1wb3J0IHsgZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9laW5zdW0nO1xuaW1wb3J0IHsgZXhwYW5kIH0gZnJvbSAnLi9vcHMvZXhwYW5kJztcbmltcG9ydCB7IGZhc3RHZWx1IH0gZnJvbSAnLi9vcHMvZmFzdC1nZWx1JztcbmltcG9ydCB7IGdhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2F0aGVyJztcbmltcG9ydCB7IGdhdGhlck5ELCBwYXJzZUdhdGhlck5EQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1uZCc7XG5pbXBvcnQgeyBnYXRoZXJCbG9ja1F1YW50aXplZCwgcGFyc2VHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9nYXRoZXItYmxvY2stcXVhbnRpemVkJztcbmltcG9ydCB7IGdhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1lbGVtZW50cyc7XG5pbXBvcnQgeyBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2VtbSc7XG5pbXBvcnQgeyBncmlkU2FtcGxlLCBwYXJzZUdyaWRTYW1wbGVBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ3JpZC1zYW1wbGUnO1xuaW1wb3J0IHsgZ3JvdXBRdWVyeUF0dGVudGlvbiB9IGZyb20gJy4vb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbic7XG5pbXBvcnQgeyBpbnN0YW5jZU5vcm0gfSBmcm9tICcuL29wcy9pbnN0YW5jZS1ub3JtJztcbmltcG9ydCB7IGxheWVyTm9ybSB9IGZyb20gJy4vb3BzL2xheWVyLW5vcm0nO1xuaW1wb3J0IHsgbWF0TXVsIH0gZnJvbSAnLi9vcHMvbWF0bXVsJztcbmltcG9ydCB7IG1hdE11bE5CaXRzLCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL21hdG11bG5iaXRzJztcbmltcG9ydCB7IG11bHRpSGVhZEF0dGVudGlvbiwgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvbXVsdGloZWFkLWF0dGVudGlvbic7XG5pbXBvcnQgeyBwYWQgfSBmcm9tICcuL29wcy9wYWQnO1xuaW1wb3J0ICogYXMgcG9vbCBmcm9tICcuL29wcy9wb29sJztcbmltcG9ydCB7IGRlcXVhbnRpemVMaW5lYXIsIHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9xdWFudGl6ZS1saW5lYXInO1xuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tICcuL29wcy9yYW5nZSc7XG5pbXBvcnQgeyBzY2F0dGVyTkQsIHBhcnNlU2NhdHRlck5EQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL3NjYXR0ZXItbmQnO1xuaW1wb3J0IHtcbiAgcmVkdWNlTDEsXG4gIHJlZHVjZUwyLFxuICByZWR1Y2VMb2dTdW0sXG4gIHJlZHVjZUxvZ1N1bUV4cCxcbiAgcmVkdWNlTWF4LFxuICByZWR1Y2VNZWFuLFxuICByZWR1Y2VNaW4sXG4gIHJlZHVjZVByb2QsXG4gIHJlZHVjZVN1bSxcbiAgcmVkdWNlU3VtU3F1YXJlLFxufSBmcm9tICcuL29wcy9yZWR1Y2UnO1xuaW1wb3J0IHsgcGFyc2VSZXNpemVBdHRyaWJ1dGVzLCByZXNpemUgfSBmcm9tICcuL29wcy9yZXNpemUnO1xuaW1wb3J0IHsgcm90YXJ5RW1iZWRkaW5nIH0gZnJvbSAnLi9vcHMvcm90YXJ5LWVtYmVkZGluZyc7XG5pbXBvcnQgeyBza2lwTGF5ZXJOb3JtIH0gZnJvbSAnLi9vcHMvc2tpcC1sYXllci1ub3JtJztcbmltcG9ydCB7IHBhcnNlU2xpY2VBdHRyaWJ1dGVzLCBzbGljZSB9IGZyb20gJy4vb3BzL3NsaWNlJztcbmltcG9ydCB7IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMsIHNvZnRtYXggfSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7IHBhcnNlU3BsaXRBdHRyaWJ1dGVzLCBzcGxpdCB9IGZyb20gJy4vb3BzL3NwbGl0JztcbmltcG9ydCB7IHRpbGUgfSBmcm9tICcuL29wcy90aWxlJztcbmltcG9ydCB7IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcywgdHJhbnNwb3NlIH0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7IHdoZXJlIH0gZnJvbSAnLi9vcHMvd2hlcmUnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgUnVuRnVuY3Rpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZT86IHVua25vd24pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uID0gKGF0dHJpYnV0ZVJhdzogdW5rbm93bikgPT4gdW5rbm93bjtcbmV4cG9ydCB0eXBlIE9wZXJhdG9ySW1wbGVtZW50YXRpb24gPSBbUnVuRnVuY3Rpb25dIHwgW1J1bkZ1bmN0aW9uLCBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uXTtcblxuZXhwb3J0IGNvbnN0IFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTOiBNYXA8c3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPiA9IG5ldyBNYXAoW1xuICBbJ0FicycsIFt1bmFyeU9wcy5hYnNdXSxcbiAgWydBY29zJywgW3VuYXJ5T3BzLmFjb3NdXSxcbiAgWydBY29zaCcsIFt1bmFyeU9wcy5hY29zaF1dLFxuICBbJ0FkZCcsIFtiaW5hcnlPcHMuYWRkXV0sXG4gIFsnQXJnTWF4JywgW2FyZ01heCwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXJnTWluJywgW2FyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXNpbicsIFt1bmFyeU9wcy5hc2luXV0sXG4gIFsnQXNpbmgnLCBbdW5hcnlPcHMuYXNpbmhdXSxcbiAgWydBdGFuJywgW3VuYXJ5T3BzLmF0YW5dXSxcbiAgWydBdGFuaCcsIFt1bmFyeU9wcy5hdGFuaF1dLFxuICBbJ0F0dGVudGlvbicsIFthdHRlbnRpb25dXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgQXZlcmFnZVBvb2wtMTBcbiAgWydBdmVyYWdlUG9vbCcsIFtwb29sLmF2ZXJhZ2VQb29sLCBwb29sLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnQmF0Y2hOb3JtYWxpemF0aW9uJywgW2JhdGNoTm9ybV1dLFxuICBbJ0JpYXNBZGQnLCBbYmlhc0FkZF1dLFxuICBbJ0JpYXNTcGxpdEdlbHUnLCBbYmlhc1NwbGl0R2VsdV1dLFxuICBbJ0Nhc3QnLCBbdW5hcnlPcHMuY2FzdCwgdW5hcnlPcHMucGFyc2VDYXN0QXR0cmlidXRlc11dLFxuICBbJ0NlaWwnLCBbdW5hcnlPcHMuY2VpbF1dLFxuICBbJ0NsaXAnLCBbdW5hcnlPcHMuY2xpcF1dLFxuICBbJ0NvbmNhdCcsIFtjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlc11dLFxuICBbJ0NvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxuICBbJ0NvbnZUcmFuc3Bvc2UnLCBbY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc11dLFxuICBbJ0NvcycsIFt1bmFyeU9wcy5jb3NdXSxcbiAgWydDb3NoJywgW3VuYXJ5T3BzLmNvc2hdXSxcbiAgWydDdW1TdW0nLCBbY3Vtc3VtLCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXNdXSxcbiAgWydEZXB0aFRvU3BhY2UnLCBbZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXNdXSxcbiAgWydEZXF1YW50aXplTGluZWFyJywgW2RlcXVhbnRpemVMaW5lYXIsIHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXNdXSxcbiAgWydEaXYnLCBbYmluYXJ5T3BzLmRpdl1dLFxuICBbJ0VpbnN1bScsIFtlaW5zdW0sIHBhcnNlRWluc3VtQXR0cmlidXRlc11dLFxuICBbJ0VsdScsIFt1bmFyeU9wcy5lbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnRXF1YWwnLCBbYmluYXJ5T3BzLmVxdWFsXV0sXG4gIFsnRXJmJywgW3VuYXJ5T3BzLmVyZl1dLFxuICBbJ0V4cCcsIFt1bmFyeU9wcy5leHBdXSxcbiAgWydFeHBhbmQnLCBbZXhwYW5kXV0sXG4gIFsnRmFzdEdlbHUnLCBbZmFzdEdlbHVdXSxcbiAgWydGbG9vcicsIFt1bmFyeU9wcy5mbG9vcl1dLFxuICBbJ0Z1c2VkQ29udicsIFtjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyJywgW2dhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyRWxlbWVudHMnLCBbZ2F0aGVyRWxlbWVudHMsIHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLCBbZ2F0aGVyQmxvY2tRdWFudGl6ZWQsIHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyTkQnLCBbZ2F0aGVyTkQsIHBhcnNlR2F0aGVyTkRBdHRyaWJ1dGVzXV0sXG4gIFsnR2VsdScsIFt1bmFyeU9wcy5nZWx1XV0sXG4gIFsnR2VtbScsIFtnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzXV0sXG4gIFsnR2xvYmFsQXZlcmFnZVBvb2wnLCBbcG9vbC5nbG9iYWxBdmVyYWdlUG9vbCwgcG9vbC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlc11dLFxuICBbJ0dsb2JhbE1heFBvb2wnLCBbcG9vbC5nbG9iYWxNYXhQb29sLCBwb29sLnBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydHcmVhdGVyJywgW2JpbmFyeU9wcy5ncmVhdGVyXV0sXG4gIFsnR3JlYXRlck9yRXF1YWwnLCBbYmluYXJ5T3BzLmdyZWF0ZXJPckVxdWFsXV0sXG4gIFsnR3JpZFNhbXBsZScsIFtncmlkU2FtcGxlLCBwYXJzZUdyaWRTYW1wbGVBdHRyaWJ1dGVzXV0sXG4gIFsnR3JvdXBRdWVyeUF0dGVudGlvbicsIFtncm91cFF1ZXJ5QXR0ZW50aW9uXV0sXG4gIFsnSGFyZFNpZ21vaWQnLCBbdW5hcnlPcHMuaGFyZFNpZ21vaWQsIHVuYXJ5T3BzLnBhcnNlSGFyZFNpZ21vaWRBdHRyaWJ1dGVzXV0sXG4gIFsnSW5zdGFuY2VOb3JtYWxpemF0aW9uJywgW2luc3RhbmNlTm9ybV1dLFxuICBbJ0xheWVyTm9ybWFsaXphdGlvbicsIFtsYXllck5vcm1dXSxcbiAgWydMZWFreVJlbHUnLCBbdW5hcnlPcHMubGVha3lSZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ0xlc3MnLCBbYmluYXJ5T3BzLmxlc3NdXSxcbiAgWydMZXNzT3JFcXVhbCcsIFtiaW5hcnlPcHMubGVzc09yRXF1YWxdXSxcbiAgWydMb2cnLCBbdW5hcnlPcHMubG9nXV0sXG4gIFsnTWF0TXVsJywgW21hdE11bF1dLFxuICBbJ01hdE11bE5CaXRzJywgW21hdE11bE5CaXRzLCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlc11dLFxuICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBNYXhQb29sLTggYW5kIE1heFBvb2wtMTBcbiAgWydNYXhQb29sJywgW3Bvb2wubWF4UG9vbCwgcG9vbC5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnTXVsJywgW2JpbmFyeU9wcy5tdWxdXSxcbiAgWydNdWx0aUhlYWRBdHRlbnRpb24nLCBbbXVsdGlIZWFkQXR0ZW50aW9uLCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXNdXSxcbiAgWydOZWcnLCBbdW5hcnlPcHMubmVnXV0sXG4gIFsnTm90JywgW3VuYXJ5T3BzLm5vdF1dLFxuICBbJ1BhZCcsIFtwYWRdXSxcbiAgWydQb3cnLCBbYmluYXJ5T3BzLnBvd11dLFxuICBbJ1F1aWNrR2VsdScsIFt1bmFyeU9wcy5xdWlja2dlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnUmFuZ2UnLCBbcmFuZ2VdXSxcbiAgWydSZWNpcHJvY2FsJywgW3VuYXJ5T3BzLnJlY2lwcm9jYWxdXSxcbiAgWydSZWR1Y2VNaW4nLCBbcmVkdWNlTWluXV0sXG4gIFsnUmVkdWNlTWVhbicsIFtyZWR1Y2VNZWFuXV0sXG4gIFsnUmVkdWNlTWF4JywgW3JlZHVjZU1heF1dLFxuICBbJ1JlZHVjZVN1bScsIFtyZWR1Y2VTdW1dXSxcbiAgWydSZWR1Y2VQcm9kJywgW3JlZHVjZVByb2RdXSxcbiAgWydSZWR1Y2VMMScsIFtyZWR1Y2VMMV1dLFxuICBbJ1JlZHVjZUwyJywgW3JlZHVjZUwyXV0sXG4gIFsnUmVkdWNlTG9nU3VtJywgW3JlZHVjZUxvZ1N1bV1dLFxuICBbJ1JlZHVjZUxvZ1N1bUV4cCcsIFtyZWR1Y2VMb2dTdW1FeHBdXSxcbiAgWydSZWR1Y2VTdW1TcXVhcmUnLCBbcmVkdWNlU3VtU3F1YXJlXV0sXG4gIFsnUmVsdScsIFt1bmFyeU9wcy5yZWx1XV0sXG4gIFsnUmVzaXplJywgW3Jlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzXV0sXG4gIFsnUm90YXJ5RW1iZWRkaW5nJywgW3JvdGFyeUVtYmVkZGluZ11dLFxuICBbJ1NjYXR0ZXJORCcsIFtzY2F0dGVyTkQsIHBhcnNlU2NhdHRlck5EQXR0cmlidXRlc11dLFxuICBbJ1NpZ21vaWQnLCBbdW5hcnlPcHMuc2lnbW9pZF1dLFxuICBbJ1NpbicsIFt1bmFyeU9wcy5zaW5dXSxcbiAgWydTaW5oJywgW3VuYXJ5T3BzLnNpbmhdXSxcbiAgWydTbGljZScsIFtzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdXSxcbiAgWydTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJywgW3NraXBMYXllck5vcm1dXSxcbiAgWydTcGxpdCcsIFtzcGxpdCwgcGFyc2VTcGxpdEF0dHJpYnV0ZXNdXSxcbiAgWydTcXJ0JywgW3VuYXJ5T3BzLnNxcnRdXSxcbiAgWydTb2Z0bWF4JywgW3NvZnRtYXgsIHBhcnNlU29mdG1heEF0dHJpYnV0ZXNdXSxcbiAgWydTdWInLCBbYmluYXJ5T3BzLnN1Yl1dLFxuICBbJ1RhbicsIFt1bmFyeU9wcy50YW5dXSxcbiAgWydUYW5oJywgW3VuYXJ5T3BzLnRhbmhdXSxcbiAgWydUaHJlc2hvbGRlZFJlbHUnLCBbdW5hcnlPcHMudGhyZXNob2xkZWRSZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ1RpbGUnLCBbdGlsZV1dLFxuICBbJ1RyYW5zcG9zZScsIFt0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc11dLFxuICBbJ1doZXJlJywgW3doZXJlXV0sXG5dKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vbG9nJztcblxuaW1wb3J0IHsgY3JlYXRlU2hhZGVySGVscGVyIH0gZnJvbSAnLi9vcHMvY29tbW9uJztcbmltcG9ydCB7IEFydGlmYWN0LCBHcHVEYXRhLCBQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47IC8vIHRoaXMgc2hvdWxkIGJlIHBlci1zZXNzaW9uIG9iamVjdFxuICBhdHRyaWJ1dGVzQm91bmQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kKSB7XG4gICAgdGhpcy5yZXBvID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gZmFsc2U7XG4gIH1cbiAgZ2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duKTogQXJ0aWZhY3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihcbiAgICBidWlsZEFydGlmYWN0OiBBcnRpZmFjdCxcbiAgICBpbnB1dHM6IEdwdURhdGFbXSxcbiAgICBvdXRwdXRzOiBHcHVEYXRhW10sXG4gICAgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIHVuaWZvcm1CdWZmZXJCaW5kaW5nOiBHUFVCaW5kaW5nUmVzb3VyY2UgfCB1bmRlZmluZWQsXG4gICk6IHZvaWQge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xuICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7IGJ1ZmZlcjogaW5wdXQuYnVmZmVyIH0gfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZTogeyBidWZmZXI6IG91dHB1dC5idWZmZXIgfSB9KTtcbiAgICB9XG4gICAgaWYgKHVuaWZvcm1CdWZmZXJCaW5kaW5nKSB7XG4gICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBlbnRyaWVzLmxlbmd0aCwgcmVzb3VyY2U6IHVuaWZvcm1CdWZmZXJCaW5kaW5nIH0pO1xuICAgIH1cbiAgICBjb25zdCBiaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgIGxheW91dDogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLFxuICAgICAgZW50cmllcyxcbiAgICAgIGxhYmVsOiBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XG4gICAgICBjb25zdCBjb21tYW5kSW5mbyA9IHtcbiAgICAgICAga2VybmVsSWQ6IHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQhLFxuICAgICAgICBjb21wdXRlUGlwZWxpbmU6IGJ1aWxkQXJ0aWZhY3QuY29tcHV0ZVBpcGVsaW5lLFxuICAgICAgICBiaW5kR3JvdXAsXG4gICAgICAgIGRpc3BhdGNoR3JvdXAsXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2Vzc2lvbkNvbW1hbmRMaXN0ID0gdGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgICBzZXNzaW9uQ29tbWFuZExpc3QhLnB1c2goY29tbWFuZEluZm8pO1xuICAgIH1cblxuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZSk7XG4gICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uZGlzcGF0Y2hHcm91cCk7XG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XG4gICAgdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXIgfHxcbiAgICAgIHRoaXMuYmFja2VuZC5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnXG4gICAgKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuZmx1c2goKTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIC8vIHRoaXMucmVwby5mb3JFYWNoKGEgPT4gdGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShhLnByb2dyYW0pKTtcbiAgfVxuICBidWlsZChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogQXJ0aWZhY3Qge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4ocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5iYWNrZW5kLmRldmljZTtcbiAgICBjb25zdCBlbmFibGVEaXJlY3RpdmVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gRW5hYmxlIFdHU0wgZXh0ZW5zaW9ucyBiYXNlZCBvbiBhdmFpbGFibGUgV2ViR1BVIGZlYXR1cmVzXG4gICAgY29uc3QgZXh0ZW5zaW9uc0luZm86IEFycmF5PHsgZmVhdHVyZTogR1BVRmVhdHVyZU5hbWU7IGV4dGVuc2lvbjogc3RyaW5nIH0+ID0gW1xuICAgICAgeyBmZWF0dXJlOiAnc2hhZGVyLWYxNicsIGV4dGVuc2lvbjogJ2YxNicgfSxcbiAgICAgIHsgZmVhdHVyZTogJ3N1Ymdyb3VwcycgYXMgR1BVRmVhdHVyZU5hbWUsIGV4dGVuc2lvbjogJ3N1Ymdyb3VwcycgfSxcbiAgICBdO1xuICAgIGV4dGVuc2lvbnNJbmZvLmZvckVhY2goKGluZm8pID0+IHtcbiAgICAgIGlmIChkZXZpY2UuZmVhdHVyZXMuaGFzKGluZm8uZmVhdHVyZSkpIHtcbiAgICAgICAgZW5hYmxlRGlyZWN0aXZlcy5wdXNoKGBlbmFibGUgJHtpbmZvLmV4dGVuc2lvbn07YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzaGFkZXJIZWxwZXIgPSBjcmVhdGVTaGFkZXJIZWxwZXIobm9ybWFsaXplZERpc3BhdGNoR3JvdXBTaXplLCB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cyk7XG4gICAgY29uc3QgdXNlckNvZGUgPSBwcm9ncmFtSW5mby5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVySGVscGVyKTtcbiAgICBjb25zdCBjb2RlID0gYCR7ZW5hYmxlRGlyZWN0aXZlcy5qb2luKCdcXG4nKX1cXG4ke3NoYWRlckhlbHBlci5hZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zfVxcbiR7dXNlckNvZGV9YDtcbiAgICBjb25zdCBzaGFkZXJNb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHsgY29kZSwgbGFiZWw6IHByb2dyYW1JbmZvLm5hbWUgfSk7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdICR7cHJvZ3JhbUluZm8ubmFtZX0gc2hhZGVyIGNvZGU6ICR7Y29kZX1gKTtcblxuICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe1xuICAgICAgY29tcHV0ZTogeyBtb2R1bGU6IHNoYWRlck1vZHVsZSwgZW50cnlQb2ludDogJ21haW4nIH0sXG4gICAgICBsYXlvdXQ6ICdhdXRvJyxcbiAgICAgIGxhYmVsOiBwcm9ncmFtSW5mby5uYW1lLFxuICAgIH0pO1xuXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgcmV0dXJuIHsgcHJvZ3JhbUluZm8sIGNvbXB1dGVQaXBlbGluZSwgdW5pZm9ybVZhcmlhYmxlc0luZm86IHNoYWRlckhlbHBlci52YXJpYWJsZXNJbmZvIH07XG4gIH1cblxuICBub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShcbiAgICBkaXNwYXRjaEdyb3VwOiBSZXR1cm5UeXBlPFByb2dyYW1JbmZvWydnZXRSdW5EYXRhJ10+WydkaXNwYXRjaEdyb3VwJ10sXG4gICk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgeCA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IGRpc3BhdGNoR3JvdXAgOiBkaXNwYXRjaEdyb3VwLng7XG4gICAgY29uc3QgeSA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IDEgOiBkaXNwYXRjaEdyb3VwLnkgfHwgMTtcbiAgICBjb25zdCB6ID0gdHlwZW9mIGRpc3BhdGNoR3JvdXAgPT09ICdudW1iZXInID8gMSA6IGRpc3BhdGNoR3JvdXAueiB8fCAxO1xuICAgIGNvbnN0IGxpbWl0UGVyRGltZW5zaW9uID0gdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247XG4gICAgaWYgKHggPD0gbGltaXRQZXJEaW1lbnNpb24gJiYgeSA8PSBsaW1pdFBlckRpbWVuc2lvbiAmJiB6IDw9IGxpbWl0UGVyRGltZW5zaW9uKSB7XG4gICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0geCAqIHkgKiB6O1xuICAgIGxldCBkaXNwYXRjaEF2ZXJhZ2UgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHNpemUpKTtcbiAgICBpZiAoZGlzcGF0Y2hBdmVyYWdlID4gbGltaXRQZXJEaW1lbnNpb24pIHtcbiAgICAgIGRpc3BhdGNoQXZlcmFnZSA9IE1hdGguY2VpbChNYXRoLmNicnQoc2l6ZSkpO1xuICAgICAgaWYgKGRpc3BhdGNoQXZlcmFnZSA+IGxpbWl0UGVyRGltZW5zaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVG90YWwgZGlzcGF0Y2ggc2l6ZSBleGNlZWRzIFdlYkdQVSBtYXhpbXVtLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZSwgMV07XG4gICAgfVxuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiwgVGVuc29yLCBUUkFDRSwgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSwgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmltcG9ydCB7IGNvbmZpZ3VyZUxvZ2dlciwgTE9HX0RFQlVHIH0gZnJvbSAnLi9sb2cnO1xuaW1wb3J0IHsgY3JlYXRlVmlldywgVGVuc29yVmlldyB9IGZyb20gJy4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgY3JlYXRlR3B1RGF0YU1hbmFnZXIsIGRvd25sb2FkR3B1RGF0YSwgR3B1RGF0YU1hbmFnZXIgfSBmcm9tICcuL3dlYmdwdS9ncHUtZGF0YS1tYW5hZ2VyJztcbmltcG9ydCB7IFJ1bkZ1bmN0aW9uLCBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUyB9IGZyb20gJy4vd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMnO1xuaW1wb3J0IHsgUHJvZ3JhbU1hbmFnZXIgfSBmcm9tICcuL3dlYmdwdS9wcm9ncmFtLW1hbmFnZXInO1xuaW1wb3J0IHtcbiAgQWRhcHRlckluZm8sXG4gIENvbXB1dGVDb250ZXh0LFxuICBHcHVBcmNoaXRlY3R1cmUsXG4gIEdwdURhdGEsXG4gIEdwdVZlbmRvcixcbiAgUHJvZ3JhbUluZm8sXG4gIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LFxuICBTZXNzaW9uU3RhdGUsXG4gIFRpbWVzdGFtcFF1ZXJ5LFxufSBmcm9tICcuL3dlYmdwdS90eXBlcyc7XG5cbmludGVyZmFjZSBDb21tYW5kSW5mbyB7XG4gIHJlYWRvbmx5IGtlcm5lbElkOiBudW1iZXI7XG4gIHJlYWRvbmx5IGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xuICByZWFkb25seSBiaW5kR3JvdXA6IEdQVUJpbmRHcm91cDtcbiAgcmVhZG9ubHkgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xufVxuXG5pbnRlcmZhY2UgS2VybmVsSW5mbyB7XG4gIHJlYWRvbmx5IGtlcm5lbFR5cGU6IHN0cmluZztcbiAgcmVhZG9ubHkga2VybmVsTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBrZXJuZWxFbnRyeTogUnVuRnVuY3Rpb247XG4gIHJlYWRvbmx5IGF0dHJpYnV0ZXM6IFsoKGF0dHJpYnV0ZTogdW5rbm93bikgPT4gdW5rbm93bikgfCB1bmRlZmluZWQsIHVua25vd25dO1xufVxuXG5pbnRlcmZhY2UgUGVuZGluZ0tlcm5lbEluZm8ge1xuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xuICByZWFkb25seSBwcm9ncmFtTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBpbnB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG4gIHJlYWRvbmx5IG91dHB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG59XG5cbmNvbnN0IGdldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5ID0gKFxuICBpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgaW5wdXREZXBlbmRlbmNpZXM6IHJlYWRvbmx5IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10sXG4pOiBzdHJpbmcgPT4ge1xuICBpZiAoaW5wdXREZXBlbmRlbmNpZXMubGVuZ3RoICE9PSBpbnB1dFRlbnNvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke2lucHV0RGVwZW5kZW5jaWVzLmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtcbiAgICAgICAgaW5wdXRUZW5zb3JzLmxlbmd0aFxuICAgICAgfS5gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBpbnB1dEluZm9zOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0VGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHR5cGUgPSBpbnB1dFRlbnNvcnNbaV0uZGF0YVR5cGU7XG4gICAgc3dpdGNoIChpbnB1dERlcGVuZGVuY2llc1tpXSkge1xuICAgICAgY2FzZSAnbm9uZSc6IHtcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKCcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICd0eXBlJzoge1xuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdyYW5rJzoge1xuICAgICAgICBjb25zdCByYW5rID0gaW5wdXRUZW5zb3JzW2ldLmRpbXMubGVuZ3RoO1xuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtyYW5rfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2RpbXMnOiB7XG4gICAgICAgIGNvbnN0IGRpbXMgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5qb2luKCcsJyk7XG4gICAgICAgIGlucHV0SW5mb3MucHVzaChgJHt0eXBlfTske2RpbXN9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke2lucHV0RGVwZW5kZW5jaWVzW2ldfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnB1dEluZm9zLmpvaW4oJ3wnKTtcbn07XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGtleSByZXByZXNlbnRpbmcgdGhlIHByb2dyYW0gZnJvbSB0aGUgcHJvZ3JhbSBpbmZvLCBpbnB1dCBzaGFwZXMgYW5kIHR5cGVzLlxuICpcbiAqIEByZXR1cm5zIGEgdW5pcXVlIGtleSBpcyBhIHNob3J0ZXIgc3RyaW5nIHRoYW4gdGhlIHNoYWRlciBzb3VyY2UsIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdG8gaWRlbnRpZnkgYVxuICogcHJvZ3JhbS4gaWYgdGhlIGtleSBpcyB0aGUgc2FtZSwgdGhlIHByb2dyYW0gc2hhZGVyIHNvdXJjZSBzaG91bGQgYmUgdGhlIHNhbWUsIHNvIHdlIGNhbiByZXVzZSB0aGUgcHJvZ3JhbS5cbiAqXG4gKi9cbmNvbnN0IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5ID0gKFxuICBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sXG4gIGlucHV0VGVuc29yczogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBpczFEaW1lbnNpb25EaXNwYXRjaDogYm9vbGVhbixcbik6IHN0cmluZyA9PiB7XG4gIC8vIGZpbmFsIGtleSBmb3JtYXQ6XG4gIC8vIDxQUk9HUkFNX05BTUU+WzxQUk9HUkFNX0NVU1RPTV9DQUNIRV9ISU5UPl06aXMxRGltZW5zaW9uRGlzcGF0Y2g6PElOUFVUU19JTkZPXzA+fDxJTlBVVFNfSU5GT18xPnwuLi5cbiAgbGV0IGtleSA9IHByb2dyYW1JbmZvLm5hbWU7XG4gIGlmIChwcm9ncmFtSW5mby5zaGFkZXJDYWNoZT8uaGludCkge1xuICAgIGtleSArPSAnWycgKyBwcm9ncmFtSW5mby5zaGFkZXJDYWNoZS5oaW50ICsgJ10nO1xuICB9XG4gIGtleSArPVxuICAgICc6JyArXG4gICAgaXMxRGltZW5zaW9uRGlzcGF0Y2ggK1xuICAgIGA6JHtnZXRQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeUtleShcbiAgICAgIGlucHV0VGVuc29ycyxcbiAgICAgIHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcyA/P1xuICAgICAgICBuZXcgQXJyYXk8UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3k+KGlucHV0VGVuc29ycy5sZW5ndGgpLmZpbGwoJ2RpbXMnKSxcbiAgICApfWA7XG4gIHJldHVybiBrZXk7XG59O1xuXG5jbGFzcyBBZGFwdGVySW5mb0ltcGwgaW1wbGVtZW50cyBBZGFwdGVySW5mbyB7XG4gIHJlYWRvbmx5IGFyY2hpdGVjdHVyZT86IHN0cmluZztcbiAgcmVhZG9ubHkgdmVuZG9yPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXJJbmZvOiBHUFVBZGFwdGVySW5mbykge1xuICAgIGlmIChhZGFwdGVySW5mbykge1xuICAgICAgdGhpcy5hcmNoaXRlY3R1cmUgPSBhZGFwdGVySW5mby5hcmNoaXRlY3R1cmU7XG4gICAgICB0aGlzLnZlbmRvciA9IGFkYXB0ZXJJbmZvLnZlbmRvcjtcbiAgICB9XG4gIH1cblxuICBpc0FyY2hpdGVjdHVyZShhcmNoaXRlY3R1cmU6IEdwdUFyY2hpdGVjdHVyZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFyY2hpdGVjdHVyZSA9PT0gYXJjaGl0ZWN0dXJlO1xuICB9XG5cbiAgaXNWZW5kb3IodmVuZG9yOiBHcHVWZW5kb3IpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52ZW5kb3IgPT09IHZlbmRvcjtcbiAgfVxufVxuXG4vKipcbiAqIHRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gc3RvcmUgc3RhdHVzIGFuZCBiZWluZyB1c2VkIGFzIGEgc2luZ2xldG9uIGZvciBKU0VQLiBJdCB3aWxsIGJlIHBhc3NlZCB0byBqc2VwSW5pdCgpIGFzXG4gKiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNvIHRoYXQgaXQgaXMgc3RvcmVkIGZvciBmdXR1cmUgdXNlLlxuICovXG5leHBvcnQgY2xhc3MgV2ViR3B1QmFja2VuZCB7XG4gIGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mb0ltcGw7XG4gIGRldmljZTogR1BVRGV2aWNlO1xuICAvKipcbiAgICogYW4gaW5zdGFuY2Ugb2YgR3B1RGF0YU1hbmFnZXIgdG8gbWFuYWdlIGEgR3B1RGF0YUlkIC0+IEdwdUJ1ZmZlciBtYXBwaW5nXG4gICAqL1xuICBncHVEYXRhTWFuYWdlcjogR3B1RGF0YU1hbmFnZXI7XG4gIC8qKlxuICAgKiBhbiBpbnN0YW5jZSBvZiBQcm9ncmFtTWFuYWdlciB0byBidWlsZCBhbmQgcnVuIFdlYkdQVSBjb21wdXRlIHNoYWRlciBwcm9ncmFtLCBhbmQgbWFuYWdlIGEgUHJvZ3JhbUtleSAtPiBQcm9ncmFtXG4gICAqIGFydGlmYWN0cyBtYXBwaW5nXG4gICAqL1xuICBwcm9ncmFtTWFuYWdlcjogUHJvZ3JhbU1hbmFnZXI7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudGluZyB0aGUgc2Vzc2lvbiBJRCBvZiB3aGljaCBpcyBjdXJyZW50bHkgYmVpbmcgcnVuLlxuICAgKiBgbnVsbGAgbWVhbnMgbm8gc2Vzc2lvbiBpcyBiZWluZyBydW4uXG4gICAqIG9ubHkgdmFsaWQgd2hlbiBzZXNzaW9uLnJ1biBpcyBleGVjdXRlZC5cbiAgICovXG4gIGN1cnJlbnRTZXNzaW9uSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnRpbmcgdGhlIGtlcm5lbCBJRCBvZiB3aGljaCBpcyBjdXJyZW50bHkgYmVpbmcgY29tcHV0ZWQgKENQVSBjb2RlIHBlcnNwZWN0aXZlKS5cbiAgICogYG51bGxgIG1lYW5zIG5vIGtlcm5lbCBpcyBiZWluZyBjb21wdXRlZC5cbiAgICogb25seSBvbmUga2VybmVsIGNhbiBiZSBjb21wdXRlZCBhdCBhIG1vbWVudC5cbiAgICovXG4gIGN1cnJlbnRLZXJuZWxJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgdGVtcG9yYXJ5IEdQVSBkYXRhIGZvciB0aGUgY3VycmVudCBrZXJuZWwuIHNob3VsZCByZWxlYXNlIHdoZW4gdGhlIGtlcm5lbCBkb25lIGNvbXB1dGF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSB0ZW1wb3JhcnlEYXRhOiBHcHVEYXRhW107XG4gIC8qKlxuICAgKiBhIEtlcm5lbElEIC0+IGEgR1BVIGRhdGEgbGlzdCwgd2hpY2ggc3RvcmVzIHBlcnNpc3RlbnQgR1BVIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cbiAgICovXG4gIHByaXZhdGUga2VybmVsUGVyc2lzdGVudERhdGE6IE1hcDxudW1iZXIsIEdwdURhdGFbXT47XG4gIC8qKlxuICAgKiBhIEtlcm5lbElEIC0+IGEgY3VzdG9tIGRhdGEsIHdoaWNoIHN0b3JlcyBjdXN0b20gZGF0YSBvd25lZCBieSB0aGUgc3BlY2lmaWMga2VybmVsLlxuICAgKi9cbiAgcHJpdmF0ZSBrZXJuZWxDdXN0b21EYXRhOiBNYXA8bnVtYmVyLCB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfT47XG4gIC8qKlxuICAgKiBnZXQgdGhlIGN1c3RvbSBkYXRhIG9mIHRoZSBjdXJyZW50IGtlcm5lbFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9IHtcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvLyBLZXJuZWxJRCAtPiBrZXJuZWxJbmZvIG1hcHBpbmdcbiAga2VybmVsczogTWFwPG51bWJlciwgS2VybmVsSW5mbz47XG4gIHByaXZhdGUgY29tbWFuZEVuY29kZXI6IEdQVUNvbW1hbmRFbmNvZGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY29tcHV0ZVBhc3NFbmNvZGVyOiBHUFVDb21wdXRlUGFzc0VuY29kZXIgfCBudWxsID0gbnVsbDtcbiAgbWF4RGlzcGF0Y2hOdW1iZXIgPSAxNjtcbiAgcGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcblxuICAvLyBpbmZvIG9mIGtlcm5lbHMgcGVuZGluZyBzdWJtaXNzaW9uIGZvciBhIHNpbmdsZSBiYXRjaFxuICBwcml2YXRlIHBlbmRpbmdLZXJuZWxzOiBQZW5kaW5nS2VybmVsSW5mb1tdID0gW107XG4gIC8vIHF1ZXJ5UmVhZEJ1ZmZlciAtPiBwZW5kaW5nS2VybmVscyBtYXBwaW5nIGZvciBhbGwgdGhlIGJhdGNoZXNcbiAgcHJpdmF0ZSBwZW5kaW5nUXVlcmllczogTWFwPEdQVUJ1ZmZlciwgUGVuZGluZ0tlcm5lbEluZm9bXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcXVlcnlSZXNvbHZlQnVmZmVyPzogR1BVQnVmZmVyO1xuICBwcml2YXRlIHF1ZXJ5U2V0PzogR1BVUXVlcnlTZXQ7XG4gIHByaXZhdGUgcXVlcnlUaW1lQmFzZT86IGJpZ2ludDtcbiAgcXVlcnlUeXBlOiBUaW1lc3RhbXBRdWVyeTtcblxuICBlbnY6IEVudjtcbiAgc2Vzc2lvblN0YXR1czogU2Vzc2lvblN0YXRlID0gJ2RlZmF1bHQnO1xuICAvKipcbiAgICogYSBTZXNzaW9uSUQgLT4gQ29tbWFuZEluZm9bXSBtYXBwaW5nLiBJdCdzIHVzZWQgdG8gcmVjb3JkIGFsbCBHUFUgY29tbWFuZHMgZm9yIGNvcnJlc3BvbmRpbmcgc2Vzc2lvbi5cbiAgICovXG4gIGNhcHR1cmVkQ29tbWFuZExpc3Q6IE1hcDxudW1iZXIsIENvbW1hbmRJbmZvW10+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBhIFNlc3Npb25JRCAtPiBQZW5kaW5nS2VybmVsSW5mb1tdIG1hcHBpbmcgZm9yIHByb2ZpbGluZy5cbiAgICovXG4gIHByaXZhdGUgY2FwdHVyZWRQZW5kaW5nS2VybmVsczogTWFwPG51bWJlciwgUGVuZGluZ0tlcm5lbEluZm9bXT4gPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIGEgU2Vzc2lvbklEIC0+IGEgTWFwIG9mIChJbnB1dE91dHB1dEluZGV4IC0+IFtJRCwgR1BVQnVmZmVyXSkgbWFwcGluZy5cbiAgICovXG4gIHNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nOiBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBbbnVtYmVyLCBHUFVCdWZmZXJdPj4gPSBuZXcgTWFwKCk7XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZShlbnY6IEVudiwgYWRhcHRlcjogR1BVQWRhcHRlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXM6IEdQVUZlYXR1cmVOYW1lW10gPSBbXTtcbiAgICBjb25zdCBkZXZpY2VEZXNjcmlwdG9yOiBHUFVEZXZpY2VEZXNjcmlwdG9yID0ge1xuICAgICAgcmVxdWlyZWRMaW1pdHM6IHtcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixcbiAgICAgICAgbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUsXG4gICAgICAgIG1heEJ1ZmZlclNpemU6IGFkYXB0ZXIubGltaXRzLm1heEJ1ZmZlclNpemUsXG4gICAgICAgIG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaLFxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMsXG4gICAgfTtcblxuICAgIC8vIFRyeSByZXF1aXJpbmcgV2ViR1BVIGZlYXR1cmVzXG4gICAgY29uc3QgcmVxdWlyZUZlYXR1cmVJZkF2YWlsYWJsZSA9IChmZWF0dXJlOiBHUFVGZWF0dXJlTmFtZSkgPT5cbiAgICAgIGFkYXB0ZXIuZmVhdHVyZXMuaGFzKGZlYXR1cmUpICYmIHJlcXVpcmVkRmVhdHVyZXMucHVzaChmZWF0dXJlKSAmJiB0cnVlO1xuICAgIC8vIFRyeSBjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMgYW5kIGZhbGxiYWNrIHRvIHRpbWVzdGFtcC1xdWVyeVxuICAgIGlmICghcmVxdWlyZUZlYXR1cmVJZkF2YWlsYWJsZSgnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJyBhcyBHUFVGZWF0dXJlTmFtZSkpIHtcbiAgICAgIHJlcXVpcmVGZWF0dXJlSWZBdmFpbGFibGUoJ3RpbWVzdGFtcC1xdWVyeScpO1xuICAgIH1cbiAgICByZXF1aXJlRmVhdHVyZUlmQXZhaWxhYmxlKCdzaGFkZXItZjE2Jyk7XG4gICAgLy8gVHJ5IHN1Ymdyb3Vwc1xuICAgIHJlcXVpcmVGZWF0dXJlSWZBdmFpbGFibGUoJ3N1Ymdyb3VwcycgYXMgR1BVRmVhdHVyZU5hbWUpO1xuXG4gICAgdGhpcy5kZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoZGV2aWNlRGVzY3JpcHRvcik7XG4gICAgdGhpcy5hZGFwdGVySW5mbyA9IG5ldyBBZGFwdGVySW5mb0ltcGwoYWRhcHRlci5pbmZvIHx8IChhd2FpdCBhZGFwdGVyLnJlcXVlc3RBZGFwdGVySW5mbygpKSk7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlciA9IGNyZWF0ZUdwdURhdGFNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5rZXJuZWxzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gc2V0IHVwIGZsYWdzIGZvciBsb2dnZXJcbiAgICBjb25maWd1cmVMb2dnZXIoZW52LmxvZ0xldmVsISwgISFlbnYuZGVidWcpO1xuXG4gICAgLy8gVE9ETzogc2V0IHVwIGZsYWdzXG5cbiAgICB0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvciA9IChldikgPT4ge1xuICAgICAgaWYgKGV2LmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7ZXYuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSwgJ2RldmljZScsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRldmljZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsICdhZGFwdGVyJywge1xuICAgICAgdmFsdWU6IGFkYXB0ZXIsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIGluaXQgcXVlcnlUeXBlLCB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIEluZmVyZW5jZVNlc3Npb24uY3JlYXRlXG4gICAgdGhpcy5zZXRRdWVyeVR5cGUoKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnF1ZXJ5U2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5xdWVyeVNldC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgZ2V0Q29tbWFuZEVuY29kZXIoKTogR1BVQ29tbWFuZEVuY29kZXIge1xuICAgIGlmICghdGhpcy5jb21tYW5kRW5jb2Rlcikge1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyO1xuICB9XG5cbiAgZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk6IEdQVUNvbXB1dGVQYXNzRW5jb2RlciB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcikge1xuICAgICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmdldENvbW1hbmRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBjb21wdXRlUGFzc0Rlc2NyaXB0b3I6IEdQVUNvbXB1dGVQYXNzRGVzY3JpcHRvciA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XG4gICAgICAgIGNvbXB1dGVQYXNzRGVzY3JpcHRvci50aW1lc3RhbXBXcml0ZXMgPSB7XG4gICAgICAgICAgcXVlcnlTZXQ6IHRoaXMucXVlcnlTZXQhLFxuICAgICAgICAgIGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcbiAgICAgICAgICBlbmRPZlBhc3NXcml0ZUluZGV4OiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luQ29tcHV0ZVBhc3MoY29tcHV0ZVBhc3NEZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyO1xuICB9XG5cbiAgZW5kQ29tcHV0ZVBhc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKSB7XG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmbHVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG5cbiAgICB0aGlzLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgbGV0IHF1ZXJ5UmVhZEJ1ZmZlcjogR1BVQnVmZmVyO1xuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldChcbiAgICAgICAgdGhpcy5xdWVyeVNldCEsXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIhLFxuICAgICAgICAwLFxuICAgICAgKTtcblxuICAgICAgcXVlcnlSZWFkQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB7IHNpemU6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiAqIDgsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIH0sXG4gICAgICApO1xuXG4gICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLnNldChxdWVyeVJlYWRCdWZmZXIsIHRoaXMucGVuZGluZ0tlcm5lbHMpO1xuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgIHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyISxcbiAgICAgICAgMCxcbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpO1xuICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB2b2lkIHF1ZXJ5UmVhZEJ1ZmZlciEubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGF0YSA9IG5ldyBCaWdVaW50NjRBcnJheShxdWVyeVJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxzID0gdGhpcy5wZW5kaW5nUXVlcmllcy5nZXQocXVlcnlSZWFkQnVmZmVyKSE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkRGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwZW5kaW5nS2VybmVsSW5mbyA9IHBlbmRpbmdLZXJuZWxzW2ldO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbElkID0gcGVuZGluZ0tlcm5lbEluZm8ua2VybmVsSWQ7XG4gICAgICAgICAgY29uc3Qga2VybmVsSW5mbyA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpITtcbiAgICAgICAgICBjb25zdCBrZXJuZWxUeXBlID0ga2VybmVsSW5mby5rZXJuZWxUeXBlO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWxJbmZvLmtlcm5lbE5hbWU7XG4gICAgICAgICAgY29uc3QgcHJvZ3JhbU5hbWUgPSBwZW5kaW5nS2VybmVsSW5mby5wcm9ncmFtTmFtZTtcbiAgICAgICAgICBjb25zdCBpbnB1dFRlbnNvclZpZXdzID0gcGVuZGluZ0tlcm5lbEluZm8uaW5wdXRUZW5zb3JWaWV3cztcbiAgICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLm91dHB1dFRlbnNvclZpZXdzO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZVU2NCA9IG1hcHBlZERhdGFbaSAqIDJdO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWVVNjQgPSBtYXBwZWREYXRhW2kgKiAyICsgMV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUaW1lQmFzZSA9IHN0YXJ0VGltZVU2NDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBOdW1iZXIoc3RhcnRUaW1lVTY0IC0gdGhpcy5xdWVyeVRpbWVCYXNlKTtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gTnVtYmVyKGVuZFRpbWVVNjQgLSB0aGlzLnF1ZXJ5VGltZUJhc2UpO1xuXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzdGFydFRpbWUpIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihlbmRUaW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7XG4gICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIGlucHV0c01ldGFkYXRhOiBpbnB1dFRlbnNvclZpZXdzLm1hcCgodmFsdWUpID0+ICh7XG4gICAgICAgICAgICAgICAgZGltczogdmFsdWUuZGltcyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpLFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIG91dHB1dHNNZXRhZGF0YTogb3V0cHV0VGVuc29yVmlld3MubWFwKCh2YWx1ZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBkaW1zOiB2YWx1ZS5kaW1zLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSksXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgICAgIGtlcm5lbFR5cGUsXG4gICAgICAgICAgICAgIGtlcm5lbE5hbWUsXG4gICAgICAgICAgICAgIHByb2dyYW1OYW1lLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHByaW50IHRoZSBwcm9maWxpbmcgbWVzc2FnZSB0byBjb25zb2xlXG4gICAgICAgICAgICBsZXQgaW5wdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIGlucHV0VGVuc29yVmlld3MuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZXMgKz0gYGlucHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIG91dHB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIG91dHB1dFNoYXBlcyArPSBgb3V0cHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7a2VybmVsSWR9fCR7a2VybmVsVHlwZX18JHtrZXJuZWxOYW1lfXwke3Byb2dyYW1OYW1lfVwiICR7aW5wdXRTaGFwZXN9JHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXNcbiAgICAgICAgICAgICAgfXN0YXJ0IHRpbWU6ICR7c3RhcnRUaW1lfSBucywgZXhlY3V0aW9uIHRpbWU6ICR7ZW5kVGltZSAtIHN0YXJ0VGltZX0gbnNgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVFJBQ0UoJ0dQVScsIGAke3Byb2dyYW1OYW1lfTo6JHtzdGFydFRpbWVVNjR9Ojoke2VuZFRpbWVVNjR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLnVubWFwKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMuZGVsZXRlKHF1ZXJ5UmVhZEJ1ZmZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBydW4gYSBXZWJHUFUgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHByb2dyYW0gYSBQcm9ncmFtSW5mbyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gaW5wdXRUZW5zb3JWaWV3cyBhIFRlbnNvclZpZXcgYXJyYXkuIGVhY2ggZWxlbWVudCByZXByZXNlbnRzIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMgaW4gR1BVLlxuICAgKiBAcGFyYW0gb3V0cHV0SW5kaWNlcyBhbiBpbmRpY2VzIGFycmF5LiBlYWNoIGVsZW1lbnQgY2FuIGJlIGVpdGhlciAtMSAodGVtcG9yYXJ5IGRhdGEpLCAtMiAocGVyc2lzdGVudCBkYXRhKSBvciBhblxuICAgKiBpbmRleCB0byB0aGUga2VybmVsJ3Mgb3V0cHV0LlxuICAgKiBAcGFyYW0gY3JlYXRlS2VybmVsT3V0cHV0IGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjcmVhdGUgYSB2YWx1ZSB0byBrZXJuZWwncyBvdXRwdXQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgdmFsdWUgYXMgYSBpbnRlcm1lZGlhdGUgdmFsdWUsIGVpdGhlciB0ZW1wb3JhcnlcbiAgICogb3IgcGVyc2lzdGVudCAob3duZWQgYnkgdGhlIGN1cnJlbnQga2VybmVsKVxuICAgKiBAcmV0dXJucyBhIFRlbnNvclZpZXcgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAqL1xuICBydW4oXG4gICAgcHJvZ3JhbTogUHJvZ3JhbUluZm8sXG4gICAgaW5wdXRUZW5zb3JWaWV3czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICAgIG91dHB1dEluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGNyZWF0ZUtlcm5lbE91dHB1dDogKGluZGV4OiBudW1iZXIsIGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBUZW5zb3JWaWV3LFxuICAgIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dDogKGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBUZW5zb3JWaWV3LFxuICAgIG91dHB1dENvdW50OiBudW1iZXIsXG4gICk6IFRlbnNvclZpZXdbXSB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTihwcm9ncmFtLm5hbWUpO1xuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBpbnB1dHNcbiAgICBjb25zdCBpbnB1dERhdGFzOiBHcHVEYXRhW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0VGVuc29yVmlld3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnB1dFRlbnNvclZpZXdzW2ldLmRhdGE7XG4gICAgICAvLyBpZiB0ZW5zb3IgdmlldyBkYXRhIGlzIDAsIGl0IG1lYW5zIHRoZSBvdXRwdXQgaXMgemVyby1zaXplZCB0ZW5zb3IsIGFuZCB0aGVyZSBpcyBubyBHUFUgZGF0YSBmb3IgaXQuXG4gICAgICBpZiAoZGF0YSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldChkYXRhKTtcbiAgICAgIGlmICghZ3B1RGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHtkYXRhfWApO1xuICAgICAgfVxuICAgICAgaW5wdXREYXRhcy5wdXNoKGdwdURhdGEpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cCwgcHJvZ3JhbVVuaWZvcm1zIH0gPSBwcm9ncmFtLmdldFJ1bkRhdGEoaW5wdXRUZW5zb3JWaWV3cyk7XG5cbiAgICAvLyBjaGVjayBvdXRwdXQgaW5kaWNlc1xuICAgIGNvbnN0IHZhbGlkYXRlZE91dHB1dEluZGljZXMgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aCA9PT0gMCA/IG91dHB1dHMubWFwKChfLCBpKSA9PiBpKSA6IG91dHB1dEluZGljZXM7XG4gICAgaWYgKHZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RoICE9PSBvdXRwdXRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke3ZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7b3V0cHV0cy5sZW5ndGh9LmApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBvdXRwdXRzXG4gICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3M6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dERhdGFzOiBHcHVEYXRhW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIHZhbHVlIC0xIGFuZCAtMiBhcmUgdXNlZCBmb3IgY3JlYXRpbmcgdGVtcG9yYXJ5IGFuZCBwZXJzaXN0ZW50IG91dHB1dHMuXG4gICAgICAvLyB2YWx1ZSAtMyBpcyB1c2VkIGZvciBwbGFjZWhvbGRlciBvdXRwdXQuIFNvIC0zLCAtMiwgLTEgYW5kIDAsIDEsIDIsIC4uLiBhcmUgdmFsaWRcbiAgICAgIC8vIG91dHB1dCBpbmRpY2VzLiBzZWUgdHlwZSBkZWZpbml0aW9uIG9mIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmIChcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIodmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSkgfHxcbiAgICAgICAgdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA8IC0zIHx8XG4gICAgICAgIHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPj0gb3V0cHV0Q291bnRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke3ZhbGlkYXRlZE91dHB1dEluZGljZXNbaV19YCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1RlbXBvcmFyeSA9IHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0xO1xuICAgICAgY29uc3QgaXNQZXJzaXN0ZW50ID0gdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTI7XG4gICAgICBjb25zdCB0ZW5zb3JWaWV3ID1cbiAgICAgICAgaXNUZW1wb3JhcnkgfHwgaXNQZXJzaXN0ZW50XG4gICAgICAgICAgPyBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQob3V0cHV0c1tpXS5kYXRhVHlwZSwgb3V0cHV0c1tpXS5kaW1zKVxuICAgICAgICAgIDogY3JlYXRlS2VybmVsT3V0cHV0KHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0sIG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcyk7XG4gICAgICBvdXRwdXRUZW5zb3JWaWV3cy5wdXNoKHRlbnNvclZpZXcpO1xuICAgICAgLy8gaWYgdGVuc29yIHZpZXcgZGF0YSBpcyAwLCBpdCBtZWFucyB0aGUgb3V0cHV0IGlzIHplcm8tc2l6ZWQgdGVuc29yLCBhbmQgdGhlcmUgaXMgbm8gR1BVIGRhdGEgZm9yIGl0LlxuICAgICAgaWYgKHRlbnNvclZpZXcuZGF0YSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0ZW5zb3JWaWV3LmRhdGEpO1xuICAgICAgaWYgKCFncHVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHt0ZW5zb3JWaWV3LmRhdGF9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goZ3B1RGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQZXJzaXN0ZW50KSB7XG4gICAgICAgIGxldCBwZXJzaXN0ZW50RGF0YSA9IHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkISk7XG4gICAgICAgIGlmICghcGVyc2lzdGVudERhdGEpIHtcbiAgICAgICAgICBwZXJzaXN0ZW50RGF0YSA9IFtdO1xuICAgICAgICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkISwgcGVyc2lzdGVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHBlcnNpc3RlbnREYXRhLnB1c2goZ3B1RGF0YSk7XG4gICAgICB9XG4gICAgICBvdXRwdXREYXRhcy5wdXNoKGdwdURhdGEpO1xuICAgIH1cblxuICAgIC8vIHdoZW4gdGhlcmUgYXJlIGFueSB6ZXJvLXNpemVkIHRlbnNvciBpbiB0aGUgaW5wdXRzIG9yIG91dHB1dHMsIHdlIHNob3VsZCByZXBvcnQgZXJyb3IgdW5sZXNzIGFsbCBvdXRwdXRzIGFyZVxuICAgIC8vIHplcm8tc2l6ZWQgdGVuc29ycy5cbiAgICBpZiAoaW5wdXREYXRhcy5sZW5ndGggIT09IGlucHV0VGVuc29yVmlld3MubGVuZ3RoIHx8IG91dHB1dERhdGFzLmxlbmd0aCAhPT0gb3V0cHV0VGVuc29yVmlld3MubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBhbGwgb3V0cHV0cyBhcmUgemVyby1zaXplZCB0ZW5zb3JzLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cbiAgICAgIGlmIChvdXRwdXREYXRhcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dFRlbnNvclZpZXdzO1xuICAgICAgfVxuICAgICAgLy8gaWYgc29tZSBvdXRwdXRzIGFyZSB6ZXJvLXNpemVkIHRlbnNvcnMsIHJlcG9ydCBhbiBlcnJvci5cbiAgICAgIC8vXG4gICAgICAvLyBUT0RPOiBzbyBmYXIgd2UgZG9uJ3Qgc2VlIGFueSB1c2UgY2FzZSB0aGF0IG91dHB1dHMgaW5jbHVkZSBib3RoIHplcm8tc2l6ZWQgdGVuc29ycyBhbmQgbm9uLXplcm8tc2l6ZWQgdGVuc29ycy5cbiAgICAgIC8vIElmIHdlIHNlZSBzdWNoIHVzZSBjYXNlLCB3ZSBuZWVkIHRvIG1ha2UgYSBjaGFuZ2UgaGVyZSB0byBzdXBwb3J0IGl0LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUHJvZ3JhbSAke3Byb2dyYW0ubmFtZX0gaGFzIHplcm8tc2l6ZWQgdGVuc29yKHMpIGluIGlucHV0cyBvciBvdXRwdXRzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgbm93LmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGxvYWQgdW5pZm9ybXNcbiAgICAvLyBUT0RPOiBhZGQgY2FjaGUgZm9yIHVuaWZvcm0gKGlzIGl0IG5lY2Vzc2FyeT8pXG4gICAgLy9cbiAgICBsZXQgdW5pZm9ybUJ1ZmZlckJpbmRpbmc6IEdQVUJpbmRpbmdSZXNvdXJjZSB8IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvZ3JhbVVuaWZvcm1zKSB7XG4gICAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG4gICAgICBjb25zdCBvZmZzZXRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBwcm9ncmFtVW5pZm9ybXMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIHYuZGF0YSA9PT0gJ251bWJlcicgPyBbdi5kYXRhXSA6IHYuZGF0YTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XR1NMLyNhbGlnbm9mXG4gICAgICAgIGNvbnN0IHNpemVPZkVsZW1lbnQgPSB2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYgPyAyIDogNDtcbiAgICAgICAgbGV0IHNpemVPZlZlY09yTWF0O1xuICAgICAgICBsZXQgYmFzZUFsaWdubWVudDtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNikge1xuICAgICAgICAgIGJhc2VBbGlnbm1lbnQgPSBkYXRhLmxlbmd0aCA+IDQgPyAxNiA6IGRhdGEubGVuZ3RoID4gMiA/IDggOiBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQ7XG4gICAgICAgICAgc2l6ZU9mVmVjT3JNYXQgPSBkYXRhLmxlbmd0aCA+IDQgPyAxNiA6IHNpemVPZkVsZW1lbnQgKiBkYXRhLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPD0gMiA/IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudCA6IDE2O1xuICAgICAgICAgIHNpemVPZlZlY09yTWF0ID0gMTY7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gYmFzZUFsaWdubWVudCkgKiBiYXNlQWxpZ25tZW50O1xuICAgICAgICBvZmZzZXRzLnB1c2goY3VycmVudE9mZnNldCk7XG4gICAgICAgIC8vIEZvciBub24tZmxvYXQxNiB0eXBlLCB3aGVuIGRhdGEubGVuZ3RoID4gNCwgdGhlIHVuaWZvcm0gdmFyaWFibGUgaXMgb2YgdHlwZSBhcnJheTx2ZWM0PGkzMnx1MzJ8ZjMyPixOPiwgd2hlcmVcbiAgICAgICAgLy8gTiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQpIGFuZCBTaXplT2YodmVjNDxpMzJ8dTMyfGYzMj4pID0gMTYuIFRoZSB0b3RhbCBieXRlIGxlbmd0aCBpcyBOICpcbiAgICAgICAgLy8gU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KS4gRm9yIGZsb2F0MTYgdHlwZSwgd2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYXJyYXk8bWF0Mng0PGYxNj4sTj4sIHdoZXJlIE4gPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA4KSBhbmQgU2l6ZU9mKG1hdDJ4NDxmMTY+KSA9IDE2LiBUaGUgdG90YWwgYnl0ZVxuICAgICAgICAvLyBsZW5ndGggaXMgTiAqIFNpemVPZihtYXQyeDQ8ZjE2PikuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRQZXJWZWNPck1hdCA9IHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IDggOiA0O1xuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9XG4gICAgICAgICAgZGF0YS5sZW5ndGggPiA0ID8gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gZWxlbWVudFBlclZlY09yTWF0KSAqIHNpemVPZlZlY09yTWF0IDogZGF0YS5sZW5ndGggKiBzaXplT2ZFbGVtZW50O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1lZXQgYWxpZ25tZW50IG9mIHN0cnVjdCBoZXJlOiBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jYWxpZ25tZW50LWFuZC1zaXplLiBGb3Igc2ltcGxpY2l0eSwgc2V0XG4gICAgICAvLyBtYXhBbGlnbm1lbnRPZkZpZWxkIHRvIDE2IHNpbmNlIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBoYXMgYmVlbiByb3VuZGVkIHVwIHRvIDE2LlxuICAgICAgY29uc3QgbWF4QWxpZ25tZW50T2ZGaWVsZCA9IDE2O1xuICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gbWF4QWxpZ25tZW50T2ZGaWVsZCkgKiBtYXhBbGlnbm1lbnRPZkZpZWxkO1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3VycmVudE9mZnNldCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2ldO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIHYuZGF0YSA9PT0gJ251bWJlcicgPyBbdi5kYXRhXSA6IHYuZGF0YTtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgICAgICBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUudWludDMyKSB7XG4gICAgICAgICAgbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2KSB7XG4gICAgICAgICAgbmV3IFVpbnQxNkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZTogJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2LnR5cGUpfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5pZm9ybUJ1ZmZlckRhdGEgPVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShjdXJyZW50T2Zmc2V0LCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO1xuICAgICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodW5pZm9ybUJ1ZmZlckRhdGEuYnVmZmVyLCAwLCBhcnJheUJ1ZmZlciwgMCwgY3VycmVudE9mZnNldCk7XG4gICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodW5pZm9ybUJ1ZmZlckRhdGEuaWQpO1xuICAgICAgdW5pZm9ybUJ1ZmZlckJpbmRpbmcgPSB7IG9mZnNldDogMCwgc2l6ZTogY3VycmVudE9mZnNldCwgYnVmZmVyOiB1bmlmb3JtQnVmZmVyRGF0YS5idWZmZXIgfTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCA9IHRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoZGlzcGF0Y2hHcm91cCk7XG4gICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXSA9PT0gMSAmJiBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXSA9PT0gMTtcbiAgICAvLyBnZXQgcHJvZ3JhbSBpbmZvXG4gICAgY29uc3Qga2V5ID0gZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkocHJvZ3JhbSwgaW5wdXRUZW5zb3JWaWV3cywgaXMxRGltZW5zaW9uRGlzcGF0Y2gpO1xuICAgIGxldCBhcnRpZmFjdCA9IHRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qoa2V5KTtcbiAgICBpZiAoIWFydGlmYWN0KSB7XG4gICAgICBhcnRpZmFjdCA9IHRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbSwgbm9ybWFsaXplZERpc3BhdGNoR3JvdXApO1xuICAgICAgdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChrZXksIGFydGlmYWN0KTtcbiAgICAgIExPR19ERUJVRygnaW5mbycsICgpID0+IGBbYXJ0aWZhY3RdIGtleTogJHtrZXl9LCBwcm9ncmFtTmFtZTogJHtwcm9ncmFtLm5hbWV9YCk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgdW5pZm9ybSB2YXJpYWJsZXNcbiAgICBpZiAocHJvZ3JhbVVuaWZvcm1zICYmIGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvKSB7XG4gICAgICBpZiAocHJvZ3JhbVVuaWZvcm1zLmxlbmd0aCAhPT0gYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke2FydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aH0sIGdvdCAke1xuICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLmxlbmd0aFxuICAgICAgICAgIH0gaW4gcHJvZ3JhbSBcIiR7YXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZX1cIi5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtVW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdW5pZm9ybSA9IHByb2dyYW1Vbmlmb3Jtc1tpXTtcbiAgICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IHVuaWZvcm0udHlwZTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gdHlwZW9mIHVuaWZvcm0uZGF0YSA9PT0gJ251bWJlcicgPyAxIDogdW5pZm9ybS5kYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgW3R5cGUsIGxlbmd0aF0gPSBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mb1tpXTtcbiAgICAgICAgaWYgKGFjdHVhbFR5cGUgIT09IHR5cGUgfHwgYWN0dWFsTGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5pZm9ybSB2YXJpYWJsZSAke2l9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke3R5cGV9IHdpdGggc2l6ZSAke2xlbmd0aH0sIGdvdCB0eXBlICR7XG4gICAgICAgICAgICAgIGFjdHVhbFR5cGVcbiAgICAgICAgICAgIH0gd2l0aCBzaXplICR7YWN0dWFsTGVuZ3RofSBpbiBwcm9ncmFtIFwiJHthcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lfVwiLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIExPR19ERUJVRyhcbiAgICAgICdpbmZvJyxcbiAgICAgICgpID0+XG4gICAgICAgIGBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7cHJvZ3JhbS5uYW1lfVwiIChrZXk9JHtrZXl9KSB3aXRoICR7bm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF19eCR7XG4gICAgICAgICAgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV1cbiAgICAgICAgfXgke25vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdfWAsXG4gICAgKTtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnIHx8IHRoaXMuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxJbmZvOiBQZW5kaW5nS2VybmVsSW5mbyA9IHtcbiAgICAgICAga2VybmVsSWQ6IHRoaXMuY3VycmVudEtlcm5lbElkISxcbiAgICAgICAgcHJvZ3JhbU5hbWU6IGFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUsXG4gICAgICAgIGlucHV0VGVuc29yVmlld3MsXG4gICAgICAgIG91dHB1dFRlbnNvclZpZXdzLFxuICAgICAgfTtcbiAgICAgIHRoaXMucGVuZGluZ0tlcm5lbHMucHVzaChwZW5kaW5nS2VybmVsSW5mbyk7XG5cbiAgICAgIGlmICh0aGlzLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgICAgIHNlc3Npb25QZW5kaW5nS2VybmVscyEucHVzaChwZW5kaW5nS2VybmVsSW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4oYXJ0aWZhY3QsIGlucHV0RGF0YXMsIG91dHB1dERhdGFzLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCwgdW5pZm9ybUJ1ZmZlckJpbmRpbmcpO1xuXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbS5uYW1lKTtcbiAgICByZXR1cm4gb3V0cHV0VGVuc29yVmlld3M7XG4gIH1cblxuICB1cGxvYWQoZ3B1RGF0YUlkOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZChncHVEYXRhSWQsIGRhdGEpO1xuICB9XG5cbiAgbWVtY3B5KHNyYzogbnVtYmVyLCBkc3Q6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHNyYywgZHN0KTtcbiAgfVxuXG4gIGFzeW5jIGRvd25sb2FkKGdwdURhdGFJZDogbnVtYmVyLCBnZXRUYXJnZXRCdWZmZXI6ICgpID0+IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyB0aGUgdW5kZXJseWluZyBidWZmZXIgbWF5IGJlIGNoYW5nZWQgYWZ0ZXIgdGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGNhbGxlZC4gc28gd2UgdXNlIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZSBidWZmZXIgaXMgdXAtdG8tZGF0ZS5cbiAgICBhd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKGdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyKTtcbiAgfVxuXG4gIGFsbG9jKHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemUpLmlkO1xuICB9XG5cbiAgZnJlZShwdHI6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShwdHIpO1xuICB9XG5cbiAgY3JlYXRlS2VybmVsKGtlcm5lbFR5cGU6IHN0cmluZywga2VybmVsSWQ6IG51bWJlciwgYXR0cmlidXRlOiB1bmtub3duLCBrZXJuZWxOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBvcCA9IFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTLmdldChrZXJuZWxUeXBlKTtcbiAgICBpZiAoIW9wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7a2VybmVsVHlwZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXJuZWxJbmZvOiBLZXJuZWxJbmZvID0ge1xuICAgICAga2VybmVsVHlwZSxcbiAgICAgIGtlcm5lbE5hbWUsXG4gICAgICBrZXJuZWxFbnRyeTogb3BbMF0sXG4gICAgICBhdHRyaWJ1dGVzOiBbb3BbMV0sIGF0dHJpYnV0ZV0sXG4gICAgfTtcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGtlcm5lbElkLCBrZXJuZWxJbmZvKTtcbiAgfVxuXG4gIHJlbGVhc2VLZXJuZWwoa2VybmVsSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHBlcnNpc3RlbnREYXRhID0gdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQoa2VybmVsSWQpO1xuICAgIGlmIChwZXJzaXN0ZW50RGF0YSkge1xuICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHBlcnNpc3RlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShkYXRhLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKGtlcm5lbElkKTtcbiAgICB9XG5cbiAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKGtlcm5lbElkKTtcbiAgICB0aGlzLmtlcm5lbHMuZGVsZXRlKGtlcm5lbElkKTtcbiAgfVxuXG4gIGNvbXB1dGVLZXJuZWwoa2VybmVsSWQ6IG51bWJlciwgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGVycm9yczogQXJyYXk8UHJvbWlzZTxzdHJpbmcgfCBudWxsPj4pOiBudW1iZXIge1xuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHtrZXJuZWxJZH1gKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbC5rZXJuZWxUeXBlO1xuICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWwua2VybmVsTmFtZTtcbiAgICBjb25zdCBrZXJuZWxFbnRyeSA9IGtlcm5lbC5rZXJuZWxFbnRyeTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ga2VybmVsLmF0dHJpYnV0ZXM7XG4gICAgaWYgKHRoaXMuY3VycmVudEtlcm5lbElkICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEtlcm5lbElkID0ga2VybmVsSWQ7XG5cbiAgICAvLyBwYXJzZSBhdHRyaWJ1dGVzIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChhdHRyaWJ1dGVzWzBdKSB7XG4gICAgICBhdHRyaWJ1dGVzWzFdID0gYXR0cmlidXRlc1swXShhdHRyaWJ1dGVzWzFdKTtcbiAgICAgIGF0dHJpYnV0ZXNbMF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiLi4uYCk7XG5cbiAgICBjb25zdCB1c2VFcnJvclNjb3BlID0gdGhpcy5lbnYuZGVidWc7XG5cbiAgICB0aGlzLnRlbXBvcmFyeURhdGEgPSBbXTtcbiAgICB0cnkge1xuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoJ3ZhbGlkYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAga2VybmVsRW50cnkoY29udGV4dCwgYXR0cmlidXRlc1sxXSk7XG4gICAgICByZXR1cm4gMDsgLy8gT1JUX09LXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JzLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiIGZhaWxlZC4gJHtlfWApKTtcbiAgICAgIHJldHVybiAxOyAvLyBPUlRfRkFJTFxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodXNlRXJyb3JTY29wZSkge1xuICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICB0aGlzLmRldmljZVxuICAgICAgICAgICAgLnBvcEVycm9yU2NvcGUoKVxuICAgICAgICAgICAgLnRoZW4oKGVycikgPT5cbiAgICAgICAgICAgICAgZXJyID8gYEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiOiAke2Vyci5tZXNzYWdlfWAgOiBudWxsLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSkge1xuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZGF0YS5pZCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRlbXBvcmFyeURhdGEgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudEtlcm5lbElkID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyAjcmVnaW9uIGV4dGVybmFsIGJ1ZmZlclxuICByZWdpc3RlckJ1ZmZlcihzZXNzaW9uSWQ6IG51bWJlciwgaW5kZXg6IG51bWJlciwgYnVmZmVyOiBHUFVCdWZmZXIsIHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldChzZXNzaW9uSWQpO1xuICAgIGlmICghc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZykge1xuICAgICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHNlc3Npb25JZCwgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGJ1ZmZlciBtYXkgYmUgdXNlciBjcmVhdGVkLCBvciBtYW5hZ2VkIGJ5IEdQVSBkYXRhIG1hbmFnZXIuXG4gICAgLy8gVGhlIEdQVSBkYXRhIG1hbmFnZXIgd2lsbCBub3QgbWFuYWdlIHRoZXNlIGJ1ZmZlcnMuIHdlIHJlZ2lzdGVyIHRoZW0gYXMgZXh0ZXJuYWwgYnVmZmVycy5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXAgYHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmdgIGlzIHVzZWQgdG8gc3RvcmUgdGhlIGRhdGEgSUQgYW5kIGJ1ZmZlciBmb3IgZWFjaCBpbnB1dC9vdXRwdXQuIE9uY2UgYVxuICAgIC8vIHNwZWNpZmljIGlucHV0L291dHB1dCBpcyByZWdpc3RlcmVkLCB0aGUgZGF0YSBJRCB3aWxsIG5vdCBjaGFuZ2UuXG4gICAgY29uc3QgcHJldmlvdXNCdWZmZXIgPSBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLmdldChpbmRleCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVyLCBzaXplLCBwcmV2aW91c0J1ZmZlcik7XG4gICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5zZXQoaW5kZXgsIFtpZCwgYnVmZmVyXSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcbiAgICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuZm9yRWFjaCgoYnVmZmVySW5mbykgPT4gdGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVySW5mb1swXSkpO1xuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gIH1cbiAgZ2V0QnVmZmVyKGdwdURhdGFJZDogbnVtYmVyKTogR1BVQnVmZmVyIHtcbiAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoZ3B1RGF0YUlkKTtcbiAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHtncHVEYXRhSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBncHVEYXRhLmJ1ZmZlcjtcbiAgfVxuICBjcmVhdGVEb3dubG9hZGVyKFxuICAgIGdwdUJ1ZmZlcjogR1BVQnVmZmVyLFxuICAgIHNpemU6IG51bWJlcixcbiAgICB0eXBlOiBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzLFxuICApOiAoKSA9PiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZT4ge1xuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMsIGdwdUJ1ZmZlciwgc2l6ZSk7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhkYXRhLmJ1ZmZlciwgdHlwZSk7XG4gICAgfTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG4gIHdyaXRlVGltZXN0YW1wKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdpbnNpZGUtcGFzc2VzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyIGFzIGFueSkud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCwgaW5kZXgpO1xuICB9XG4gIHNldFF1ZXJ5VHlwZSgpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdub25lJztcbiAgICBpZiAoXG4gICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlID09PSAnZGVmYXVsdCcgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5lbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gdGhpcy5lbnYud2FzbS50cmFjZSA6IHRoaXMuZW52LnRyYWNlKVxuICAgICkge1xuICAgICAgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnaW5zaWRlLXBhc3Nlcyc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnYXQtcGFzc2VzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScgJiYgdHlwZW9mIHRoaXMucXVlcnlTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXQgPSB0aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7XG4gICAgICAgICAgdHlwZTogJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgY291bnQ6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICB7IHNpemU6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmVCZWdpbigpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ2luZm8nLCAnY2FwdHVyZUJlZ2luJyk7XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Quc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnY2FwdHVyaW5nJztcbiAgfVxuICBjYXB0dXJlRW5kKCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlRW5kJyk7XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cbiAgcmVwbGF5KCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdyZXBsYXknKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAncmVwbGF5aW5nJztcbiAgICBjb25zdCBzZXNzaW9uQ29tbWFuZExpc3QgPSB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpO1xuICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2Vzc2lvbkNvbW1hbmRMaXN0IS5sZW5ndGg7XG4gICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XG4gICAgICBjb25zdCBjb21tYW5kID0gc2Vzc2lvbkNvbW1hbmRMaXN0IVtpXTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShjb21tYW5kLmNvbXB1dGVQaXBlbGluZSk7XG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbW1hbmQuYmluZEdyb3VwKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uY29tbWFuZC5kaXNwYXRjaEdyb3VwKTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XG4gICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHNlc3Npb25QZW5kaW5nS2VybmVscyFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgfHwgdGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XG4gICAgICAgIHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLm1heERpc3BhdGNoTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cblxuICBvbkNyZWF0ZVNlc3Npb24oKTogdm9pZCB7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5vbkNyZWF0ZVNlc3Npb24oKTtcbiAgfVxuXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZCk7XG4gICAgaWYgKHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXMoc2Vzc2lvbklkKSkge1xuICAgICAgdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmhhcyhzZXNzaW9uSWQpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIub25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG5cbiAgb25SdW5TdGFydChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB0aGlzLnNldFF1ZXJ5VHlwZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMsIERhdGFUeXBlIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21Nb2R1bGUgfSBmcm9tICcuLi93YXNtLXR5cGVzJztcblxuaW1wb3J0IHR5cGUgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLXdlYmdwdSc7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgdHlwZSB7IFRlbnNvclZpZXcgfSBmcm9tICcuL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IEFkYXB0ZXJJbmZvLCBDb21wdXRlQ29udGV4dCwgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZywgUHJvZ3JhbUluZm8gfSBmcm9tICcuL3dlYmdwdS90eXBlcyc7XG5pbXBvcnQgeyBXZWJOTkJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQtd2Vibm4nO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbmNsYXNzIFRlbnNvclZpZXdJbXBsIGltcGxlbWVudHMgVGVuc29yVmlldyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLFxuICAgIHB1YmxpYyByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyLFxuICAgIHB1YmxpYyByZWFkb25seSBkYXRhOiBudW1iZXIsXG4gICAgcHVibGljIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICApIHt9XG5cbiAgZ2V0RmxvYXQzMkFycmF5KCk6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMFxuICAgICAgPyBuZXcgRmxvYXQzMkFycmF5KClcbiAgICAgIDogbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIGdldEJpZ0ludDY0QXJyYXkoKTogQmlnSW50NjRBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMFxuICAgICAgPyBuZXcgQmlnSW50NjRBcnJheSgpXG4gICAgICA6IG5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEludDMyQXJyYXkoKSA6IG5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0VWludDE2QXJyYXkoKTogVWludDE2QXJyYXkge1xuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2ICYmIHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLnVpbnQxNikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDAgPyBuZXcgVWludDE2QXJyYXkoKSA6IG5ldyBVaW50MTZBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIHJlc2hhcGUobmV3RGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3IHtcbiAgICBpZiAoU2hhcGVVdGlsLnNpemUobmV3RGltcykgIT09IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXcgc2hhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgdGhpcy5kYXRhVHlwZSwgdGhpcy5kYXRhLCBuZXdEaW1zKTtcbiAgfVxufVxuXG5jbGFzcyBDb21wdXRlQ29udGV4dEltcGwgaW1wbGVtZW50cyBDb21wdXRlQ29udGV4dCB7XG4gIHJlYWRvbmx5IGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mbztcbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xuICBnZXQga2VybmVsQ3VzdG9tRGF0YSgpOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YTtcbiAgfVxuICBnZXQgY3VzdG9tRGF0YUJ1ZmZlcigpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCwgdGhpcy5jdXN0b21EYXRhT2Zmc2V0ICsgdGhpcy5jdXN0b21EYXRhU2l6ZSk7XG4gIH1cbiAgcHJpdmF0ZSBjdXN0b21EYXRhT2Zmc2V0ID0gMDtcbiAgcHJpdmF0ZSBjdXN0b21EYXRhU2l6ZSA9IDA7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLFxuICAgIHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCxcbiAgICBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyLFxuICApIHtcbiAgICB0aGlzLmFkYXB0ZXJJbmZvID0gYmFja2VuZC5hZGFwdGVySW5mbztcblxuICAgIC8vIGV4dHJhY3QgY29udGV4dCBkYXRhXG4gICAgY29uc3QgcHRyU2l6ZSA9IG1vZHVsZS5QVFJfU0laRTtcbiAgICBsZXQgZGF0YUluZGV4ID0gY29udGV4dERhdGFPZmZzZXQgLyBtb2R1bGUuUFRSX1NJWkU7XG4gICAgY29uc3QgdHlwZSA9IHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnO1xuICAgIHRoaXMub3BLZXJuZWxDb250ZXh0ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICBjb25zdCBpbnB1dENvdW50ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICB0aGlzLm91dHB1dENvdW50ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICB0aGlzLmN1c3RvbURhdGFPZmZzZXQgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgJyonKSk7XG4gICAgdGhpcy5jdXN0b21EYXRhU2l6ZSA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XG5cbiAgICBjb25zdCBpbnB1dHM6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XG4gICAgICBjb25zdCBkYXRhID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssICcqJykpO1xuICAgICAgY29uc3QgZGltID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcbiAgICAgIGNvbnN0IGRpbXM6IG51bWJlcltdID0gW107XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgZCsrKSB7XG4gICAgICAgIGRpbXMucHVzaChOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgdHlwZSkpKTtcbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKG5ldyBUZW5zb3JWaWV3SW1wbChtb2R1bGUsIGRhdGFUeXBlLCBkYXRhLCBkaW1zKSk7XG4gICAgfVxuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICB9XG5cbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdIHtcbiAgICAvLyBwcmVwYXJlIGlucHV0cy4gaW5wdXRzIHNob3VsZCBhbHdheXMgYmUgdmFsaWQgZGF0YS5cbiAgICBjb25zdCBtYXBwZWRJbnB1dHMgPVxuICAgICAgaW5wdXRzT3V0cHV0c01hcHBpbmc/LmlucHV0cz8ubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdudW1iZXInID8gdGhpcy5pbnB1dHNbaV0gOiBpKSkgPz8gdGhpcy5pbnB1dHM7XG4gICAgLy8gcHJlcGFyZSBvdXRwdXRzLlxuICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBpbnB1dHNPdXRwdXRzTWFwcGluZz8ub3V0cHV0cyA/PyBbXTtcbiAgICBjb25zdCBjcmVhdGVLZXJuZWxPdXRwdXQgPSAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3ID0+XG4gICAgICBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCB0aGlzLm91dHB1dChpbmRleCwgZGltcyksIGRpbXMpO1xuICAgIGNvbnN0IGNyZWF0ZVRlbXBvcmFyeU91dHB1dCA9IChkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKGRhdGFUeXBlLCBkaW1zKTtcbiAgICAgIGlmICghYnVmZmVyU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGFJZCA9IGJ1ZmZlclNpemUgPiAwID8gdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShidWZmZXJTaXplKS5pZCA6IDA7XG4gICAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCBkYXRhVHlwZSwgZ3B1RGF0YUlkLCBkaW1zKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQucnVuKFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIG1hcHBlZElucHV0cyxcbiAgICAgIG91dHB1dEluZGljZXMsXG4gICAgICBjcmVhdGVLZXJuZWxPdXRwdXQsXG4gICAgICBjcmVhdGVUZW1wb3JhcnlPdXRwdXQsXG4gICAgICB0aGlzLm91dHB1dENvdW50LFxuICAgICk7XG4gIH1cblxuICBvdXRwdXQoaW5kZXg6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB0clNpemUgPSB0aGlzLm1vZHVsZS5QVFJfU0laRTtcbiAgICAgIGNvbnN0IHR5cGUgPSBwdHJTaXplID09PSA0ID8gJ2kzMicgOiAnaTY0JztcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxICsgZGltcy5sZW5ndGgpICogcHRyU2l6ZSAvKiBzaXplb2Yoc2l6ZV90KSAqLyk7XG4gICAgICB0aGlzLm1vZHVsZS5zZXRWYWx1ZShkYXRhLCBkaW1zLmxlbmd0aCwgdHlwZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2R1bGUuc2V0VmFsdWUoZGF0YSArIHB0clNpemUgKiAoaSArIDEpLCBkaW1zW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCEodGhpcy5vcEtlcm5lbENvbnRleHQsIGluZGV4LCBkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7aW5kZXh9XSB3aXRoIGRpbXMgWyR7ZGltc31dLiBgICtcbiAgICAgICAgICAnSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuICcgK1xuICAgICAgICAgIGBFcnJvcjogJHtlfWAsXG4gICAgICApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgSlNFUCB3aXRoIFdlYkdQVSBiYWNrZW5kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBsb2FkZWQgYW5kIGluaXRpYWxpemVkIChcIl9PcnRJbml0XCIgaXMgY2FsbGVkKSwgb25jZSBmb3JcbiAqIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBFUHMgaWYgdGhleSBhcmUgc3BlY2lmaWVkOlxuICogLSBcIndlYmdwdVwiXG4gKiAtIFwid2Vibm5cIlxuICpcbiAqIEZvciBXZWJHUFUsIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcbiAqICAtIFdlYkdQVSBpcyBlbmFibGVkIGluIGJ1aWxkIChCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCA9PT0gZmFsc2UpLlxuICogIC0gV2ViR1BVIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LiAoYSB2YWxpZCBHUFVBZGFwdGVyIGlzIHBhc3NlZCBpbilcbiAqXG4gKiBGb3IgV2ViTk4sIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcbiAqIC0gV2ViTk4gaXMgZW5hYmxlZCBpbiBidWlsZCAoQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgPT09IGZhbHNlKS5cbiAqIC0gV2ViTk4gaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuIChuYXZpZ2F0b3IubWwgaXMgbm90IHVuZGVmaW5lZClcbiAqXG4gKiBJZiB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydCwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGVycm9yLiBUaGlzIHdpbGwgaW52YWxpZGF0ZVxuICogJ3dlYmdwdScvJ3dlYm5uJyBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIEVQLCBlaXRoZXIgXCJ3ZWJncHVcIiBvciBcIndlYm5uXCJcbiAqIEBwYXJhbSBtb2R1bGUgLSB0aGUgT1JUIFdlYkFzc2VtYmx5IG1vZHVsZVxuICogQHBhcmFtIGVudiAtIHRoZSBPUlQgZW52aXJvbm1lbnQgdmFyaWFibGUgKG9ydC5lbnYpXG4gKiBAcGFyYW0gZ3B1QWRhcHRlciAtIHRoZSBwcmUtY3JlYXRlZCBHUFUgYWRhcHRlclxuICovXG5leHBvcnQgY29uc3QgaW5pdCA9IGFzeW5jIChcbiAgbmFtZTogJ3dlYmdwdScgfCAnd2Vibm4nLFxuICBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsXG4gIGVudjogRW52LFxuICBncHVBZGFwdGVyPzogR1BVQWRhcHRlcixcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBqc2VwSW5pdCA9IG1vZHVsZS5qc2VwSW5pdDtcbiAgaWYgKCFqc2VwSW5pdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuJyk7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gJ3dlYmdwdScpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIGNvbnN0IHdlYkdwdUJhY2tlbmRJbXBsID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdlYmdwdScpLldlYkdwdUJhY2tlbmQ7XG4gICAgY29uc3QgYmFja2VuZCA9IG5ldyB3ZWJHcHVCYWNrZW5kSW1wbCgpO1xuICAgIGF3YWl0IGJhY2tlbmQuaW5pdGlhbGl6ZShlbnYsIGdwdUFkYXB0ZXIhKTtcblxuICAgIGpzZXBJbml0KCd3ZWJncHUnLCBbXG4gICAgICAvLyBiYWNrZW5kXG4gICAgICBiYWNrZW5kLFxuXG4gICAgICAvLyBqc2VwQWxsb2MoKVxuICAgICAgKHNpemU6IG51bWJlcikgPT4gYmFja2VuZC5hbGxvYyhOdW1iZXIoc2l6ZSkpLFxuXG4gICAgICAvLyBqc2VwRnJlZSgpXG4gICAgICAocHRyOiBudW1iZXIpID0+IGJhY2tlbmQuZnJlZShwdHIpLFxuXG4gICAgICAvLyBqc2VwQ29weShzcmMsIGRzdCwgc2l6ZSwgaXNTb3VyY2VHcHUpXG4gICAgICAoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGlzU291cmNlR3B1ID0gZmFsc2UpID0+IHtcbiAgICAgICAgaWYgKGlzU291cmNlR3B1KSB7XG4gICAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICAgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke051bWJlcihzcmMpfSwgZHN0PSR7TnVtYmVyKGRzdCl9LCBzaXplPSR7TnVtYmVyKHNpemUpfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBiYWNrZW5kLm1lbWNweShOdW1iZXIoc3JjKSwgTnVtYmVyKGRzdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExPR19ERUJVRyhcbiAgICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICAgIGBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7TnVtYmVyKHNyYyl9LCBncHVEYXRhSWQ9JHtOdW1iZXIoZHN0KX0sIHNpemU9JHtOdW1iZXIoc2l6ZSl9YCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KE51bWJlcihzcmMgPj4+IDApLCBOdW1iZXIoc3JjID4+PiAwKSArIE51bWJlcihzaXplKSk7XG4gICAgICAgICAgYmFja2VuZC51cGxvYWQoTnVtYmVyKGRzdCksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ29weUFzeW5jKHNyYywgZHN0LCBzaXplKVxuICAgICAgYXN5bmMgKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhT2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtncHVEYXRhSWR9LCBkYXRhT2Zmc2V0PSR7ZGF0YU9mZnNldH0sIHNpemU9JHtzaXplfWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgYXdhaXQgYmFja2VuZC5kb3dubG9hZChOdW1iZXIoZ3B1RGF0YUlkKSwgKCkgPT5cbiAgICAgICAgICBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KE51bWJlcihkYXRhT2Zmc2V0KSA+Pj4gMCwgTnVtYmVyKGRhdGFPZmZzZXQgKyBzaXplKSA+Pj4gMCksXG4gICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ3JlYXRlS2VybmVsXG4gICAgICAoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24pID0+XG4gICAgICAgIGJhY2tlbmQuY3JlYXRlS2VybmVsKFxuICAgICAgICAgIGtlcm5lbFR5cGUsXG4gICAgICAgICAgTnVtYmVyKGtlcm5lbElkKSxcbiAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgbW9kdWxlLlVURjhUb1N0cmluZyhtb2R1bGUuX0pzZXBHZXROb2RlTmFtZSEoTnVtYmVyKGtlcm5lbElkKSkpLFxuICAgICAgICApLFxuXG4gICAgICAvLyBqc2VwUmVsZWFzZUtlcm5lbFxuICAgICAgKGtlcm5lbDogbnVtYmVyKSA9PiBiYWNrZW5kLnJlbGVhc2VLZXJuZWwoa2VybmVsKSxcblxuICAgICAgLy8ganNlcFJ1blxuICAgICAgKGtlcm5lbDogbnVtYmVyLCBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyLCBzZXNzaW9uSGFuZGxlOiBudW1iZXIsIGVycm9yczogQXJyYXk8UHJvbWlzZTxzdHJpbmcgfCBudWxsPj4pID0+IHtcbiAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtzZXNzaW9uSGFuZGxlfSwga2VybmVsPSR7a2VybmVsfSwgY29udGV4dERhdGFPZmZzZXQ9JHtjb250ZXh0RGF0YU9mZnNldH1gLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbXB1dGVDb250ZXh0SW1wbChtb2R1bGUsIGJhY2tlbmQsIE51bWJlcihjb250ZXh0RGF0YU9mZnNldCkpO1xuICAgICAgICByZXR1cm4gYmFja2VuZC5jb21wdXRlS2VybmVsKE51bWJlcihrZXJuZWwpLCBjb250ZXh0LCBlcnJvcnMpO1xuICAgICAgfSxcbiAgICAgIC8vIGpzZXBDYXB0dXJlQmVnaW5cbiAgICAgICgpID0+IGJhY2tlbmQuY2FwdHVyZUJlZ2luKCksXG4gICAgICAvLyBqc2VwQ2FwdHVyZUVuZFxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlRW5kKCksXG4gICAgICAvLyBqc2VwUmVwbGF5XG4gICAgICAoKSA9PiBiYWNrZW5kLnJlcGxheSgpLFxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBuZXcgV2ViTk5CYWNrZW5kKGVudik7XG4gICAganNlcEluaXQoJ3dlYm5uJywgW1xuICAgICAgYmFja2VuZCxcbiAgICAgIC8vIHdlYm5uUmVzZXJ2ZVRlbnNvcklkXG4gICAgICAoKSA9PiBiYWNrZW5kLnJlc2VydmVUZW5zb3JJZCgpLFxuICAgICAgLy8gd2Vibm5SZWxlYXNlVGVuc29ySWRcbiAgICAgICh0ZW5zb3JJZDogbnVtYmVyKSA9PiBiYWNrZW5kLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCksXG4gICAgICAvLyB3ZWJubkVuc3VyZVRlbnNvclxuICAgICAgYXN5bmMgKFxuICAgICAgICBzZXNzaW9uSWQ6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICAgICAgdGVuc29ySWQ6IG51bWJlcixcbiAgICAgICAgb25ueERhdGFUeXBlOiBudW1iZXIsXG4gICAgICAgIHNoYXBlOiBudW1iZXJbXSxcbiAgICAgICAgY29weU9sZDogYm9vbGVhbixcbiAgICAgICkgPT4gYmFja2VuZC5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3JJZCwgb25ueERhdGFUeXBlLCBzaGFwZSwgY29weU9sZCksXG4gICAgICAvLyB3ZWJublVwbG9hZFRlbnNvclxuICAgICAgKHRlbnNvcklkOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgYmFja2VuZC51cGxvYWRUZW5zb3IodGVuc29ySWQsIGRhdGEpO1xuICAgICAgfSxcbiAgICAgIC8vIHdlYm5uRG93bmxvYWRUZW5zb3JcbiAgICAgIGFzeW5jICh0ZW5zb3JJZDogbnVtYmVyLCBkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKSA9PiBiYWNrZW5kLmRvd25sb2FkVGVuc29yKHRlbnNvcklkLCBkc3RCdWZmZXIpLFxuICAgICAgLy8gd2Vibm5SZWdpc3Rlck1MQ29udGV4dFxuICAgICAgKHNlc3Npb25JZDogbnVtYmVyLCBtbENvbnRleHQ6IE1MQ29udGV4dCkgPT4gYmFja2VuZC5yZWdpc3Rlck1MQ29udGV4dChzZXNzaW9uSWQsIG1sQ29udGV4dCksXG4gICAgICAvLyB3ZWJubkVuYWJsZVRyYWNlRXZlbnRcbiAgICAgICEhZW52LnRyYWNlLFxuICAgIF0pO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImpzZXAvd2Vibm4vd2Vibm4uZC50c1wiIC8+XG5cbmltcG9ydCB7IEVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgVGVuc29yLCBUUkFDRV9FVkVOVF9CRUdJTiwgVFJBQ0VfRVZFTlRfRU5EIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtcbiAgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSxcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXG4gIFRlbnNvck1ldGFkYXRhLFxufSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCB7IHNldFJ1bk9wdGlvbnMgfSBmcm9tICcuL3J1bi1vcHRpb25zJztcbmltcG9ydCB7IHNldFNlc3Npb25PcHRpb25zIH0gZnJvbSAnLi9zZXNzaW9uLW9wdGlvbnMnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMsXG4gIGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bSxcbiAgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLFxuICBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSxcbiAgbG9nTGV2ZWxTdHJpbmdUb0VudW0sXG4gIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nLFxuICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSxcbiAgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxufSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG4vLyAjcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIFRoZXJlIGFyZSA0IGRpZmZlcmVudCBcImluaXRpYWxpemF0aW9uXCIgc3RlcHMgZm9yIE9SVC4gVGhleSBoYXBwZW4gaW4gZGlmZmVyZW50IHBsYWNlcyBhbmQgZGlmZmVyZW50IHRpbWUuXG4gKlxuICogMS4gSmF2YVNjcmlwdCBpbml0aWFsaXphdGlvbiBmb3Igb25ueHJ1bnRpbWUtY29tbW9uIGFuZCBvbm54cnVudGltZS13ZWIuXG4gKiAgICBUaGlzIGlzIHRoZSBmaXJzdCBpbml0aWFsaXphdGlvbiBzdGVwLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBjYWxscyBvbm54cnVudGltZS1jb21tb24ncyByZWdpc3RlckJhY2tlbmQoKVxuICogZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgYWxsIHRoZSBhdmFpbGFibGUgYmFja2VuZHMuIFRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbiBpcyB2ZXJ5IGZhc3QuIEl0IG9ubHlcbiAqIHJlZ2lzdGVycyB0aGUgYmFja2VuZCBuYW1lIHdpdGggdGhlIHVuaW5pdGlhbGl6ZWQgYmFja2VuZCBvYmplY3QuIE5vIGhlYXZ5IGluaXRpYWxpemF0aW9uIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgUmVmZXIgdG8gd2ViL2xpYi9pbmRleC50cyBmb3IgdGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uLlxuICpcbiAqIDIuIFdlYkFzc2VtYmx5IGFydGlmYWN0IGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYW55IHJlZ2lzdGVyZWQgd2FzbSBiYWNrZW5kIGlzIHVzZWQgZm9yIHRoZSBmaXJzdCB0aW1lIChpZS4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpc1xuICogY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cbiAqICAgICAtIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24sIGxvY2F0ZSBjb3JyZWN0IFdlYkFzc2VtYmx5IGFydGlmYWN0IHBhdGggYW5kIGNhbGwgdGhlIEVtc2NyaXB0ZW4gZ2VuZXJhdGVkXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXG4gKiAgICAgICAgIC0gZG93bmxvYWRpbmcgdGhlICdvcnQtd2FzbXsuLi59Lndhc20nIGZpbGUgaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxuICpcbiAqIDMuIE9SVCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxuICogICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LW9ydCcuXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxuICpcbiAqIDQuIFNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZC4gVW5saWtlIHRoZSBmaXJzdCAzIHN0ZXBzICh0aGV5IG9ubHkgY2FsbGVkIG9uY2UpLFxuICogdGhpcyBzdGVwIHdpbGwgYmUgZG9uZSBmb3IgZWFjaCBzZXNzaW9uLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBkb2VzIHRoZSBmb2xsb3dpbmdzOlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVSTDpcbiAqICAgIC0gZG93bmxvYWQgdGhlIG1vZGVsIGRhdGEgZnJvbSB0aGUgVVJMLlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGRlcmVmZXJlbmNlIHRoZSBtb2RlbCBidWZmZXIuIFRoaXMgc3RlcCBhbGxvd3MgdGhlIG9yaWdpbmFsIEFycmF5QnVmZmVyIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXG4gKlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVpbnQ4QXJyYXkgb2JqZWN0OlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKlxuICovXG5cbi8qKlxuICogaW5pdGlhbGl6ZSBPUlQgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIG51bVRocmVhZHMgU2V0R2xvYmFsSW50cmFPcE51bVRocmVhZHMobnVtVGhyZWFkcylcbiAqIEBwYXJhbSBsb2dnaW5nTGV2ZWwgQ3JlYXRlRW52KHN0YXRpY19jYXN0PE9ydExvZ2dpbmdMZXZlbD4obG9nZ2luZ19sZXZlbCkpXG4gKi9cbmNvbnN0IGluaXRPcnQgPSAobnVtVGhyZWFkczogbnVtYmVyLCBsb2dnaW5nTGV2ZWw6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBlcnJvckNvZGUgPSBnZXRJbnN0YW5jZSgpLl9PcnRJbml0KG51bVRocmVhZHMsIGxvZ2dpbmdMZXZlbCk7XG4gIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIGluaXRpYWxpemUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSBlbnYgcGFzc2VkIGluIHRoZSBlbnZpcm9ubWVudCBjb25maWcgb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgaW5pdFJ1bnRpbWUgPSBhc3luYyAoZW52OiBFbnYpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgLy8gaW5pdCBPUlRcbiAgaW5pdE9ydChlbnYud2FzbS5udW1UaHJlYWRzISwgbG9nTGV2ZWxTdHJpbmdUb0VudW0oZW52LmxvZ0xldmVsKSk7XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIGVudlxuICogQHBhcmFtIGVwTmFtZVxuICovXG5leHBvcnQgY29uc3QgaW5pdEVwID0gYXN5bmMgKGVudjogRW52LCBlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAvLyBpbml0aWFsaXplIEFTWU5DSUZZIHN1cHBvcnRcbiAgZ2V0SW5zdGFuY2UoKS5hc3luY0luaXQ/LigpO1xuXG4gIC8vIHBlcmZvcm0gV2ViR1BVIGF2YWlsYWJpbGl0eSBjaGVjayAoIGVpdGhlciBKU0VQIG9yIFdlYkdQVSBFUCApXG4gIGxldCB3ZWJncHVBZGFwdGVyID0gZW52LndlYmdwdS5hZGFwdGVyIGFzIEdQVUFkYXB0ZXIgfCBudWxsO1xuICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmdwdSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgfVxuICAgIGlmICghd2ViZ3B1QWRhcHRlcikge1xuICAgICAgLy8gaWYgYWRhcHRlciBpcyBub3Qgc2V0LCByZXF1ZXN0IGEgbmV3IGFkYXB0ZXIuXG4gICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSBlbnYud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgIGlmIChwb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCAmJiBwb3dlclByZWZlcmVuY2UgIT09ICdsb3ctcG93ZXInICYmIHBvd2VyUHJlZmVyZW5jZSAhPT0gJ2hpZ2gtcGVyZm9ybWFuY2UnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke3Bvd2VyUHJlZmVyZW5jZX1cImApO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9yY2VGYWxsYmFja0FkYXB0ZXIgPSBlbnYud2ViZ3B1LmZvcmNlRmFsbGJhY2tBZGFwdGVyO1xuICAgICAgaWYgKGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtmb3JjZUZhbGxiYWNrQWRhcHRlcn1cImApO1xuICAgICAgfVxuICAgICAgd2ViZ3B1QWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoeyBwb3dlclByZWZlcmVuY2UsIGZvcmNlRmFsbGJhY2tBZGFwdGVyIH0pO1xuICAgICAgaWYgKCF3ZWJncHVBZGFwdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgc2V0LCB2YWxpZGF0ZSBpdC5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHdlYmdwdUFkYXB0ZXIubGltaXRzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICB0eXBlb2Ygd2ViZ3B1QWRhcHRlci5mZWF0dXJlcyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgdHlwZW9mIHdlYmdwdUFkYXB0ZXIucmVxdWVzdERldmljZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwZXJmb3JtIFdlYk5OIGF2YWlsYWJpbGl0eSBjaGVjayAoIGVpdGhlciBKU0VQIG9yIFdlYk5OIEVQIClcbiAgaWYgKGVwTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKG5hdmlnYXRvciBhcyB1bmtub3duIGFzIHsgbWw6IHVua25vd24gfSkubWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgY29uc3QgaW5pdEpzZXAgPSByZXF1aXJlKCcuL2pzZXAvaW5pdCcpLmluaXQ7XG5cbiAgICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYmdwdScsIGdldEluc3RhbmNlKCksIGVudiwgd2ViZ3B1QWRhcHRlcik7XG4gICAgfVxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJubicpIHtcbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJubicsIGdldEluc3RhbmNlKCksIGVudik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSAmJiBlcE5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgICBnZXRJbnN0YW5jZSgpLndlYmdwdUluaXQhKChkZXZpY2UpID0+IHtcbiAgICAgICAgZW52LndlYmdwdS5kZXZpY2UgPSBkZXZpY2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCTk4gJiYgZXBOYW1lID09PSAnd2Vibm4nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgY29uc3QgYmFja2VuZCA9IG5ldyAocmVxdWlyZSgnLi9qc2VwL2JhY2tlbmQtd2Vibm4nKS5XZWJOTkJhY2tlbmQpKGVudik7XG4gICAgICBnZXRJbnN0YW5jZSgpLndlYm5uSW5pdCEoW1xuICAgICAgICBiYWNrZW5kLFxuICAgICAgICAvLyB3ZWJublJlc2VydmVUZW5zb3JJZFxuICAgICAgICAoKSA9PiBiYWNrZW5kLnJlc2VydmVUZW5zb3JJZCgpLFxuICAgICAgICAvLyB3ZWJublJlbGVhc2VUZW5zb3JJZCxcbiAgICAgICAgKHRlbnNvcklkOiBudW1iZXIpID0+IGJhY2tlbmQucmVsZWFzZVRlbnNvcklkKHRlbnNvcklkKSxcbiAgICAgICAgLy8gd2Vibm5FbnN1cmVUZW5zb3JcbiAgICAgICAgYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0ZW5zb3JJZDogbnVtYmVyLCBvbm54RGF0YVR5cGU6IG51bWJlciwgc2hhcGU6IG51bWJlcltdLCBjb3B5T2xkKSA9PlxuICAgICAgICAgIGJhY2tlbmQuZW5zdXJlVGVuc29yKHNlc3Npb25JZCwgdGVuc29ySWQsIG9ubnhEYXRhVHlwZSwgc2hhcGUsIGNvcHlPbGQpLFxuICAgICAgICAvLyB3ZWJublVwbG9hZFRlbnNvclxuICAgICAgICAodGVuc29ySWQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSkgPT4ge1xuICAgICAgICAgIGJhY2tlbmQudXBsb2FkVGVuc29yKHRlbnNvcklkLCBkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2Vibm5Eb3dubG9hZFRlbnNvclxuICAgICAgICBhc3luYyAodGVuc29ySWQ6IG51bWJlciwgZHN0QnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcikgPT5cbiAgICAgICAgICBiYWNrZW5kLmRvd25sb2FkVGVuc29yKHRlbnNvcklkLCBkc3RCdWZmZXIpLFxuICAgICAgICAvLyB3ZWJublJlZ2lzdGVyTUxDb250ZXh0XG4gICAgICAgIChzZXNzaW9uSWQ6IG51bWJlciwgbWxDb250ZXh0OiBNTENvbnRleHQpID0+IGJhY2tlbmQucmVnaXN0ZXJNTENvbnRleHQoc2Vzc2lvbklkLCBtbENvbnRleHQpLFxuICAgICAgICAvLyB3ZWJubkVuYWJsZVRyYWNlRXZlbnRcbiAgICAgICAgISFlbnYudHJhY2UsXG4gICAgICBdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vICNlbmRyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogdmFsaWQgZGF0YSBsb2NhdGlvbnMgZm9yIGlucHV0L291dHB1dCB0ZW5zb3JzLlxuICovXG50eXBlIFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0ID1cbiAgfCAnY3B1J1xuICB8ICdjcHUtcGlubmVkJ1xuICB8ICdncHUtYnVmZmVyJ1xuICB8ICdtbC10ZW5zb3InXG4gIC8vIFVzZSAnbWwtdGVuc29yJyBkdXJpbmcgaW5mZXJlbmNlLCBidXQgb3V0cHV0IGEgdGVuc29yIGxvY2F0ZWQgb24gdGhlIENQVS5cbiAgfCAnbWwtdGVuc29yLWNwdS1vdXRwdXQnO1xuXG50eXBlIElPQmluZGluZ1N0YXRlID0ge1xuICAvKipcbiAgICogdGhlIGhhbmRsZSBvZiBJTyBiaW5kaW5nLlxuICAgKi9cbiAgcmVhZG9ubHkgaGFuZGxlOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cbiAgICpcbiAgICogdmFsdWUgaXMgb25lIG9mICdjcHUnLCAnY3B1LXBpbm5lZCcsICdncHUtYnVmZmVyJywgJ21sLXRlbnNvcicuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IHJlYWRvbmx5IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W107XG5cbiAgLyoqXG4gICAqIGVudW0gdmFsdWUgb2YgdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDogcmVhZG9ubHkgbnVtYmVyW107XG59O1xuXG4vKipcbiAqICB0dXBsZSBlbGVtZW50cyBhcmU6IEluZmVyZW5jZVNlc3Npb24gSUQ7IGlucHV0TmFtZXNVVEY4RW5jb2RlZDsgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDsgYmluZGluZ1N0YXRlXG4gKi9cbnR5cGUgU2Vzc2lvbk1ldGFkYXRhID0gW1xuICBpbmZlcmVuY2VTZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXROYW1lc1VURjhFbmNvZGVkOiBudW1iZXJbXSxcbiAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXG4gIGJpbmRpbmdTdGF0ZTogSU9CaW5kaW5nU3RhdGUgfCBudWxsLFxuICBlbmFibGVHcmFwaENhcHR1cmU6IGJvb2xlYW4sXG4gIGlucHV0T3V0cHV0Qm91bmQ6IGJvb2xlYW4sXG5dO1xuXG5jb25zdCBhY3RpdmVTZXNzaW9ucyA9IG5ldyBNYXA8bnVtYmVyLCBTZXNzaW9uTWV0YWRhdGE+KCk7XG5cbi8qKlxuICogZ2V0IHRoZSBpbnB1dC9vdXRwdXQgY291bnQgb2YgdGhlIHNlc3Npb24uXG4gKiBAcGFyYW0gc2Vzc2lvbkhhbmRsZSB0aGUgaGFuZGxlIHJlcHJlc2VudGluZyB0aGUgc2Vzc2lvbi4gc2hvdWxkIGJlIG5vbi16ZXJvLlxuICogQHJldHVybnMgYSB0dXBsZSBpbmNsdWRpbmcgMiBudW1iZXJzLCByZXByZXNlbnRpbmcgdGhlIGlucHV0IGNvdW50IGFuZCBvdXRwdXQgY291bnQuXG4gKi9cbmNvbnN0IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50ID0gKHNlc3Npb25IYW5kbGU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIHB0clNpemUpO1xuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnO1xuICAgIHJldHVybiBbTnVtYmVyKHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCwgdHlwZSkpLCBOdW1iZXIod2FzbS5nZXRWYWx1ZShkYXRhT2Zmc2V0ICsgcHRyU2l6ZSwgdHlwZSkpXTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gIH1cbn07XG5cbmNvbnN0IGdldFNlc3Npb25JbnB1dE91dHB1dE1ldGFkYXRhID0gKFxuICBzZXNzaW9uSGFuZGxlOiBudW1iZXIsXG4gIGluZGV4OiBudW1iZXIsXG4pOiBbbmFtZU9mZnNldDogbnVtYmVyLCBlbGVtZW50VHlwZTogbnVtYmVyLCBkaW1zPzogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPl0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBsZXQgbWV0YWRhdGFPZmZzZXQgPSAwO1xuICB0cnkge1xuICAgIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaW5kZXgsIGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBwdHJTaXplKTtcbiAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBtZXRhZGF0YS5cIik7XG4gICAgfVxuICAgIGNvbnN0IG5hbWVPZmZzZXQgPSBOdW1iZXIod2FzbS5nZXRWYWx1ZShkYXRhT2Zmc2V0LCAnKicpKTtcbiAgICBtZXRhZGF0YU9mZnNldCA9IE51bWJlcih3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQgKyBwdHJTaXplLCAnKicpKTtcbiAgICAvLyBnZXQgZWxlbWVudCB0eXBlXG4gICAgY29uc3QgZWxlbWVudFR5cGUgPSB3YXNtLkhFQVAzMlttZXRhZGF0YU9mZnNldCAvIDRdO1xuICAgIGlmIChlbGVtZW50VHlwZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtuYW1lT2Zmc2V0LCAwXTsgLy8gbm9uLXRlbnNvclxuICAgIH1cblxuICAgIC8vIGdldCBkaW1zIGNvdW50XG4gICAgY29uc3QgZGltc0NvdW50ID0gd2FzbS5IRUFQVTMyW21ldGFkYXRhT2Zmc2V0IC8gNCArIDFdO1xuICAgIC8vIGdldCBkaW1zXG4gICAgY29uc3QgZGltczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHN5bWJvbGljRGltTmFtZU9mZnNldCA9IE51bWJlcih3YXNtLmdldFZhbHVlKG1ldGFkYXRhT2Zmc2V0ICsgOCArIGkgKiBwdHJTaXplLCAnKicpKTtcbiAgICAgIGRpbXMucHVzaChcbiAgICAgICAgc3ltYm9saWNEaW1OYW1lT2Zmc2V0ICE9PSAwXG4gICAgICAgICAgPyB3YXNtLlVURjhUb1N0cmluZyhzeW1ib2xpY0RpbU5hbWVPZmZzZXQpXG4gICAgICAgICAgOiBOdW1iZXIod2FzbS5nZXRWYWx1ZShtZXRhZGF0YU9mZnNldCArIDggKyAoaSArIGRpbXNDb3VudCkgKiBwdHJTaXplLCAnKicpKSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbbmFtZU9mZnNldCwgZWxlbWVudFR5cGUsIGRpbXNdO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICBpZiAobWV0YWRhdGFPZmZzZXQgIT09IDApIHtcbiAgICAgIHdhc20uX09ydEZyZWUobWV0YWRhdGFPZmZzZXQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBhbGxvY2F0ZSB0aGUgbWVtb3J5IGFuZCBtZW1jcHkgdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxuICogQHJldHVybnMgYSAyLWVsZW1lbnRzIHR1cGxlIC0gdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIGFsbG9jYXRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHttb2RlbC5ieXRlTGVuZ3RofS5gKTtcbiAgfVxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XG4gIHJldHVybiBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoXTtcbn07XG5cbi8qKlxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWxEYXRhIC0gZWl0aGVyIGEgVWludDhBcnJheSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBkYXRhLCBvciBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGVcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIDMtZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyBbc2Vzc2lvbiBoYW5kbGUsIGlucHV0IG5hbWVzLCBvdXRwdXQgbmFtZXNdXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMgKFxuICBtb2RlbERhdGE6IFVpbnQ4QXJyYXkgfCBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBsZXQgbW9kZWxEYXRhT2Zmc2V0OiBudW1iZXIsIG1vZGVsRGF0YUxlbmd0aDogbnVtYmVyO1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbERhdGEpKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSBpcyBhbiBhcnJheSwgaXQgbXVzdCBiZSBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YVxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBtb2RlbERhdGE7XG4gIH0gZWxzZSBpZiAobW9kZWxEYXRhLmJ1ZmZlciA9PT0gd2FzbS5IRUFQVTguYnVmZmVyKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSB1c2VzIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQuXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IFttb2RlbERhdGEuYnl0ZU9mZnNldCwgbW9kZWxEYXRhLmJ5dGVMZW5ndGhdO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKG1vZGVsRGF0YSk7XG4gIH1cblxuICBsZXQgc2Vzc2lvbkhhbmRsZSA9IDA7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBpb0JpbmRpbmdIYW5kbGUgPSAwO1xuICBsZXQgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xuXG4gIHRyeSB7XG4gICAgW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdID0gYXdhaXQgc2V0U2Vzc2lvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0ZXJuYWxEYXRhICYmIHdhc20ubW91bnRFeHRlcm5hbERhdGEpIHtcbiAgICAgIGNvbnN0IGxvYWRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIG9wdGlvbnMuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5wYXRoO1xuICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChcbiAgICAgICAgICBsb2FkRmlsZSh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5kYXRhKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKHBhdGgsIGRhdGEpO1xuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyB3YWl0IGZvciBhbGwgZXh0ZXJuYWwgZGF0YSBmaWxlcyB0byBiZSBsb2FkZWRcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRpbmdQcm9taXNlcyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm92aWRlciBvZiBvcHRpb25zPy5leGVjdXRpb25Qcm92aWRlcnMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyTmFtZSA9IHR5cGVvZiBwcm92aWRlciA9PT0gJ3N0cmluZycgPyBwcm92aWRlciA6IHByb3ZpZGVyLm5hbWU7XG4gICAgICBpZiAocHJvdmlkZXJOYW1lID09PSAnd2Vibm4nKSB7XG4gICAgICAgIHdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gcHJvdmlkZXIgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dCk/LmNvbnRleHQ7XG4gICAgICAgICAgY29uc3QgZ3B1RGV2aWNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dlYkdwdSk/LmdwdURldmljZTtcbiAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5kZXZpY2VUeXBlO1xuICAgICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8ucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gY29udGV4dCBhcyBNTENvbnRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChncHVEZXZpY2UpIHtcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCB3YXNtLndlYm5uQ3JlYXRlTUxDb250ZXh0IShncHVEZXZpY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgd2FzbS53ZWJubkNyZWF0ZU1MQ29udGV4dCEoeyBkZXZpY2VUeXBlLCBwb3dlclByZWZlcmVuY2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCB3YXNtLndlYm5uQ3JlYXRlTUxDb250ZXh0ISgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlc3Npb25IYW5kbGUgPSBhd2FpdCB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uKG1vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoLCBzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgd2FzbS53ZWJncHVPbkNyZWF0ZVNlc3Npb24/LihzZXNzaW9uSGFuZGxlKTtcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKTtcbiAgICB9XG5cbiAgICB3YXNtLmpzZXBPbkNyZWF0ZVNlc3Npb24/LigpO1xuXG4gICAgLy8gY2xlYXIgY3VycmVudCBNTENvbnRleHQgYWZ0ZXIgc2Vzc2lvbiBjcmVhdGlvblxuICAgIGlmICh3YXNtLmN1cnJlbnRDb250ZXh0KSB7XG4gICAgICB3YXNtLndlYm5uUmVnaXN0ZXJNTENvbnRleHQhKHNlc3Npb25IYW5kbGUsIHdhc20uY3VycmVudENvbnRleHQpO1xuICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIHdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBbaW5wdXRDb3VudCwgb3V0cHV0Q291bnRdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSAhIW9wdGlvbnM/LmVuYWJsZUdyYXBoQ2FwdHVyZTtcblxuICAgIGNvbnN0IGlucHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXROYW1lcyA9IFtdO1xuICAgIGNvbnN0IGlucHV0TWV0YWRhdGE6IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdID0gW107XG4gICAgY29uc3Qgb3V0cHV0TWV0YWRhdGE6IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdID0gW107XG4gICAgY29uc3Qgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IFtuYW1lT2Zmc2V0LCBlbGVtZW50VHlwZSwgc2hhcGVdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaSk7XG4gICAgICBpZiAobmFtZU9mZnNldCA9PT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKTtcbiAgICAgIH1cbiAgICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWVPZmZzZXQpO1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWVPZmZzZXQpO1xuICAgICAgaW5wdXROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgaW5wdXRNZXRhZGF0YS5wdXNoKFxuICAgICAgICBlbGVtZW50VHlwZSA9PT0gMFxuICAgICAgICAgID8geyBuYW1lLCBpc1RlbnNvcjogZmFsc2UgfVxuICAgICAgICAgIDogeyBuYW1lLCBpc1RlbnNvcjogdHJ1ZSwgdHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZWxlbWVudFR5cGUpLCBzaGFwZTogc2hhcGUhIH0sXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IFtuYW1lT2Zmc2V0LCBlbGVtZW50VHlwZSwgc2hhcGVdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaSArIGlucHV0Q291bnQpO1xuICAgICAgaWYgKG5hbWVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWVPZmZzZXQpO1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWVPZmZzZXQpO1xuICAgICAgb3V0cHV0TmFtZXMucHVzaChuYW1lU3RyaW5nKTtcbiAgICAgIG91dHB1dE1ldGFkYXRhLnB1c2goXG4gICAgICAgIGVsZW1lbnRUeXBlID09PSAwXG4gICAgICAgICAgPyB7IG5hbWU6IG5hbWVTdHJpbmcsIGlzVGVuc29yOiBmYWxzZSB9XG4gICAgICAgICAgOiB7IG5hbWU6IG5hbWVTdHJpbmcsIGlzVGVuc29yOiB0cnVlLCB0eXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhlbGVtZW50VHlwZSksIHNoYXBlOiBzaGFwZSEgfSxcbiAgICAgICk7XG5cbiAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnB1c2goJ2dwdS1idWZmZXInKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9XG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBvcHRpb25zLnByZWZlcnJlZE91dHB1dExvY2F0aW9uXG4gICAgICAgICAgICA6IChvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW25hbWVTdHJpbmddID8/ICdjcHUnKTtcbiAgICAgICAgY29uc3QgaXNHcmFwaE91dHB1dCA9IHdhc20ud2Vibm5Jc0dyYXBoT3V0cHV0O1xuICAgICAgICBpZiAobG9jYXRpb24gPT09ICdjcHUnICYmIGlzR3JhcGhPdXRwdXQgJiYgaXNHcmFwaE91dHB1dChzZXNzaW9uSGFuZGxlLCBuYW1lU3RyaW5nKSkge1xuICAgICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKCdtbC10ZW5zb3ItY3B1LW91dHB1dCcpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhdGlvbiAhPT0gJ2NwdScgJiYgbG9jYXRpb24gIT09ICdjcHUtcGlubmVkJyAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInICYmIGxvY2F0aW9uICE9PSAnbWwtdGVuc29yJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke2xvY2F0aW9ufS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke2xvY2F0aW9ufS4gT25seSAnZ3B1LWJ1ZmZlcicgbG9jYXRpb24gaXMgc3VwcG9ydGVkIHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1c2UgSU8gYmluZGluZyBvbmx5IHdoZW4gYXQgbGVhc3Qgb25lIG91dHB1dCBpcyBwcmVmZXJyZWQgdG8gYmUgb24gR1BVLlxuICAgIGxldCBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKFxuICAgICAgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCB8fCAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkgJiZcbiAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5zb21lKChsKSA9PiBsID09PSAnZ3B1LWJ1ZmZlcicgfHwgbCA9PT0gJ21sLXRlbnNvcicgfHwgbCA9PT0gJ21sLXRlbnNvci1jcHUtb3V0cHV0JylcbiAgICApIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc1xuICAgICAgICAgIC8vICdtbC10ZW5zb3ItY3B1LW91dHB1dCcgaXMgdHJlYXRlZCBhcyAnbWwtdGVuc29yJyBmb3IgdGhlIHB1cnBvc2Ugb2YgSU8gYmluZGluZy5cbiAgICAgICAgICAubWFwKChsKSA9PiAobCA9PT0gJ21sLXRlbnNvci1jcHUtb3V0cHV0JyA/ICdtbC10ZW5zb3InIDogbCkpXG4gICAgICAgICAgLm1hcCgobCkgPT4gZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGwpKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYWN0aXZlU2Vzc2lvbnMuc2V0KHNlc3Npb25IYW5kbGUsIFtcbiAgICAgIHNlc3Npb25IYW5kbGUsXG4gICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgYmluZGluZ1N0YXRlLFxuICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgZmFsc2UsXG4gICAgXSk7XG4gICAgcmV0dXJuIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzLCBvdXRwdXROYW1lcywgaW5wdXRNZXRhZGF0YSwgb3V0cHV0TWV0YWRhdGFdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcblxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcbiAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlQmluZGluZyhpb0JpbmRpbmdIYW5kbGUpICE9PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSAhPT0gMCkge1xuICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpICE9PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLl9mcmVlKG1vZGVsRGF0YU9mZnNldCk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKSAhPT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG5cbiAgICAvLyB1bm1vdW50IGV4dGVybmFsIGRhdGEgaWYgbmVjZXNzYXJ5XG4gICAgd2FzbS51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke3Nlc3Npb25JZH1gKTtcbiAgfVxuICBjb25zdCBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkLCBpb0JpbmRpbmdTdGF0ZSwgZW5hYmxlR3JhcGhDYXB0dXJlXSA9IHNlc3Npb247XG5cbiAgaWYgKGlvQmluZGluZ1N0YXRlKSB7XG4gICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgaWYgKHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKTtcbiAgICB9XG4gIH1cblxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcbiAgd2FzbS53ZWJubk9uUmVsZWFzZVNlc3Npb24/LihzZXNzaW9uSWQpO1xuICB3YXNtLndlYmdwdU9uUmVsZWFzZVNlc3Npb24/LihzZXNzaW9uSWQpO1xuXG4gIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKChidWYpID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG4gIG91dHB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCgoYnVmKSA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSkgIT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIik7XG4gIH1cbiAgYWN0aXZlU2Vzc2lvbnMuZGVsZXRlKHNlc3Npb25JZCk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yID0gYXN5bmMgKFxuICB0ZW5zb3I6IFRlbnNvck1ldGFkYXRhIHwgbnVsbCxcbiAgdGVuc29ySGFuZGxlczogbnVtYmVyW10sXG4gIGFsbG9jczogbnVtYmVyW10sXG4gIHNlc3Npb25JZDogbnVtYmVyLFxuICB0ZW5zb3JOYW1lVVRGOEVuY29kZWQ6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UsXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCF0ZW5zb3IpIHtcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xuXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICBjb25zdCBkaW1zID0gdGVuc29yWzFdO1xuICBjb25zdCBsb2NhdGlvbiA9IHRlbnNvclszXTtcbiAgbGV0IGFjdHVhbExvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgbGV0IHJhd0RhdGE6IG51bWJlcjtcbiAgbGV0IGRhdGFCeXRlTGVuZ3RoOiBudW1iZXI7XG5cbiAgaWYgKGRhdGFUeXBlID09PSAnc3RyaW5nJyAmJiAobG9jYXRpb24gPT09ICdncHUtYnVmZmVyJyB8fCBsb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICB9XG5cbiAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtpbmRleH0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gLFxuICAgICk7XG4gIH1cblxuICBpZiAobG9jYXRpb24gPT09ICdncHUtYnVmZmVyJykge1xuICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRlbnNvclsyXS5ncHVCdWZmZXI7XG4gICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpITtcblxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICAgICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLndlYmdwdVJlZ2lzdGVyQnVmZmVyO1xuICAgICAgaWYgKCFyZWdpc3RlckJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgICAgfVxuXG4gICAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoZ3B1QnVmZmVyLCBzZXNzaW9uSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWdpc3RlckJ1ZmZlciA9IHdhc20uanNlcFJlZ2lzdGVyQnVmZmVyO1xuICAgICAgaWYgKCFyZWdpc3RlckJ1ZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgICAgfVxuICAgICAgcmF3RGF0YSA9IHJlZ2lzdGVyQnVmZmVyKHNlc3Npb25JZCwgaW5kZXgsIGdwdUJ1ZmZlciwgZGF0YUJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicpIHtcbiAgICBjb25zdCBtbFRlbnNvciA9IHRlbnNvclsyXS5tbFRlbnNvciBhcyBNTFRlbnNvcjtcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJNTFRlbnNvciA9IHdhc20ud2Vibm5SZWdpc3Rlck1MVGVuc29yO1xuICAgIGlmICghcmVnaXN0ZXJNTFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XG4gICAgfVxuICAgIHJhd0RhdGEgPSByZWdpc3Rlck1MVGVuc29yKHNlc3Npb25JZCwgbWxUZW5zb3IsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICBkYXRhQnl0ZUxlbmd0aCA9IHB0clNpemUgKiBkYXRhLmxlbmd0aDtcbiAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7aX0gaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgd2FzbS5zZXRWYWx1ZShyYXdEYXRhICsgaSAqIHB0clNpemUsIGFsbG9jV2FzbVN0cmluZyhkYXRhW2ldLCBhbGxvY3MpLCAnKicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc0dyYXBoSW5wdXQgPSB3YXNtLndlYm5uSXNHcmFwaElucHV0O1xuICAgICAgY29uc3QgaXNHcmFwaE91dHB1dCA9IHdhc20ud2Vibm5Jc0dyYXBoT3V0cHV0O1xuICAgICAgaWYgKGRhdGFUeXBlICE9PSAnc3RyaW5nJyAmJiBpc0dyYXBoSW5wdXQgJiYgaXNHcmFwaE91dHB1dCkge1xuICAgICAgICBjb25zdCB0ZW5zb3JOYW1lID0gd2FzbS5VVEY4VG9TdHJpbmcodGVuc29yTmFtZVVURjhFbmNvZGVkKTtcbiAgICAgICAgLy8gUHJvbW90ZSB0aGUgdGVuc29yIHRvICdtbC10ZW5zb3InIGlmIGl0IGlzIGEgZ3JhcGggaW5wdXQuXG4gICAgICAgIGlmIChpc0dyYXBoSW5wdXQoc2Vzc2lvbklkLCB0ZW5zb3JOYW1lKSB8fCBpc0dyYXBoT3V0cHV0KHNlc3Npb25JZCwgdGVuc29yTmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBkYXRhVHlwZUVudW0gPSB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSk7XG4gICAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyhkYXRhVHlwZUVudW0sIGRpbXMpITtcbiAgICAgICAgICBhY3R1YWxMb2NhdGlvbiA9ICdtbC10ZW5zb3InO1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZVRlbXBvcmFyeVRlbnNvciA9IHdhc20ud2Vibm5DcmVhdGVUZW1wb3JhcnlUZW5zb3I7XG4gICAgICAgICAgY29uc3QgdXBsb2FkVGVuc29yID0gd2FzbS53ZWJublVwbG9hZFRlbnNvcjtcbiAgICAgICAgICBpZiAoIWNyZWF0ZVRlbXBvcmFyeVRlbnNvciB8fCAhdXBsb2FkVGVuc29yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGVuc29ySWQgPSBhd2FpdCBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ioc2Vzc2lvbklkLCBkYXRhVHlwZUVudW0sIGRpbXMgYXMgbnVtYmVyW10pO1xuICAgICAgICAgIHVwbG9hZFRlbnNvcih0ZW5zb3JJZCwgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgICAgcmF3RGF0YSA9IHRlbnNvcklkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgICAgIHdhc20uSEVBUFU4LnNldChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhQnl0ZUxlbmd0aCksIHJhd0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgcmF3RGF0YSA9IHdhc20uX21hbGxvYyhkYXRhQnl0ZUxlbmd0aCk7XG4gICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgICB3YXNtLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YUJ5dGVMZW5ndGgpLCByYXdEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIGRpbXMubGVuZ3RoKTtcbiAgdHJ5IHtcbiAgICBkaW1zLmZvckVhY2goKGQsIGluZGV4KSA9PiB3YXNtLnNldFZhbHVlKGRpbXNPZmZzZXQgKyBpbmRleCAqIHB0clNpemUsIGQsIHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnKSk7XG4gICAgY29uc3QgdGVuc29yID0gd2FzbS5fT3J0Q3JlYXRlVGVuc29yKFxuICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLFxuICAgICAgcmF3RGF0YSxcbiAgICAgIGRhdGFCeXRlTGVuZ3RoLFxuICAgICAgZGltc09mZnNldCxcbiAgICAgIGRpbXMubGVuZ3RoLFxuICAgICAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGFjdHVhbExvY2F0aW9uKSxcbiAgICApO1xuICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtzZXNzaW9uSWR9LCBpbmRleD0ke2luZGV4fS5gKTtcbiAgICB9XG4gICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gaW5mZXJlbmNlIHJ1blxuICovXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLFxuICBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgb3V0cHV0VGVuc29yczogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7c2Vzc2lvbklkfWApO1xuICB9XG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzFdO1xuICBjb25zdCBvdXRwdXROYW1lc1VURjhFbmNvZGVkID0gc2Vzc2lvblsyXTtcbiAgY29uc3QgaW9CaW5kaW5nU3RhdGUgPSBzZXNzaW9uWzNdO1xuICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSBzZXNzaW9uWzRdO1xuICBjb25zdCBpbnB1dE91dHB1dEJvdW5kID0gc2Vzc2lvbls1XTtcblxuICBjb25zdCBpbnB1dENvdW50ID0gaW5wdXRJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0Q291bnQgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aDtcblxuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBydW5PcHRpb25zQWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IGlucHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgb3V0cHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXRPdXRwdXRBbGxvY3M6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHByZUFsbG9jYXRlZE91dHB1dHM6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgYmVmb3JlUnVuU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBjb25zdCBpbnB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogcHRyU2l6ZSk7XG4gIGNvbnN0IGlucHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIHB0clNpemUpO1xuICBjb25zdCBvdXRwdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiBwdHJTaXplKTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiBwdHJTaXplKTtcblxuICB0cnkge1xuICAgIFtydW5PcHRpb25zSGFuZGxlLCBydW5PcHRpb25zQWxsb2NzXSA9IHNldFJ1bk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBUUkFDRV9FVkVOVF9CRUdJTignd2FzbSBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3InKTtcbiAgICAvLyBjcmVhdGUgaW5wdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBhd2FpdCBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoXG4gICAgICAgIGlucHV0VGVuc29yc1tpXSxcbiAgICAgICAgaW5wdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5wdXRJbmRpY2VzW2ldXSxcbiAgICAgICAgaW5wdXRJbmRpY2VzW2ldLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgYXdhaXQgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLFxuICAgICAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkW291dHB1dEluZGljZXNbaV1dLFxuICAgICAgICBpbnB1dENvdW50ICsgb3V0cHV0SW5kaWNlc1tpXSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgKTtcbiAgICB9XG4gICAgVFJBQ0VfRVZFTlRfRU5EKCd3YXNtIHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcicpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIHdhc20uc2V0VmFsdWUoaW5wdXRWYWx1ZXNPZmZzZXQgKyBpICogcHRyU2l6ZSwgaW5wdXRUZW5zb3JIYW5kbGVzW2ldLCAnKicpO1xuICAgICAgd2FzbS5zZXRWYWx1ZShpbnB1dE5hbWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZFtpbnB1dEluZGljZXNbaV1dLCAnKicpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIHdhc20uc2V0VmFsdWUob3V0cHV0VmFsdWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIG91dHB1dFRlbnNvckhhbmRsZXNbaV0sICcqJyk7XG4gICAgICB3YXNtLnNldFZhbHVlKG91dHB1dE5hbWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbb3V0cHV0SW5kaWNlc1tpXV0sICcqJyk7XG4gICAgfVxuXG4gICAgaWYgKCghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpICYmIGlvQmluZGluZ1N0YXRlICYmICFpbnB1dE91dHB1dEJvdW5kKSB7XG4gICAgICBjb25zdCB7IGhhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIH0gPSBpb0JpbmRpbmdTdGF0ZTtcblxuICAgICAgaWYgKGlucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGggIT09IGlucHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2lucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgVFJBQ0VfRVZFTlRfQkVHSU4oJ3dhc20gYmluZElucHV0c091dHB1dHMnKTtcbiAgICAgIC8vIHByb2Nlc3MgaW5wdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGlucHV0SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0QmluZElucHV0KGhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgaW5wdXRUZW5zb3JIYW5kbGVzW2ldKTtcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIGlucHV0WyR7aX1dIGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIHByZS1hbGxvY2F0ZWQgb3V0cHV0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gb3V0cHV0SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBvdXRwdXRUZW5zb3JzW2ldPy5bM107IC8vIHVuZGVmaW5lZCBtZWFucyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuXG5cbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgLy8gb3V0cHV0IGlzIHByZS1hbGxvY2F0ZWQsIHN0b3JlIGFuZCBiaW5kIHRoZSB0ZW5zb3IuXG4gICAgICAgICAgcHJlQWxsb2NhdGVkT3V0cHV0cy5wdXNoKG91dHB1dFRlbnNvckhhbmRsZXNbaV0pO1xuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KFxuICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBvdXRwdXRbJHtpfV0gdG8gJHtvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaV19IGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFRSQUNFX0VWRU5UX0VORCgnd2FzbSBiaW5kSW5wdXRzT3V0cHV0cycpO1xuICAgICAgYWN0aXZlU2Vzc2lvbnMuc2V0KHNlc3Npb25JZCwgW1xuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICAgIGlvQmluZGluZ1N0YXRlLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICAgIHRydWUsXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICB3YXNtLmpzZXBPblJ1blN0YXJ0Py4oc2Vzc2lvbkhhbmRsZSk7XG4gICAgd2FzbS53ZWJubk9uUnVuU3RhcnQ/LihzZXNzaW9uSGFuZGxlKTtcblxuICAgIGxldCBlcnJvckNvZGU6IG51bWJlcjtcbiAgICBpZiAoKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCB8fCAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkgJiYgaW9CaW5kaW5nU3RhdGUpIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bldpdGhCaW5kaW5nKFxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZS5oYW5kbGUsXG4gICAgICAgIG91dHB1dENvdW50LFxuICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW4oXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXG4gICAgICAgIGlucHV0TmFtZXNPZmZzZXQsXG4gICAgICAgIGlucHV0VmFsdWVzT2Zmc2V0LFxuICAgICAgICBpbnB1dENvdW50LFxuICAgICAgICBvdXRwdXROYW1lc09mZnNldCxcbiAgICAgICAgb3V0cHV0Q291bnQsXG4gICAgICAgIG91dHB1dFZhbHVlc09mZnNldCxcbiAgICAgICAgcnVuT3B0aW9uc0hhbmRsZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ2ZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogVGVuc29yTWV0YWRhdGFbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dFByb21pc2VzOiBBcnJheTxQcm9taXNlPFtudW1iZXIsIFRlbnNvci5EYXRhVHlwZV0+PiA9IFtdO1xuXG4gICAgVFJBQ0VfRVZFTlRfQkVHSU4oJ3dhc20gUHJvY2Vzc091dHB1dFRlbnNvcicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGVuc29yID0gTnVtYmVyKHdhc20uZ2V0VmFsdWUob3V0cHV0VmFsdWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsICcqJykpO1xuICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHBhcnQgdG8gZW5zdXJlIGl0IHdvcmtzIGZvciBXZWJHUFUgd2hlbiBib3RoIHByZS1hbGxvY2F0ZWQgb3V0cHV0cyBhbmRcbiAgICAgIC8vIHByZWZlcnJlZCBsb2NhdGlvbiBhcmUgc3BlY2lmaWVkLlxuICAgICAgLy8gQ2VydGFpbiBwcmUtYWxsb2NhdGVkIHRlbnNvcnMgbWF5IGFscmVhZHkgYmUgYm91bmQgaW4gdGhlIElPIGJpbmRpbmcuIGUuZy4gdGhlIFdlYk5OIGJhY2tlbmRcbiAgICAgIC8vIGFsd2F5cyBiaW5kcyBpdHMgdGVuc29yIHRvICdtbC10ZW5zb3InLiBJbiBzdWNoIGNhc2VzLCB0aGUgdGVuc29yIElEIG1pZ2h0IGNoYW5nZSBhZnRlciBiaW5kaW5nLFxuICAgICAgLy8gYnV0IGNvcHlpbmcgZGF0YSBmb3IgdGhlc2UgdGVuc29ycyBzaG91bGQgc3RpbGwgYmUgYXZvaWRlZC5cbiAgICAgIGlmICh0ZW5zb3IgPT09IG91dHB1dFRlbnNvckhhbmRsZXNbaV0gfHwgcHJlQWxsb2NhdGVkT3V0cHV0cy5pbmNsdWRlcyhvdXRwdXRUZW5zb3JIYW5kbGVzW2ldKSkge1xuICAgICAgICAvLyBvdXRwdXQgdGVuc29yIGlzIHByZS1hbGxvY2F0ZWQuIG5vIG5lZWQgdG8gY29weSBkYXRhLlxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3JzW2ldISk7XG4gICAgICAgIGlmICh0ZW5zb3IgIT09IG91dHB1dFRlbnNvckhhbmRsZXNbaV0pIHtcbiAgICAgICAgICAvLyByZWxlYXNlIHJlZHVuZGFudCB0ZW5zb3IgZWFybGllci5cbiAgICAgICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gICAgICAvLyBzdGFjayBhbGxvY2F0ZSA0IHBvaW50ZXIgdmFsdWVcbiAgICAgIGNvbnN0IHRlbnNvckRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIHB0clNpemUpO1xuXG4gICAgICBsZXQga2VlcE91dHB1dFRlbnNvciA9IGZhbHNlO1xuICAgICAgbGV0IHR5cGU6IFRlbnNvci5UeXBlIHwgdW5kZWZpbmVkLFxuICAgICAgICBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldFRlbnNvckRhdGEoXG4gICAgICAgICAgdGVuc29yLFxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQsXG4gICAgICAgICAgdGVuc29yRGF0YU9mZnNldCArIHB0clNpemUsXG4gICAgICAgICAgdGVuc29yRGF0YU9mZnNldCArIDIgKiBwdHJTaXplLFxuXG4gICAgICAgICAgdGVuc29yRGF0YU9mZnNldCArIDMgKiBwdHJTaXplLFxuICAgICAgICApO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBwdHJTaXplID09PSA0ID8gJ2kzMicgOiAnaTY0JztcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSBOdW1iZXIod2FzbS5nZXRWYWx1ZSh0ZW5zb3JEYXRhT2Zmc2V0LCB2YWx1ZVR5cGUpKTtcbiAgICAgICAgZGF0YU9mZnNldCA9IHdhc20uZ2V0VmFsdWUodGVuc29yRGF0YU9mZnNldCArIHB0clNpemUsICcqJyk7XG4gICAgICAgIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLmdldFZhbHVlKHRlbnNvckRhdGFPZmZzZXQgKyBwdHJTaXplICogMiwgJyonKTtcbiAgICAgICAgY29uc3QgZGltc0xlbmd0aCA9IE51bWJlcih3YXNtLmdldFZhbHVlKHRlbnNvckRhdGFPZmZzZXQgKyBwdHJTaXplICogMywgdmFsdWVUeXBlKSk7XG4gICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkaW1zLnB1c2goTnVtYmVyKHdhc20uZ2V0VmFsdWUoZGltc09mZnNldCArIGkgKiBwdHJTaXplLCB2YWx1ZVR5cGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhc20uX09ydEZyZWUoZGltc09mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGZyZWUgbWVtb3J5IGZvciB0ZW5zb3IgZGltcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gICAgICAgIHR5cGUgPSB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhkYXRhVHlwZSk7XG5cbiAgICAgICAgY29uc3QgcHJlZmVycmVkTG9jYXRpb24gPSBpb0JpbmRpbmdTdGF0ZT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW291dHB1dEluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInIHx8IHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQgKyBpICogcHRyU2l6ZSwgJyonKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSB3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQgKyAoaSArIDEpICogcHRyU2l6ZSwgJyonKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9SZWFkID0gaSA9PT0gc2l6ZSAtIDEgPyB1bmRlZmluZWQgOiBuZXh0T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgc3RyaW5nRGF0YS5wdXNoKHdhc20uVVRGOFRvU3RyaW5nKG9mZnNldCwgbWF4Qnl0ZXNUb1JlYWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LnB1c2goW3R5cGUsIGRpbXMsIHN0cmluZ0RhdGEsICdjcHUnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgYSBjZXJ0YWluIG91dHB1dCdzIHByZWZlcnJlZCBsb2NhdGlvbiBpcyBHUFUgYnV0IHRoZSB0ZW5zb3IgaXMgZW1wdHksIHdlIHN0aWxsIG5lZWQgdG8gY3JlYXRlIGEgQ1BVXG4gICAgICAgICAgLy8gdGVuc29yIGZvciBpdC4gVGhlcmUgaXMgbm8gbWFwcGluZyBHUFUgYnVmZmVyIGZvciBhbiBlbXB0eSB0ZW5zb3IuXG4gICAgICAgICAgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgJiYgc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGdldEJ1ZmZlciA9ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVID8gd2FzbS53ZWJncHVHZXRCdWZmZXIgOiB3YXNtLmpzZXBHZXRCdWZmZXI7XG4gICAgICAgICAgICBpZiAoIWdldEJ1ZmZlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBncHVCdWZmZXIgPSBnZXRCdWZmZXIoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICAgICAgICAgICAgICB3YXNtLndlYmdwdVJlZ2lzdGVyQnVmZmVyIShncHVCdWZmZXIsIHNlc3Npb25JZCwgZGF0YU9mZnNldCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkRGF0YUZ1bmN0aW9uID0gd2FzbS53ZWJncHVDcmVhdGVEb3dubG9hZGVyIShncHVCdWZmZXIsIGJ1ZmZlclNpemUsIHNlc3Npb25JZCk7XG4gICAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZ3B1QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgZG93bmxvYWQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBkb3dubG9hZERhdGFGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3ICh0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSEpKShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhIGFzIFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzXTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdncHUtYnVmZmVyJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXQucHVzaChbXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBkaW1zLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgIGRvd25sb2FkOiB3YXNtLmpzZXBDcmVhdGVEb3dubG9hZGVyIShncHVCdWZmZXIsIGJ1ZmZlclNpemUsIHR5cGUpLFxuICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCByZWxlYXNlIHRlbnNvci5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdtbC10ZW5zb3InICYmIHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbnN1cmVUZW5zb3IgPSB3YXNtLndlYm5uRW5zdXJlVGVuc29yO1xuICAgICAgICAgICAgY29uc3QgaXNHcmFwaElucHV0T3V0cHV0VHlwZVN1cHBvcnRlZCA9IHdhc20ud2Vibm5Jc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkO1xuICAgICAgICAgICAgaWYgKCFlbnN1cmVUZW5zb3IgfHwgIWlzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlbnNvclNpemUgPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyhkYXRhVHlwZSwgc2l6ZSk7XG4gICAgICAgICAgICBpZiAodGVuc29yU2l6ZSA9PT0gdW5kZWZpbmVkIHx8ICFpc01MVGVuc29yU3VwcG9ydGVkVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkKHNlc3Npb25JZCwgdHlwZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgcHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBmb3IgJHt0eXBlfSBvdXRwdXQgaXMgbm90IHN1cHBvcnRlZCBieSBjdXJyZW50IFdlYk5OIENvbnRleHQuYCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGdyYXBoIGhhcyBiZWVuIHBhcnRpdGlvbmVkLCB0aGUgb3V0cHV0IHRlbnNvciBtYXkgaGF2ZSBub3QgYmVlbiBjcmVhdGVkLiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZVxuICAgICAgICAgICAgLy8gZW5zdXJlVGVuc29yIHRvIGdldC9jcmVhdGUgdGhlIE1MVGVuc29yLiBJbiB3aGljaCBjYXNlLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgdGhlIGRhdGEgaWYgYSBuZXcgdGVuc29yXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgICAgY29uc3QgbWxUZW5zb3IgPSBhd2FpdCBlbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCBkYXRhT2Zmc2V0LCBkYXRhVHlwZSwgZGltcywgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBkbyBub3QgcmVsZWFzZSB0aGUgdGVuc29yIHJpZ2h0IG5vdy4gaXQgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHVzZXIgY2FsbHMgdGVuc29yLmRpc3Bvc2UoKS5cbiAgICAgICAgICAgIGtlZXBPdXRwdXRUZW5zb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICBvdXRwdXQucHVzaChbXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtbFRlbnNvcixcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS53ZWJubkNyZWF0ZU1MVGVuc29yRG93bmxvYWRlciEoZGF0YU9mZnNldCwgdHlwZSksXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgd2FzbS53ZWJublJlbGVhc2VUZW5zb3JJZCEoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ21sLXRlbnNvcicsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yLWNwdS1vdXRwdXQnICYmIHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gd2FzbS53ZWJubkNyZWF0ZU1MVGVuc29yRG93bmxvYWRlciEoZGF0YU9mZnNldCwgdHlwZSBhcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMpKCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgZGF0YSBkb3dubG9hZCBhbmQgcmVsZWFzaW5nIHRoZSB0ZW5zb3IgdW50aWwgd2UgY2FuIHdhaXQgZm9yIGFsbCBvdXRwdXQgdGVuc29ycyB0byBiZSBkb3dubG9hZGVkLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG4gICAgICAgICAgICBvdXRwdXRQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogW251bWJlciwgVGVuc29yLkRhdGFUeXBlXSA9IFtpbmRleCwgYXdhaXQgZGF0YV07XG4gICAgICAgICAgICAgICAgd2FzbS53ZWJublJlbGVhc2VUZW5zb3JJZCEoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICAgICAgd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goW3R5cGUsIGRpbXMsIFtdLCAnY3B1J10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzaXplKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkuc2V0KFxuICAgICAgICAgICAgICB3YXNtLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgZGF0YSwgJ2NwdSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBkYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBPdXRwdXRUZW5zb3IpIHtcbiAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW9CaW5kaW5nU3RhdGUgJiYgIWVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgaWYgKHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICBmYWxzZSxcbiAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBXYWl0IGZvciBhbGwgb3V0cHV0IHRlbnNvciBkYXRhIHRvIGJlIGRvd25sb2FkZWQuXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGRhdGFdIG9mIGF3YWl0IFByb21pc2UuYWxsKG91dHB1dFByb21pc2VzKSkge1xuICAgICAgb3V0cHV0W2luZGV4XVsyXSA9IGRhdGE7XG4gICAgfVxuICAgIFRSQUNFX0VWRU5UX0VORCgnd2FzbSBQcm9jZXNzT3V0cHV0VGVuc29yJyk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLndlYm5uT25SdW5FbmQ/LihzZXNzaW9uSGFuZGxlKTtcblxuICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZVJ1blN0YWNrKTtcblxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICAgICAgaW5wdXRUZW5zb3JzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgaWYgKHQgJiYgdFszXSA9PT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgd2FzbS53ZWJncHVVbnJlZ2lzdGVyQnVmZmVyISh0WzJdLmdwdUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb3V0cHV0VGVuc29ycy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ICYmIHRbM10gPT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICAgIHdhc20ud2ViZ3B1VW5yZWdpc3RlckJ1ZmZlciEodFsyXS5ncHVCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaW5wdXRUZW5zb3JIYW5kbGVzLmZvckVhY2goKHYpID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIG91dHB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCgodikgPT4gd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih2KSk7XG4gICAgaW5wdXRPdXRwdXRBbGxvY3MuZm9yRWFjaCgocCkgPT4gd2FzbS5fZnJlZShwKSk7XG5cbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIHJ1bk9wdGlvbnNBbGxvY3MuZm9yRWFjaCgocCkgPT4gd2FzbS5fZnJlZShwKSk7XG4gIH1cbn07XG5cbi8qKlxuICogZW5kIHByb2ZpbGluZ1xuICovXG5leHBvcnQgY29uc3QgZW5kUHJvZmlsaW5nID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZXNzaW9uIGlkJyk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG5cbiAgLy8gcHJvZmlsZSBmaWxlIG5hbWUgaXMgbm90IHVzZWQgeWV0LCBidXQgaXQgbXVzdCBiZSBmcmVlZC5cbiAgY29uc3QgcHJvZmlsZUZpbGVOYW1lID0gd2FzbS5fT3J0RW5kUHJvZmlsaW5nKHNlc3Npb25IYW5kbGUpO1xuICBpZiAocHJvZmlsZUZpbGVOYW1lID09PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpO1xuICB9XG4gIHdhc20uX09ydEZyZWUocHJvZmlsZUZpbGVOYW1lKTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyA9ICh0ZW5zb3JzOiByZWFkb25seSBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdKTogQXJyYXlCdWZmZXJMaWtlW10gPT4ge1xuICBjb25zdCBidWZmZXJzOiBBcnJheUJ1ZmZlckxpa2VbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlbnNvciBvZiB0ZW5zb3JzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgJ2J1ZmZlcicgaW4gZGF0YSkge1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEuYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYsIEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1xuICBPcnRXYXNtTWVzc2FnZSxcbiAgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSxcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXG4gIFRlbnNvck1ldGFkYXRhLFxufSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnLi93YXNtLWNvcmUtaW1wbCc7XG5pbXBvcnQgeyBpbml0aWFsaXplV2ViQXNzZW1ibHkgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQge1xuICBpbXBvcnRQcm94eVdvcmtlcixcbiAgaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMsXG4gIGlzRXNtSW1wb3J0TWV0YVVybEhhcmRjb2RlZEFzRmlsZVVyaSxcbn0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XG5cbmNvbnN0IGlzUHJveHkgPSAoKTogYm9vbGVhbiA9PiAhIWVudi53YXNtLnByb3h5ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgcHJveHlXb3JrZXI6IFdvcmtlciB8IHVuZGVmaW5lZDtcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGFib3J0ZWQgPSBmYWxzZTtcbmxldCB0ZW1wb3JhcnlPYmplY3RVcmw6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxudHlwZSBQcm9taXNlQ2FsbGJhY2tzPFQgPSB2b2lkPiA9IFtyZXNvbHZlOiAocmVzdWx0OiBUKSA9PiB2b2lkLCByZWplY3Q6IChyZWFzb246IHVua25vd24pID0+IHZvaWRdO1xubGV0IGluaXRXYXNtQ2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzO1xuY29uc3QgcXVldWVkQ2FsbGJhY2tzOiBNYXA8T3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgQXJyYXk8UHJvbWlzZUNhbGxiYWNrczx1bmtub3duPj4+ID0gbmV3IE1hcCgpO1xuXG5jb25zdCBlbnF1ZXVlQ2FsbGJhY2tzID0gKHR5cGU6IE9ydFdhc21NZXNzYWdlWyd0eXBlJ10sIGNhbGxiYWNrczogUHJvbWlzZUNhbGxiYWNrczx1bmtub3duPik6IHZvaWQgPT4ge1xuICBjb25zdCBxdWV1ZSA9IHF1ZXVlZENhbGxiYWNrcy5nZXQodHlwZSk7XG4gIGlmIChxdWV1ZSkge1xuICAgIHF1ZXVlLnB1c2goY2FsbGJhY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZWRDYWxsYmFja3Muc2V0KHR5cGUsIFtjYWxsYmFja3NdKTtcbiAgfVxufTtcblxuY29uc3QgZW5zdXJlV29ya2VyID0gKCk6IHZvaWQgPT4ge1xuICBpZiAoaW5pdGlhbGl6aW5nIHx8ICFpbml0aWFsaXplZCB8fCBhYm9ydGVkIHx8ICFwcm94eVdvcmtlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignd29ya2VyIG5vdCByZWFkeScpO1xuICB9XG59O1xuXG5jb25zdCBvblByb3h5V29ya2VyTWVzc2FnZSA9IChldjogTWVzc2FnZUV2ZW50PE9ydFdhc21NZXNzYWdlPik6IHZvaWQgPT4ge1xuICBzd2l0Y2ggKGV2LmRhdGEudHlwZSkge1xuICAgIGNhc2UgJ2luaXQtd2FzbSc6XG4gICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgIGlmIChldi5kYXRhLmVycikge1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaW5pdFdhc21DYWxsYmFja3NbMV0oZXYuZGF0YS5lcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1swXSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBvcmFyeU9iamVjdFVybCkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRlbXBvcmFyeU9iamVjdFVybCk7XG4gICAgICAgIHRlbXBvcmFyeU9iamVjdFVybCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2luaXQtZXAnOlxuICAgIGNhc2UgJ2NvcHktZnJvbSc6XG4gICAgY2FzZSAnY3JlYXRlJzpcbiAgICBjYXNlICdyZWxlYXNlJzpcbiAgICBjYXNlICdydW4nOlxuICAgIGNhc2UgJ2VuZC1wcm9maWxpbmcnOiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZWRDYWxsYmFja3MuZ2V0KGV2LmRhdGEudHlwZSkhO1xuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVsxXShldi5kYXRhLmVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKSFbMF0oZXYuZGF0YS5vdXQhKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZSA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbml0aWFsaXppbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO1xuICB9XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtcbiAgfVxuXG4gIGluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcHJveHlXb3JrZXI/LnRlcm1pbmF0ZSgpO1xuXG4gICAgICB2b2lkIGltcG9ydFByb3h5V29ya2VyKCkudGhlbigoW29iamVjdFVybCwgd29ya2VyXSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb3h5V29ya2VyID0gd29ya2VyO1xuICAgICAgICAgIHByb3h5V29ya2VyLm9uZXJyb3IgPSAoZXY6IEVycm9yRXZlbnQpID0+IHJlamVjdChldik7XG4gICAgICAgICAgcHJveHlXb3JrZXIub25tZXNzYWdlID0gb25Qcm94eVdvcmtlck1lc3NhZ2U7XG4gICAgICAgICAgaW5pdFdhc21DYWxsYmFja3MgPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2luaXQtd2FzbScsIGluOiBlbnYgfTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBwcm94eSB3b3JrZXIgaXMgbG9hZGVkIGZyb20gYSBibG9iIFVSTCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIHBhdGggaW5mb3JtYXRpb24gaXMgbm90IGxvc3QuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyB3aGVuIGBlbnYud2FzbS53YXNtUGF0aHNgIGlzIG5vdCBzZXQsIHdlIG5lZWQgdG8gcGFzcyB0aGUgcGF0aCBpbmZvcm1hdGlvbiB0byB0aGUgd29ya2VyLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKCFCVUlMRF9ERUZTLkVOQUJMRV9CVU5ETEVfV0FTTV9KUyAmJiAhbWVzc2FnZS5pbiEud2FzbS53YXNtUGF0aHMgJiYgb2JqZWN0VXJsKSB7XG4gICAgICAgICAgICAvLyBmb3IgYSBidWlsZCBub3QgYnVuZGxlZCB0aGUgd2FzbSBKUywgd2UgbmVlZCB0byBwYXNzIHRoZSBwYXRoIHByZWZpeCB0byB0aGUgd29ya2VyLlxuICAgICAgICAgICAgLy8gdGhlIHBhdGggcHJlZml4IHdpbGwgYmUgdXNlZCB0byByZXNvbHZlIHRoZSBwYXRoIHRvIGJvdGggdGhlIHdhc20gSlMgYW5kIHRoZSB3YXNtIGZpbGUuXG4gICAgICAgICAgICBjb25zdCBpbmZlcnJlZFdhc21QYXRoUHJlZml4ID0gaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMoKTtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFdhc21QYXRoUHJlZml4KSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW4hLndhc20ud2FzbVBhdGhzID0gaW5mZXJyZWRXYXNtUGF0aFByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBCVUlMRF9ERUZTLklTX0VTTSAmJlxuICAgICAgICAgICAgQlVJTERfREVGUy5FTkFCTEVfQlVORExFX1dBU01fSlMgJiZcbiAgICAgICAgICAgICFtZXNzYWdlLmluIS53YXNtLndhc21QYXRocyAmJlxuICAgICAgICAgICAgKG9iamVjdFVybCB8fCBpc0VzbUltcG9ydE1ldGFVcmxIYXJkY29kZWRBc0ZpbGVVcmkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBmb3IgYSBidWlsZCBidW5kbGVkIHRoZSB3YXNtIEpTLCBpZiBlaXRoZXIgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGlzIG1ldDpcbiAgICAgICAgICAgIC8vIC0gdGhlIHByb3h5IHdvcmtlciBpcyBsb2FkZWQgZnJvbSBhIGJsb2IgVVJMXG4gICAgICAgICAgICAvLyAtIGBpbXBvcnQubWV0YS51cmxgIGlzIGEgZmlsZSBVUkwsIGl0IG1lYW5zIGl0IGlzIG92ZXJ3cml0dGVuIGJ5IHRoZSBidW5kbGVyLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGluIGVpdGhlciBjYXNlLCB0aGUgcGF0aCBpbmZvcm1hdGlvbiBpcyBsb3N0LCB3ZSBuZWVkIHRvIHBhc3MgdGhlIHBhdGggb2YgdGhlIC53YXNtIGZpbGUgdG8gdGhlIHdvcmtlci5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHRoZSBidW5kbGVyIHByZWZlcnJlZCBVUkwgZm9ybWF0OlxuICAgICAgICAgICAgLy8gbmV3IFVSTCgnZmlsZW5hbWUnLCBpbXBvcnQubWV0YS51cmwpXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBidW5kbGVyIGNhbiBoYW5kbGUgdGhlIGZpbGUgdXNpbmcgY29ycmVzcG9uZGluZyBsb2FkZXJzLlxuICAgICAgICAgICAgbWVzc2FnZS5pbiEud2FzbS53YXNtUGF0aHMgPSB7XG4gICAgICAgICAgICAgIHdhc206ICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUFxuICAgICAgICAgICAgICAgID8gbmV3IFVSTCgnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc20nLCBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwpLmhyZWZcbiAgICAgICAgICAgICAgICA6IEJVSUxEX0RFRlMuRU5BQkxFX0pTUElcbiAgICAgICAgICAgICAgICAgID8gbmV3IFVSTCgnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc3BpLndhc20nLCBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwpLmhyZWZcbiAgICAgICAgICAgICAgICAgIDogIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFVcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgVVJMKCdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmFzeW5jaWZ5Lndhc20nLCBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwpLmhyZWZcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVVJMKCdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc20nLCBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwpLmhyZWYsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm94eVdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICB0ZW1wb3JhcnlPYmplY3RVcmwgPSBvYmplY3RVcmw7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGluaXRpYWxpemVXZWJBc3NlbWJseShlbnYud2FzbSk7XG4gICAgICBhd2FpdCBjb3JlLmluaXRSdW50aW1lKGVudik7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplT3J0RXAgPSBhc3luYyAoZXBOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnaW5pdC1lcCcsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnaW5pdC1lcCcsIGluOiB7IGVwTmFtZSwgZW52IH0gfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCBjb3JlLmluaXRFcChlbnYsIGVwTmFtZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjb3B5RnJvbUV4dGVybmFsQnVmZmVyID0gYXN5bmMgKGJ1ZmZlcjogVWludDhBcnJheSk6IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2NvcHktZnJvbScsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnY29weS1mcm9tJywgaW46IHsgYnVmZmVyIH0gfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBbYnVmZmVyLmJ1ZmZlcl0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLmNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlc3Npb24gPSBhc3luYyAoXG4gIG1vZGVsOiBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlciB8IFVpbnQ4QXJyYXksXG4gIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuKTogUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICAvLyBjaGVjayB1bnN1cHBvcnRlZCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gb3B0aW9uIFwicHJlZmVycmVkT3V0cHV0TG9jYXRpb25cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY3JlYXRlJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdjcmVhdGUnLCBpbjogeyBtb2RlbCwgb3B0aW9uczogeyAuLi5vcHRpb25zIH0gfSB9O1xuICAgICAgY29uc3QgdHJhbnNmZXJhYmxlOiBUcmFuc2ZlcmFibGVbXSA9IFtdO1xuICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICB0cmFuc2ZlcmFibGUucHVzaChtb2RlbC5idWZmZXIpO1xuICAgICAgfVxuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUuY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IGFzeW5jIChzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdyZWxlYXNlJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdyZWxlYXNlJywgaW46IHNlc3Npb25JZCB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvcmUucmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJ1biA9IGFzeW5jIChcbiAgc2Vzc2lvbklkOiBudW1iZXIsXG4gIGlucHV0SW5kaWNlczogbnVtYmVyW10sXG4gIGlucHV0czogVGVuc29yTWV0YWRhdGFbXSxcbiAgb3V0cHV0SW5kaWNlczogbnVtYmVyW10sXG4gIG91dHB1dHM6IEFycmF5PFRlbnNvck1ldGFkYXRhIHwgbnVsbD4sXG4gIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbik6IFByb21pc2U8VGVuc29yTWV0YWRhdGFbXT4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIC8vIGNoZWNrIGlucHV0cyBsb2NhdGlvblxuICAgIGlmIChpbnB1dHMuc29tZSgodCkgPT4gdFszXSAhPT0gJ2NwdScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvciBvbiBHUFUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XG4gICAgfVxuICAgIC8vIGNoZWNrIG91dHB1dHMgbG9jYXRpb25cbiAgICBpZiAob3V0cHV0cy5zb21lKCh0KSA9PiB0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmUtYWxsb2NhdGVkIG91dHB1dCB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XG4gICAgfVxuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdydW4nLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBzZXJpYWxpemFibGVJbnB1dHMgPSBpbnB1dHMgYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXTsgLy8gZXZlcnkgaW5wdXQgaXMgb24gQ1BVLlxuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6ICdydW4nLFxuICAgICAgICBpbjogeyBzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzOiBzZXJpYWxpemFibGVJbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnMgfSxcbiAgICAgIH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgY29yZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyhzZXJpYWxpemFibGVJbnB1dHMpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5ydW4oc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBlbmRQcm9maWxpbmcgPSBhc3luYyAoc2Vzc2lvbklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnZW5kLXByb2ZpbGluZycsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnZW5kLXByb2ZpbGluZycsIGluOiBzZXNzaW9uSWQgfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb3JlLmVuZFByb2ZpbGluZyhzZXNzaW9uSWQpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBJbmZlcmVuY2VTZXNzaW9uLFxuICBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcixcbiAgU2Vzc2lvbkhhbmRsZXIsXG4gIFRlbnNvcixcbiAgVFJBQ0VfRlVOQ19CRUdJTixcbiAgVFJBQ0VfRlVOQ19FTkQsXG59IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLCBUZW5zb3JNZXRhZGF0YSB9IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0IHsgY29weUZyb21FeHRlcm5hbEJ1ZmZlciwgY3JlYXRlU2Vzc2lvbiwgZW5kUHJvZmlsaW5nLCByZWxlYXNlU2Vzc2lvbiwgcnVuIH0gZnJvbSAnLi9wcm94eS13cmFwcGVyJztcbmltcG9ydCB7IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSwgaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUgfSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuaW1wb3J0IHsgbG9hZEZpbGUgfSBmcm9tICcuL3dhc20tdXRpbHMtbG9hZC1maWxlJztcblxuZXhwb3J0IGNvbnN0IGVuY29kZVRlbnNvck1ldGFkYXRhID0gKHRlbnNvcjogVGVuc29yLCBnZXROYW1lOiAoKSA9PiBzdHJpbmcpOiBUZW5zb3JNZXRhZGF0YSA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBbdGVuc29yLnR5cGUsIHRlbnNvci5kaW1zLCB0ZW5zb3IuZGF0YSwgJ2NwdSddO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgZ3B1QnVmZmVyOiB0ZW5zb3IuZ3B1QnVmZmVyIH0sICdncHUtYnVmZmVyJ107XG4gICAgY2FzZSAnbWwtdGVuc29yJzpcbiAgICAgIHJldHVybiBbdGVuc29yLnR5cGUsIHRlbnNvci5kaW1zLCB7IG1sVGVuc29yOiB0ZW5zb3IubWxUZW5zb3IgfSwgJ21sLXRlbnNvciddO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3IubG9jYXRpb259IGZvciAke2dldE5hbWUoKX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlY29kZVRlbnNvck1ldGFkYXRhID0gKHRlbnNvcjogVGVuc29yTWV0YWRhdGEpOiBUZW5zb3IgPT4ge1xuICBzd2l0Y2ggKHRlbnNvclszXSkge1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih0ZW5zb3JbMF0sIHRlbnNvclsyXSwgdGVuc29yWzFdKTtcbiAgICBjYXNlICdncHUtYnVmZmVyJzoge1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XG4gICAgICBpZiAoIWlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZShkYXRhVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBncHVCdWZmZXIsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSB0ZW5zb3JbMl07XG4gICAgICByZXR1cm4gVGVuc29yLmZyb21HcHVCdWZmZXIoZ3B1QnVmZmVyLCB7IGRhdGFUeXBlLCBkaW1zOiB0ZW5zb3JbMV0sIGRvd25sb2FkLCBkaXNwb3NlIH0pO1xuICAgIH1cbiAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGlmICghaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUoZGF0YVR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBtbFRlbnNvciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcbiAgICAgIHJldHVybiBUZW5zb3IuZnJvbU1MVGVuc29yKG1sVGVuc29yLCB7IGRhdGFUeXBlLCBkaW1zOiB0ZW5zb3JbMV0sIGRvd25sb2FkLCBkaXNwb3NlIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7dGVuc29yWzNdfWApO1xuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIge1xuICBwcml2YXRlIHNlc3Npb25JZDogbnVtYmVyO1xuXG4gIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIGlucHV0TWV0YWRhdGE6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdO1xuICBvdXRwdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XG5cbiAgYXN5bmMgZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkocGF0aDogc3RyaW5nKTogUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4ge1xuICAgIC8vIGZldGNoIG1vZGVsIGZyb20gdXJsIGFuZCBtb3ZlIHRvIHdhc20gaGVhcC5cbiAgICByZXR1cm4gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihhd2FpdCBsb2FkRmlsZShwYXRoKSk7XG4gIH1cblxuICBhc3luYyBsb2FkTW9kZWwocGF0aE9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBsZXQgbW9kZWw6IFBhcmFtZXRlcnM8dHlwZW9mIGNyZWF0ZVNlc3Npb24+WzBdO1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoT3JCdWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIC8vIG5vZGVcbiAgICAgICAgbW9kZWwgPSBhd2FpdCBsb2FkRmlsZShwYXRoT3JCdWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYnJvd3NlclxuICAgICAgICAvLyBmZXRjaCBtb2RlbCBhbmQgY29weSB0byB3YXNtIGhlYXAuXG4gICAgICAgIG1vZGVsID0gYXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoT3JCdWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbCA9IHBhdGhPckJ1ZmZlcjtcbiAgICB9XG5cbiAgICBbdGhpcy5zZXNzaW9uSWQsIHRoaXMuaW5wdXROYW1lcywgdGhpcy5vdXRwdXROYW1lcywgdGhpcy5pbnB1dE1ldGFkYXRhLCB0aGlzLm91dHB1dE1ldGFkYXRhXSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24oXG4gICAgICBtb2RlbCxcbiAgICAgIG9wdGlvbnMsXG4gICAgKTtcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gcmVsZWFzZVNlc3Npb24odGhpcy5zZXNzaW9uSWQpO1xuICB9XG5cbiAgYXN5bmMgcnVuKFxuICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG4gICAgY29uc3QgaW5wdXRBcnJheTogVGVuc29yW10gPSBbXTtcbiAgICBjb25zdCBpbnB1dEluZGljZXM6IG51bWJlcltdID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoZmVlZHMpLmZvckVhY2goKGt2cCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnB1dE5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtuYW1lfSdgKTtcbiAgICAgIH1cbiAgICAgIGlucHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgaW5wdXRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb3V0cHV0QXJyYXk6IEFycmF5PFRlbnNvciB8IG51bGw+ID0gW107XG4gICAgY29uc3Qgb3V0cHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZXRjaGVzKS5mb3JFYWNoKChrdnApID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBrdnBbMF07XG4gICAgICBjb25zdCB0ZW5zb3IgPSBrdnBbMV07XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtuYW1lfSdgKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dEFycmF5LnB1c2godGVuc29yKTtcbiAgICAgIG91dHB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnB1dHMgPSBpbnB1dEFycmF5Lm1hcCgodCwgaSkgPT5cbiAgICAgIGVuY29kZVRlbnNvck1ldGFkYXRhKHQsICgpID0+IGBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2lucHV0SW5kaWNlc1tpXV19XCJgKSxcbiAgICApO1xuICAgIGNvbnN0IG91dHB1dHMgPSBvdXRwdXRBcnJheS5tYXAoKHQsIGkpID0+XG4gICAgICB0ID8gZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tvdXRwdXRJbmRpY2VzW2ldXX1cImApIDogbnVsbCxcbiAgICApO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHJ1bih0aGlzLnNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG91dHB1dHMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgcmVzdWx0TWFwOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRNYXBbdGhpcy5vdXRwdXROYW1lc1tvdXRwdXRJbmRpY2VzW2ldXV0gPSBvdXRwdXRBcnJheVtpXSA/PyBkZWNvZGVUZW5zb3JNZXRhZGF0YShyZXN1bHRzW2ldKTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmVzdWx0TWFwO1xuICB9XG5cbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHByb2ZpbGluZ1xuICB9XG5cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHZvaWQgZW5kUHJvZmlsaW5nKHRoaXMuc2Vzc2lvbklkKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBCYWNrZW5kLCBlbnYsIEluZmVyZW5jZVNlc3Npb24sIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgaW5pdGlhbGl6ZU9ydEVwLCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lIH0gZnJvbSAnLi93YXNtL3Byb3h5LXdyYXBwZXInO1xuaW1wb3J0IHsgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi93YXNtL3Nlc3Npb24taGFuZGxlci1pbmZlcmVuY2UnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYWxsIGZsYWdzIGZvciBXZWJBc3NlbWJseS5cbiAqXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cbiAqIGJlaW5nIGNyZWF0ZWQsIHRvIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2YgZW52Lndhc20uaW5pdFRpbWVvdXQgIT09ICdudW1iZXInIHx8IGVudi53YXNtLmluaXRUaW1lb3V0IDwgMCkge1xuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcbiAgfVxuXG4gIGNvbnN0IHNpbWQgPSBlbnYud2FzbS5zaW1kO1xuICBpZiAodHlwZW9mIHNpbWQgIT09ICdib29sZWFuJyAmJiBzaW1kICE9PSB1bmRlZmluZWQgJiYgc2ltZCAhPT0gJ2ZpeGVkJyAmJiBzaW1kICE9PSAncmVsYXhlZCcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBQcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gdW5rbm93biB2YWx1ZSBcIiR7c2ltZH1cIi4gUmVzZXQgaXQgdG8gXFxgZmFsc2VcXGAgYW5kIGlnbm9yZSBTSU1EIGZlYXR1cmUgY2hlY2tpbmcuYCxcbiAgICApO1xuICAgIGVudi53YXNtLnNpbWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20ucHJveHkgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnByb3h5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLnRyYWNlICE9PSAnYm9vbGVhbicpIHtcbiAgICBlbnYud2FzbS50cmFjZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5udW1UaHJlYWRzICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihlbnYud2FzbS5udW1UaHJlYWRzKSB8fCBlbnYud2FzbS5udW1UaHJlYWRzIDw9IDApIHtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGxvZ2ljIG9ubHkgYXBwbGllcyB3aGVuIGBvcnQuZW52Lndhc20ubnVtVGhyZWFkc2AgaXMgbm90IHNldCBieSB1c2VyLiBXZSB3aWxsIGFsd2F5cyBob25vciB1c2VyJ3NcbiAgICAvLyBzZXR0aW5nIGlmIGl0IGlzIHByb3ZpZGVkLlxuXG4gICAgLy8gQnJvd3Nlcjogd2hlbiBjcm9zc09yaWdpbklzb2xhdGVkIGlzIGZhbHNlLCBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlIHNvIFdlYkFzc2VtYmx5IHRocmVhZHMgd2lsbCBub3RcbiAgICAvLyB3b3JrLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgc2V0IG51bVRocmVhZHMgdG8gMS5cbiAgICAvL1xuICAgIC8vIFRoZXJlIGlzIGFuIGV4Y2VwdGlvbjogd2hlbiB0aGUgYnJvd3NlciBpcyBjb25maWd1cmVkIHRvIGZvcmNlLWVuYWJsZSBTaGFyZWRBcnJheUJ1ZmZlciAoZS5nLiBDaHJvbXVpbSB3aXRoXG4gICAgLy8gLS1lbmFibGUtZmVhdHVyZXM9U2hhcmVkQXJyYXlCdWZmZXIpLCBpdCBpcyBwb3NzaWJsZSB0aGF0IGBzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWRgIGlzIGZhbHNlIGFuZFxuICAgIC8vIFNoYXJlZEFycmF5QnVmZmVyIGlzIGF2YWlsYWJsZSBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIHVzdWFsbHkgZm9yIHRlc3RpbmcuIEluIHRoaXMgY2FzZSwgIHdlIHdpbGwgc3RpbGwgc2V0XG4gICAgLy8gbnVtVGhyZWFkcyB0byAxIGhlcmUuIElmIHdlIHdhbnQgdG8gZW5hYmxlIG11bHRpLXRocmVhZGluZyBpbiB0ZXN0LCB3ZSBzaG91bGQgc2V0IGBvcnQuZW52Lndhc20ubnVtVGhyZWFkc2AgdG8gYVxuICAgIC8vIHZhbHVlIGdyZWF0ZXIgdGhhbiAxLlxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCkge1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bUNwdUxvZ2ljYWxDb3JlcyA9XG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgnbm9kZTpvcycpLmNwdXMoKS5sZW5ndGggOiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtcbiAgICAgIGVudi53YXNtLm51bVRocmVhZHMgPSBNYXRoLm1pbig0LCBNYXRoLmNlaWwoKG51bUNwdUxvZ2ljYWxDb3JlcyB8fCAxKSAvIDIpKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyB0aGUgV2ViQXNzZW1ibHkgYmFja2VuZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgZm9yIGVhY2ggYmFja2VuZCBuYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSB3aGVuXG4gICAqIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkIHdpdGggYSByZWdpc3RlcmVkIGJhY2tlbmQgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIGJhY2tlbmROYW1lIC0gdGhlIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxuICAgKi9cbiAgYXN5bmMgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gcG9wdWxhdGUgd2FzbSBmbGFnc1xuICAgIGluaXRpYWxpemVGbGFncygpO1xuXG4gICAgLy8gaW5pdCB3YXNtXG4gICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZSgpO1xuXG4gICAgLy8gcGVyZm9ybWUgRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBpbml0aWFsaXplT3J0RXAoYmFja2VuZE5hbWUpO1xuICB9XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XG4gICAgYXdhaXQgaGFuZGxlci5sb2FkTW9kZWwocGF0aE9yQnVmZmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd2FzbUJhY2tlbmQgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQoKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuXG4vLyBXZSB1c2UgXCJyZXF1aXJlXCIgaW5zdGVhZCBvZiBcImltcG9ydFwiIGhlcmUgYmVjYXVzZSBpbXBvcnQgc3RhdGVtZW50IG11c3QgYmUgcHV0IGluIHRvcCBsZXZlbC4gT3VyIGN1cnJlbnQgY29kZSBkb2VzXG4vLyBub3QgYWxsb3cgYnVuZGxlciB0byB0cmVlLXNoYWtpbmcgY29kZSBhcyBleHBlY3RlZCBiZWNhdXNlIHNvbWUgY29kZXMgYXJlIHRyZWF0ZWQgYXMgaGF2aW5nIHNpZGUgZWZmZWN0cy5cbi8vIFNvIHdlIGltcG9ydCBjb2RlIGluc2lkZSB0aGUgaWYtY2xhdXNlIHRvIGFsbG93IGJ1bmRsZXIgcmVtb3ZlIHRoZSBjb2RlIHNhZmVseS5cblxuZXhwb3J0ICogZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCAqIGFzIG9ydCBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuZXhwb3J0IGRlZmF1bHQgb3J0O1xuXG5pbXBvcnQgeyByZWdpc3RlckJhY2tlbmQsIGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR0wpIHtcbiAgY29uc3Qgb25ueGpzQmFja2VuZCA9IHJlcXVpcmUoJy4vYmFja2VuZC1vbm54anMnKS5vbm54anNCYWNrZW5kO1xuICByZWdpc3RlckJhY2tlbmQoJ3dlYmdsJywgb25ueGpzQmFja2VuZCwgLTEwKTtcbn1cblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCAmJiAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ1RoZSBjdXJyZW50IGJ1aWxkIGlzIHNwZWNpZmllZCB0byBlbmFibGUgYm90aCBKU0VQIGFuZCBXZWJHUFUgRVAuIFRoaXMgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbi4gJyArXG4gICAgICAnSlNFUCBhbmQgV2ViR1BVIEVQcyBjYW5ub3QgYmUgZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lLicsXG4gICk7XG59XG5cbmlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQk5OICYmIEJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIEJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdUaGUgY3VycmVudCBidWlsZCBpcyBzcGVjaWZpZWQgdG8gZW5hYmxlIFdlYk5OIEVQIHdpdGhvdXQgSlNFUCBvciBXZWJHUFUgRVAuIFRoaXMgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbi4gJyArXG4gICAgICAnV2ViTk4gRVAgcmVxdWlyZXMgZWl0aGVyIEpTRVAgb3IgV2ViR1BVIEVQIHRvIGJlIGVuYWJsZWQuJyxcbiAgKTtcbn1cblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTSkge1xuICBjb25zdCB3YXNtQmFja2VuZCA9IHJlcXVpcmUoJy4vYmFja2VuZC13YXNtJykud2FzbUJhY2tlbmQ7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcbiAgICByZWdpc3RlckJhY2tlbmQoJ3dlYmdwdScsIHdhc21CYWNrZW5kLCA1KTtcbiAgfVxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJOTikge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XG4gIH1cbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywgeyB2YWx1ZTogdmVyc2lvbiwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjUuMC1kZXYuMjAyNjAyMTItMWE3MWE1ZjQ2ZSc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQWdCTSxVQUNBLDBCQVlPLGlCQXdDUCxnQ0F3Q087QUE3R2I7OztBQWdCQSxJQUFNLFdBQXFDLG9CQUFJLElBQUc7QUFDbEQsSUFBTSwyQkFBcUMsQ0FBQTtBQVlwQyxJQUFNLGtCQUFrQixDQUFDLE1BQWMsU0FB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QUFJO0FBQUEsWUFBSztBQUFBLFlBQUs7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUk7QUFBQSxZQUFJO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFLO0FBQUEsWUFDM0c7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUk7QUFBQSxVQUNaLENBQUM7QUFBQSxRQUNIO0FBQUEsTUFDRixRQUFRO0FBQ04sZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBRUEsSUFBTSxrQkFBa0IsTUFBZTtBQUNyQyxVQUFJO0FBZUYsZUFBTyxZQUFZO0FBQUEsVUFDakIsSUFBSSxXQUFXO0FBQUEsWUFDYjtBQUFBLFlBQUc7QUFBQSxZQUFJO0FBQUEsWUFBSztBQUFBLFlBQUs7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUk7QUFBQSxZQUFJO0FBQUEsWUFBRztBQUFBLFlBQUk7QUFBQSxZQUFHO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFLO0FBQUEsWUFBSTtBQUFBLFlBQUs7QUFBQSxZQUFJO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUM3RztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEs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QUFVLE9BQU8sRUFBRSxPQUFPQyxVQUFTLFlBQVksS0FBSyxDQUFDOyIsCiAgIm5hbWVzIjogWyJpIiwgImVudiIsICJGbG9hdDE2QXJyYXkiLCAiVGVuc29yIiwgIlRlbnNvciIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgImVudiIsICJlbnYiLCAid2FzbSIsICJ3YXNtIiwgIndhc20iLCAibG9jYXRpb24iLCAicGFkIiwgInRlbnNvciIsICJlbnYiLCAibWxDb250ZXh0SW5kZXgiLCAid2FzbSIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgImkiLCAiaW5wdXRWYXJpYWJsZSIsICJ0cmFuc3Bvc2UiLCAib3V0cHV0VmFyaWFibGUiLCAiaW5uZXJFbGVtZW50U2l6ZSIsICJwYWQiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29udklucHV0cyIsICJ0cmFuc3Bvc2VkV2VpZ2h0IiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInBlcm1GdW5jdGlvbkJvZHkiLCAic3ltYm9sIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsICJmYXN0R2VsdSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJpbnB1dHMiLCAib3V0cHV0U2l6ZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRhdGFUeXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJnZXRPdXRwdXRTaGFwZSIsICJhIiwgImIiLCAiYyIsICJmYXN0R2VsdSIsICJlbnYiLCAiaSIsICJlbnYiLCAiZW52IiwgIndhc20iLCAibG9jYXRpb24iLCAiaW5kZXgiLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJUZW5zb3IiLCAiY29weUZyb21FeHRlcm5hbEJ1ZmZlciIsICJjcmVhdGVTZXNzaW9uIiwgInJlbGVhc2VTZXNzaW9uIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiZW52IiwgInZlcnNpb24iLCAid2FzbUJhY2tlbmQiLCAiZW52IiwgInZlcnNpb24iXQp9Cg==
